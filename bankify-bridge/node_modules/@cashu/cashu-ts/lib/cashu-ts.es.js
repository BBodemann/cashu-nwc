import { bech32m as wt, bech32 as kt } from "@scure/base";
import { secp256k1 as b, schnorr as ft } from "@noble/curves/secp256k1.js";
import { sha256 as B } from "@noble/hashes/sha2.js";
import { utf8ToBytes as Ke, hexToBytes as $, bytesToHex as j, randomBytes as be } from "@noble/hashes/utils.js";
import { bytesToHex as I, randomBytes as Mt, hexToBytes as T, numberToBytesBE as Nn } from "@noble/curves/utils.js";
import { HDKey as Ne } from "@scure/bip32";
import { hmac as Ln } from "@noble/hashes/hmac.js";
class ut extends Error {
  constructor(t, e) {
    super(t), this.status = e, this.name = "HttpResponseError", Object.setPrototypeOf(this, ut.prototype);
  }
}
class Gt extends Error {
  constructor(t) {
    super(t), this.name = "NetworkError", Object.setPrototypeOf(this, Gt.prototype);
  }
}
class Vt extends ut {
  constructor(t, e) {
    super(e || "Unknown mint operation error", 400), this.code = t, this.name = "MintOperationError", Object.setPrototypeOf(this, Vt.prototype);
  }
}
const M = {
  error() {
  },
  warn() {
  },
  info() {
  },
  debug() {
  },
  trace() {
  },
  log() {
  }
};
function Ct(s, t = M, e) {
  throw t.error(s, e), new Error(s);
}
function Jt(s, t, e = M, n) {
  s && Ct(t, e, n);
}
function Le(s, t, e = M, n) {
  s == null && Ct(t, e, n);
}
function ht(s, t, e = M, n) {
  if (s)
    try {
      const r = s(t);
      r && typeof r.then == "function" && r.catch((i) => {
        try {
          e.warn("callback failed", {
            ...n ?? {},
            error: i,
            cb: s.name ?? ""
          });
        } catch {
        }
      });
    } catch (r) {
      try {
        e.warn("callback failed", {
          ...n ?? {},
          error: r,
          cb: s.name ?? ""
        });
      } catch {
      }
    }
}
const _e = {
  error: 0,
  warn: 1,
  info: 2,
  debug: 3,
  trace: 4
};
class Lr {
  constructor(t = "info") {
    this.minLevel = t;
  }
  should(t) {
    return _e[t] <= _e[this.minLevel];
  }
  method(t) {
    switch (t) {
      case "error":
        return console.error;
      case "warn":
        return console.warn;
      case "info":
        return console.info;
      case "debug":
        return console.debug;
      case "trace":
        return console.trace;
      default:
        return console.log;
    }
  }
  header(t, e) {
    return `[${t.toUpperCase()}] ${e}`;
  }
  flattenContext(t) {
    if (!t) return;
    const e = {};
    for (const [n, r] of Object.entries(t))
      e[n] = r instanceof Error ? { message: r.message, stack: r.stack } : r;
    return e;
  }
  emit(t, e, n) {
    if (!this.should(t)) return;
    const r = this.header(t, e), i = this.flattenContext(n), o = this.method(t);
    i && Object.keys(i).length ? o(r, i) : o(r);
  }
  error(t, e) {
    this.emit("error", t, e);
  }
  warn(t, e) {
    this.emit("warn", t, e);
  }
  info(t, e) {
    this.emit("info", t, e);
  }
  debug(t, e) {
    this.emit("debug", t, e);
  }
  trace(t, e) {
    this.emit("trace", t, e);
  }
  log(t, e, n) {
    this.emit(t, e, n);
  }
}
function Un() {
  const s = Date.now();
  return {
    elapsed: () => Date.now() - s
  };
}
let Ue = {}, Fe = M;
function Ur(s) {
  Ue = s;
}
function Fn(s) {
  Fe = s;
}
async function qn({
  endpoint: s,
  requestBody: t,
  headers: e,
  ...n
}) {
  const r = t ? JSON.stringify(t) : void 0, i = {
    Accept: "application/json, text/plain, */*",
    ...r ? { "Content-Type": "application/json" } : void 0,
    ...e
  };
  let o;
  try {
    o = await fetch(s, { body: r, headers: i, ...n });
  } catch (a) {
    throw new Gt(a instanceof Error ? a.message : "Network request failed");
  }
  if (!o.ok) {
    let a;
    try {
      a = await o.json();
    } catch {
      a = { error: "bad response" };
    }
    if (o.status === 400 && "code" in a && typeof a.code == "number" && "detail" in a && typeof a.detail == "string")
      throw new Vt(a.code, a.detail);
    let c = "HTTP request failed";
    throw "error" in a && typeof a.error == "string" ? c = a.error : "detail" in a && typeof a.detail == "string" && (c = a.detail), new ut(c, o.status);
  }
  try {
    return await o.json();
  } catch (a) {
    throw Fe.error("Failed to parse HTTP response", { err: a }), new ut("bad response", o.status);
  }
}
async function qe(s) {
  return await qn({ ...s, ...Ue });
}
let bt;
typeof WebSocket < "u" && (bt = WebSocket);
function Fr(s) {
  bt = s;
}
function Rn() {
  if (bt === void 0)
    throw new Error("WebSocket implementation not initialized");
  return bt;
}
class w {
  static fromHex(t) {
    if (t = t.trim(), t.length === 0)
      return new Uint8Array(0);
    if (t.length < 2 || t.length & 1)
      throw new Error("Invalid hex string: odd length.");
    if ((t.startsWith("0x") || t.startsWith("0X")) && (t = t.slice(2)), !t.match(/^[0-9a-fA-F]*$/))
      throw new Error("Invalid hex string: contains non-hex characters");
    const n = t.match(/.{1,2}/g);
    if (!n)
      throw new Error("Invalid hex string");
    return new Uint8Array(n.map((r) => parseInt(r, 16)));
  }
  static toHex(t) {
    return Array.from(t, (e) => e.toString(16).padStart(2, "0")).join("");
  }
  static fromString(t) {
    return t = t.trim(), new TextEncoder().encode(t);
  }
  static toString(t) {
    return new TextDecoder("utf-8").decode(t);
  }
  static concat(...t) {
    const e = t.reduce((i, o) => i + o.length, 0), n = new Uint8Array(e);
    let r = 0;
    for (const i of t)
      n.set(i, r), r += i.length;
    return n;
  }
  static alloc(t) {
    return new Uint8Array(t);
  }
  static writeBigUint64BE(t) {
    const e = new ArrayBuffer(8);
    return new DataView(e).setBigUint64(0, t, !1), new Uint8Array(e);
  }
  static toBase64(t) {
    if (typeof Buffer < "u")
      return Buffer.from(t).toString("base64");
    if (t.length > 32768) {
      let e = "";
      for (let n = 0; n < t.length; n += 32768) {
        const r = t.slice(n, n + 32768);
        e += btoa(String.fromCharCode(...r));
      }
      return e;
    }
    return btoa(String.fromCharCode(...t));
  }
  static fromBase64(t) {
    t = t.trim();
    let e = t.replace(/-/g, "+").replace(/_/g, "/");
    for (; e.length % 4; )
      e += "=";
    return typeof Buffer < "u" ? new Uint8Array(Buffer.from(e, "base64")) : new Uint8Array([...atob(e)].map((n) => n.charCodeAt(0)));
  }
  // NOTE: MUST remain a constant-time implementation (full byte check)
  // because callers rely on it (e.g. deriveP2BKSecretKey).
  static equals(t, e) {
    if (t.length !== e.length) return !1;
    let n = 0;
    for (let r = 0; r < t.length; r++)
      n |= t[r] ^ e[r];
    return n === 0;
  }
  static compare(t, e) {
    const n = Math.min(t.length, e.length);
    for (let r = 0; r < n; r++) {
      if (t[r] < e[r]) return -1;
      if (t[r] > e[r]) return 1;
    }
    return t.length - e.length;
  }
  static toBigInt(t) {
    let e = 0n;
    for (const n of t)
      e = e << 8n | BigInt(n);
    return e;
  }
  static fromBigInt(t) {
    if (t < 0n)
      throw new RangeError("value must be non-negative");
    if (t === 0n)
      return new Uint8Array([0]);
    let e = t, n = 0;
    for (; e > 0n; )
      n++, e >>= 8n;
    const r = new Uint8Array(n);
    e = t;
    for (let i = n - 1; i >= 0; i--)
      r[i] = Number(e & 0xffn), e >>= 8n;
    return r;
  }
}
function qt(s) {
  return w.toBase64(s).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function Xt(s) {
  return w.fromBase64(s);
}
function Re(s) {
  const t = JSON.stringify(s);
  return Wn(w.toBase64(w.fromString(t)));
}
function $n(s) {
  const t = w.toString(w.fromBase64(Hn(s)));
  return JSON.parse(t);
}
function Hn(s) {
  return s.replace(/-/g, "+").replace(/_/g, "/").split("=")[0];
}
function Wn(s) {
  return s.replace(/\+/g, "-").replace(/\//g, "_").split("=")[0];
}
function xt(s) {
  if (typeof s != "string" || s.length === 0) return !1;
  const t = /^[A-Za-z0-9\-_]+={0,2}$/, e = /^[A-Za-z0-9+/]+={0,2}$/;
  if (!t.test(s) && !e.test(s)) return !1;
  const n = s.replace(/-/g, "+").replace(/_/g, "/"), r = (4 - n.length % 4) % 4;
  if (r > 2) return !1;
  const i = n + "=".repeat(r);
  try {
    const o = w.fromBase64(i), a = w.toBase64(o), c = a.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, ""), u = n.replace(/=+$/, "");
    return a.replace(/=+$/, "") === u || c === u;
  } catch {
    return !1;
  }
}
const Yt = 1023;
function jn(s) {
  const t = s.lastIndexOf("1");
  if (t < 1 || t === s.length - 1)
    throw new Error("Invalid bech32m string: missing or misplaced separator");
}
function Qn(s, t, e = Yt) {
  const n = wt.toWords(t);
  return wt.encode(s, n, e);
}
function zn(s, t = Yt) {
  jn(s);
  const { prefix: e, words: n } = wt.decode(s, t), r = wt.fromWords(n);
  return { hrp: e, data: r };
}
function Gn(s, t = Yt) {
  return zn(s, t).data;
}
function Vn(s) {
  return typeof s == "number" || typeof s == "string";
}
function Zt(s) {
  const t = [];
  return te(s, t), new Uint8Array(t);
}
function te(s, t) {
  if (s === null)
    t.push(246);
  else if (s === void 0)
    t.push(247);
  else if (typeof s == "boolean")
    t.push(s ? 245 : 244);
  else if (typeof s == "number")
    Zn(s, t);
  else if (typeof s == "string")
    $e(s, t);
  else if (Array.isArray(s))
    es(s, t);
  else if (s instanceof Uint8Array)
    ts(s, t);
  else if (
    // Defensive: POJO only (null/array handled above)
    typeof s == "object" && s !== null && !Array.isArray(s)
  )
    ns(s, t);
  else
    throw new Error("Unsupported type");
}
function Jn(s, t) {
  if (s < 24)
    t.push(s);
  else if (s < 256)
    t.push(24, s);
  else if (s < 65536)
    t.push(25, s >>> 8 & 255, s & 255);
  else if (s < 4294967296)
    t.push(
      26,
      s >>> 24 & 255,
      s >>> 16 & 255,
      s >>> 8 & 255,
      s & 255
    );
  else
    throw new Error("Unsupported integer size");
}
function Xn(s, t) {
  const e = -1 - s;
  if (e < 24)
    t.push(32 | e);
  else if (e < 256)
    t.push(56, e & 255);
  else if (e < 65536)
    t.push(57, e >>> 8 & 255, e & 255);
  else if (e < 4294967296)
    t.push(
      58,
      e >>> 24 & 255,
      e >>> 16 & 255,
      e >>> 8 & 255,
      e & 255
    );
  else
    throw new Error("Unsupported integer size");
}
function Yn(s, t) {
  const e = new ArrayBuffer(8), n = new DataView(e);
  n.setFloat64(0, s, !1), t.push(251);
  for (let r = 0; r < 8; r++) t.push(n.getUint8(r));
}
function Zn(s, t) {
  Number.isInteger(s) ? s >= 0 ? Jn(s, t) : Xn(s, t) : Yn(s, t);
}
function ts(s, t) {
  const e = s.length;
  if (e < 24)
    t.push(64 + e);
  else if (e < 256)
    t.push(88, e);
  else if (e < 65536)
    t.push(89, e >> 8 & 255, e & 255);
  else if (e < 4294967296)
    t.push(
      90,
      e >>> 24 & 255,
      e >>> 16 & 255,
      e >>> 8 & 255,
      e & 255
    );
  else
    throw new Error("Byte string too long to encode");
  for (let n = 0; n < s.length; n++)
    t.push(s[n]);
}
function $e(s, t) {
  const e = new TextEncoder().encode(s), n = e.length;
  if (n < 24)
    t.push(96 + n);
  else if (n < 256)
    t.push(120, n);
  else if (n < 65536)
    t.push(121, n >>> 8 & 255, n & 255);
  else if (n < 4294967296)
    t.push(
      122,
      n >>> 24 & 255,
      n >>> 16 & 255,
      n >>> 8 & 255,
      n & 255
    );
  else
    throw new Error("String too long to encode");
  for (let r = 0; r < e.length; r++)
    t.push(e[r]);
}
function es(s, t) {
  const e = s.length;
  if (e < 24)
    t.push(128 | e);
  else if (e < 256)
    t.push(152, e);
  else if (e < 65536)
    t.push(153, e >>> 8 & 255, e & 255);
  else
    throw new Error("Unsupported array length");
  for (const n of s)
    te(n, t);
}
function ns(s, t) {
  const e = Object.keys(s), n = e.length;
  if (n >= 4294967296)
    throw new Error("Object has too many keys to encode");
  n < 24 ? t.push(160 | n) : n < 256 ? t.push(184, n) : n < 65536 ? t.push(185, n >> 8 & 255, n & 255) : t.push(
    186,
    n >> 24 & 255,
    n >> 16 & 255,
    n >> 8 & 255,
    n & 255
  );
  for (const r of e)
    $e(r, t), te(s[r], t);
}
function ee(s) {
  const t = new DataView(s.buffer, s.byteOffset, s.byteLength);
  return _t(t, 0).value;
}
function _t(s, t) {
  if (t >= s.byteLength)
    throw new Error("Unexpected end of data");
  const e = s.getUint8(t++), n = e >> 5, r = e & 31;
  switch (n) {
    case 0:
      return ss(s, t, r);
    case 1:
      return rs(s, t, r);
    case 2:
      return is(s, t, r);
    case 3:
      return os(s, t, r);
    case 4:
      return as(s, t, r);
    case 5:
      return cs(s, t, r);
    case 7:
      return hs(s, t, r);
    default:
      throw new Error(`Unsupported major type: ${n}`);
  }
}
function Q(s, t, e) {
  if (t + e > s.byteLength)
    throw new Error("Unexpected end of data");
}
function ot(s, t, e) {
  if (e < 24) return { value: e, offset: t };
  if (e === 24)
    return Q(s, t, 1), { value: s.getUint8(t++), offset: t };
  if (e === 25) {
    Q(s, t, 2);
    const n = s.getUint16(t, !1);
    return t += 2, { value: n, offset: t };
  }
  if (e === 26) {
    Q(s, t, 4);
    const n = s.getUint32(t, !1);
    return t += 4, { value: n, offset: t };
  }
  if (e === 27) {
    Q(s, t, 8);
    const n = s.getUint32(t, !1), r = s.getUint32(t + 4, !1);
    return t += 8, { value: n * 2 ** 32 + r, offset: t };
  }
  throw new Error(`Unsupported length: ${e}`);
}
function ss(s, t, e) {
  const { value: n, offset: r } = ot(s, t, e);
  return { value: n, offset: r };
}
function rs(s, t, e) {
  const { value: n, offset: r } = ot(s, t, e);
  return { value: -1 - n, offset: r };
}
function is(s, t, e) {
  const { value: n, offset: r } = ot(s, t, e);
  if (r + n > s.byteLength)
    throw new Error("Byte string length exceeds data length");
  return { value: new Uint8Array(s.buffer, s.byteOffset + r, n), offset: r + n };
}
function os(s, t, e) {
  const { value: n, offset: r } = ot(s, t, e);
  if (r + n > s.byteLength)
    throw new Error("String length exceeds data length");
  const i = new Uint8Array(s.buffer, s.byteOffset + r, n);
  return { value: new TextDecoder().decode(i), offset: r + n };
}
function as(s, t, e) {
  const { value: n, offset: r } = ot(s, t, e), i = [];
  let o = r;
  for (let a = 0; a < n; a++) {
    const c = _t(s, o);
    i.push(c.value), o = c.offset;
  }
  return { value: i, offset: o };
}
function cs(s, t, e) {
  const { value: n, offset: r } = ot(s, t, e), i = {};
  let o = r;
  for (let a = 0; a < n; a++) {
    const c = _t(s, o);
    if (!Vn(c.value))
      throw new Error("Invalid key type");
    const u = _t(s, c.offset);
    i[c.value] = u.value, o = u.offset;
  }
  return { value: i, offset: o };
}
function us(s) {
  const t = (s & 31744) >> 10, e = s & 1023, n = s & 32768 ? -1 : 1;
  return t === 0 ? n * 2 ** -14 * (e / 1024) : t === 31 ? e ? NaN : n * (1 / 0) : n * 2 ** (t - 15) * (1 + e / 1024);
}
function hs(s, t, e) {
  if (e < 24)
    switch (e) {
      case 20:
        return { value: !1, offset: t };
      case 21:
        return { value: !0, offset: t };
      case 22:
        return { value: null, offset: t };
      case 23:
        return { value: void 0, offset: t };
      default:
        throw new Error(`Unknown simple value: ${e}`);
    }
  if (e === 24)
    return Q(s, t, 1), { value: s.getUint8(t++), offset: t };
  if (e === 25) {
    Q(s, t, 2);
    const n = us(s.getUint16(t, !1));
    return t += 2, { value: n, offset: t };
  }
  if (e === 26) {
    Q(s, t, 4);
    const n = s.getFloat32(t, !1);
    return t += 4, { value: n, offset: t };
  }
  if (e === 27) {
    Q(s, t, 8);
    const n = s.getFloat64(t, !1);
    return t += 8, { value: n, offset: t };
  }
  throw new Error(`Unknown simple or float value: ${e}`);
}
const ls = Ke("Secp256k1_HashToCurve_Cashu_");
function pt(s) {
  const t = B(w.concat(ls, s)), e = new Uint32Array(1), n = 2 ** 16;
  for (let r = 0; r < n; r++) {
    const i = new Uint8Array(e.buffer), o = B(w.concat(t, i));
    try {
      return Y(I(w.concat(new Uint8Array([2]), o)));
    } catch {
      e[0]++;
    }
  }
  throw new Error("No valid point found");
}
function He(s) {
  const e = s.map((n) => n.toHex(!1)).join("");
  return B(new TextEncoder().encode(e));
}
function qr(s) {
  return b.Point.fromHex(I(s));
}
function Y(s) {
  return b.Point.fromHex(s);
}
const ds = (s) => {
  let t;
  return /^[a-fA-F0-9]+$/.test(s) ? t = Tt(s) % BigInt(2 ** 31 - 1) : t = w.toBigInt(Xt(s)) % BigInt(2 ** 31 - 1), t;
};
function ne() {
  return b.utils.randomSecretKey();
}
function Rr(s, t, e, n) {
  const r = b.Point.Fn.fromBytes(t);
  return { C_: s.multiply(r), amount: e, id: n };
}
function $r(s) {
  return fs();
}
function fs() {
  const s = I(Mt(32)), t = new TextEncoder().encode(s);
  return yt(t);
}
function yt(s, t) {
  const e = pt(s);
  t || (t = b.Point.Fn.fromBytes(ne()));
  const n = b.Point.BASE.multiply(t);
  return { B_: e.add(n), r: t, secret: s };
}
function ps(s, t, e) {
  return s.subtract(e.multiply(t));
}
function gs(s, t, e, n) {
  const r = n, i = ps(s.C_, t, r);
  return {
    id: s.id,
    amount: s.amount,
    secret: e,
    C: i
  };
}
const ms = (s) => ({
  amount: s.amount,
  C: s.C.toHex(!0),
  id: s.id,
  secret: new TextDecoder().decode(s.secret),
  witness: JSON.stringify(s.witness)
}), Hr = (s) => ({
  amount: s.amount,
  C: Y(s.C),
  id: s.id,
  secret: new TextEncoder().encode(s.secret),
  witness: s.witness ? JSON.parse(s.witness) : void 0
}), We = (s, t) => {
  const e = B(new TextEncoder().encode(s)), n = typeof t == "string" ? T(t) : t, r = ft.sign(e, n);
  return I(r);
}, Bt = (s, t, e, n = !1) => {
  try {
    const r = B(new TextEncoder().encode(t)), i = e.length === 66 ? e.slice(2) : e;
    return ft.verify(T(s), r, T(i));
  } catch (r) {
    if (n)
      throw r;
  }
  return !1;
};
function Rt(s, t, e) {
  return Array.from(new Set(e)).filter(
    (r) => s.some((i) => Bt(i, t, r))
  );
}
const Wr = (s, t, e, n = 1) => Rt(s, t, e).length >= n, Ae = "m/0'/0'/0'";
function ys(s) {
  const t = {};
  return Object.keys(s).forEach((e) => {
    t[e] = I(s[e]);
  }), t;
}
function jr(s) {
  const t = {};
  return Object.keys(s).forEach((e) => {
    t[e] = T(s[e]);
  }), t;
}
function ws(s) {
  return b.getPublicKey(s, !0);
}
function Qr(s, t, e) {
  const { expiry: n, input_fee_ppk: r, unit: i = "sat", versionByte: o = 1 } = e || {};
  let a = 0n;
  const c = {}, u = {};
  let h;
  for (t && (h = Ne.fromMasterSeed(t)); a < s; ) {
    const d = (2n ** a).toString();
    if (h) {
      const f = h.derive(`${Ae}/${a}`).privateKey;
      if (f)
        u[d] = f;
      else
        throw new Error(`Could not derive Private key from: ${Ae}/${a}`);
    } else
      u[d] = ne();
    c[d] = ws(u[d]), a++;
  }
  const l = fe(ys(c), {
    expiry: n,
    input_fee_ppk: r,
    unit: i,
    versionByte: o
  });
  return { pubKeys: c, privKeys: u, keysetId: l };
}
function zr(s, t) {
  const e = pt(s.secret), n = b.Point.Fn.fromBytes(t);
  return e.multiply(n).equals(s.C);
}
function je(s, t, e) {
  const n = [
    s,
    {
      nonce: I(Mt(32)),
      data: t,
      tags: e
    }
  ];
  return JSON.stringify(n);
}
function Ot(s) {
  let t;
  try {
    typeof s == "string" ? t = JSON.parse(s) : t = s;
  } catch {
    throw new Error("Can't parse secret");
  }
  if (!Array.isArray(t) || t.length !== 2 || typeof t[0] != "string" || // kind
  typeof t[1] != "object" || // data
  t[0].trim().length === 0 || t[1] === null)
    throw new Error("Invalid NUT-10 secret");
  const [e, n] = t;
  if (typeof n.nonce != "string" || typeof n.data != "string")
    throw new Error("Invalid NUT-10 secret nonce / data");
  if (n.tags) {
    if (!Array.isArray(n.tags))
      throw new Error("Invalid NUT-10 secret tags");
    if (n.tags.some(
      (i) => !Array.isArray(i) || i.length === 0 || i.some((o) => typeof o != "string" || !o.length)
    ))
      throw new Error("Invalid NUT-10 tag(s)");
  }
  return [
    e,
    {
      nonce: n.nonce,
      data: n.data,
      tags: n.tags
    }
  ];
}
function Qe(s, t) {
  const e = Array.isArray(s) ? s : [s], n = Ot(t), r = n[0];
  if (!e.includes(r))
    throw new Error(`Invalid secret kind: ${r} Allowed: ${e.join(", ")}`);
  return n;
}
function ze(s) {
  return Ot(s)[0];
}
function Ge(s) {
  return Ot(s)[1];
}
function Ve(s) {
  const { data: t } = Ge(s);
  return t;
}
function Je(s) {
  const { tags: t } = Ge(s);
  return t ?? [];
}
function Gr(s, t) {
  return Je(s).some((e) => e[0] === t);
}
function se(s, t) {
  const e = Je(s).find((n) => n[0] === t);
  if (!(!e || e.length <= 1))
    return e.slice(1);
}
function Xe(s, t) {
  const e = se(s, t);
  return e && e.length > 0 ? e[0] : void 0;
}
function re(s, t) {
  const e = Xe(s, t);
  if (e === void 0) return;
  const n = Number.parseInt(e, 10);
  return Number.isFinite(n) ? n : void 0;
}
const Se = Ke("Cashu_P2BK_v1");
function ks(s, t, e) {
  if (!s.length) return { blinded: [], Ehex: "" };
  e = e ?? b.utils.randomSecretKey();
  const n = b.Point.Fn.fromBytes(e), r = b.getPublicKey(e, !0), i = $(t);
  return { blinded: s.map((a, c) => {
    const u = Y(a), h = Ye(u, n, i, c), l = u.add(b.Point.BASE.multiply(h));
    if (l.equals(b.Point.ZERO)) throw new Error("Blinded key at infinity");
    return l.toHex(!0);
  }), Ehex: j(r) };
}
function bs(s, t, e, n) {
  const r = Array.isArray(t) ? t : [t], i = Array.isArray(e) ? e : [e], o = /* @__PURE__ */ new Set(), a = b.Point.fromHex(s), c = $(n);
  for (const u of r) {
    const h = b.Point.Fn.fromBytes($(u)), l = b.getPublicKey($(u), !0);
    i.forEach((d, f) => {
      const p = Ye(a, h, c, f), g = $(d), k = _s(u, p, g, l);
      k && o.add(k);
    });
  }
  return Array.from(o);
}
function _s(s, t, e, n) {
  const r = b.Point.CURVE().n, i = typeof s == "string" ? Tt(s) : s, o = typeof t == "string" ? Tt(t) : t;
  if (i <= 0n || i >= r) throw new Error("Invalid private key");
  if (o <= 0n || o >= r) throw new Error("Invalid scalar r");
  if (n = n ?? b.Point.BASE.multiply(i).toBytes(!0), n.length !== 33) throw new Error("naturalPub must be 33 bytes");
  const a = (i + o) % r, c = (r - i + o) % r;
  if (!e) {
    if (a === 0n) throw new Error("Derived secret key is zero");
    return Wt(a);
  }
  if (e.length !== 33) throw new Error("blindPubkey must be 33 bytes");
  const u = b.Point.fromHex(j(e)), h = b.Point.BASE.multiply(o), l = u.subtract(h);
  if (l.equals(b.Point.ZERO)) return null;
  const d = l.toBytes(!0).slice(1), f = n.slice(1);
  if (!w.equals(d, f))
    return null;
  const p = l.toBytes(!0)[0] & 1, g = n[0] & 1, k = p === g ? a : c;
  if (k === 0n) throw new Error("Derived secret key is zero");
  return Wt(k);
}
function Ye(s, t, e, n) {
  const r = s.multiply(t).toBytes(!0).slice(1), i = new Uint8Array([n & 255]);
  let o = w.toBigInt(B(w.concat(Se, r, e, i)));
  if ((o === 0n || o >= b.Point.CURVE().n) && (o = w.toBigInt(B(w.concat(Se, r, e, i, new Uint8Array([255])))), o === 0n || o >= b.Point.CURVE().n))
    throw new Error("P2BK: tweak derivation failed");
  return o;
}
function Vr(s, t) {
  return je("P2PK", s, t);
}
function N(s) {
  return s instanceof Uint8Array && (s = new TextDecoder().decode(s)), Qe(["P2PK", "HTLC"], s);
}
function Ze(s) {
  try {
    const t = N(s), e = Dt(t), n = ie(t), r = gt(t);
    if (e === "ACTIVE" || e === "PERMANENT")
      return n;
    if (e === "EXPIRED" && r.length) {
      const i = [...n, ...r];
      return Array.from(new Set(i));
    }
  } catch {
  }
  return [];
}
function ie(s) {
  const t = N(s);
  let e = "";
  ze(t) === "P2PK" && (e = Ve(t));
  const n = se(t, "pubkeys") ?? [], r = [e, ...n].filter(Boolean);
  return Array.from(new Set(r));
}
function gt(s) {
  const t = N(s);
  return se(t, "refund") ?? [];
}
function As(s) {
  const t = N(s), e = re(t, "locktime");
  return e === void 0 || !Number.isFinite(e) || e <= 0 ? 1 / 0 : e;
}
function Dt(s, t = Math.floor(Date.now() / 1e3)) {
  const e = N(s), n = As(e);
  return Number.isFinite(n) ? t < n ? "ACTIVE" : "EXPIRED" : "PERMANENT";
}
function Ss(s) {
  const t = N(s), e = Dt(t);
  return !gt(t).length && e === "EXPIRED" ? 0 : re(t, "n_sigs") ?? 1;
}
function Ps(s) {
  const t = N(s), e = Dt(t);
  return gt(t).length && e === "EXPIRED" ? re(t, "n_sigs_refund") ?? 1 : 0;
}
function $t(s) {
  const t = N(s);
  return Xe(t, "sigflag") === "SIG_ALL" ? "SIG_ALL" : "SIG_INPUTS";
}
function oe(s) {
  return tn(s)?.signatures ?? [];
}
function tn(s) {
  if (!s) return;
  let t;
  try {
    t = typeof s == "string" ? JSON.parse(s) : s;
  } catch (n) {
    console.error("Failed to parse witness string:", n);
    return;
  }
  const e = {
    // always normalise signatures to an array
    signatures: t.signatures ?? []
  };
  return typeof t.preimage == "string" && t.preimage.length > 0 && (e.preimage = t.preimage), e;
}
function Pe(s, t, e = M, n) {
  const r = (o) => typeof o == "string" ? o : I(o), i = Array.isArray(t) ? t.map(r) : r(t);
  return s.map((o, a) => {
    const c = Es(i, o);
    let u = o;
    for (const h of c)
      try {
        u = vs(u, h, n);
      } catch (l) {
        const d = l instanceof Error ? l.message : "Unknown error";
        e.warn(`Proof #${a + 1}: ${d}`);
      }
    return u;
  });
}
function vs(s, t, e) {
  const n = N(s.secret);
  e = e ?? s.secret;
  const r = typeof t == "string" ? T(t) : t, i = I(ft.getPublicKey(r)), o = Ze(n);
  if (!o.length || !o.some((d) => d.includes(i)))
    throw new Error(`Signature not required from [02|03]${i}`);
  if (oe(s.witness).some((d) => Bt(d, e, i)))
    throw new Error(`Proof already signed by [02|03]${i}`);
  const u = We(e, t), h = tn(s.witness), l = {
    ...h && h.preimage !== void 0 ? { preimage: h.preimage } : {},
    signatures: [...h?.signatures ?? [], u]
  };
  return { ...s, witness: l };
}
function Jr(s, t, e) {
  if (!t.witness)
    return !1;
  if (At([t]) && !e)
    throw new Error("Cannot verify a SIG_ALL proof without the message to sign");
  return e = e ?? t.secret, oe(t.witness).some((r) => Bt(r, e, s));
}
function en(s, t = M, e) {
  if (At([s]) && !e)
    throw t.error("Cannot verify a SIG_ALL proof without the message to sign"), new Error("Cannot verify a SIG_ALL proof without the message to sign");
  e = e ?? s.secret;
  const n = N(s.secret), r = oe(s.witness), i = Dt(n), o = ie(n), a = Ss(n), c = Rt(r, e, o), u = {
    success: !0,
    path: "MAIN",
    lockState: i,
    requiredSigners: a,
    eligibleSigners: o.length,
    receivedSigners: c
  };
  let h = u;
  if (o.length && a > 0 && c.length >= a)
    return t.debug("Spending condition satisfied via main pubkeys", { result: h }), h;
  if (i !== "EXPIRED")
    return h = { ...u, success: !1, path: "FAILED" }, t.debug("P2PK lock enabled, but threshold not met by main pubkeys", { result: h }), h;
  t.debug("P2PK lock expired. Checking refund path.", { lockState: i });
  const l = gt(n);
  if (l.length) {
    const d = Ps(n), f = Rt(r, e, l), p = {
      ...u,
      path: "REFUND",
      requiredSigners: d,
      eligibleSigners: l.length,
      receivedSigners: f
    };
    return d > 0 && f.length >= d ? (h = p, t.debug("Spending condition satisfied via refund pubkeys", { result: h }), h) : (h = { ...p, success: !1, path: "FAILED" }, t.debug("Spending threshold not met by refund pubkeys", { result: h }), h);
  }
  return h = { ...u, path: "UNLOCKED" }, t.debug("No refund pubkeys, anyone can spend.", { result: h }), h;
}
function Ts(s, t = M, e) {
  return en(s, t, e).success;
}
function Es(s, t) {
  const e = Array.isArray(s) ? s : [s], n = t?.p2pk_e;
  if (!n)
    return Array.from(new Set(e));
  const r = N(t.secret), i = [...ie(r), ...gt(r)], o = t.id;
  return bs(n, e, i, o);
}
function Is(s) {
  if (s.length === 0) throw new Error("No proofs");
  const t = N(s[0].secret);
  if ($t(t) !== "SIG_ALL") throw new Error("First proof is not SIG_ALL");
  const e = t[1].data, n = JSON.stringify(t[1].tags ?? []);
  for (let r = 1; r < s.length; r++) {
    const i = N(s[r].secret);
    if (i[0] !== t[0]) throw new Error(`Proof #${r + 1} is not ${t[0]}`);
    if ($t(i) !== "SIG_ALL") throw new Error(`Proof #${r + 1} is not SIG_ALL`);
    if (i[1].data !== e) throw new Error("SIG_ALL inputs must share identical Secret.data");
    if (JSON.stringify(i[1].tags ?? []) !== n)
      throw new Error("SIG_ALL inputs must share identical Secret.tags");
  }
}
function Ms(s, t, e) {
  const n = [];
  for (const r of s)
    n.push(r.secret, r.C);
  for (const r of t)
    n.push(String(r.blindedMessage.amount), r.blindedMessage.B_);
  return e && n.push(e), n.join("");
}
function At(s) {
  return s.some((t) => {
    try {
      return $t(t.secret) === "SIG_ALL";
    } catch {
      return !1;
    }
  });
}
function Cs(s, t, e) {
  const n = [];
  for (const r of s)
    n.push(r.secret, r.C);
  for (const r of t)
    n.push(String(r.blindedMessage.amount), r.blindedMessage.id, r.blindedMessage.B_);
  return e && n.push(e), n.join("");
}
function xs(s, t, e) {
  const n = [];
  for (const r of s)
    n.push(r.secret);
  for (const r of t)
    n.push(r.blindedMessage.B_);
  return e && n.push(e), n.join("");
}
const Xr = (s, t) => We(s, t), Yr = (s, t, e) => Bt(s, t, e);
function Zr(s) {
  return Ze(s);
}
function ti(s) {
  return Ts(s);
}
function Bs(s, t) {
  if (s.length !== t.length) return !1;
  for (let e = 0; e < s.length; e++)
    if (s[e] !== t[e]) return !1;
  return !0;
}
const Os = (s, t, e, n) => {
  const r = b.Point.Fn.fromBytes(s.s), i = b.Point.Fn.fromBytes(s.e), o = b.Point.BASE.multiply(r), a = n.multiply(i), c = t.multiply(r), u = e.multiply(i), h = o.subtract(a), l = c.subtract(u), d = He([h, l, n, e]);
  return Bs(d, s.e);
}, Ds = (s, t, e, n) => {
  if (t.r === void 0) throw new Error("verifyDLEQProof_reblind: Undefined blinding factor");
  const r = pt(s), i = e.add(n.multiply(t.r)), o = b.Point.BASE.multiply(t.r), a = r.add(o);
  return Os(t, a, i, n);
}, ei = (s, t) => {
  const e = b.Point.Fn.fromBytes(ne()), n = b.Point.BASE.multiply(e), r = s.multiply(e), i = b.Point.Fn.fromBytes(t), o = s.multiply(i), a = b.Point.BASE.multiply(i), c = He([n, r, a, o]), u = b.Point.Fn.fromBytes(c), h = b.Point.Fn.add(e, b.Point.Fn.mul(u, i));
  return { s: Nn(h, 32), e: c };
}, Ks = "m/129372'/0'", ve = BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141"), Ns = (s, t, e) => {
  const n = /^[a-fA-F0-9]+$/.test(t);
  if (!n && xt(t) || n && t.startsWith("00"))
    return St(
      s,
      t,
      e,
      0
      /* SECRET */
    );
  if (n && t.startsWith("01"))
    return nn(
      s,
      t,
      e,
      0
      /* SECRET */
    );
  throw new Error(`Unrecognized keyset ID version ${t.slice(0, 2)}`);
}, Ls = (s, t, e) => {
  const n = /^[a-fA-F0-9]+$/.test(t);
  if (!n && xt(t) || n && t.startsWith("00"))
    return St(
      s,
      t,
      e,
      1
      /* BLINDING_FACTOR */
    );
  if (n && t.startsWith("01"))
    return nn(
      s,
      t,
      e,
      1
      /* BLINDING_FACTOR */
    );
  throw new Error(`Unrecognized keyset ID version ${t.slice(0, 2)}`);
}, nn = (s, t, e, n) => {
  let r = w.concat(
    w.fromString("Cashu_KDF_HMAC_SHA256"),
    w.fromHex(t),
    w.writeBigUint64BE(BigInt(e))
  );
  switch (n) {
    case 0:
      r = w.concat(r, w.fromHex("00"));
      break;
    case 1:
      r = w.concat(r, w.fromHex("01"));
  }
  const i = Ln(B, s, r);
  if (n === 1) {
    const o = w.toBigInt(i);
    if (o >= ve)
      return w.fromBigInt(o - ve);
    if (o === 0n)
      throw new Error("Derived invalid blinding scalar r == 0");
    return i;
  }
  return i;
}, St = (s, t, e, n) => {
  const r = Ne.fromMasterSeed(s), i = ds(t), o = `${Ks}/${i}'/${e}'/${n}`, a = r.derive(o);
  if (a.privateKey === null)
    throw new Error("Could not derive private key");
  return a.privateKey;
};
function ni(s, t) {
  return je("HTLC", s, t);
}
function si(s) {
  return Qe("HTLC", s);
}
function Us(s) {
  const t = s !== void 0;
  if (t && !/^[0-9a-f]{64}$/i.test(s))
    throw new Error("Preimage must be a 64 character hexadecimal string (32 bytes).");
  const e = t ? T(s) : Mt(32);
  return { hash: I(B(e)), preimage: I(e) };
}
function Fs(s, t) {
  const { hash: e } = Us(s);
  return t === e;
}
function qs(s, t = M, e) {
  let n;
  e = e ?? s.secret;
  const r = Ot(s.secret), i = en(s, t, e);
  if (i.path != "MAIN" || ze(r) !== "HTLC")
    return i;
  const o = Rs(s.witness);
  if (!o)
    return n = { ...i, success: !1, path: "FAILED" }, t.debug("Hashlock spend failed, no preimage found", { result: n }), n;
  const a = Ve(r);
  return Fs(o, a) ? (n = i, t.debug("Spending condition satisfied via hashlock (receiver) pathway", { result: n }), n) : (n = { ...i, success: !1, path: "FAILED" }, t.debug("Hashlock spend failed, wrong preimage for hash", { result: n }), n);
}
function ri(s, t = M, e) {
  return qs(s, t, e).success;
}
function Rs(s) {
  if (!s) return;
  let t;
  try {
    t = typeof s == "string" ? JSON.parse(s) : s;
  } catch (n) {
    console.error("Failed to parse HTLC witness string:", n);
    return;
  }
  const e = t.preimage;
  return typeof e == "string" && e.length > 0 ? e : void 0;
}
function sn(s, t) {
  let e = s;
  for (const r of t)
    e += r.B_;
  const n = new TextEncoder().encode(e);
  return B(n);
}
function $s(s, t, e) {
  const n = sn(t, e), r = $(s), i = ft.sign(n, r);
  return j(i);
}
function ii(s, t, e, n) {
  const r = $(n);
  let i = $(s);
  if (i.length !== 33) return !1;
  i = i.slice(1);
  const o = sn(t, e);
  return ft.verify(r, o, i);
}
var Pt = /* @__PURE__ */ ((s) => (s.POST = "post", s.NOSTR = "nostr", s))(Pt || {});
const rn = 1, on = 2, Ht = 3, an = 4, cn = 5, un = 6, hn = 7, ln = 8, dn = 1, fn = 2, pn = 3, ae = 0, gn = 1, mn = 1, yn = 2, wn = 3, kn = 0, bn = 1;
function Hs(s) {
  const t = ce(s), e = {};
  for (const n of t)
    switch (n.tag) {
      case rn:
        e.id = X(n.value);
        break;
      case on:
        e.amount = js(n.value);
        break;
      case Ht:
        n.value.length === 1 && n.value[0] === 0 ? e.unit = "sat" : e.unit = X(n.value);
        break;
      case an:
        e.singleUse = ue(n.value) === 1;
        break;
      case cn:
        e.mints || (e.mints = []), e.mints.push(X(n.value));
        break;
      case un:
        e.description = X(n.value);
        break;
      case hn:
        e.transports || (e.transports = []), e.transports.push(Gs(n.value));
        break;
      case ln:
        e.nut10 || (e.nut10 = []), e.nut10.push(Vs(n.value));
        break;
    }
  return e;
}
function ce(s) {
  const t = [];
  let e = 0;
  for (; e < s.length; ) {
    const n = Ws(s.subarray(e));
    t.push(n), e += 3 + n.length;
  }
  return t;
}
function Ws(s) {
  if (s.length < 3)
    throw new Error("TLV data too short: need at least 3 bytes for tag and length");
  const t = new DataView(s.buffer, s.byteOffset, s.byteLength), e = t.getUint8(0), n = t.getUint16(1, !1);
  if (s.length < 3 + n)
    throw new Error(`TLV data too short: expected ${3 + n} bytes, got ${s.length}`);
  const r = s.subarray(3, 3 + n);
  return { tag: e, length: n, value: r };
}
function X(s) {
  return new TextDecoder().decode(s);
}
function js(s) {
  if (s.length !== 8)
    throw new Error(`Invalid u64: expected 8 bytes, got ${s.length}`);
  return new DataView(s.buffer, s.byteOffset, s.byteLength).getBigUint64(0, !1);
}
function ue(s) {
  if (s.length !== 1)
    throw new Error(`Invalid u8: expected 1 byte, got ${s.length}`);
  return s[0];
}
function Qs(s) {
  switch (s) {
    case ae:
      return "nostr";
    case gn:
      return "post";
    default:
      throw new Error(`Unsupported transport kind: ${s}`);
  }
}
function zs(s) {
  switch (s) {
    case kn:
      return "P2PK";
    case bn:
      return "HTLC";
    default:
      throw new Error(`Unsupported NUT-10 kind: ${s}`);
  }
}
function Gs(s) {
  const t = ce(s);
  let e, n, r;
  for (const a of t)
    switch (a.tag) {
      case dn:
        e = ue(a.value);
        break;
      case fn:
        n = a.value;
        break;
      case pn:
        r || (r = []), r.push(_n(a.value));
        break;
    }
  if (e === void 0)
    throw new Error("Transport missing required kind field");
  if (n === void 0)
    throw new Error("Transport missing required target field");
  let i;
  if (e === ae) {
    const a = r?.filter((c) => c[0] === "r").flatMap((c) => c.slice(1)) ?? [];
    i = sr(n, a), r = r?.filter((c) => c[0] !== "r");
  } else
    i = X(n);
  const o = r && r.length > 0 ? r : void 0;
  return {
    type: Qs(e),
    target: i,
    tags: o
  };
}
function Vs(s) {
  const t = ce(s);
  let e, n, r;
  for (const o of t)
    switch (o.tag) {
      case mn:
        e = ue(o.value);
        break;
      case yn:
        n = X(o.value);
        break;
      case wn:
        r || (r = []), r.push(_n(o.value));
        break;
    }
  if (e === void 0)
    throw new Error("NUT-10 spending condition missing required kind field");
  if (n === void 0)
    throw new Error("NUT-10 spending condition missing required data field");
  const i = r && r.length > 0 ? r : void 0;
  return {
    kind: zs(e),
    data: n,
    tags: i
  };
}
function _n(s) {
  const t = [];
  let e = 0;
  for (; e < s.length; ) {
    const n = s[e];
    if (e += 1, s.length - e < n)
      throw new Error(
        `Tag tuple data too short: expected ${n} bytes, got ${s.length - e}`
      );
    const r = X(s.subarray(e, e + n));
    t.push(r), e += n;
  }
  return t;
}
function Js(s) {
  const t = [];
  if (s.id && t.push(C(rn, st(s.id))), s.amount !== void 0 && t.push(C(on, Xs(s.amount))), s.unit && (s.unit === "sat" ? t.push(C(Ht, new Uint8Array([0]))) : t.push(C(Ht, st(s.unit)))), s.singleUse !== void 0 && t.push(C(an, he(s.singleUse ? 1 : 0))), s.mints && s.mints.length > 0)
    for (const i of s.mints)
      t.push(C(cn, st(i)));
  if (s.description && t.push(C(un, st(s.description))), s.transports && s.transports.length > 0)
    for (const i of s.transports)
      t.push(C(hn, tr(i)));
  if (s.nut10 && s.nut10.length > 0)
    for (const i of s.nut10)
      t.push(C(ln, er(i)));
  const e = t.reduce((i, o) => i + o.length, 0), n = new Uint8Array(e);
  let r = 0;
  for (const i of t)
    n.set(i, r), r += i.length;
  return n;
}
function C(s, t) {
  const e = t.length;
  if (e > 65535)
    throw new Error(`TLV value too long: ${e} bytes (max 65535)`);
  const n = new Uint8Array(3 + e);
  return n[0] = s, n[1] = e >> 8 & 255, n[2] = e & 255, n.set(t, 3), n;
}
function st(s) {
  return new TextEncoder().encode(s);
}
function Xs(s) {
  const t = new ArrayBuffer(8);
  return new DataView(t).setBigUint64(0, s, !1), new Uint8Array(t);
}
function he(s) {
  return new Uint8Array([s]);
}
function Ys(s) {
  switch (s) {
    case Pt.NOSTR:
      return ae;
    case Pt.POST:
      return gn;
    default:
      throw new Error(`Unsupported transport type: ${s}`);
  }
}
function Zs(s) {
  switch (s) {
    case "P2PK":
      return kn;
    case "HTLC":
      return bn;
    default:
      throw new Error(`Unsupported NUT-10 type: ${s}`);
  }
}
function tr(s) {
  const t = [], e = Ys(s.type);
  t.push(C(dn, he(e)));
  let n, r = [];
  if (s.type === Pt.NOSTR) {
    const { pubkey: u, relays: h } = nr(s.target);
    n = u, r = h.map((l) => ["r", l]);
  } else
    n = st(s.target);
  t.push(C(fn, n));
  const i = [...r, ...s.tags || []];
  if (i.length > 0)
    for (const u of i)
      t.push(C(pn, An(u)));
  const o = t.reduce((u, h) => u + h.length, 0), a = new Uint8Array(o);
  let c = 0;
  for (const u of t)
    a.set(u, c), c += u.length;
  return a;
}
function er(s) {
  const t = [], e = Zs(s.kind);
  if (t.push(C(mn, he(e))), t.push(C(yn, st(s.data))), s.tags && s.tags.length > 0)
    for (const o of s.tags)
      t.push(C(wn, An(o)));
  const n = t.reduce((o, a) => o + a.length, 0), r = new Uint8Array(n);
  let i = 0;
  for (const o of t)
    r.set(o, i), i += o.length;
  return r;
}
function An(s) {
  const t = new TextEncoder(), e = [];
  for (const o of s) {
    const a = t.encode(o);
    if (a.length > 255)
      throw new Error(`Tag tuple string too long: ${o} (max 255 bytes)`);
    const c = new Uint8Array(1 + a.length);
    c[0] = a.length, c.set(a, 1), e.push(c);
  }
  const n = e.reduce((o, a) => o + a.length, 0), r = new Uint8Array(n);
  let i = 0;
  for (const o of e)
    r.set(o, i), i += o.length;
  return r;
}
function nr(s) {
  const t = kt.decode(s, 1024);
  if (t.prefix !== "nprofile")
    throw new Error(`Invalid nprofile: expected prefix 'nprofile', got '${t.prefix}'`);
  const e = kt.fromWords(t.words), n = new Uint8Array(e);
  let r;
  const i = [];
  let o = 0;
  for (; o < n.length; ) {
    if (o + 2 > n.length)
      throw new Error("Nprofile TLV data too short");
    const a = n[o], c = n[o + 1];
    if (o += 2, o + c > n.length)
      throw new Error(`Nprofile TLV value too short: expected ${c} bytes`);
    const u = n.subarray(o, o + c);
    if (o += c, a === 0) {
      if (u.length !== 32)
        throw new Error(`Invalid pubkey length: expected 32 bytes, got ${u.length}`);
      r = u;
    } else a === 1 && i.push(new TextDecoder().decode(u));
  }
  if (!r)
    throw new Error("Nprofile missing required pubkey");
  return { pubkey: r, relays: i };
}
function sr(s, t) {
  const e = rr(s, t), n = kt.toWords(e);
  return kt.encode("nprofile", n, 1024);
}
function rr(s, t) {
  if (s.length !== 32)
    throw new Error(`Invalid pubkey: expected 32 bytes, got ${s.length}`);
  const e = new TextEncoder(), n = t.map((a) => e.encode(a));
  for (let a = 0; a < n.length; a++)
    if (n[a].length > 255)
      throw new Error(`Relay URL too long: ${t[a]} (max 255 bytes)`);
  const r = 34 + n.reduce((a, c) => a + 2 + c.length, 0), i = new Uint8Array(r);
  let o = 0;
  i[o++] = 0, i[o++] = 32, i.set(s, o), o += 32;
  for (const a of n)
    i[o++] = 1, i[o++] = a.length, i.set(a, o), o += a.length;
  return i;
}
class vt {
  constructor(t, e, n, r, i, o, a = !1, c, u = !1) {
    this.transport = t, this.id = e, this.amount = n, this.unit = r, this.mints = i, this.description = o, this.singleUse = a, this.nut10 = c, this.nut26 = u;
  }
  toRawRequest() {
    const t = {};
    return this.transport && (t.t = this.transport.map((e) => ({
      t: e.type,
      a: e.target,
      g: e.tags
    }))), this.id && (t.i = this.id), this.amount && (t.a = this.amount), this.unit && (t.u = this.unit), this.mints && (t.m = this.mints), this.description && (t.d = this.description), this.singleUse && (t.s = this.singleUse), this.nut10 && (t.nut10 = {
      k: this.nut10.kind,
      d: this.nut10.data,
      t: this.nut10.tags
    }), this.nut26 && (t.nut26 = this.nut26), t;
  }
  toEncodedRequest() {
    const t = this.toRawRequest(), e = Zt(t);
    return "creqA" + w.toBase64(e);
  }
  /**
   * Encodes the payment request to creqA format (CBOR).
   *
   * @returns A base64 encoded payment request string with 'creqA' prefix.
   */
  toEncodedCreqA() {
    return this.toEncodedRequest();
  }
  /**
   * Encodes the payment request to creqB format (TLV + bech32m).
   *
   * @returns A bech32m encoded payment request string with 'CREQB' prefix.
   * @experimental
   */
  toEncodedCreqB() {
    const t = {
      id: this.id,
      amount: this.amount !== void 0 ? BigInt(this.amount) : void 0,
      unit: this.unit,
      singleUse: this.singleUse,
      mints: this.mints,
      description: this.description,
      transports: this.transport,
      nut10: this.nut10 ? [
        {
          kind: this.nut10.kind,
          data: this.nut10.data,
          tags: this.nut10.tags
        }
      ] : void 0
    }, e = Js(t);
    return Qn("creqb", e).toUpperCase();
  }
  getTransport(t) {
    return this.transport?.find((e) => e.type === t);
  }
  /**
   * Creates a PaymentRequest from a raw payment request. Supports both creqA and creqB versions.
   *
   * @param rawPaymentRequest - The raw payment request string to create a PaymentRequest from.
   * @returns A PaymentRequest object.
   * @throws An error if the raw payment request is not supported.
   */
  static fromRawRequest(t) {
    const e = t.t ? t.t.map((r) => ({
      type: r.t,
      target: r.a,
      tags: r.g
    })) : void 0, n = t.nut10 ? {
      kind: t.nut10.k,
      data: t.nut10.d,
      tags: t.nut10.t
    } : void 0;
    return new vt(
      e,
      t.i,
      t.a,
      t.u,
      t.m,
      t.d,
      t.s,
      n,
      t.nut26
    );
  }
  static fromEncodedRequest(t) {
    const e = t.toLowerCase();
    if (e.startsWith("creqb")) {
      const a = Gn(e), c = Hs(a);
      return new vt(
        c.transports,
        c.id,
        c.amount !== void 0 ? Number(c.amount) : void 0,
        c.unit,
        c.mints,
        c.description,
        c.singleUse ?? !1,
        void 0,
        !1
      );
    }
    if (!t.startsWith("creq"))
      throw new Error("unsupported pr: invalid prefix");
    if (t[4] !== "A")
      throw new Error("unsupported pr version");
    const r = t.slice(5), i = Xt(r), o = ee(i);
    return this.fromRawRequest(o);
  }
}
function z(s, t, e, n) {
  if (e) {
    const i = Te(e);
    if (s === 0 && i === 0)
      return e;
    const o = e.filter((c) => c > 0), a = Te(o);
    if (a > s)
      throw new Error(`Split is greater than total amount: ${a} > ${s}`);
    if (o.some((c) => !Pn(c, t)))
      throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");
    if (a === s)
      return o;
    e = o, s -= a;
  } else
    e = [];
  const r = Sn(t, "desc");
  if (!r || r.length === 0)
    throw new Error("Cannot split amount, keyset is inactive or contains no keys");
  for (const i of r) {
    if (i <= 0) continue;
    const o = Math.floor(s / i);
    if (e.push(...Array(o).fill(i)), s -= i * o, s === 0) break;
  }
  if (s !== 0)
    throw new Error(`Unable to split remaining amount: ${s}`);
  return n ? e.sort((i, o) => n === "desc" ? o - i : i - o) : e;
}
function ir(s, t, e, n) {
  const r = [], i = s.map((c) => c.amount);
  Sn(e, "asc").forEach((c) => {
    const u = i.filter((l) => l === c).length, h = Math.max(n - u, 0);
    for (let l = 0; l < h && !(r.reduce((d, f) => d + f, 0) + c > t); ++l)
      r.push(c);
  });
  const a = t - r.reduce((c, u) => c + u, 0);
  return a && z(a, e).forEach((u) => {
    r.push(u);
  }), r.sort((c, u) => c - u);
}
function Sn(s, t = "desc") {
  return t == "desc" ? Object.keys(s).map((e) => parseInt(e)).sort((e, n) => n - e) : Object.keys(s).map((e) => parseInt(e)).sort((e, n) => e - n);
}
function Pn(s, t) {
  return s in t;
}
function oi(s) {
  return w.toBigInt(s);
}
function Tt(s) {
  return BigInt(`0x${s}`);
}
function Wt(s) {
  return s.toString(16).padStart(64, "0");
}
function it(s) {
  return /^[a-f0-9]*$/i.test(s);
}
function le(s) {
  return Array.isArray(s) ? s.some((t) => !it(t.id)) : !it(s.id);
}
function ai(s, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function or(s, t) {
  le(s.proofs) || (s.proofs = vn(s.proofs)), t && (s.proofs = Cn(s.proofs));
  const e = { token: [{ mint: s.mint, proofs: s.proofs }] };
  return s.unit && (e.unit = s.unit), s.memo && (e.memo = s.memo), "cashu" + "A" + Re(e);
}
function vn(s) {
  return s.map((t) => {
    const e = { ...t };
    return e.id = e.id.slice(0, 16), e;
  });
}
function ci(s, t) {
  if (le(s.proofs) || t?.version === 3) {
    if (t?.version === 4)
      throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");
    return or(s, t?.removeDleq);
  }
  return ar(s, t?.removeDleq);
}
function ar(s, t) {
  if (t && (s.proofs = Cn(s.proofs)), s.proofs.forEach((c) => {
    if (c.dleq && c.dleq.r == null)
      throw new Error("Missing blinding factor in included DLEQ proof");
  }), le(s.proofs))
    throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");
  s.proofs = vn(s.proofs);
  const n = Tn(s), r = Zt(n), i = "cashu", o = "B", a = qt(r);
  return i + o + a;
}
function Tn(s) {
  const t = {}, e = s.mint;
  for (let r = 0; r < s.proofs.length; r++) {
    const i = s.proofs[r];
    t[i.id] ? t[i.id].push(i) : t[i.id] = [i];
  }
  const n = {
    m: e,
    u: s.unit || "sat",
    t: Object.keys(t).map(
      (r) => ({
        i: T(r),
        p: t[r].map(
          (i) => ({
            a: i.amount,
            s: i.secret,
            c: T(i.C),
            ...i.dleq && {
              d: {
                e: T(i.dleq.e),
                s: T(i.dleq.s),
                r: T(i.dleq.r ?? "00")
              }
            },
            ...i.p2pk_e && {
              pe: T(i.p2pk_e)
            },
            ...i.witness && {
              w: JSON.stringify(i.witness)
            }
          })
        )
      })
    )
  };
  return s.memo && (n.d = s.memo), n;
}
function de(s, t = !1) {
  if (typeof s != "number" || !Number.isFinite(s) || !Number.isInteger(s))
    throw new Error(`Invalid amount: ${String(s)}`);
  if (!Number.isSafeInteger(s))
    throw new Error(`Amount must be a safe integer: ${s}`);
  if (t ? s < 0 : s <= 0)
    throw new Error(`Amount must be ${t ? "non-negative" : "positive"}: ${s}`);
}
function En(s) {
  const t = [];
  s.t.forEach(
    (n) => n.p.forEach((r) => {
      de(r.a, !0), t.push({
        secret: r.s,
        C: I(r.c),
        amount: r.a,
        id: I(n.i),
        ...r.d && {
          dleq: {
            r: I(r.d.r),
            s: I(r.d.s),
            e: I(r.d.e)
          }
        },
        ...r.pe && {
          p2pk_e: I(r.pe)
        },
        ...r.w && {
          witness: r.w
        }
      });
    })
  );
  const e = { mint: s.m, proofs: t, unit: s.u || "sat" };
  return s.d && (e.memo = s.d), e;
}
function cr(s, t) {
  const e = (t ?? []).map((i) => typeof i == "string" ? i : i.id), n = Bn(s), r = In(n);
  return r.proofs = dr(r.proofs, e), r;
}
function ui(s) {
  s = Bn(s);
  const t = In(s);
  return {
    unit: t.unit || "sat",
    mint: t.mint,
    amount: nt(t.proofs),
    ...t.memo && { memo: t.memo },
    incompleteProofs: t.proofs.map((e) => ({
      secret: e.secret,
      C: e.C,
      amount: e.amount,
      ...e.dleq && {
        dleq: e.dleq
      },
      ...e.witness && {
        witness: e.witness
      }
    }))
  };
}
function In(s) {
  const t = s.slice(0, 1), e = s.slice(1);
  if (t === "A") {
    const n = $n(e);
    if (n.token.length > 1)
      throw new Error("Multi entry token are not supported");
    const r = n.token[0];
    for (const o of r.proofs)
      de(o.amount, !0);
    const i = {
      mint: r.mint,
      proofs: r.proofs,
      unit: n.unit || "sat"
    };
    return n.memo && (i.memo = n.memo), i;
  } else if (t === "B") {
    const n = Xt(e), r = ee(n);
    return En(r);
  }
  throw new Error("Token version is not supported");
}
function fe(s, t, e, n, r, i) {
  let o = "sat";
  if (t && typeof t == "object" ? (o = t.unit ?? "sat", e = t.expiry, n = t.versionByte ?? 1, i = t.input_fee_ppk, r = t.isDeprecatedBase64 ?? !1) : (o = t ?? "sat", n = n ?? 0, r = r ?? !1), r) {
    const a = Object.entries(s).sort(([h], [l]) => Number(h) - Number(l)).map(([, h]) => h).reduce((h, l) => h + l, ""), c = B(w.fromString(a));
    return w.toBase64(c).slice(0, 12);
  }
  switch (n) {
    case 0: {
      const a = Object.entries(s).sort(([h], [l]) => Number(h) - Number(l)).map(([, h]) => T(h)).reduce(
        (h, l) => ur(h, l),
        new Uint8Array()
      ), c = B(a);
      return "00" + w.toHex(c).slice(0, 14);
    }
    case 1: {
      if (!o)
        throw new Error("Cannot compute keyset ID version 01: unit is required.");
      let c = Object.entries(s).sort(
        ([l], [d]) => Number(l) - Number(d)
      ).map(([l, d]) => `${l}:${d}`).join(",");
      c += `|unit:${o}`, i && (c += `|input_fee_ppk:${i}`), e && (c += `|final_expiry:${e}`);
      const u = B(w.fromString(c));
      return "01" + w.toHex(u);
    }
    default:
      throw new Error(`Unrecognized keyset ID version: ${n}`);
  }
}
function ur(s, t) {
  const e = new Uint8Array(s.length + t.length);
  return e.set(s), e.set(t, s.length), e;
}
function hi(s) {
  return s.sort((t, e) => t.id.localeCompare(e.id));
}
function U(s) {
  return typeof s == "object";
}
function li(s) {
  if (U(s)) {
    if ("error" in s && s.error)
      throw new Error(s.error);
    if ("detail" in s && s.detail)
      throw new Error(s.detail);
  }
}
function R(...s) {
  return s.map((t) => t.replace(/(^\/+|\/+$)/g, "")).join("/");
}
function Mn(s) {
  return s.replace(/\/$/, "");
}
function nt(s) {
  return s.reduce((t, e) => t + e.amount, 0);
}
function di(s) {
  return vt.fromEncodedRequest(s);
}
class hr {
  get value() {
    return this._value;
  }
  set value(t) {
    this._value = t;
  }
  get next() {
    return this._next;
  }
  set next(t) {
    this._next = t;
  }
  constructor(t) {
    this._value = t, this._next = null;
  }
}
class lr {
  get first() {
    return this._first;
  }
  set first(t) {
    this._first = t;
  }
  get last() {
    return this._last;
  }
  set last(t) {
    this._last = t;
  }
  get size() {
    return this._size;
  }
  set size(t) {
    this._size = t;
  }
  constructor() {
    this._first = null, this._last = null, this._size = 0;
  }
  enqueue(t) {
    const e = new hr(t);
    return this._size === 0 || !this._last ? (this._first = e, this._last = e) : (this._last.next = e, this._last = e), this._size++, !0;
  }
  dequeue() {
    if (this._size === 0 || !this._first) return null;
    const t = this._first;
    return this._first = t.next, t.next = null, this._size--, t.value;
  }
}
function Cn(s) {
  return s.map((t) => {
    const e = { ...t };
    return delete e.dleq, e;
  });
}
function fi(s) {
  const t = xt(s.id), e = /^[a-fA-F0-9]+$/.test(s.id), n = e ? T(s.id)[0] : 0;
  return fe(s.keys, {
    expiry: s.final_expiry,
    input_fee_ppk: s.input_fee_ppk,
    unit: s.unit,
    versionByte: n,
    isDeprecatedBase64: t && !e
  }) === s.id;
}
function dr(s, t) {
  const e = (t ?? []).map((r) => typeof r == "string" ? r : r.id), n = [];
  for (const r of s) {
    let i;
    try {
      i = T(r.id);
    } catch {
      n.push(r);
      continue;
    }
    if (i[0] === 0)
      n.push(r);
    else if (i[0] === 1) {
      if (!e)
        throw new Error("A short keyset ID v2 was encountered, but got no keysets to map it to.");
      const o = e.filter((a) => r.id === a.slice(0, r.id.length));
      if (o.length > 1)
        throw new Error(`Short keyset ID ${r.id} is ambiguous.`);
      if (o.length === 0)
        throw new Error(
          `Couldn't map short keyset ID ${r.id} to any known keysets of the current Mint`
        );
      r.id = o[0], n.push(r);
    } else
      throw new Error(`Unknown keyset ID version: ${i[0]}`);
  }
  return n;
}
function xn(s, t) {
  if (s.dleq == null)
    return !1;
  const e = {
    e: T(s.dleq.e),
    s: T(s.dleq.s),
    r: Tt(s.dleq.r ?? "00")
  };
  if (!Pn(s.amount, t.keys))
    throw new Error(`Undefined key for amount ${s.amount} in keyset ${t.id}`);
  const n = t.keys[s.amount];
  return Ds(
    new TextEncoder().encode(s.secret),
    e,
    Y(s.C),
    Y(n)
  );
}
function fr(...s) {
  const t = s.reduce((r, i) => r + i.length, 0), e = new Uint8Array(t);
  let n = 0;
  for (let r = 0; r < s.length; r++)
    e.set(s[r], n), n = n + s[r].length;
  return e;
}
function pi(s) {
  const t = new TextEncoder(), e = Tn(s), n = Zt(e), r = t.encode("craw"), i = t.encode("B");
  return fr(r, i, n);
}
function gi(s) {
  const t = new TextDecoder(), e = t.decode(s.slice(0, 4)), n = t.decode(new Uint8Array([s[4]]));
  if (e !== "craw" || n !== "B")
    throw new Error("not a valid binary token");
  const r = s.slice(5), i = ee(r);
  return En(i);
}
function Te(s) {
  return s.reduce((t, e) => t + e, 0);
}
function Ee(s, t) {
  if (s === t) return !0;
  if (s == null || t == null || typeof s != "object" || typeof t != "object") return !1;
  if (Array.isArray(s) && Array.isArray(t))
    return s.length !== t.length ? !1 : s.every((r, i) => Ee(r, t[i]));
  if (Array.isArray(s) || Array.isArray(t)) return !1;
  const e = Object.keys(s), n = Object.keys(t);
  return e.length !== n.length ? !1 : e.every((r) => n.includes(r) && Ee(s[r], t[r]));
}
function Bn(s) {
  return ["web+cashu://", "cashu://", "cashu:", "cashu"].forEach((e) => {
    s.startsWith(e) && (s = s.slice(e.length));
  }), s;
}
function pr(s) {
  return /^ln[a-z]{2,}[1-9][0-9]*(?:[mun]|0p)?1/i.test(s);
}
class rt {
  constructor() {
    this.connectionMap = /* @__PURE__ */ new Map();
  }
  static getInstance() {
    return rt.instance || (rt.instance = new rt()), rt.instance;
  }
  getConnection(t, e) {
    const n = this.connectionMap.get(t);
    if (n)
      return e && n.setLogger(e), n;
    const r = new gr(t, e);
    return this.connectionMap.set(t, r), r;
  }
}
class gr {
  constructor(t, e) {
    this.subListeners = {}, this.rpcListeners = {}, this.rpcId = 0, this.onCloseCallbacks = [], this._WS = Rn(), this.url = new URL(t), this.messageQueue = new lr(), this._logger = e ?? M;
  }
  setLogger(t) {
    this._logger = t;
  }
  connect(t = 1e4) {
    return this.connectionPromise ? this.connectionPromise : (this.connectionPromise = new Promise((e, n) => {
      let r = !1, i = !1, o = null;
      const a = (h) => {
        i || (i = !0, o && clearTimeout(o), h());
      }, c = () => {
        if (this.ws) {
          try {
            this.ws.onopen = null, this.ws.onerror = null, this.ws.onmessage = null, this.ws.onclose = null;
          } catch {
          }
          try {
            this.ws.close();
          } catch {
          }
          this.ws = void 0, this.stopMessageHandling();
        }
      }, u = (h) => {
        this.connectionPromise = void 0, c();
        const l = h instanceof Error ? h : new Error(String(h));
        this.failPendingRpc(l), a(() => n(l));
      };
      try {
        this.ws = new this._WS(this.url.toString());
      } catch (h) {
        u(h);
        return;
      }
      o = setTimeout(() => {
        u(new Error(`WebSocket connect timeout after ${t}ms`));
      }, t), this.ws.onopen = () => {
        r = !0, a(e);
      }, this.ws.onerror = (h) => {
        if (!r) {
          u(new Error("Failed to open WebSocket"));
          return;
        }
        this._logger.error("WebSocket error after open", { ev: h });
      }, this.ws.onmessage = (h) => {
        this.messageQueue.enqueue(h.data), this.handlingInterval || (this.handlingInterval = setInterval(this.handleNextMessage.bind(this), 0));
      }, this.ws.onclose = (h) => {
        if (this.connectionPromise = void 0, !r) {
          const g = h?.reason ? `, ${h.reason}` : "";
          u(new Error(`WebSocket closed before open (code ${h?.code ?? 0}${g})`));
          return;
        }
        this.stopMessageHandling();
        const l = h?.reason ? `, ${h.reason}` : "", d = h?.code ?? 0;
        !(typeof h.wasClean == "boolean" ? h.wasClean : !0) || d !== 1e3 && d !== 1001 ? this.failPendingRpc(new Error(`WebSocket closed (code ${d}${l})`)) : this.rpcListeners = {}, this.onCloseCallbacks.forEach((g) => g(h));
      };
    }), this.connectionPromise);
  }
  sendRequest(t, e) {
    if (this.ws?.readyState !== this._WS.OPEN) {
      if (t === "unsubscribe")
        return;
      throw this._logger.error("Attempted sendRequest, but socket was not open"), new Error("Socket not open");
    }
    const n = this.rpcId;
    this.rpcId++, this.sendRpcMessage(t, e, n);
  }
  /**
   * @deprecated Use cancelSubscription for JSONRPC compliance.
   */
  closeSubscription(t) {
    this.ws?.send(JSON.stringify(["CLOSE", t]));
  }
  addSubListener(t, e) {
    (this.subListeners[t] = this.subListeners[t] || []).push(
      e
    );
  }
  stopMessageHandling() {
    for (this.handlingInterval && (clearInterval(this.handlingInterval), this.handlingInterval = void 0); this.messageQueue.size > 0; )
      this.messageQueue.dequeue();
  }
  failPendingRpc(t) {
    const e = this.rpcListeners;
    this.rpcListeners = {};
    for (const n of Object.keys(e))
      try {
        e[n].errorCallback(t);
      } catch {
      }
  }
  sendRpcMessage(t, e, n) {
    if (this.ws?.readyState !== this._WS.OPEN)
      throw new Error("Socket not open");
    const r = JSON.stringify({ jsonrpc: "2.0", method: t, params: e, id: n });
    try {
      this.ws.send(r);
    } catch (i) {
      this._logger.error("WebSocket send failed", { e: i }), this.connectionPromise = void 0;
      try {
        this.ws.close();
      } catch {
      }
      this.ws = void 0, this.stopMessageHandling();
      const o = i instanceof Error ? i : new Error(String(i));
      throw this.failPendingRpc(o), o;
    }
  }
  addRpcListener(t, e, n) {
    this.rpcListeners[n] = { callback: t, errorCallback: e };
  }
  removeRpcListener(t) {
    delete this.rpcListeners[t];
  }
  removeListener(t, e) {
    if (this.subListeners[t]) {
      if (this.subListeners[t].length === 1) {
        delete this.subListeners[t];
        return;
      }
      this.subListeners[t] = this.subListeners[t].filter(
        (n) => n !== e
      );
    }
  }
  async ensureConnection(t) {
    this.ws?.readyState !== this._WS.OPEN && await this.connect(t);
  }
  handleNextMessage() {
    if (this.messageQueue.size === 0) {
      this.handlingInterval && (clearInterval(this.handlingInterval), this.handlingInterval = void 0);
      return;
    }
    const t = this.messageQueue.dequeue();
    try {
      const e = JSON.parse(t);
      if ("result" in e && e.id != null)
        this.rpcListeners[e.id] && (this.rpcListeners[e.id].callback(), this.removeRpcListener(e.id));
      else if ("error" in e && e.id != null)
        this.rpcListeners[e.id] && (this.rpcListeners[e.id].errorCallback(new Error(e.error.message)), this.removeRpcListener(e.id));
      else if ("method" in e && !("id" in e)) {
        const n = e.params?.subId;
        if (!n)
          return;
        if (this.subListeners[n]?.length > 0) {
          const r = e;
          this.subListeners[n].forEach((i) => {
            try {
              i(r.params?.payload);
            } catch (o) {
              this._logger.error("Subscription handler threw", { e: o });
            }
          });
        }
      }
    } catch (e) {
      this._logger.error("Error doing handleNextMessage", { e });
    }
  }
  createSubscription(t, e, n) {
    if (this.ws?.readyState !== this._WS.OPEN)
      throw this._logger.error("Attempted createSubscription, but socket was not open"), new Error("Socket is not open");
    const r = (Math.random() + 1).toString(36).substring(7), i = this.rpcId;
    this.addRpcListener(
      () => {
        this.addSubListener(r, e);
      },
      n,
      i
    );
    try {
      this.sendRequest("subscribe", { ...t, subId: r });
    } catch (o) {
      throw this.removeRpcListener(i), o;
    }
    return r;
  }
  /**
   * Cancels a subscription, sending an unsubscribe request and handling responses.
   *
   * @param subId The subscription ID to cancel.
   * @param callback The original payload callback to remove.
   * @param errorCallback Optional callback for unsubscribe errors (defaults to logging).
   */
  cancelSubscription(t, e, n) {
    if (this.removeListener(t, e), this.ws?.readyState !== this._WS.OPEN) {
      this._logger.info("Socket not open, removed listener locally {subId}", { subId: t });
      return;
    }
    const r = this.rpcId;
    this.rpcId++, this.addRpcListener(
      () => {
        this._logger.info("Unsubscribed {subId}", { subId: t });
      },
      n || ((i) => this._logger.error("Unsubscribe failed", { e: i })),
      r
    );
    try {
      this.sendRpcMessage("unsubscribe", { subId: t }, r);
    } catch (i) {
      throw this.removeRpcListener(r), i;
    }
  }
  get activeSubscriptions() {
    return Object.keys(this.subListeners);
  }
  close() {
    if (this.ws) {
      try {
        this.ws.close();
      } catch {
      }
      this.ws = void 0;
    }
    this.connectionPromise = void 0, this.stopMessageHandling();
  }
  onClose(t) {
    this.onCloseCallbacks.push(t);
  }
}
const jt = {
  UNPAID: "UNPAID",
  PAID: "PAID",
  ISSUED: "ISSUED"
}, lt = {
  UNPAID: "UNPAID",
  PENDING: "PENDING",
  PAID: "PAID"
}, Nt = {
  UNSPENT: "UNSPENT",
  PENDING: "PENDING",
  SPENT: "SPENT"
};
function Lt(s, t) {
  return s.state || (t.warn(
    "Field 'state' not found in Melt quote response. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"
  ), typeof s.paid == "boolean" && (s.state = s.paid ? lt.PAID : lt.UNPAID)), s;
}
function Ie(s, t) {
  return s.state || (t.warn(
    "Field 'state' not found in Mint quote response. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"
  ), typeof s.paid == "boolean" && (s.state = s.paid ? jt.PAID : jt.UNPAID)), s;
}
function mr(s, t) {
  return Array.isArray(s?.contact) && s?.contact.length > 0 && (s.contact = s.contact.map((e) => Array.isArray(e) && e.length === 2 && typeof e[0] == "string" && typeof e[1] == "string" ? (t.warn(
    "Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"
  ), { method: e[0], info: e[1] }) : e)), s;
}
class Et {
  constructor(t) {
    this._mintInfo = t;
    const e = this.toEndpoints(t?.nuts?.[22]?.protected_endpoints);
    this._protected22 = this.buildIndex(e);
    const n = this.toEndpoints(t?.nuts?.[21]?.protected_endpoints);
    this._protected21 = this.buildIndex(n);
  }
  isSupported(t) {
    switch (t) {
      case 4:
      case 5:
        return this.checkMintMelt(t);
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 14:
      case 20:
        return this.checkGenericNut(t);
      case 17:
        return this.checkNut17();
      case 15:
        return this.checkNut15();
      default:
        throw new Error("nut is not supported by cashu-ts");
    }
  }
  requiresBlindAuthToken(t, e) {
    return this.matchesProtected(this._protected22, t, e);
  }
  requiresClearAuthToken(t, e) {
    return this.matchesProtected(this._protected21, t, e);
  }
  matchesProtected(t, e, n) {
    if (!t) return !1;
    const r = `${e} ${n}`, i = t.cache[r];
    if (typeof i == "boolean") return i;
    const o = t.exact.some((u) => u.method === e && u.path === n), a = o ? !1 : t.prefix.some((u) => u.method === e && n.startsWith(u.path)), c = o || a;
    return t.cache[r] = c, c;
  }
  checkGenericNut(t) {
    return this._mintInfo.nuts[t]?.supported ? { supported: !0 } : { supported: !1 };
  }
  checkMintMelt(t) {
    const e = this._mintInfo.nuts[t];
    return e && e.methods.length > 0 && !e.disabled ? { disabled: !1, params: e.methods } : { disabled: !0, params: e?.methods ?? [] };
  }
  checkNut17() {
    return this._mintInfo.nuts[17] && this._mintInfo.nuts[17].supported.length > 0 ? { supported: !0, params: this._mintInfo.nuts[17].supported } : { supported: !1 };
  }
  checkNut15() {
    return this._mintInfo.nuts[15] && this._mintInfo.nuts[15].methods.length > 0 ? { supported: !0, params: this._mintInfo.nuts[15].methods } : { supported: !1 };
  }
  // ---------- private helpers ----------
  toEndpoints(t) {
    if (!Array.isArray(t)) return [];
    const e = [];
    for (const n of t)
      if (n && typeof n == "object") {
        const r = n, i = r.method, o = r.path;
        if (typeof i == "string" && typeof o == "string") {
          const a = i.toUpperCase();
          (a === "GET" || a === "POST") && e.push({ method: a, path: o });
        }
      }
    return e;
  }
  buildIndex(t) {
    if (!t || t.length === 0) return;
    const e = [], n = [];
    for (const i of t) {
      let o = i.path;
      o.startsWith("^") && (o = o.slice(1)), o.endsWith("$") && (o = o.slice(0, -1)), o.endsWith(".*") ? n.push({ method: i.method, path: o.slice(0, -2) }) : e.push({ method: i.method, path: o });
    }
    return { cache: {}, exact: e, prefix: n };
  }
  // ---------- getters ----------
  get cache() {
    return this._mintInfo;
  }
  get contact() {
    return this._mintInfo.contact;
  }
  get description() {
    return this._mintInfo.description;
  }
  get description_long() {
    return this._mintInfo.description_long;
  }
  get name() {
    return this._mintInfo.name;
  }
  get pubkey() {
    return this._mintInfo.pubkey;
  }
  get nuts() {
    return this._mintInfo.nuts;
  }
  get version() {
    return this._mintInfo.version;
  }
  get motd() {
    return this._mintInfo.motd;
  }
  /**
   * @deprecated Use supportsNut04Description(method, unit)
   */
  get supportsBolt12Description() {
    return this.supportsNut04Description("bolt12");
  }
  /**
   * Checks if the mint supports creating invoices/offers with a description for the specified
   * payment method.
   *
   * @param method - The payment method to check ('bolt11' or 'bolt12')
   * @returns True if the mint supports description for the method, false otherwise.
   */
  supportsNut04Description(t, e) {
    return this._mintInfo.nuts[4]?.methods.some(
      (n) => n.method === t && (e ? n.unit === e : !0) && (n.options?.description === !0 || n.description === !0)
    );
  }
  supportsAmountless(t = "bolt11", e = "sat") {
    const n = this._mintInfo?.nuts?.[5]?.methods ?? [];
    return Array.isArray(n) ? n.some(
      (r) => r.method === t && r.unit === e && r.options?.amountless === !0
    ) : !1;
  }
}
class pe {
  constructor(t, e) {
    this.tokenListeners = [], this.discoveryUrl = t, this.logger = e?.logger ?? M, this.clientId = e?.clientId ?? "cashu-client", this.scope = e?.scope ?? "openid", this.onTokens = e?.onTokens;
  }
  static fromMintInfo(t, e) {
    const n = t?.nuts?.["21"];
    if (!n?.openid_discovery)
      throw new Error("OIDCAuth: mint does not advertise NUT-21 openid_discovery");
    const r = e?.clientId ?? n.client_id ?? "cashu-client";
    return new pe(n.openid_discovery, { ...e, clientId: r });
  }
  setClient(t) {
    this.clientId = t;
  }
  setScope(t) {
    this.scope = t ?? "openid";
  }
  /**
   * Subscribe to token updates. Listeners are called after the primary onTokens callback.
   */
  addTokenListener(t) {
    this.tokenListeners.push(t);
  }
  // ---- Discovery ----
  async loadConfig() {
    if (this.config) return this.config;
    const t = await fetch(this.discoveryUrl, {
      method: "GET",
      headers: { Accept: "application/json" }
    }), e = await t.text();
    let n;
    try {
      n = e ? JSON.parse(e) : void 0;
    } catch (i) {
      this.logger.warn("OIDCAuth: bad discovery JSON", { err: i });
    }
    if (!t.ok || !n)
      throw new Error("OIDCAuth: invalid discovery document");
    const r = n;
    if (typeof r.token_endpoint != "string" || r.token_endpoint.length === 0)
      throw new Error("OIDCAuth: invalid discovery document, missing token_endpoint");
    return this.config = r, r;
  }
  // --- Authorization Code with PKCE ---
  /**
   * Generate a PKCE verifier and S256 challenge.
   *
   * - Verifier: base64url of random bytes, length >= 43, RFC 7636 compliant.
   * - Challenge: base64url(sha256(verifier))
   */
  generatePKCE() {
    const t = Mt(48), e = qt(t), n = w.fromString(e), r = B(n), i = qt(r);
    return { verifier: e, challenge: i };
  }
  /**
   * Build an Authorization Code + PKCE URL.
   */
  async buildAuthCodeUrl(t) {
    const e = await this.loadConfig(), n = t.scope ?? this.scope, r = new URLSearchParams({
      response_type: "code",
      client_id: this.clientId,
      redirect_uri: t.redirectUri,
      scope: n,
      code_challenge_method: t.codeChallengeMethod ?? "S256",
      code_challenge: t.codeChallenge
    });
    if (t.state && r.set("state", t.state), !e.authorization_endpoint)
      throw new Error("OIDCAuth: discovery lacks authorization_endpoint");
    return `${e.authorization_endpoint}?${r.toString()}`;
  }
  /**
   * Exchange an auth code for tokens, using the PKCE verifier.
   */
  async exchangeAuthCode(t) {
    const e = await this.loadConfig(), n = this.toForm({
      grant_type: "authorization_code",
      code: t.code,
      redirect_uri: t.redirectUri,
      client_id: this.clientId,
      code_verifier: t.codeVerifier
    }), r = await this.postFormStrict(e.token_endpoint, n);
    return this.handleTokens(r), r;
  }
  // ---- Device Code (recommended for CLIs) ----
  async deviceStart() {
    const e = (await this.loadConfig()).device_authorization_endpoint;
    if (!e) throw new Error("OIDCAuth: provider lacks device_authorization_endpoint");
    const n = this.toForm({ client_id: this.clientId, scope: this.scope });
    return this.postFormStrict(e, n);
  }
  async devicePoll(t, e = 5) {
    const n = await this.loadConfig();
    let r = Math.max(1, e);
    for (; ; ) {
      await this.sleep(r * 1e3);
      const i = this.toForm({
        grant_type: "urn:ietf:params:oauth:grant-type:device_code",
        device_code: t,
        client_id: this.clientId
      }), o = await this.postFormLoose(n.token_endpoint, i);
      if (o.access_token)
        return this.handleTokens(o), o;
      const a = (o.error ?? "").toString();
      if (a === "authorization_pending") continue;
      if (a === "slow_down") {
        r = Math.max(r + 5, r * 2);
        continue;
      }
      const c = o.error_description || a || "device authorization failed";
      throw new Error(`OIDCAuth: ${c}`);
    }
  }
  /**
   * One call convenience for Device Code flow.
   *
   * @remarks
   * Polling interval will be the MAX of intervalSec and Mint interval.
   * @param intervalSec Desired polling interval in seconds.
   * @returns The start fields and helpers to poll or cancel.
   */
  async startDeviceAuth(t = 5) {
    const e = await this.deviceStart(), n = Math.max(e.interval ?? 1, t);
    let r = !1;
    return { ...e, poll: async () => {
      const a = await this.loadConfig();
      let c = Math.max(1, n);
      for (; ; ) {
        if (r) throw new Error("OIDCAuth: device polling cancelled");
        await this.sleep(c * 1e3);
        const u = this.toForm({
          grant_type: "urn:ietf:params:oauth:grant-type:device_code",
          device_code: e.device_code,
          client_id: this.clientId
        }), h = await this.postFormLoose(a.token_endpoint, u);
        if (h.access_token)
          return this.handleTokens(h), h;
        const l = (h.error ?? "").toString();
        if (l === "authorization_pending") continue;
        if (l === "slow_down") {
          c = Math.max(c + 5, c * 2);
          continue;
        }
        const d = h.error_description || l || "device authorization failed";
        throw new Error(`OIDCAuth: ${d}`);
      }
    }, cancel: () => {
      r = !0;
    } };
  }
  // ---- Refresh ----
  async refresh(t) {
    const e = await this.loadConfig(), n = this.toForm({
      grant_type: "refresh_token",
      refresh_token: t,
      client_id: this.clientId
    }), r = await this.postFormStrict(e.token_endpoint, n);
    return this.handleTokens(r), r;
  }
  // ---- ROPC (discouraged, but some mints allow it) ----
  async passwordGrant(t, e) {
    const n = await this.loadConfig(), r = this.toForm({
      grant_type: "password",
      client_id: this.clientId,
      username: t,
      password: e,
      scope: this.scope
    }), i = await this.postFormStrict(n.token_endpoint, r);
    return this.handleTokens(i), i;
  }
  // ---- internals ----
  /**
   * Fire and forget token fan out. Any listener errors are logged inside safeCallback. Nothing
   * thrown here will come from listeners.
   */
  handleTokens(t) {
    if (!t.access_token) {
      const e = t.error_description || t.error || "token response missing access_token";
      throw new Error(`OIDCAuth: ${e}`);
    }
    queueMicrotask(
      () => ht(this.onTokens, t, this.logger, { where: "OIDCAuth.handleTokens" })
    );
    for (const e of this.tokenListeners)
      queueMicrotask(
        () => ht(e, t, this.logger, {
          where: "OIDCAuth.handleTokens.listener"
        })
      );
  }
  toForm(t) {
    const e = (n) => encodeURIComponent(n).replace(/%20/g, "+");
    return Object.entries(t).map(([n, r]) => `${e(n)}=${e(r)}`).join("&");
  }
  // Strict, throws on non 2xx
  async postFormStrict(t, e) {
    try {
      this.logger.debug("OIDCAuth Request", { formBody: e });
      const n = await fetch(t, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Accept: "application/json"
        },
        body: e
      }), r = await n.text();
      let i;
      try {
        i = r ? JSON.parse(r) : void 0;
      } catch (o) {
        this.logger.warn("OIDCAuth: bad JSON (strict)", { err: o });
      }
      if (!n.ok) {
        const o = i ?? {}, a = o.error_description || o.error || `HTTP ${n.status}`;
        throw new Error(`OIDCAuth: ${a}`);
      }
      return this.logger.debug("OIDCAuth Response", { json: i }), i ?? {};
    } catch (n) {
      throw this.logger.error("OIDCAuth: postFormStrict failed", { err: n }), n;
    }
  }
  // Loose, returns JSON payload even on non 2xx
  async postFormLoose(t, e) {
    try {
      this.logger.debug("OIDCAuth Request", { formBody: e });
      const r = await (await fetch(t, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Accept: "application/json"
        },
        body: e
      })).text();
      let i;
      try {
        i = r ? JSON.parse(r) : void 0;
      } catch (o) {
        this.logger.warn("OIDCAuth: bad JSON (loose)", { err: o });
      }
      return this.logger.debug("OIDCAuth Response", { json: i }), i ?? {};
    } catch (n) {
      return this.logger.error("OIDCAuth: postFormLoose network error", { err: n }), { error: "network_error", error_description: String(n) };
    }
  }
  sleep(t) {
    return new Promise((e) => setTimeout(e, t));
  }
}
class ge {
  /**
   * @param mintUrl Requires mint URL to create this object.
   * @param customRequest Optional, for custom network communication with the mint.
   * @param authTokenGetter Optional. Function to obtain a NUT-22 BlindedAuthToken (e.g. from a
   *   database or localstorage)
   */
  constructor(t, e) {
    this._mintUrl = Mn(t), this._request = e?.customRequest ?? qe, this._authProvider = e?.authProvider, this._logger = e?.logger ?? M, Fn(this._logger);
  }
  get mintUrl() {
    return this._mintUrl;
  }
  /**
   * Create an OIDC client using this mints NUT-21 metadata.
   *
   * @example
   *
   * ```ts
   * const oidc = await mint.oidcAuth({ onTokens: (t) => authMgr.setCAT(t.access_token!) });
   * const start = await oidc.deviceStart();
   * // show start.user_code / start.verification_uri to the user
   * const token = await oidc.devicePoll(start.device_code, start.interval ?? 5);
   * // token.access_token is your CAT
   * ```
   */
  async oidcAuth(t) {
    const e = (await this.getLazyMintInfo()).nuts[21];
    if (!e?.openid_discovery)
      throw new Error("Mint: no NUT-21 openid_discovery");
    return new pe(e.openid_discovery, {
      ...t,
      clientId: t?.clientId ?? e.client_id ?? "cashu-client"
    });
  }
  /**
   * Fetches mint's info at the /info endpoint.
   *
   * @param customRequest Optional override for the request function.
   * @returns The mint's information response.
   */
  async getInfo(t) {
    const n = await (t ?? this._request)({
      endpoint: R(this._mintUrl, "/v1/info")
    });
    return mr(n, this._logger);
  }
  /**
   * Lazily fetches and caches the mint's info if not already loaded.
   *
   * @returns The parsed MintInfo object.
   */
  async getLazyMintInfo() {
    if (this._mintInfo)
      return this._mintInfo;
    const t = await this.getInfo();
    return this._mintInfo = new Et(t), this._mintInfo;
  }
  /**
   * Performs a swap operation with ecash inputs and outputs.
   *
   * @param swapPayload Payload containing inputs and outputs.
   * @param customRequest Optional override for the request function.
   * @returns Signed outputs.
   */
  async swap(t, e) {
    const n = await this.requestWithAuth(
      "POST",
      "/v1/swap",
      { requestBody: t },
      e
    );
    if (!U(n) || !Array.isArray(n?.signatures))
      throw this._logger.error("Invalid response from mint...", { data: n, op: "swap" }), new Error("Invalid response from mint");
    return n;
  }
  /**
   * Requests a new mint quote from the mint.
   *
   * @param mintQuotePayload Payload for creating a new mint quote.
   * @param customRequest Optional override for the request function.
   * @returns A new mint quote containing a payment request for the specified amount and unit.
   */
  async createMintQuoteBolt11(t, e) {
    const n = await this.requestWithAuth("POST", "/v1/mint/quote/bolt11", { requestBody: t }, e);
    return Ie(n, this._logger);
  }
  /**
   * Requests a new BOLT12 mint quote from the mint using Lightning Network offers.
   *
   * @param mintQuotePayload Payload containing amount, unit, optional description, and required
   *   pubkey.
   * @param customRequest Optional override for the request function.
   * @returns A mint quote containing a BOLT12 offer.
   */
  async createMintQuoteBolt12(t, e) {
    return await this.requestWithAuth(
      "POST",
      "/v1/mint/quote/bolt12",
      { requestBody: t },
      e
    );
  }
  /**
   * Gets an existing mint quote from the mint.
   *
   * @param quote Quote ID.
   * @param customRequest Optional override for the request function.
   * @returns The status of the mint quote, including payment details and state.
   */
  async checkMintQuoteBolt11(t, e) {
    const n = await this.requestWithAuth("GET", `/v1/mint/quote/bolt11/${t}`, {}, e);
    return Ie(n, this._logger);
  }
  /**
   * Gets an existing BOLT12 mint quote from the mint.
   *
   * @param quote Quote ID to check.
   * @param customRequest Optional override for the request function.
   * @returns Updated quote with current payment and issuance amounts.
   */
  async checkMintQuoteBolt12(t, e) {
    return await this.requestWithAuth(
      "GET",
      `/v1/mint/quote/bolt12/${t}`,
      {},
      e
    );
  }
  /**
   * Mints new tokens by requesting blind signatures on the provided outputs.
   *
   * @param mintPayload Payload containing the outputs to get blind signatures on.
   * @param customRequest Optional override for the request function.
   * @returns Serialized blinded signatures.
   */
  async mintBolt11(t, e) {
    const n = await this.requestWithAuth(
      "POST",
      "/v1/mint/bolt11",
      { requestBody: t },
      e
    );
    if (!U(n) || !Array.isArray(n?.signatures))
      throw this._logger.error("Invalid response from mint...", { data: n, op: "mintBolt11" }), new Error("Invalid response from mint");
    return n;
  }
  /**
   * Mints new tokens using a BOLT12 quote by requesting blind signatures on the provided outputs.
   *
   * @param mintPayload Payload containing the quote ID and outputs to get blind signatures on.
   * @param customRequest Optional override for the request function.
   * @returns Serialized blinded signatures for the requested outputs.
   */
  async mintBolt12(t, e) {
    const n = await this.requestWithAuth(
      "POST",
      "/v1/mint/bolt12",
      { requestBody: t },
      e
    );
    if (!U(n) || !Array.isArray(n?.signatures))
      throw this._logger.error("Invalid response from mint...", { data: n, op: "mintBolt12" }), new Error("Invalid response from mint");
    return n;
  }
  /**
   * Requests a new melt quote from the mint.
   *
   * @param meltQuotePayload Payload for creating a new melt quote.
   * @param customRequest Optional override for the request function.
   * @returns The melt quote response.
   */
  async createMeltQuoteBolt11(t, e) {
    const n = await this.requestWithAuth("POST", "/v1/melt/quote/bolt11", { requestBody: t }, e), r = Lt(n, this._logger);
    if (!U(r) || typeof r?.amount != "number" || typeof r?.fee_reserve != "number" || typeof r?.quote != "string")
      throw this._logger.error("Invalid response from mint...", { data: r, op: "createMeltQuoteBolt11" }), new Error("Invalid response from mint");
    return r;
  }
  /**
   * Requests a new BOLT12 melt quote from the mint for paying a Lightning Network offer. For
   * amount-less offers, specify the amount in options.amountless.amount_msat.
   *
   * @param meltQuotePayload Payload containing the BOLT12 offer to pay and unit.
   * @param customRequest Optional override for the request function.
   * @returns Melt quote with amount, fee reserve, and payment state.
   */
  async createMeltQuoteBolt12(t, e) {
    return await this.requestWithAuth(
      "POST",
      "/v1/melt/quote/bolt12",
      { requestBody: t },
      e
    );
  }
  /**
   * Gets an existing melt quote.
   *
   * @param quote Quote ID.
   * @param customRequest Optional override for the request function.
   * @returns The melt quote response.
   */
  async checkMeltQuoteBolt11(t, e) {
    const n = await this.requestWithAuth("GET", `/v1/melt/quote/bolt11/${t}`, {}, e), r = Lt(n, this._logger);
    if (!U(r) || typeof r?.amount != "number" || typeof r?.fee_reserve != "number" || typeof r?.quote != "string" || typeof r?.state != "string" || !Object.values(lt).includes(r.state))
      throw this._logger.error("Invalid response from mint...", { data: r, op: "checkMeltQuoteBolt11" }), new Error("Invalid response from mint");
    return r;
  }
  /**
   * Gets an existing BOLT12 melt quote from the mint. Returns current payment state (UNPAID,
   * PENDING, or PAID) and payment preimage if paid.
   *
   * @param quote Quote ID to check.
   * @param customRequest Optional override for the request function.
   * @returns Updated quote with current payment state and preimage if available.
   */
  async checkMeltQuoteBolt12(t, e) {
    return await this.requestWithAuth(
      "GET",
      `/v1/melt/quote/bolt12/${t}`,
      {},
      e
    );
  }
  /**
   * Generic method to melt tokens using any payment method endpoint.
   *
   * @remarks
   * This method enables support for custom payment methods without modifying the Mint class. It
   * constructs the endpoint as `/v1/melt/{method}` and POSTs the payload. The response must contain
   * the common fields: quote, amount, fee_reserve, state, expiry.
   * @example
   *
   * ```ts
   * const response = await mint.melt('bolt11', { quote: 'q1', inputs: [...], outputs: [...] });
   * const response = await mint.melt('custom-payment', { quote: 'c1', inputs: [...], outputs: [...] });
   * ```
   *
   * @param method The payment method (e.g., 'bolt11', 'bolt12', or custom method name).
   * @param meltPayload The melt payload containing inputs and optional outputs.
   * @param options.customRequest Optional override for the request function.
   * @param options.preferAsync Optional override to set 'respond-async' header.
   * @returns A response object with at least the required melt quote fields.
   */
  async melt(t, e, n) {
    const r = {
      ...n?.preferAsync ? { Prefer: "respond-async" } : {}
    };
    Jt(!this.isValidMethodString(t), `Invalid melt method: ${t}`, this._logger);
    const i = await this.requestWithAuth(
      "POST",
      `/v1/melt/${t}`,
      { requestBody: e, headers: r },
      n?.customRequest
    );
    if (!U(i))
      throw this._logger.error("Invalid response from mint...", { data: i, op: "melt" }), new Error("Invalid response from mint");
    return i;
  }
  /**
   * Requests the mint to pay for a Bolt11 payment request by providing ecash as inputs to be spent.
   * The inputs contain the amount and the fee_reserves for a Lightning payment. The payload can
   * also contain blank outputs in order to receive back overpaid Lightning fees.
   *
   * @param meltPayload The melt payload containing inputs and optional outputs.
   * @param options.customRequest Optional override for the request function.
   * @param options.preferAsync Optional override to set 'respond-async' header.
   * @returns The melt response.
   */
  async meltBolt11(t, e) {
    const n = await this.melt("bolt11", t, e), r = Lt(n, this._logger);
    if (!U(r) || typeof r?.state != "string" || !Object.values(lt).includes(r.state))
      throw this._logger.error("Invalid response from mint...", { data: r, op: "meltBolt11" }), new Error("Invalid response from mint");
    return r;
  }
  /**
   * Requests the mint to pay a BOLT12 offer by providing ecash inputs to be spent. The inputs must
   * cover the amount plus fee reserves. Optional outputs can be included to receive change for
   * overpaid Lightning fees.
   *
   * @param meltPayload Payload containing quote ID, inputs, and optional outputs for change.
   * @param options.customRequest Optional override for the request function.
   * @param options.preferAsync Optional override to set 'respond-async' header.
   * @returns Payment result with state and optional change signatures.
   */
  async meltBolt12(t, e) {
    return this.melt("bolt12", t, e);
  }
  /**
   * Checks if specific proofs have already been redeemed.
   *
   * @param checkPayload The payload containing proofs to check.
   * @param customRequest Optional override for the request function.
   * @returns Redeemed and unredeemed ordered list of booleans.
   */
  async check(t, e) {
    const n = await this.requestWithAuth(
      "POST",
      "/v1/checkstate",
      { requestBody: t },
      e
    );
    if (!U(n) || !Array.isArray(n?.states))
      throw this._logger.error("Invalid response from mint...", { data: n, op: "check" }), new Error("Invalid response from mint");
    return n;
  }
  /**
   * Get the mint's public keys.
   *
   * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the
   *   keys from all active keysets are fetched.
   * @param mintUrl Optional alternative mint URL to use for this request.
   * @param customRequest Optional override for the request function.
   * @returns The mint's public keys.
   */
  async getKeys(t, e, n) {
    const r = e || this._mintUrl;
    t && (t = t.replace(/\//g, "_").replace(/\+/g, "-"));
    const o = await (n ?? this._request)({
      endpoint: t ? R(r, "/v1/keys", t) : R(r, "/v1/keys")
    });
    if (!U(o) || !Array.isArray(o.keysets))
      throw this._logger.error("Invalid response from mint...", { data: o, op: "getKeys" }), new Error("Invalid response from mint");
    return o;
  }
  /**
   * Get the mint's keysets in no specific order.
   *
   * @param customRequest Optional override for the request function.
   * @returns All the mint's past and current keysets.
   */
  async getKeySets(t) {
    return (t ?? this._request)({
      endpoint: R(this._mintUrl, "/v1/keysets")
    });
  }
  /**
   * Restores proofs from the provided blinded messages.
   *
   * @param restorePayload The payload containing outputs to restore.
   * @param customRequest Optional override for the request function.
   * @returns The restore response with outputs and signatures.
   */
  async restore(t, e) {
    const r = await (e ?? this._request)({
      endpoint: R(this._mintUrl, "/v1/restore"),
      method: "POST",
      requestBody: t
    });
    if (!U(r) || !Array.isArray(r?.outputs) || !Array.isArray(r?.signatures))
      throw this._logger.error("Invalid response from mint...", { data: r, op: "restore" }), new Error("Invalid response from mint");
    return r;
  }
  /**
   * Tries to establish a websocket connection with the websocket mint url according to NUT-17.
   */
  async connectWebSocket() {
    try {
      const t = new URL(this._mintUrl), e = "v1/ws";
      t.pathname.endsWith("/") ? t.pathname += e : t.pathname += "/" + e, t.protocol = t.protocol === "https:" ? "wss:" : "ws:";
      const n = t.toString();
      this.ws || (this.ws = rt.getInstance().getConnection(n, this._logger)), await this.ws.ensureConnection();
    } catch (t) {
      this._logger.error("Failed to connect to WebSocket...", { e: t });
      try {
        this.ws?.close();
      } catch {
      }
      throw this.ws = void 0, new Error("Failed to connect to WebSocket...");
    }
  }
  /**
   * Closes a websocket connection.
   */
  disconnectWebSocket() {
    this.ws && this.ws.close();
  }
  get webSocketConnection() {
    return this.ws;
  }
  /**
   * Returns the Clear Authentication Token (CAT) to use in the 'Clear-auth' header, or undefined if
   * not required for the given path and method.
   *
   * @param method The method to call on the path.
   * @param path The API path to check for blind auth requirement.
   * @returns The blind auth token if required, otherwise undefined.
   */
  async handleClearAuth(t, e) {
    if (!(!this._authProvider || !(await this.getLazyMintInfo()).requiresClearAuthToken(t, e)))
      return this._logger.error("Clear Authentication Token...", { cat: this._authProvider.getCAT() }), this._authProvider.getCAT();
  }
  /**
   * Returns a serialized Blind Authentication Token (BAT) to use in the 'Blind-auth' header, or
   * undefined if not required for the given path and method.
   *
   * @param method The method to call on the path.
   * @param path The API path to check for blind auth requirement.
   * @returns The blind auth token if required, otherwise undefined.
   */
  async handleBlindAuth(t, e) {
    if (!this._authProvider || !(await this.getLazyMintInfo()).requiresBlindAuthToken(t, e)) return;
    const r = await this._authProvider.getBlindAuthToken({ method: t, path: e });
    return this._logger.error("Blind Authentication Token...", { bat: r }), r;
  }
  async requestWithAuth(t, e, n = {}, r) {
    const i = r ?? this._request, o = await this.handleBlindAuth(t, e), a = await this.handleClearAuth(t, e), c = {
      ...n.headers ?? {},
      ...o ? { "Blind-auth": o } : {},
      ...a ? { "Clear-auth": a } : {}
    };
    return i({
      ...n,
      endpoint: R(this._mintUrl, e),
      method: t,
      headers: c
    });
  }
  isValidMethodString(t) {
    return !!(typeof t == "string" && /^[a-z0-9_-]+$/.test(t));
  }
}
class dt {
  constructor(t, e, n, r, i) {
    this._keys = {}, this._id = t, this._unit = e, this._active = n, this._input_fee_ppk = r, this._final_expiry = i;
  }
  get id() {
    return this._id;
  }
  get unit() {
    return this._unit;
  }
  get isActive() {
    return this._active;
  }
  get fee() {
    return this._input_fee_ppk ?? 0;
  }
  get expiry() {
    return this._final_expiry;
  }
  get hasKeys() {
    return Object.keys(this._keys).length > 0;
  }
  get hasHexId() {
    return it(this._id);
  }
  get keys() {
    return this._keys;
  }
  set keys(t) {
    this._keys = t;
  }
  /**
   * @deprecated Use `isActive` instead.
   */
  get active() {
    return this.isActive;
  }
  /**
   * @deprecated Use `fee` instead.
   */
  get input_fee_ppk() {
    return this.fee;
  }
  /**
   * @deprecated Use `expiry` instead.
   */
  get final_expiry() {
    return this.expiry;
  }
  /**
   * To Mint API MintKeyset format.
   *
   * @returns MintKeyset object.
   */
  toMintKeyset() {
    return {
      id: this._id,
      unit: this._unit,
      active: this._active,
      input_fee_ppk: this._input_fee_ppk,
      final_expiry: this._final_expiry
    };
  }
  /**
   * To Mint API MintKeys format.
   *
   * @returns MintKeys object.
   */
  toMintKeys() {
    return this.hasKeys ? {
      id: this._id,
      unit: this._unit,
      active: this._active,
      input_fee_ppk: this._input_fee_ppk,
      final_expiry: this._final_expiry,
      keys: this._keys
    } : null;
  }
  /**
   * Verifies that the keyset's ID matches the derived ID from its keys, unit, and expiry.
   *
   * @returns True if verification succeeds, false otherwise (e.g: no keys or mismatch).
   */
  verify() {
    return this.hasKeys ? dt.verifyKeysetId(this.toMintKeys()) : !1;
  }
  /**
   * Verifies that a MintKeys DTO has a correct id for its keys/unit/expiry.
   *
   * @returns True if verification succeeds, false otherwise (e.g: no keys or mismatch).
   */
  static verifyKeysetId(t) {
    if (!t.keys || Object.keys(t.keys).length === 0)
      return !1;
    const e = xt(t.id) && !it(t.id), n = it(t.id) ? T(t.id)[0] : 0;
    return fe(t.keys, {
      input_fee_ppk: t.input_fee_ppk,
      expiry: t.final_expiry,
      unit: t.unit,
      versionByte: n,
      isDeprecatedBase64: e
    }) === t.id;
  }
  /**
   * Create a Keyset from Mint API DTOs.
   *
   * @param meta The MintKeyset metadata from GetKeysetsResponse.
   * @param keys The MintKeys from GetKeysResponse.
   * @returns Keyset instance.
   */
  static fromMintApi(t, e) {
    const n = new dt(t.id, t.unit, t.active, t.input_fee_ppk, t.final_expiry);
    if (e) {
      if (e.id !== t.id)
        throw new Error(`Mismatched keyset ids: meta=${t.id}, keys=${e.id}`);
      if (e.unit !== t.unit)
        throw new Error(`Mismatched keyset units: meta=${t.unit}, keys=${e.unit}`);
      if (e.final_expiry !== void 0 && t.final_expiry !== void 0 && e.final_expiry !== t.final_expiry)
        throw new Error(`Mismatched keyset expiry for id=${t.id}`);
      n.keys = e.keys;
    }
    return n;
  }
}
class G {
  constructor(t, e, n, r) {
    if (this.keysets = {}, this.mint = typeof t == "string" ? new ge(t) : t, this.unit = e, n && r) {
      const i = Array.isArray(r) ? r : [r];
      this.buildKeychain(n, i), this.getCheapestKeyset();
    }
  }
  // ---------------------------------------------------------------------
  // Static helpers
  // ---------------------------------------------------------------------
  /**
   * Construct a KeyChain from previously cached data.
   *
   * @remarks
   * Does not hit the network. The cache should have been produced by `keyChain.cache`.
   */
  static fromCache(t, e) {
    const n = new G(t, e.unit);
    return n.loadFromCache(e), n;
  }
  /**
   * Convert Mint API DTOs into a consolidated KeyChainCache.
   *
   * @remarks
   * This is symmetrical to {@link KeyChain.cacheToMintDTO}. It is used by the `cache` getter and any
   * code that wants to move from raw Mint DTOs to the new cache shape.
   */
  static mintToCacheDTO(t, e, n, r) {
    const i = new Map(r.map((a) => [a.id, a]));
    return {
      keysets: n.map((a) => {
        const c = i.get(a.id), u = { ...a };
        return c && (u.keys = c.keys), u;
      }),
      unit: t,
      mintUrl: e
    };
  }
  /**
   * Convert a KeyChainCache back into Mint API DTOs.
   *
   * @remarks
   * This is the inverse of {@link KeyChain.mintToCacheDTO} and is used by `loadFromCache` and the
   * deprecated `getCache()` wrapper.
   */
  static cacheToMintDTO(t) {
    const e = t.keysets.map((r) => ({
      id: r.id,
      unit: r.unit,
      active: r.active,
      input_fee_ppk: r.input_fee_ppk,
      final_expiry: r.final_expiry
    })), n = t.keysets.filter((r) => !!r.keys).map((r) => ({
      id: r.id,
      unit: r.unit,
      active: r.active,
      input_fee_ppk: r.input_fee_ppk,
      final_expiry: r.final_expiry,
      keys: r.keys
    }));
    return { keysets: e, keys: n };
  }
  // ---------------------------------------------------------------------
  // Mint loading
  // ---------------------------------------------------------------------
  /**
   * Asynchronously load keysets and keys from the mint.
   *
   * @remarks
   * Intended for callers that want the freshest data from the mint and can use an asynchronous
   * path.
   * @param forceRefresh If true, re-fetches data even if already loaded.
   */
  async init(t) {
    if (Object.keys(this.keysets).length > 0 && !t)
      return;
    const [e, n] = await Promise.all([this.mint.getKeySets(), this.mint.getKeys()]);
    this.buildKeychain(e.keysets, n.keysets), this.getCheapestKeyset();
  }
  /**
   * Synchronously load keysets and keys from cached data.
   *
   * @remarks
   * Does not hit the network. Intended for callers that already have a KeyChainCache and want a
   * synchronous path.
   */
  loadFromCache(t) {
    if (t.unit !== this.unit)
      throw new Error(
        `KeyChain unit mismatch in cache, expected '${this.unit}', got '${t.unit}' from ${t.mintUrl}`
      );
    const { keysets: e, keys: n } = G.cacheToMintDTO(t);
    this.buildKeychain(e, n), this.getCheapestKeyset();
  }
  /**
   * Builds keychain from Mint Keyset and Keys data.
   *
   * @param allKeysets Keyset data from mint.getKeySets() API.
   * @param allKeys Keys data from mint.getKeys() API.
   */
  buildKeychain(t, e) {
    this.keysets = {};
    const n = t.filter((i) => i.unit === this.unit);
    if (!n.length)
      throw new Error(`No Keysets found for unit: ${this.unit}`);
    const r = new Map(
      e.filter((i) => i.unit === this.unit).map((i) => [i.id, i])
    );
    for (const i of n) {
      let o;
      if (i.active && it(i.id)) {
        const a = r.get(i.id);
        o = dt.fromMintApi(i, a);
      } else
        o = dt.fromMintApi(i);
      if (o.hasKeys && !o.verify())
        throw new Error(`Keyset verification failed for ID ${o.id}`);
      this.keysets[o.id] = o;
    }
  }
  // ---------------------------------------------------------------------
  // Queries
  // ---------------------------------------------------------------------
  /**
   * Get a keyset by ID or the cheapest keyset if no ID is provided.
   *
   * @param id Optional keyset ID.
   * @returns Keyset with keys.
   * @throws If keyset not found or uninitialized.
   */
  getKeyset(t) {
    const e = t ? this.keysets[t] : this.getCheapestKeyset();
    if (!e)
      throw new Error(`Keyset '${t}' not found`);
    return e;
  }
  /**
   * Get the cheapest active keyset.
   *
   * @remarks
   * Selects active keyset with lowest fee and hex ID.
   * @returns Active Keyset.
   * @throws If none found or uninitialized.
   */
  getCheapestKeyset() {
    if (Object.keys(this.keysets).length === 0)
      throw new Error("KeyChain not initialized");
    const t = Object.values(this.keysets).filter(
      (e) => e.isActive && e.hasHexId && e.hasKeys
    );
    if (t.length === 0)
      throw new Error("No active keyset found");
    return t.sort((e, n) => e.fee - n.fee)[0];
  }
  /**
   * Get list of all keysets for the unit.
   *
   * @returns Array of Keysets.
   * @throws If uninitialized.
   */
  getKeysets() {
    if (Object.keys(this.keysets).length === 0)
      throw new Error("KeyChain not initialized");
    return Object.values(this.keysets);
  }
  /**
   * Returns all the keys in this KeyChain.
   *
   * @remarks
   * This mirrors the old `wallet.getAllKeys()` behaviour and is the preferred replacement in v3.
   * @returns Array of MintKeys objects.
   * @throws If uninitialized.
   */
  getAllKeys() {
    return this.getKeysets().map((t) => t.toMintKeys()).filter((t) => t !== null);
  }
  /**
   * Returns all the keyset IDs in this KeyChain.
   *
   * @returns Array of keyset IDs.
   * @throws If uninitialized.
   */
  getAllKeysetIds() {
    return this.getKeysets().map((t) => t.id);
  }
  // ---------------------------------------------------------------------
  // Caching
  // ---------------------------------------------------------------------
  /**
   * Preferred consolidated cache representation.
   *
   * @remarks
   * Built from the live Keyset instances via their Mint DTO exporters. This is the canonical cache
   * API going forward.
   */
  get cache() {
    const t = this.getKeysets(), e = t.map((r) => r.toMintKeyset()), n = t.map((r) => r.toMintKeys()).filter((r) => r !== null);
    return G.mintToCacheDTO(this.unit, this.mint.mintUrl, e, n);
  }
  /**
   * Legacy Mint API cache format.
   *
   * @remarks
   * Useful for instantiating new wallets / keychains without repeatedly calling the mint API.
   * @deprecated Use the `cache` getter which returns a consolidated KeyChainCache.
   */
  getCache() {
    const t = this.cache, { keysets: e, keys: n } = G.cacheToMintDTO(t);
    return {
      keysets: e,
      keys: n,
      unit: t.unit,
      mintUrl: t.mintUrl
    };
  }
}
class Ut {
  constructor(t, e, n) {
    this.amount = t, this.B_ = e, this.id = n;
  }
  getSerializedBlindedMessage() {
    return { amount: this.amount, B_: this.B_.toHex(!0), id: this.id };
  }
}
const yr = /* @__PURE__ */ new Set([
  "locktime",
  "pubkeys",
  "n_sigs",
  "refund",
  "n_sigs_refund"
]);
function On(s) {
  if (!s || typeof s != "string") throw new Error("tag key must be a non empty string");
  if (yr.has(s))
    throw new Error(`additionalTags must not use reserved key "${s}"`);
}
const Me = 1024, Qt = /* @__PURE__ */ new WeakMap();
function wr(s, t) {
  t && Qt.set(s, t);
}
function kr(s) {
  const t = Qt.get(s);
  if (t)
    return Qt.delete(s), t;
}
class K {
  constructor(t, e, n) {
    this.secret = n, this.blindingFactor = e, this.blindedMessage = t;
  }
  toProof(t, e) {
    let n;
    t.dleq && (n = {
      s: $(t.dleq.s),
      e: $(t.dleq.e),
      r: this.blindingFactor
    });
    const r = {
      id: t.id,
      amount: t.amount,
      C_: Y(t.C_)
    }, i = Y(e.keys[t.amount]), o = gs(r, this.blindingFactor, this.secret, i), a = {
      ...ms(o),
      ...n && {
        dleq: {
          s: j(n.s),
          e: j(n.e),
          r: Wt(n.r ?? BigInt(0))
        }
      }
    }, c = kr(this);
    return c && (a.p2pk_e = c), a;
  }
  static createP2PKData(t, e, n, r) {
    return z(e, n.keys, r).map((o) => this.createSingleP2PKData(t, o, n.id));
  }
  static createSingleP2PKData(t, e, n) {
    const r = Array.isArray(t.pubkey) ? t.pubkey : [t.pubkey], i = t.refundKeys ?? [], o = Math.max(1, Math.min(t.requiredSignatures ?? 1, r.length)), a = Math.max(
      1,
      Math.min(t.requiredRefundSignatures ?? 1, i.length || 1)
    );
    if (r.length === 0)
      throw new Error("P2PK requires at least one pubkey");
    const c = typeof t.hashlock == "string" && t.hashlock.length > 0;
    let u = c ? t.hashlock : r[0], h = c ? r : r.slice(1), l = i, d;
    if (t.blindKeys) {
      const V = [...r, ...i], { blinded: F, Ehex: v } = ks(V, n);
      c ? h = F.slice(0, r.length) : (u = F[0], h = F.slice(1, r.length)), l = F.slice(r.length), d = v;
    }
    const f = [], p = t.locktime ?? NaN;
    if (Number.isSafeInteger(p) && p >= 0 && f.push(["locktime", String(p)]), h.length > 0 && (f.push(["pubkeys", ...h]), o > 1 && f.push(["n_sigs", String(o)])), l.length > 0 && (f.push(["refund", ...l]), a > 1 && f.push(["n_sigs_refund", String(a)])), t.sigFlag == "SIG_ALL" && f.push(["sigflag", "SIG_ALL"]), t.additionalTags?.length) {
      const V = t.additionalTags.map(([F, ...v]) => (On(F), [F, ...v.map(String)]));
      f.push(...V);
    }
    const k = [
      c ? "HTLC" : "P2PK",
      {
        nonce: j(be(32)),
        data: u,
        tags: f
      }
    ], S = JSON.stringify(k), P = [...S].length;
    if (P > Me)
      throw new Error(`Secret too long (${P} characters), maximum is ${Me}`);
    const O = new TextEncoder().encode(S), { r: at, B_: mt } = yt(O), Z = new K(
      new Ut(e, mt, n).getSerializedBlindedMessage(),
      at,
      O
    );
    return t.blindKeys && d && wr(Z, d), Z;
  }
  static createRandomData(t, e, n) {
    return z(t, e.keys, n).map((i) => this.createSingleRandomData(i, e.id));
  }
  static createSingleRandomData(t, e) {
    const n = j(be(32)), r = new TextEncoder().encode(n), { r: i, B_: o } = yt(r);
    return new K(
      new Ut(t, o, e).getSerializedBlindedMessage(),
      i,
      r
    );
  }
  static createDeterministicData(t, e, n, r, i) {
    return z(t, r.keys, i).map(
      (a, c) => this.createSingleDeterministicData(a, e, n + c, r.id)
    );
  }
  /**
   * @throws May throw if blinding factor is out of range. Caller should catch, increment counter,
   *   and retry per BIP32-style derivation.
   */
  static createSingleDeterministicData(t, e, n, r) {
    const i = Ns(e, r, n), o = j(i), a = new TextEncoder().encode(o), c = w.toBigInt(Ls(e, r, n)), { r: u, B_: h } = yt(a, c);
    return new K(
      new Ut(t, h, r).getSerializedBlindedMessage(),
      u,
      a
    );
  }
  /**
   * Calculates the sum of amounts in an array of OutputDataLike objects.
   *
   * @param outputs Array of OutputDataLike objects.
   * @returns The total sum of amounts.
   */
  static sumOutputAmounts(t) {
    return t.reduce((e, n) => e + n.blindedMessage.amount, 0);
  }
}
function Ce(s) {
  const t = s.toLowerCase();
  if (t.length === 66 && (t.startsWith("02") || t.startsWith("03"))) return t;
  if (t.length === 64) return `02${t}`;
  throw new Error(
    `Invalid pubkey, expected 33 byte compressed or 32 byte x only, got length ${t.length}`
  );
}
function br(s) {
  return s instanceof Date ? Math.floor(s.getTime() / 1e3) : s < 1e12 ? Math.floor(s) : Math.floor(s / 1e3);
}
class Dn {
  constructor() {
    this.lockSet = /* @__PURE__ */ new Set(), this.refundSet = /* @__PURE__ */ new Set(), this.extraTags = [];
  }
  addLockPubkey(t) {
    const e = Array.isArray(t) ? t : [t];
    for (const n of e) this.lockSet.add(Ce(n));
    return this;
  }
  addRefundPubkey(t) {
    const e = Array.isArray(t) ? t : [t];
    for (const n of e) this.refundSet.add(Ce(n));
    return this;
  }
  lockUntil(t) {
    return this.locktime = br(t), this;
  }
  requireLockSignatures(t) {
    return this.nSigs = Math.max(1, Math.trunc(t)), this;
  }
  requireRefundSignatures(t) {
    return this.nSigsRefund = Math.max(1, Math.trunc(t)), this;
  }
  addTag(t, e) {
    On(t);
    const n = e === void 0 ? [] : Array.isArray(e) ? e : [e];
    return this.extraTags.push([t, ...n.map(String)]), this;
  }
  addTags(t) {
    for (const [e, ...n] of t) this.addTag(e, n);
    return this;
  }
  /**
   * @experimental
   */
  blindKeys() {
    return this._blindKeys = !0, this;
  }
  sigAll() {
    return this.sigFlag = "SIG_ALL", this;
  }
  /**
   * Converts a `P2PK` output into a NUT-14 `HTLC` kind output.
   */
  addHashlock(t) {
    return this.hashlock = t, this;
  }
  toOptions() {
    const t = Array.from(this.lockSet), e = Array.from(this.refundSet);
    if (t.length === 0) throw new Error("At least one lock pubkey is required");
    if (e.length > 0 && this.locktime === void 0)
      throw new Error(
        "Refund pubkeys require a locktime, add lockUntil(...) or remove refund keys"
      );
    const n = t.length + e.length;
    if (n > 10)
      throw new Error(`Too many pubkeys, ${n} provided, maximum allowed is 10 in total`);
    const r = this.nSigs ? Math.min(Math.max(1, this.nSigs), t.length) : void 0, i = this.nSigsRefund ? Math.min(Math.max(1, this.nSigsRefund), Math.max(1, e.length)) : void 0, a = {
      pubkey: t.length === 1 ? t[0] : t,
      ...this.locktime !== void 0 ? { locktime: this.locktime } : {},
      ...e.length ? { refundKeys: e } : {},
      ...r && r > 1 ? { requiredSignatures: r } : {},
      ...i && i > 1 ? { requiredRefundSignatures: i } : {},
      ...this.extraTags.length ? { additionalTags: this.extraTags.slice() } : {},
      ...this._blindKeys ? { blindKeys: !0 } : {},
      ...this.sigFlag == "SIG_ALL" ? { sigFlag: "SIG_ALL" } : {},
      ...this.hashlock ? { hashlock: this.hashlock } : {}
    };
    return K.createSingleP2PKData(a, 1, "deedbeef"), a;
  }
  static fromOptions(t) {
    const e = new Dn(), n = Array.isArray(t.pubkey) ? t.pubkey : [t.pubkey];
    return e.addLockPubkey(n), t.locktime !== void 0 && e.lockUntil(t.locktime), t.refundKeys?.length && e.addRefundPubkey(t.refundKeys), t.requiredSignatures !== void 0 && e.requireLockSignatures(t.requiredSignatures), t.requiredRefundSignatures !== void 0 && e.requireRefundSignatures(t.requiredRefundSignatures), t.additionalTags?.length && e.addTags(t.additionalTags), t.blindKeys && e.blindKeys(), t.sigFlag == "SIG_ALL" && e.sigAll(), t.hashlock && e.addHashlock(t.hashlock), e;
  }
}
const _r = (s, t, e, n = !1, r = !1, i = M) => {
  const l = Un();
  let d = null, f = 1 / 0, p = 0, g = 0;
  const k = (y) => {
    try {
      return e.getKeyset(y.id).fee;
    } catch (m) {
      Ct(`Could not get fee. No keyset found for keyset id: ${y.id}`, i, {
        error: m,
        keychain: e.getKeysets()
      });
    }
  }, S = (y, m) => y - (n ? Math.ceil(m / 1e3) : 0), P = (y) => {
    const m = [...y];
    for (let A = m.length - 1; A > 0; A--) {
      const _ = Math.floor(Math.random() * (A + 1));
      [m[A], m[_]] = [m[_], m[A]];
    }
    return m;
  }, O = (y, m, A) => {
    let _ = 0, q = y.length - 1, L = null;
    for (; _ <= q; ) {
      const W = Math.floor((_ + q) / 2), tt = y[W].exFee;
      (A ? tt <= m : tt >= m) ? (L = W, A ? _ = W + 1 : q = W - 1) : A ? q = W - 1 : _ = W + 1;
    }
    return A ? L : _ < y.length ? _ : null;
  }, at = (y, m) => {
    const A = m.exFee;
    let _ = 0, q = y.length;
    for (; _ < q; ) {
      const L = Math.floor((_ + q) / 2);
      y[L].exFee < A ? _ = L + 1 : q = L;
    }
    y.splice(_, 0, m);
  }, mt = (y, m) => S(y, m) < t ? 1 / 0 : y + m / 1e3 - t;
  let Z = 0, V = 0;
  const F = s.map((y) => {
    const m = k(y), A = n ? y.amount - m / 1e3 : y.amount, _ = { proof: y, exFee: A, ppkfee: m };
    return (!n || A > 0) && (Z += y.amount, V += m), _;
  });
  let v = n ? F.filter((y) => y.exFee > 0) : F;
  if (v.sort((y, m) => y.exFee - m.exFee), v.length > 0) {
    let y;
    if (r) {
      const m = O(v, t, !0);
      y = m !== null ? m + 1 : 0;
    } else {
      const m = O(v, t, !1);
      if (m !== null) {
        const A = v[m].exFee, _ = O(v, A, !0);
        Le(_, "Unexpected null rightIndex in binary search", i), y = _ + 1;
      } else
        y = v.length;
    }
    for (let m = y; m < v.length; m++)
      Z -= v[m].proof.amount, V -= v[m].ppkfee;
    v = v.slice(0, y);
  }
  const ye = S(Z, V);
  if (t <= 0 || t > ye)
    return { keep: s, send: [] };
  const we = Math.min(
    Math.ceil(t * (1 + 0 / 100)),
    t + 0,
    ye
  );
  for (let y = 0; y < 60; y++) {
    const m = [];
    let A = 0, _ = 0;
    for (const E of P(v)) {
      const D = A + E.proof.amount, x = _ + E.ppkfee, H = S(D, x);
      if (r && H > t || (m.push(E), A = D, _ = x, H >= t)) break;
    }
    const q = new Set(m), L = v.filter((E) => !q.has(E)), W = P(Array.from({ length: m.length }, (E, D) => D)).slice(
      0,
      5e3
    );
    for (const E of W) {
      const D = S(A, _);
      if (D === t || !r && D >= t && D <= we)
        break;
      const x = m[E], H = A - x.proof.amount, et = _ - x.ppkfee, Kn = S(H, et), ke = t - Kn, Kt = O(L, ke, r);
      if (Kt !== null) {
        const ct = L[Kt];
        (!r || ct.exFee > x.exFee) && (ke >= 0 || ct.exFee <= x.exFee) && (m[E] = ct, A = H + ct.proof.amount, _ = et + ct.ppkfee, L.splice(Kt, 1), at(L, x));
      }
    }
    const tt = mt(A, _);
    if (tt < f) {
      i.debug(
        `selectProofsToSend: best solution found in trial #${y} - amount: ${A}, delta: ${tt}`
      ), d = [...m].sort((D, x) => x.exFee - D.exFee), f = tt, p = A, g = _;
      const E = [...d];
      for (; E.length > 1 && f > 0; ) {
        const D = E.pop(), x = A - D.proof.amount, H = _ - D.ppkfee, et = mt(x, H);
        if (et == 1 / 0) break;
        et < f && (d = [...E], f = et, p = x, g = H, A = x, _ = H);
      }
    }
    if (d && f < 1 / 0) {
      const E = S(p, g);
      if (E === t || !r && E >= t && E <= we)
        break;
    }
    if (l.elapsed() > 1e3) {
      Jt(
        r,
        "Proof selection took too long. Try again with a smaller proof set.",
        i
      ), i.warn("Proof selection took too long. Returning best selection so far.");
      break;
    }
  }
  if (d && f < 1 / 0) {
    const y = d.map((_) => _.proof), m = new Set(y), A = s.filter((_) => !m.has(_));
    return i.info(`Proof selection took ${l.elapsed()}ms`), { keep: A, send: y };
  }
  return { keep: s, send: [] };
};
class Ar {
  constructor(t) {
    if (this.next = /* @__PURE__ */ new Map(), this.locks = /* @__PURE__ */ new Map(), t)
      for (const [e, n] of Object.entries(t)) this.next.set(e, n);
  }
  async withLock(t, e) {
    const n = this.locks.get(t) ?? Promise.resolve();
    let r;
    const i = new Promise((a) => r = a), o = n.then(() => i);
    this.locks.set(t, o);
    try {
      return await n, await e();
    } finally {
      r(), this.locks.get(t) === o && this.locks.delete(t);
    }
  }
  async reserve(t, e) {
    if (e < 0) throw new Error("reserve called with negative count");
    return this.withLock(t, () => {
      const n = this.next.get(t) ?? 0;
      return e === 0 ? { start: n, count: 0 } : (this.next.set(t, n + e), { start: n, count: e });
    });
  }
  async advanceToAtLeast(t, e) {
    await this.withLock(t, () => {
      const n = this.next.get(t) ?? 0;
      e > n && this.next.set(t, e);
    });
  }
  async setNext(t, e) {
    await this.withLock(t, () => {
      if (e < 0) throw new Error("setNext: negative next not allowed");
      this.next.set(t, e);
    });
  }
  snapshot() {
    return Promise.resolve(Object.fromEntries(this.next.entries()));
  }
}
class Sr {
  constructor(t) {
    this.wallet = t;
  }
  send(t, e) {
    return new Pr(this.wallet, t, e);
  }
  receive(t) {
    return new vr(this.wallet, t);
  }
  mintBolt11(t, e) {
    return new xe(this.wallet, "bolt11", t, e);
  }
  mintBolt12(t, e) {
    return new xe(this.wallet, "bolt12", t, e);
  }
  meltBolt11(t, e) {
    return new Be(this.wallet, "bolt11", t, e);
  }
  meltBolt12(t, e) {
    return new Be(this.wallet, "bolt12", t, e);
  }
}
class Pr {
  constructor(t, e, n) {
    this.wallet = t, this.amount = e, this.proofs = n, this.config = {};
  }
  /**
   * Use random blinding for the sent outputs.
   *
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asRandom(t) {
    return this.sendOT = { type: "random", denominations: t }, this;
  }
  /**
   * Use deterministic outputs for the sent proofs.
   *
   * @param counter Starting counter. Zero means auto reserve using the wallets CounterSource.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asDeterministic(t = 0, e) {
    return this.sendOT = { type: "deterministic", counter: t, denominations: e }, this;
  }
  /**
   * Use P2PK locked outputs for the sent proofs.
   *
   * @param options NUT 11 options like pubkey and locktime.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asP2PK(t, e) {
    return this.sendOT = { type: "p2pk", options: t, denominations: e }, this;
  }
  /**
   * Use a factory to generate OutputData for the sent proofs.
   *
   * @param factory OutputDataFactory used to produce blinded messages.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asFactory(t, e) {
    return this.sendOT = { type: "factory", factory: t, denominations: e }, this;
  }
  /**
   * Provide pre created OutputData for the sent proofs.
   *
   * @param data Fully formed OutputData. Their amounts must sum to the send amount, otherwise the
   *   wallet will throw.
   */
  asCustom(t) {
    return this.sendOT = { type: "custom", data: t }, this;
  }
  /**
   * Use random blinding for change outputs.
   *
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  keepAsRandom(t) {
    return this.keepOT = { type: "random", denominations: t }, this;
  }
  /**
   * Use deterministic outputs for change.
   *
   * @param counter Starting counter. Zero means auto reserve using the wallets CounterSource.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  keepAsDeterministic(t = 0, e) {
    return this.keepOT = { type: "deterministic", counter: t, denominations: e }, this;
  }
  /**
   * Use P2PK locked change (NUT 11).
   *
   * @param options Locking options applied to the kept proofs.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  keepAsP2PK(t, e) {
    return this.keepOT = { type: "p2pk", options: t, denominations: e }, this;
  }
  /**
   * Use a factory to generate OutputData for change.
   *
   * @param factory OutputDataFactory used to produce blinded messages.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  keepAsFactory(t, e) {
    return this.keepOT = { type: "factory", factory: t, denominations: e }, this;
  }
  /**
   * Provide pre created OutputData for change.
   *
   * @param data Fully formed OutputData for the keep (change) amount.
   */
  keepAsCustom(t) {
    return this.keepOT = { type: "custom", data: t }, this;
  }
  /**
   * Make the sender cover the receivers future spend fee.
   *
   * @param on When true, include fees in the sent amount. Default true if called.
   */
  includeFees(t = !0) {
    return this.config.includeFees = t, this;
  }
  /**
   * Use a specific keyset for the operation.
   *
   * @param id Keyset id to use for mint keys and fee lookup.
   */
  keyset(t) {
    return this.config.keysetId = t, this;
  }
  /**
   * Private key(s) used to sign P2PK locked proofs.
   *
   * @param k Single key or array of multisig keys.
   */
  privkey(t) {
    return this.config.privkey = t, this;
  }
  /**
   * Provide existing proofs to help optimise denomination selection.
   *
   * @remarks
   * Has no effect if denominations (custom split) was specified.
   * @param p Proofs currently held by the wallet, used to hit denomination targets.
   */
  proofsWeHave(t) {
    return this.config.proofsWeHave = t, this;
  }
  /**
   * Receive a callback once counters are atomically reserved for deterministic outputs.
   *
   * @param cb Called with OperationCounters when counters are reserved.
   */
  onCountersReserved(t) {
    return this.config.onCountersReserved = t, this;
  }
  /**
   * Force a pure offline, exact match selection. No mint calls are made. If an exact match cannot
   * be found, this throws.
   *
   * @param requireDleq Only consider proofs with a DLEQ when true.
   */
  offlineExactOnly(t = !1) {
    return this.offlineExact = { requireDleq: t }, this;
  }
  /**
   * Force a pure offline selection that allows a close match, overspend permitted per wallet RGLI.
   * No mint calls are made. Returns the best offline subset found, or throws if funds are
   * insufficient.
   *
   * @param requireDleq Only consider proofs with a DLEQ when true.
   */
  offlineCloseMatch(t = !1) {
    return this.offlineClose = { requireDleq: t }, this;
  }
  /**
   * Prepare the swap to send.
   *
   * @remarks
   * Call `wallet.completeSwap(SwapPreview)` to complete the send.
   * @returns A SwapPreview containing inputs, outputs, amount, fee and unselectedProofs.
   */
  async prepare() {
    const t = {
      send: this.sendOT ?? this.wallet.defaultOutputType(),
      ...this.keepOT ? { keep: this.keepOT } : {}
    };
    return this.wallet.prepareSwapToSend(this.amount, this.proofs, this.config, t);
  }
  /**
   * Execute the send.
   *
   * @returns The split result with kept and sent proofs.
   */
  async run() {
    if ((this.offlineExact || this.offlineClose) && (this.sendOT || this.keepOT))
      throw new Error(
        "Offline selection cannot be combined with custom output types. Remove send/keep output configuration, or use an online swap."
      );
    if (this.offlineExact)
      return this.config.privkey && (this.proofs = this.wallet.signP2PKProofs(this.proofs, this.config.privkey)), this.wallet.sendOffline(this.amount, this.proofs, {
        includeFees: this.config.includeFees,
        exactMatch: !0,
        requireDleq: this.offlineExact.requireDleq
      });
    if (this.offlineClose)
      return this.config.privkey && (this.proofs = this.wallet.signP2PKProofs(this.proofs, this.config.privkey)), this.wallet.sendOffline(this.amount, this.proofs, {
        includeFees: this.config.includeFees,
        exactMatch: !1,
        requireDleq: this.offlineClose.requireDleq
      });
    const t = {
      send: this.sendOT ?? this.wallet.defaultOutputType(),
      ...this.keepOT ? { keep: this.keepOT } : {}
    };
    return this.wallet.send(this.amount, this.proofs, this.config, t);
  }
}
class vr {
  constructor(t, e) {
    this.wallet = t, this.token = e, this.config = {};
  }
  /**
   * Use random blinding for the received outputs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asRandom(t) {
    return this.outputType = { type: "random", denominations: t }, this;
  }
  /**
   * Use deterministic outputs for the received proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param counter Starting counter. Zero means auto reserve using the wallets CounterSource.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asDeterministic(t = 0, e) {
    return this.outputType = { type: "deterministic", counter: t, denominations: e }, this;
  }
  /**
   * Use P2PK locked outputs for the received proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param options NUT 11 options like pubkey and locktime.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asP2PK(t, e) {
    return this.outputType = { type: "p2pk", options: t, denominations: e }, this;
  }
  /**
   * Use a factory to generate OutputData for received proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param factory OutputDataFactory used to produce blinded messages.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asFactory(t, e) {
    return this.outputType = { type: "factory", factory: t, denominations: e }, this;
  }
  /**
   * Provide pre created OutputData for received proofs.
   *
   * @param data Fully formed OutputData for the final amount.
   */
  asCustom(t) {
    return this.outputType = { type: "custom", data: t }, this;
  }
  /**
   * Use a specific keyset for the operation.
   *
   * @param id Keyset id to use for mint keys and fee lookup.
   */
  keyset(t) {
    return this.config.keysetId = t, this;
  }
  /**
   * Require all incoming proofs to have a valid DLEQ for the selected keyset.
   *
   * @param on When true, proofs without DLEQ are rejected.
   */
  requireDleq(t = !0) {
    return this.config.requireDleq = t, this;
  }
  /**
   * Private key(s) used to sign P2PK locked incoming proofs.
   *
   * @param k Single key or array of multisig keys.
   */
  privkey(t) {
    return this.config.privkey = t, this;
  }
  /**
   * Provide existing proofs to help optimise denomination selection.
   *
   * @remarks
   * Has no effect if denominations (custom split) was specified.
   * @param p Proofs currently held by the wallet, used to hit denomination targets.
   */
  proofsWeHave(t) {
    return this.config.proofsWeHave = t, this;
  }
  /**
   * Receive a callback once counters are atomically reserved for deterministic outputs.
   *
   * @param cb Called with OperationCounters when counters are reserved.
   */
  onCountersReserved(t) {
    return this.config.onCountersReserved = t, this;
  }
  /**
   * Prepare the swap to receive.
   *
   * @remarks
   * Call `wallet.completeSwap(SwapPreview)` to complete the receive.
   * @returns A SwapPreview containing inputs, outputs, amount, and fee.
   */
  async prepare() {
    return this.wallet.prepareSwapToReceive(this.token, this.config, this.outputType);
  }
  /**
   * Execute the receive.
   *
   * @returns The new proofs.
   */
  async run() {
    return this.wallet.receive(this.token, this.config, this.outputType);
  }
}
class xe {
  constructor(t, e, n, r) {
    this.wallet = t, this.method = e, this.amount = n, this.quote = r, this.config = {}, this._hasPrivkey;
  }
  /**
   * Use random blinding for the minted proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asRandom(t) {
    return this.outputType = { type: "random", denominations: t }, this;
  }
  /**
   * Use deterministic outputs for the minted proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param counter Starting counter. Zero means auto reserve using the wallets CounterSource.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asDeterministic(t = 0, e) {
    return this.outputType = { type: "deterministic", counter: t, denominations: e }, this;
  }
  /**
   * Use P2PK locked outputs for the minted proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param options NUT 11 options like pubkey and locktime.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asP2PK(t, e) {
    return this.outputType = { type: "p2pk", options: t, denominations: e }, this;
  }
  /**
   * Use a factory to generate OutputData for minted proofs.
   *
   * @remarks
   * If denoms specified, proofsWeHave() will have no effect.
   * @param factory OutputDataFactory used to produce blinded messages.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asFactory(t, e) {
    return this.outputType = { type: "factory", factory: t, denominations: e }, this;
  }
  /**
   * Provide pre created OutputData for minted proofs.
   *
   * @param data Fully formed OutputData for the final amount.
   */
  asCustom(t) {
    return this.outputType = { type: "custom", data: t }, this;
  }
  /**
   * Use a specific keyset for the operation.
   *
   * @param id Keyset id to use for mint keys and fee lookup.
   */
  keyset(t) {
    return this.config.keysetId = t, this;
  }
  /**
   * Private key to sign locked mint quotes.
   *
   * @param k Private key for locked quotes.
   */
  privkey(t) {
    return this.config.privkey = t, this;
  }
  /**
   * Provide existing proofs to help optimise denomination selection.
   *
   * @remarks
   * Has no effect if denominations (custom split) was specified.
   * @param p Proofs currently held by the wallet, used to hit denomination targets.
   */
  proofsWeHave(t) {
    return this.config.proofsWeHave = t, this;
  }
  /**
   * Receive a callback once counters are atomically reserved for deterministic outputs.
   *
   * @param cb Called with OperationCounters when counters are reserved.
   */
  onCountersReserved(t) {
    return this.config.onCountersReserved = t, this;
  }
  /**
   * Execute minting against the quote.
   *
   * @remarks
   * This method can only be called for bolt12 quotes when .privkey() is set.
   * @returns The newly minted proofs.
   */
  async run() {
    if (this.method === "bolt11") {
      const e = this.quote;
      if (typeof e != "string" && e.pubkey && !this.config.privkey)
        throw new Error("privkey is required for locked BOLT11 mint quotes");
      return this.wallet.mintProofsBolt11(this.amount, e, this.config, this.outputType);
    }
    const t = this.quote;
    if (!this.config.privkey)
      throw new Error("privkey is required for BOLT12 mint quotes");
    return this.wallet.mintProofsBolt12(
      this.amount,
      t,
      this.config.privkey,
      this.config,
      this.outputType
    );
  }
}
class Be {
  constructor(t, e, n, r) {
    this.wallet = t, this.method = e, this.quote = n, this.proofs = r, this.config = {};
  }
  /**
   * Use random blinding for change outputs.
   *
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asRandom(t) {
    return this.outputType = { type: "random", denominations: t }, this;
  }
  /**
   * Use deterministic outputs for change.
   *
   * @param counter Starting counter. Zero means auto reserve using the wallets CounterSource.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asDeterministic(t = 0, e) {
    return this.outputType = { type: "deterministic", counter: t, denominations: e }, this;
  }
  /**
   * Use P2PK-locked change (NUT-11).
   *
   * @param options NUT-11 locking options (e.g., pubkey, locktime).
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asP2PK(t, e) {
    return this.outputType = { type: "p2pk", options: t, denominations: e }, this;
  }
  /**
   * Use a factory to generate OutputData for change.
   *
   * @param factory Factory used to produce blinded messages.
   * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
   */
  asFactory(t, e) {
    return this.outputType = { type: "factory", factory: t, denominations: e }, this;
  }
  /**
   * Provide pre-created OutputData for change.
   *
   * @param data Fully formed OutputData for the change amount.
   */
  asCustom(t) {
    return this.outputType = { type: "custom", data: t }, this;
  }
  /**
   * Use a specific keyset for the melt operation.
   *
   * @param id Keyset id to use for mint keys and fee lookup.
   */
  keyset(t) {
    return this.config.keysetId = t, this;
  }
  /**
   * Private key(s) used to sign P2PK locked proofs.
   *
   * @param k Single key or array of multisig keys.
   */
  privkey(t) {
    return this.config.privkey = t, this;
  }
  /**
   * Receive a callback once counters are atomically reserved for deterministic outputs.
   *
   * @param cb Called with OperationCounters when counters are reserved.
   */
  onCountersReserved(t) {
    return this.config.onCountersReserved = t, this;
  }
  /**
   * Receive a callback when NUT-08 blanks (0-sat change outputs) are created for async melts.
   *
   * @remarks
   * You can persist these blanks and later call `wallet.completeMelt(blanks)` to finalize and
   * recover change once the invoice/offer is paid.
   * @deprecated Use prepare() instead of run() and store the MeltPreview instead.
   * @param cb Callback invoked with the created blanks payload.
   */
  onChangeOutputsCreated(t) {
    return this.config.onChangeOutputsCreated = t, this;
  }
  /**
   * Prepare the melt.
   *
   * @remarks
   * Call `wallet.completeMelt(MeltPreview)` to complete the melt.
   * @returns A MeltPreview containing inputs, outputs, amount, and fee.
   */
  async prepare() {
    return await this.wallet.prepareMelt(
      this.method,
      this.quote,
      this.proofs,
      this.config,
      this.outputType
    );
  }
  /**
   * Execute the melt against the quote.
   *
   * @returns The melt result: `{ quote, change }`.
   */
  async run() {
    const t = await this.wallet.prepareMelt(
      this.method,
      this.quote,
      this.proofs,
      this.config,
      this.outputType
    );
    return this.wallet.completeMelt(t, this.config.privkey);
  }
}
function Tr(s) {
  const t = /* @__PURE__ */ new WeakSet();
  try {
    return JSON.stringify(s, (e, n) => {
      if (typeof n == "object" && n !== null) {
        if (t.has(n)) return "[Circular]";
        t.add(n);
      }
      return n;
    });
  } catch {
    return Object.prototype.toString.call(s);
  }
}
function Oe(s) {
  if (s instanceof Error) return s;
  const t = typeof s == "string" ? s : Tr(s), e = new Error(t);
  return e.cause = s, e;
}
function De() {
  const s = new Error("Aborted");
  return Object.defineProperty(s, "name", { value: "AbortError" }), s;
}
function J(s) {
  s && Promise.resolve(s).then((t) => {
    try {
      t();
    } catch {
    }
  }).catch(() => {
  });
}
class Er {
  constructor(t) {
    this.wallet = t, this.countersReservedHandlers = /* @__PURE__ */ new Set(), this.meltBlanksHandlers = /* @__PURE__ */ new Set();
  }
  // Binds an abort signal to each subscription canceller
  withAbort(t, e) {
    if (!t) return e;
    if (t.aborted)
      return e(), () => {
      };
    const n = () => e();
    return t.addEventListener("abort", n, { once: !0 }), () => {
      t.removeEventListener("abort", n), e();
    };
  }
  // Subscribe to a quote-paid event and resolve when it fires.
  // Supports AbortSignal and timeout, and always cleans up.
  waitUntilPaid(t, e, n, r = "Timeout waiting for paid") {
    return new Promise((i, o) => {
      let a = null, c = null, u = !1;
      const h = (d) => {
        u || (u = !0, J(a), c && (clearTimeout(c), c = null), n?.signal && n.signal.removeEventListener("abort", l), d && o(Oe(d)));
      }, l = () => h(De());
      if (n?.signal) {
        if (n.signal.aborted) return l();
        n.signal.addEventListener("abort", l, { once: !0 });
      }
      n?.timeoutMs && n.timeoutMs > 0 && (c = setTimeout(() => h(new Error(r)), n.timeoutMs)), a = t(
        e,
        (d) => {
          h(), i(d);
        },
        (d) => h(d),
        // reject if subscription itself errors
        { signal: n?.signal }
        // delegate abort to subscription as well
      ), a.catch((d) => h(d));
    });
  }
  /**
   * Register a callback that fires whenever deterministic counters are reserved.
   *
   * Timing: the callback is invoked synchronously _after_ a successful reservation and _before_ the
   * enclosing wallet method returns. The wallet does **not** await your callback, it is
   * fire-and-forget.
   *
   * Responsibility for async work is on the consumer. If your handler calls an async function (e.g.
   * persisting `start + count` to storage), make sure to handle errors inside it to avoid unhandled
   * rejections.
   *
   * Typical use: persist `start + count` for the `keysetId` so counters survive restarts.
   *
   * @example
   *
   * ```ts
   * wallet.on.countersReserved(({ keysetId, start, count, next }) => {
   * 	saveNextToDb(keysetId, start + count); // handle async errors inside saveNextToDb
   * });
   * ```
   *
   * @param cb Handler called with { keysetId, start, count }.
   * @returns A function that unsubscribes the handler.
   */
  countersReserved(t, e) {
    this.countersReservedHandlers.add(t);
    const n = () => this.countersReservedHandlers.delete(t);
    return this.withAbort(e?.signal, n);
  }
  /**
   * @internal
   */
  _emitCountersReserved(t) {
    for (const e of this.countersReservedHandlers)
      ht(e, t, this.wallet.logger, { event: "countersReserved" });
  }
  /**
   * Register a callback fired whenever NUT-08 blanks are created during a melt.
   *
   * Called synchronously right after blanks are prepared (before the melt request), and the wallet
   * does not await your handler.
   *
   * Typical use: persist `payload` so you can later call `wallet.completeMelt(payload)`.
   *
   * @deprecated Use wallet.prepareMelt() and store the MeltPreview instead.
   */
  meltBlanksCreated(t, e) {
    this.meltBlanksHandlers.add(t);
    const n = () => this.meltBlanksHandlers.delete(t);
    return this.withAbort(e?.signal, n);
  }
  /**
   * @internal
   */
  _emitMeltBlanksCreated(t) {
    for (const e of this.meltBlanksHandlers)
      ht(e, t, this.wallet.logger, { event: "meltBlanksCreated" });
  }
  /**
   * Register a callback to be called whenever a mint quote's state changes.
   *
   * @param quoteIds List of mint quote IDs that should be subscribed to.
   * @param callback Callback function that will be called whenever a mint quote state changes.
   * @param errorCallback
   * @returns
   */
  async mintQuoteUpdates(t, e, n, r) {
    await this.wallet.mint.connectWebSocket();
    const i = this.wallet.mint.webSocketConnection;
    if (!i) throw new Error("Failed to establish WebSocket connection.");
    const o = Array.from(new Set(t)), a = i.createSubscription({ kind: "bolt11_mint_quote", filters: o }, e, n), c = () => i.cancelSubscription(a, e);
    return this.withAbort(r?.signal, c);
  }
  /**
   * Register a callback to be called when a single mint quote gets paid.
   *
   * @param quoteId Mint quote id that should be subscribed to.
   * @param callback Callback function that will be called when this mint quote gets paid.
   * @param errorCallback
   * @returns
   */
  async mintQuotePaid(t, e, n, r) {
    return this.mintQuoteUpdates(
      [t],
      (i) => {
        i.state === jt.PAID && e(i);
      },
      n,
      r
    );
  }
  /**
   * Register a callback to be called whenever a melt quotes state changes.
   *
   * @param quoteId Melt quote id that should be subscribed to.
   * @param callback Callback function that will be called when this melt quote gets paid.
   * @param errorCallback
   * @returns
   */
  async meltQuoteUpdates(t, e, n, r) {
    await this.wallet.mint.connectWebSocket();
    const i = this.wallet.mint.webSocketConnection;
    if (!i) throw new Error("Failed to establish WebSocket connection.");
    const o = Array.from(new Set(t)), a = i.createSubscription({ kind: "bolt11_melt_quote", filters: o }, e, n), c = () => i.cancelSubscription(a, e);
    return this.withAbort(r?.signal, c);
  }
  /**
   * Register a callback to be called when a single melt quote gets paid.
   *
   * @param quoteIds List of melt quote IDs that should be subscribed to.
   * @param callback Callback function that will be called whenever a melt quote state changes.
   * @param errorCallback
   * @returns
   */
  async meltQuotePaid(t, e, n, r) {
    return this.meltQuoteUpdates(
      [t],
      (i) => {
        i.state === lt.PAID && e(i);
      },
      n,
      r
    );
  }
  /**
   * Register a callback to be called whenever a subscribed proof state changes.
   *
   * @param proofs List of proofs that should be subscribed to.
   * @param callback Callback function that will be called whenever a proof's state changes.
   * @param errorCallback
   * @returns
   */
  async proofStateUpdates(t, e, n, r) {
    await this.wallet.mint.connectWebSocket();
    const i = this.wallet.mint.webSocketConnection;
    if (!i) throw new Error("Failed to establish WebSocket connection.");
    const o = new TextEncoder(), a = {};
    for (const d of t) {
      const f = pt(o.encode(d.secret)).toHex(!0);
      a[f] = d;
    }
    const c = Object.keys(a), u = (d) => {
      e({ ...d, proof: a[d.Y] });
    }, h = i.createSubscription({ kind: "proof_state", filters: c }, u, n), l = () => i.cancelSubscription(h, u);
    return this.withAbort(r?.signal, l);
  }
  /**
   * Resolve once a mint quote transitions to PAID, with automatic unsubscription, optional abort
   * signal, and optional timeout.
   *
   * The underlying subscription is always cancelled after resolution or rejection, including on
   * timeout or abort.
   *
   * @example
   *
   * ```ts
   * const ac = new AbortController();
   * // Cancel if the user navigates away
   * window.addEventListener('beforeunload', () => ac.abort(), { once: true });
   *
   * try {
   * 	const paid = await wallet.on.onceMintPaid(quoteId, {
   * 		signal: ac.signal,
   * 		timeoutMs: 60_000,
   * 	});
   * 	console.log('Mint paid, amount', paid.amount);
   * } catch (e) {
   * 	if ((e as Error).name === 'AbortError') {
   * 		console.log('User aborted');
   * 	} else {
   * 		console.error('Mint not paid', e);
   * 	}
   * }
   * ```
   *
   * @param id Mint quote id to watch.
   * @param opts Optional controls.
   * @param opts.signal AbortSignal to cancel the wait early.
   * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.
   * @returns A promise that resolves with the latest `MintQuoteBolt11Response` once PAID.
   */
  onceMintPaid(t, e) {
    return this.waitUntilPaid(
      this.mintQuotePaid.bind(this),
      t,
      e,
      "Timeout waiting for mint paid"
    );
  }
  /**
   * Resolve when ANY of several mint quotes is PAID, cancelling the rest.
   *
   * Subscribes to all distinct ids, resolves with `{ id, quote }` for the first PAID, and cancels
   * all remaining subscriptions.
   *
   * Errors from individual subscriptions are ignored by default so a single noisy stream does not
   * abort the whole race. Set `failOnError: true` to reject on the first error instead. If all
   * subscriptions error and none paid, the promise rejects with the last seen error.
   *
   * @example
   *
   * ```ts
   * // Race multiple quotes obtained from splitting a large top up
   * const { id, quote } = await wallet.on.onceAnyMintPaid(batchQuoteIds, {
   * 	timeoutMs: 120_000,
   * });
   * console.log('First top up paid', id, quote.preimage?.length);
   * ```
   *
   * @param ids Array of mint quote ids (duplicates are ignored).
   * @param opts Optional controls.
   * @param opts.signal AbortSignal to cancel the wait early.
   * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.
   * @param opts.failOnError When true, reject on first error. Default false.
   * @returns A promise resolving to the id that won and its `MintQuoteBolt11Response`.
   */
  onceAnyMintPaid(t, e) {
    return new Promise((n, r) => {
      const i = Array.from(new Set(t)), o = /* @__PURE__ */ new Map();
      let a = null, c = null, u = !1, h = !1;
      const l = (f) => {
        if (!h) {
          h = !0;
          for (const p of o.values())
            J(p);
          o.clear(), a && (clearTimeout(a), a = null), e?.signal && e.signal.removeEventListener("abort", d), f && r(Oe(f));
        }
      }, d = () => l(De());
      if (e?.signal) {
        if (e.signal.aborted) return d();
        e.signal.addEventListener("abort", d, { once: !0 });
      }
      if (e?.timeoutMs && e.timeoutMs > 0 && (a = setTimeout(
        () => l(new Error("Timeout waiting for any mint paid")),
        e.timeoutMs
      )), i.length === 0) return l(new Error("No quote ids provided"));
      for (const f of i) {
        const p = this.mintQuotePaid(
          f,
          (g) => {
            l(), n({ id: f, quote: g });
          },
          (g) => {
            if (e?.failOnError) {
              l(g);
              return;
            }
            c = g;
            const k = o.get(f);
            k && (J(k), o.delete(f)), u && o.size === 0 && l(c ?? new Error("No subscriptions remaining"));
          }
        );
        o.set(f, p), p.catch((g) => {
          if (e?.failOnError) {
            l(g);
            return;
          }
          c = g;
          const k = o.get(f);
          k && (J(k), o.delete(f)), u && o.size === 0 && l(c ?? new Error("No subscriptions remaining"));
        });
      }
      u = !0;
    });
  }
  /**
   * Resolve once a melt quote transitions to PAID, with automatic unsubscription, optional abort
   * signal, and optional timeout.
   *
   * Mirrors onceMintPaid, but for melts.
   *
   * @example
   *
   * ```ts
   * try {
   * 	const paid = await wallet.on.onceMeltPaid(meltId, { timeoutMs: 45_000 });
   * 	console.log('Invoice paid by mint, paid msat', paid.paid ?? 0);
   * } catch (e) {
   * 	console.error('Payment did not complete in time', e);
   * }
   * ```
   *
   * @param id Melt quote id to watch.
   * @param opts Optional controls.
   * @param opts.signal AbortSignal to cancel the wait early.
   * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.
   * @returns A promise that resolves with the `MeltQuoteBolt11Response` once PAID.
   */
  onceMeltPaid(t, e) {
    return this.waitUntilPaid(
      this.meltQuotePaid.bind(this),
      t,
      e,
      "Timeout waiting for melt paid"
    );
  }
  /**
   * Async iterable that yields proof state updates for the provided proofs.
   *
   * Adds a bounded buffer option:
   *
   * - If `maxBuffer` is set and the queue is full when a new payload arrives, either drop the oldest
   *   queued payload (`drop: 'oldest'`, default) or the incoming payload (`drop: 'newest'`). In
   *   both cases `onDrop` is invoked with the dropped payload.
   *
   * The stream ends and cleans up on abort or on the wallet error callback. Errors from the wallet
   * are treated as a graceful end for this iterator.
   *
   * @example
   *
   * ```ts
   * const ac = new AbortController();
   * try {
   * 	for await (const update of wallet.on.proofStatesStream(myProofs)) {
   * 		if (update.state === CheckStateEnum.SPENT) {
   * 			console.warn('Spent proof', update.proof.id);
   * 		}
   * 	}
   * } catch (e) {
   * 	if ((e as Error).name !== 'AbortError') {
   * 		console.error('Stream error', e);
   * 	}
   * }
   * ```
   *
   * @param proofs The proofs to subscribe to. Only `secret` is required.
   * @param opts Optional controls.
   * @param opts.signal AbortSignal that stops the stream when aborted.
   * @param opts.maxBuffer Maximum number of queued items before applying the drop strategy.
   * @param opts.drop Overflow strategy when `maxBuffer` is reached, 'oldest' | 'newest'. Default
   *   'oldest'.
   * @param opts.onDrop Callback invoked with the payload that was dropped.
   * @returns An async iterable of update payloads.
   */
  proofStatesStream(t, e) {
    return async function* () {
      const n = [];
      let r = !1, i = null;
      const o = e?.maxBuffer && e.maxBuffer > 0 ? e.maxBuffer : 1 / 0, a = e?.drop ?? "oldest", c = () => {
        const d = i;
        i = null, d && d();
      }, u = (d) => {
        if (n.length >= o)
          if (a === "oldest") {
            const f = n.shift();
            if (f !== void 0)
              try {
                e?.onDrop?.(f);
              } catch {
              }
            n.push(d);
          } else {
            try {
              e?.onDrop?.(d);
            } catch {
            }
            return;
          }
        else
          n.push(d);
        c();
      }, h = this.proofStateUpdates(
        t,
        (d) => {
          u(d);
        },
        () => {
          r = !0, c();
        },
        { signal: e?.signal }
      ), l = () => {
        r = !0, c();
      };
      try {
        for (e?.signal && (e.signal.aborted ? l() : e.signal.addEventListener("abort", l, { once: !0 })); !r || n.length; ) {
          for (; n.length; ) yield n.shift();
          if (r) break;
          await new Promise((d) => i = d);
        }
      } finally {
        J(h), e?.signal && e.signal.removeEventListener("abort", l);
      }
    }.call(this);
  }
  /**
   * Create a composite canceller that can collect many subscriptions and dispose them all in one
   * call.
   *
   * Accepts both a `SubscriptionCanceller` and a `Promise<SubscriptionCanceller>`. When the
   * composite canceller is called, all collected cancellations are invoked. Errors from individual
   * cancellers are caught and ignored.
   *
   * The returned function also has an `.add()` method to register more cancellers, and a
   * `.cancelled` boolean property for debugging.
   *
   * @example
   *
   * ```ts
   * const cancelAll = wallet.on.group();
   * cancelAll.add(wallet.on.mintQuotes(ids, onUpdate, onErr));
   * cancelAll.add(asyncSubscribeElsewhere());
   *
   * // later
   * cancelAll(); // disposes everything
   * ```
   *
   * @returns Composite canceller function with `.add()` and `.cancelled` members.
   */
  group() {
    const t = [];
    let e = !1;
    const n = (() => {
      if (!e)
        for (e = !0; t.length; ) J(t.pop());
    });
    return n.add = (r) => e ? (J(r), r) : (t.push(r), r), Object.defineProperty(n, "cancelled", {
      get: () => e,
      enumerable: !0
    }), n;
  }
}
class Ir {
  constructor(t) {
    this.src = t;
  }
  /**
   * Returns the "next" counter for a specified keyset.
   */
  async peekNext(t) {
    return (await this.src.reserve(t, 0)).start;
  }
  /**
   * Bumps the counter if it is behind `minNext` (no-op if ahead).
   */
  async advanceToAtLeast(t, e) {
    await this.src.advanceToAtLeast(t, e);
  }
  /**
   * Hard-sets the cursor (useful for tests or migrations).
   *
   * @throws If the CounterSource does not support setNext()
   */
  async setNext(t, e) {
    if (typeof this.src.setNext == "function") {
      await this.src.setNext(t, e);
      return;
    }
    throw new Error("CounterSource does not support setNext()");
  }
  /**
   * Returns the current "next" per keyset (what will be reserved next).
   *
   * @throws If the CounterSource does not support snapshot()
   */
  async snapshot() {
    if (typeof this.src.snapshot == "function")
      return await this.src.snapshot();
    throw new Error("CounterSource does not support snapshot()");
  }
}
const Ft = "__PENDING__";
class me {
  /**
   * Create a wallet for a given mint and unit. Call `loadMint` before use.
   *
   * Binding, if `options.keysetId` is omitted, the wallet binds to the cheapest active keyset for
   * this unit during `loadMint`. The keychain only loads keysets for this unit.
   *
   * Caching, to preload, provide both `keysets` and `keys`, otherwise the cache is ignored.
   *
   * Deterministic secrets, pass `bip39seed` and optionally `secretsPolicy`. Deterministic outputs
   * reserve counters from `counterSource`, or an ephemeral in memory source if not supplied.
   * `initialCounter` applies only with a supplied `keysetId` and the ephemeral source.
   *
   * Splitting, `denominationTarget` guides proof splits, default is 3. Override coin selection with
   * `selectProofs` if needed. Logging defaults to a null logger.
   *
   * @remarks
   * The options.keys, options.keysets, options.mintInfo options are deprecated. Use
   * wallet.loadMintFromCache() after init to load cached mint data.
   * @param mint Mint instance or URL.
   * @param options Optional settings.
   * @param options.unit Wallet unit, default 'sat'.
   * @param options.keysetId Bind to this keyset id, else bind on `loadMint`.
   * @param options.bip39seed BIP39 seed for deterministic secrets.
   * @param options.secretsPolicy Secrets policy, default 'auto'.
   * @param options.counterSource Counter source for deterministic outputs. If provided, this takes
   *   precedence over counterInit. Use when you need persistence across processes or devices.
   * @param options.counterInit Seed values for the built-in EphemeralCounterSource. Ignored if
   *   counterSource is also provided.
   * @param options.keys DEPRECATED: Use `wallet.loadMintFromCache` after init.
   * @param options.keysets DEPRECATED: Use `wallet.loadMintFromCache` after init.
   * @param options.mintInfo DEPRECATED: Use `wallet.loadMintFromCache` after init.
   * @param options.denominationTarget Target proofs per denomination, default 3.
   * @param options.selectProofs Custom proof selection function.
   * @param options.logger Logger instance, default null logger.
   */
  constructor(t, e) {
    if (this._seed = void 0, this._unit = "sat", this._mintInfo = void 0, this._denominationTarget = 3, this._secretsPolicy = "auto", this._boundKeysetId = Ft, this.swap = this.send.bind(this), this.ops = new Sr(this), this.on = new Er(this), this._logger = e?.logger ?? M, this._selectProofs = e?.selectProofs ?? _r, this.mint = typeof t == "string" ? new ge(t, { authProvider: e?.authProvider, logger: this._logger }) : t, this._unit = e?.unit ?? this._unit, this._boundKeysetId = e?.keysetId ?? this._boundKeysetId, e?.bip39seed && (this.failIf(
      !(e.bip39seed instanceof Uint8Array),
      "bip39seed must be a valid Uint8Array",
      {
        bip39seed: e.bip39seed
      }
    ), this._seed = e.bip39seed), this._secretsPolicy = e?.secretsPolicy ?? this._secretsPolicy, e?.counterSource ? this._counterSource = e.counterSource : this._counterSource = new Ar(e?.counterInit), this.counters = new Ir(this._counterSource), this._keyChain = new G(this.mint, this._unit), this._denominationTarget = e?.denominationTarget ?? this._denominationTarget, e?.keysets && e?.keys && e?.mintInfo) {
      const n = Array.isArray(e.keys) ? e.keys : [e.keys], r = G.mintToCacheDTO(
        this._unit,
        this.mint.mintUrl,
        e.keysets,
        n
      );
      this.loadMintFromCache(e.mintInfo, r);
    }
  }
  // Convenience wrappers for "log and throw"
  fail(t, e) {
    return Ct(t, this._logger, e);
  }
  failIf(t, e, n) {
    return Jt(t, e, this._logger, n);
  }
  failIfNullish(t, e, n) {
    return Le(t, e, this._logger, n);
  }
  safeCallback(t, e, n) {
    ht(t, e, this._logger, n);
  }
  /**
   * Asserts amount is a positive, safe integer.
   *
   * @param amount To check.
   * @param op Caller method name (or other identifier) for debug.
   * @throws If not.
   */
  assertAmount(t, e) {
    try {
      de(t, !1);
    } catch (n) {
      this.fail(n.message, { op: e, amount: t });
    }
  }
  /**
   * Load mint information, keysets, and keys.
   *
   * @remarks
   * Must be called before using other methods, unless loading mint from cache. See:
   * `loadMintFromCache`.
   * @param forceRefresh If true, re-fetches data even if cached.
   * @throws If fetching mint info, keysets, or keys fails.
   */
  async loadMint(t) {
    const e = [];
    (!this._mintInfo || t) && e.push(
      this.mint.getInfo().then((n) => (this._mintInfo = new Et(n), null))
    ), e.push(this._keyChain.init(t).then(() => null)), await Promise.all(e), this.finishInit();
  }
  /**
   * Load mint information, keysets, and keys from cached data.
   *
   * @remarks
   * Use this when you already have cached mint info and keychain cache and want to avoid network
   * calls.
   *
   * The `cache` argument should usually come from `wallet.keyChain.cache`.
   */
  loadMintFromCache(t, e) {
    this._mintInfo = new Et(t), this._keyChain.loadFromCache(e), this.finishInit();
  }
  /**
   * Finishes wiring up the wallet instance and checks we are "Go for launch".
   */
  finishInit() {
    const t = this._keyChain.getCheapestKeyset().id;
    if (this._logger.debug("KeyChain", { keychain: this._keyChain.cache }), this._boundKeysetId === Ft)
      this._boundKeysetId = t;
    else {
      const e = this._keyChain.getKeyset(this._boundKeysetId);
      this.failIf(!e.hasKeys, "Wallet keyset has no keys", { keyset: e.id });
    }
    this.getMintInfo();
  }
  // -----------------------------------------------------------------
  // Section: Getters
  // -----------------------------------------------------------------
  /**
   * Get the wallet's KeyChain.
   *
   * @returns The Keychain.
   */
  get keyChain() {
    return this._keyChain;
  }
  /**
   * Get the wallet's unit.
   *
   * @returns The unit (e.g., 'sat').
   */
  get unit() {
    return this._unit;
  }
  /**
   * Get information about the mint.
   *
   * @remarks
   * Returns cached mint info. Call `loadMint` first to initialize the wallet.
   * @returns Mint info.
   * @throws If mint info is not initialized.
   */
  getMintInfo() {
    return this.failIfNullish(
      this._mintInfo,
      "Mint info not initialized; call loadMint or loadMintFromCache first"
    ), this._mintInfo;
  }
  /**
   * The keyset ID bound to this wallet instance.
   */
  get keysetId() {
    return this.failIf(
      this._boundKeysetId === Ft,
      "Wallet not initialised, call loadMint or loadMintFromCache first"
    ), this._boundKeysetId;
  }
  /**
   * Gets the requested keyset or the keyset bound to the wallet.
   *
   * @remarks
   * This method enforces wallet policies. If `id` is omitted, it returns the keyset bound to this
   * wallet, including validation that:
   *
   * - The keyset exists in the keychain,
   * - The unit matches the wallet's unit,
   * - Keys are loaded for that keyset.
   *
   * Contrast with `keyChain.getKeyset(id?)`, which, when called without an id, returns the cheapest
   * active keyset for the unit, ignoring the wallet binding.
   * @param id Optional keyset id to resolve. If omitted, the wallet's bound keyset is used.
   * @returns The resolved `Keyset`.
   * @throws If the keyset is not found, has no keys, or its unit differs from the wallet.
   */
  getKeyset(t) {
    const e = this._keyChain.getKeyset(t ?? this.keysetId);
    return this.failIf(e.unit !== this._unit, "Keyset unit does not match wallet unit", {
      keyset: e.id,
      unit: e.unit,
      walletUnit: this._unit
    }), this.failIf(!e.hasKeys, "Keyset has no keys loaded", { keyset: e.id }), e;
  }
  get logger() {
    return this._logger;
  }
  // -----------------------------------------------------------------
  // Section: Counters
  // -----------------------------------------------------------------
  async reserveFor(t, e) {
    return e <= 0 ? { start: 0, count: 0 } : this._counterSource.reserve(t, e);
  }
  countersNeeded(t) {
    return t.type !== "deterministic" || t.counter !== 0 ? 0 : (t.denominations ?? []).length;
  }
  async addCountersToOutputTypes(t, ...e) {
    const n = e.filter(
      (u) => u.type === "deterministic" && u.counter > 0 && (u.denominations?.length ?? 0) > 0
    );
    if (n.length > 1) {
      const u = n.map((h) => ({
        start: h.counter,
        end: h.counter + h.denominations.length
        // exclusive
      })).sort((h, l) => h.start - l.start);
      for (let h = 1; h < u.length; h++)
        this.failIf(u[h].start < u[h - 1].end, "Manual counter ranges overlap", {
          keysetId: t,
          prev: u[h - 1],
          cur: u[h]
        });
    }
    if (n.length > 0) {
      const u = Math.max(...n.map((h) => h.counter + h.denominations.length));
      await this._counterSource.advanceToAtLeast(t, u), this._logger.debug("Counter source advanced to respect manual deterministic counters", {
        keysetId: t,
        maxManualEnd: u
      });
    }
    const r = e.reduce((u, h) => u + this.countersNeeded(h), 0);
    if (r === 0) return { outputTypes: e };
    const i = await this.reserveFor(t, r);
    let o = i.start;
    const a = e.map((u) => {
      if (u.type === "deterministic" && u.counter === 0) {
        const h = u.denominations?.length ?? 0;
        if (h > 0) {
          const l = { ...u, counter: o };
          return o += h, l;
        }
      }
      return u;
    }), c = {
      keysetId: t,
      start: i.start,
      count: i.count,
      next: i.start + i.count
    };
    return this.on._emitCountersReserved(c), { outputTypes: a, used: c };
  }
  /**
   * Bind this wallet to a specific keyset id.
   *
   * @remarks
   * This changes the default keyset used by all operations that do not explicitly pass a keysetId.
   * The method validates that the keyset exists in the keychain, matches the wallet unit, and has
   * keys loaded.
   *
   * Typical uses:
   *
   * 1. After loadMint, to pin the wallet to a particular active keyset.
   * 2. After a refresh, to rebind deliberately rather than falling back to cheapest.
   *
   * @param id The keyset identifier to bind to.
   * @throws If keyset not found, if it has no keys loaded, or if its unit is not the wallet unit.
   */
  bindKeyset(t) {
    const e = this._keyChain.getKeyset(t);
    this.failIf(e.unit !== this._unit, "Keyset unit does not match wallet unit", {
      keyset: e.id,
      unit: e.unit,
      walletUnit: this._unit
    }), this.failIf(!e.hasKeys, "Keyset has no keys loaded", { keyset: e.id }), this._boundKeysetId = e.id, this._logger.debug("Wallet bound to keyset", {
      keysetId: e.id,
      unit: e.unit,
      feePPK: e.fee
    });
  }
  /**
   * Creates a new Wallet bound to a different keyset, sharing the same CounterSource.
   *
   * Use this to operate on multiple keysets concurrently without mutating your original wallet.
   * Counters remain monotonic across instances because the same CounterSource is reused.
   *
   * Do NOT pass a fresh CounterSource for the same seed unless you know exactly why. Reusing
   * counters can recreate secrets that a mint will reject.
   *
   * @param id The keyset identifier to bind to.
   * @throws If keyset not found, if it has no keys loaded, or if its unit is not the wallet unit.
   */
  withKeyset(t, e) {
    const n = new me(this.mint, {
      keysetId: t,
      bip39seed: this._seed,
      secretsPolicy: this._secretsPolicy,
      logger: this._logger,
      counterSource: e?.counterSource ?? this._counterSource
    });
    return n.loadMintFromCache(this.getMintInfo().cache, this._keyChain.cache), n;
  }
  /**
   * Returns the default OutputType for this wallet, based on its configured secrets policy
   * (options?.secretsPolicy) and seed state.
   *
   * - If the secrets policy is 'random', returns { type: 'random' }.
   * - If the policy is 'deterministic', requires a seed and returns { type: 'deterministic', counter:
   *   0 }. Counter 0 is a flag meaning "auto-increment from current state".
   * - If no explicit policy is set, falls back to:
   *
   *   - Deterministic if a seed is present.
   *   - Random if no seed is present.
   *
   * @returns An OutputType object describing the default output strategy.
   * @throws Error if the policy is 'deterministic' but no seed has been set.
   */
  defaultOutputType() {
    return this._secretsPolicy === "random" ? { type: "random" } : this._secretsPolicy === "deterministic" ? (this.failIfNullish(this._seed, "Deterministic policy requires a seed"), { type: "deterministic", counter: 0 }) : this._seed ? { type: "deterministic", counter: 0 } : { type: "random" };
  }
  // -----------------------------------------------------------------
  // Section: Output Creation
  // -----------------------------------------------------------------
  /**
   * Configures output denominations with fee adjustments and optimization.
   *
   * @remarks
   * If 'custom' outputType, data outputs MUST sum to the amount. Other outputTypes may supply
   * denominations. If no denominations are passed in, they will be calculated based on proofsWeHave
   * or the default split. If partial denominations are passed in, the balance will be added using
   * default split. Additional denominations to cover fees will then be added if required.
   * @param amount The total amount for outputs.
   * @param keyset The mint keyset.
   * @param outputType The output configuration.
   * @param includeFees Whether to include swap fees in the output amount.
   * @param proofsWeHave Optional proofs for optimizing denomination splitting.
   * @returns OutputType with required denominations.
   */
  configureOutputs(t, e, n, r = !1, i = []) {
    let o = t;
    if (n.type === "custom") {
      this.failIf(r, "The custom OutputType does not support automatic fee inclusion");
      const c = K.sumOutputAmounts(n.data);
      return this.failIf(
        c !== t,
        `Custom output data total (${c}) does not match amount (${t})`
      ), n;
    }
    let a = n.denominations ?? [];
    if (a.length === 0 && i.length > 0 && (a = ir(
      i,
      o,
      e.keys,
      this._denominationTarget
    )), a = z(o, e.keys, a), r) {
      let c = this.getFeesForKeyset(a.length, e.id), u = z(c, e.keys);
      for (; this.getFeesForKeyset(a.length + u.length, e.id) > c; )
        c++, u = z(c, e.keys);
      o += c, a = [...a, ...u];
    }
    return { ...n, denominations: a };
  }
  /**
   * Sum total implied by a prepared OutputType. Note: Empty denomination is valid (e.g: zero
   * change).
   */
  preparedTotal(t) {
    return t.type === "custom" ? K.sumOutputAmounts(t.data) : (t.denominations ?? []).reduce((n, r) => n + r, 0);
  }
  /**
   * Generates blinded messages based on the specified output type.
   *
   * @param amount The total amount for outputs.
   * @param keyset The mint keys.
   * @param outputType The output configuration.
   * @returns Prepared output data.
   */
  createOutputData(t, e, n) {
    if (this.failIf(t < 0, "Amount was negative", { amount: t }), // 'custom' OutputType has no denominations. Every other OutputType does.
    // so let's sanity check those were filled properly (eg: configureOutputs)
    n.type != "custom" && n.denominations && n.denominations.length > 0) {
      const i = n.denominations.reduce((o, a) => o + a, 0);
      this.failIf(i !== t, "Denominations do not sum to the expected amount", {
        splitSum: i,
        expected: t
      });
    }
    let r;
    switch (n.type) {
      case "random":
        r = K.createRandomData(t, e, n.denominations);
        break;
      case "deterministic":
        this.failIfNullish(
          this._seed,
          "Deterministic outputs require a seed configured in the wallet"
        ), r = K.createDeterministicData(
          t,
          this._seed,
          n.counter,
          e,
          n.denominations
        );
        break;
      case "p2pk":
        r = K.createP2PKData(
          n.options,
          t,
          e,
          n.denominations
        );
        break;
      case "factory": {
        r = z(t, e.keys, n.denominations).map((o) => n.factory(o, e));
        break;
      }
      case "custom": {
        r = n.data;
        const i = K.sumOutputAmounts(r);
        this.failIf(
          i !== t,
          `Custom output data total (${i}) does not match amount (${t})`
        );
        break;
      }
      default:
        this.fail("Invalid OutputType");
    }
    return r;
  }
  /**
   * Creates a swap transaction with sorted outputs for privacy. This prevents a mint working out
   * which proofs will be sent or kept.
   *
   * @param inputs Prepared input proofs.
   * @param keepOutputs Outputs to keep (change or receiver's proofs).
   * @param sendOutputs Outputs to send (optional, default empty for receive/mint).
   * @returns Swap transaction with payload and metadata for processing signatures.
   */
  createSwapTransaction(t, e, n = []) {
    t = this._prepareInputsForMint(t);
    const r = [...e, ...n], i = r.map((l, d) => d);
    At(t) || i.sort(
      (l, d) => r[l].blindedMessage.amount - r[d].blindedMessage.amount
    );
    const o = [
      ...Array.from({ length: e.length }, () => !0),
      ...Array.from({ length: n.length }, () => !1)
    ], a = i.map((l) => r[l]), c = i.map((l) => o[l]), u = a.map((l) => l.blindedMessage);
    return this._logger.debug("createSwapTransaction:", {
      indices: i,
      sortedKeepVector: c
      // outputs, // <-- removed for security
    }), {
      payload: {
        inputs: t,
        outputs: u
      },
      outputData: a,
      keepVector: c,
      sortedIndices: i
    };
  }
  // -----------------------------------------------------------------
  // Section: Send and Receive
  // -----------------------------------------------------------------
  /**
   * Receive a token (swaps with mint for new proofs)
   *
   * @example
   *
   * ```typescript
   * const result = await wallet.receive(
   * 	token,
   * 	{ includeFees: true },
   * 	{ type: 'deterministic', counter: 0 },
   * );
   * ```
   *
   * @param token Token string or decoded token.
   * @param config Optional receive config.
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns Newly minted proofs.
   */
  async receive(t, e, n) {
    const r = await this.prepareSwapToReceive(t, e, n), { keep: i } = await this.completeSwap(r, e?.privkey);
    return i;
  }
  /**
   * Prepare A Receive Transaction.
   *
   * @remarks
   * Allows you to preview fees for a receive, get concrete outputs for P2PK SIG_ALL transactions,
   * and do any pre-swap tasks (such as marking proofs in-flight etc)
   * @example
   *
   * ```typescript
   * // Prepare transaction
   * const txn = await wallet.prepareSwapToReceive(token, { requireDleq: true });
   * const fees = txn.fees;
   *
   * // Complete transaction
   * const { keep } = await wallet.completeSwap(txn);
   * ```
   *
   * @param token Token string or decoded token.
   * @param config Optional receive config.
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns SwapPreview with metadata for swap transaction.
   */
  async prepareSwapToReceive(t, e, n) {
    const { keysetId: r, requireDleq: i, proofsWeHave: o, onCountersReserved: a } = e || {};
    n = n ?? this.defaultOutputType();
    const c = typeof t == "string" ? this.decodeToken(t) : t, u = Mn(c.mint);
    this.failIf(u !== this.mint.mintUrl, "Token belongs to a different mint", {
      token: u,
      wallet: this.mint.mintUrl
    }), this.failIf(c.unit !== this._unit, "Token is not in wallet unit", {
      token: c.unit,
      wallet: this._unit
    });
    let h = [];
    ({ proofs: h } = c);
    const l = nt(h);
    this.failIf(l === 0, "Token contains no proofs", { proofs: h }), this.assertAmount(l, "prepareSwapToReceive");
    const d = this.getKeyset(r);
    if (i)
      for (const P of h) {
        const O = this._keyChain.getKeyset(P.id);
        xn(P, O) || this.fail("Token contains proofs with invalid or missing DLEQ");
      }
    const f = this.getFeesForProofs(h), p = l - f;
    let g = this.configureOutputs(
      p,
      d,
      n,
      !1,
      // includeFees is not applicable for receive
      o
    );
    const k = await this.addCountersToOutputTypes(d.id, g);
    [g] = k.outputTypes, k.used && this.safeCallback(a, k.used, { op: "receive" }), this._logger.debug("receive counter", { counter: k.used, receiveOT: g });
    const S = this.createOutputData(this.preparedTotal(g), d, g);
    return {
      amount: p,
      fees: f,
      keysetId: d.id,
      inputs: h,
      keepOutputs: S
    };
  }
  /**
   * Sends proofs of a given amount from provided proofs.
   *
   * @remarks
   * If proofs are P2PK-locked to your public key, call signP2PKProofs first to sign them. The
   * default config uses exact match selection, and does not includeFees or requireDleq. Because the
   * send is offline, the user will unlock the signed proofs when they receive them online.
   * @param amount Amount to send.
   * @param proofs Array of proofs (must sum >= amount; pre-sign if P2PK-locked).
   * @param config Optional parameters for the send.
   * @returns SendResponse with keep/send proofs.
   * @throws Throws if the send cannot be completed offline.
   */
  sendOffline(t, e, n) {
    this.assertAmount(t, "sendOffline");
    const { requireDleq: r = !1, includeFees: i = !1, exactMatch: o = !0 } = n || {};
    r && (e = e.filter((h) => h.dleq != null)), this.failIf(nt(e) < t, "Not enough funds available to send");
    const { keep: a, send: c } = this.selectProofsToSend(e, t, i, o), u = this._prepareInputsForMint(c, r);
    return { keep: a, send: u };
  }
  /**
   * Send proofs with online swap if necessary.
   *
   * @example
   *
   * ```typescript
   * // Simple send
   * const result = await wallet.send(5, proofs);
   *
   * // With a SendConfig
   * const result = await wallet.send(5, proofs, { includeFees: true });
   *
   * // With Custom output configuration
   * const customConfig: OutputConfig = {
   * 	send: { type: 'p2pk', options: { pubkey: '...' } },
   * 	keep: { type: 'deterministic', counter: 0 },
   * };
   * const customResult = await wallet.send(5, proofs, { includeFees: true }, customConfig);
   * ```
   *
   * @param amount Amount to send (receiver gets this net amount).
   * @param proofs Array of proofs to split.
   * @param config Optional parameters for the swap.
   * @returns SendResponse with keep/send proofs.
   * @throws Throws if the send cannot be completed offline or if funds are insufficient.
   */
  async send(t, e, n, r) {
    this.assertAmount(t, "send");
    const { keysetId: i, includeFees: o = !1 } = n || {};
    r = r ?? {
      send: this.defaultOutputType(),
      keep: this.defaultOutputType()
    };
    try {
      const c = this.defaultOutputType().type === "deterministic", u = (f) => !f || f.type === "random" && (!f.denominations || f.denominations.length === 0);
      if (i || c || !u(r.send) || r.keep && !u(r.keep)) {
        const f = [];
        throw i && f.push("keysetId override"), c && f.push("wallet default is deterministic"), u(r.send) || f.push("non-default send output type"), r.keep && !u(r.keep) && f.push("non-default keep output type"), new Error(`Options require a swap: ${f.join(", ")}`);
      }
      const { keep: h, send: l } = this.sendOffline(t, e, {
        includeFees: o,
        exactMatch: !0,
        requireDleq: !1
        // safety
      }), d = o ? this.getFeesForProofs(l) : 0;
      if (nt(l) === t + d)
        return this._logger.info("Successful exactMatch offline selection!"), { keep: h, send: l };
    } catch (c) {
      const u = c instanceof Error ? c.message : "Unknown error";
      this._logger.debug("ExactMatch offline selection failed.", { e: u });
    }
    const a = await this.prepareSwapToSend(t, e, n, r);
    return await this.completeSwap(a, n?.privkey);
  }
  /**
   * Prepare A Send Transaction.
   *
   * @remarks
   * Allows you to preview fees for a send, get concrete outputs for P2PK SIG_ALL transactions, and
   * do any pre-swap tasks (such as marking proofs in-flight etc)
   * @example
   *
   * ```typescript
   * // Prepare transaction
   * const txn = await wallet.prepareSwapToSend(5, proofs, { includeFees: true });
   * const fees = txn.fees;
   *
   * // Complete transaction
   * const { keep, send } = await wallet.completeSwap(txn);
   * ```
   *
   * @param amount Amount to send (receiver gets this net amount).
   * @param proofs Array of proofs to split.
   * @param config Optional parameters for the swap.
   * @returns SwapPreview with metadata for swap transaction.
   * @throws Throws if the send cannot be completed offline or if funds are insufficient.
   */
  async prepareSwapToSend(t, e, n, r) {
    const { keysetId: i, includeFees: o = !1, onCountersReserved: a } = n || {};
    r = r ?? {
      send: this.defaultOutputType(),
      keep: this.defaultOutputType()
    };
    const c = this.getKeyset(i);
    let u = this.configureOutputs(
      t,
      c,
      r.send ?? this.defaultOutputType(),
      o
    );
    const h = this.preparedTotal(u), { keep: l, send: d } = this.selectProofsToSend(
      e,
      h,
      !0
      // Include fees to cover swap fee
    );
    if (d.length === 0)
      throw new Error("Not enough funds available to send");
    const f = nt(d), p = this.getFeesForProofs(d), g = f - p - h;
    this.failIf(g < 0, "Not enough funds available for swap", {
      selectedSum: f,
      swapFee: p,
      sendAmount: h,
      changeAmount: g
    });
    let k = this.configureOutputs(
      g,
      c,
      r.keep ?? this.defaultOutputType(),
      !1,
      n?.proofsWeHave
    );
    const S = this.preparedTotal(k), P = await this.addCountersToOutputTypes(c.id, u, k);
    [u, k] = P.outputTypes, P.used && this.safeCallback(a, P.used, { op: "send" }), this._logger.debug("send counters", { counter: P.used, sendOT: u, keepOT: k });
    const O = this.createOutputData(h, c, u), at = this.createOutputData(S, c, k);
    return {
      amount: t,
      fees: p,
      keysetId: c.id,
      inputs: d,
      sendOutputs: O,
      keepOutputs: at,
      unselectedProofs: l
    };
  }
  /**
   * Complete a prepared swap transaction.
   *
   * @example
   *
   * ```typescript
   * // Prepare transaction
   * const txn = await wallet.prepareSwapToSend(5, proofs, { includeFees: true });
   *
   * // Complete transaction
   * const result = await wallet.completeSwap(txn);
   * ```
   *
   * @param swapPreview With metadata for swap transaction.
   * @param privkey The private key(s) for signing.
   * @returns SendResponse with keep/send proofs.
   */
  async completeSwap(t, e) {
    const n = t?.keepOutputs ? t.keepOutputs : [], r = t.sendOutputs ? t.sendOutputs : [], i = t.unselectedProofs ? t.unselectedProofs : [];
    e && (t.inputs = this.signP2PKProofs(t.inputs, e, [
      ...n,
      ...r
    ]));
    const o = this.createSwapTransaction(
      t.inputs,
      n,
      r
    ), { signatures: a } = await this.mint.swap(o.payload);
    this.failIf(
      a.length < o.outputData.length,
      `Mint returned ${a.length} signatures, expected ${o.outputData.length}`
    );
    const c = this.getKeyset(t.keysetId), u = o.outputData.map((p, g) => p.toProof(a[g], c)), h = Array(u.length), l = Array(o.keepVector.length);
    o.sortedIndices.forEach((p, g) => {
      l[p] = o.keepVector[g], h[p] = u[g];
    });
    const d = [], f = [];
    return h.forEach((p, g) => {
      l[g] ? d.push(p) : f.push(p);
    }), this._logger.debug("SEND COMPLETED", {
      unselectedProofs: i.map((p) => p.amount),
      keepProofs: d.map((p) => p.amount),
      sendProofs: f.map((p) => p.amount)
    }), {
      keep: [...d, ...i],
      send: f
    };
  }
  // -----------------------------------------------------------------
  // Section: Transaction Helpers
  // -----------------------------------------------------------------
  /**
   * Selects proofs to send based on amount and fee inclusion.
   *
   * @remarks
   * Uses an adapted Randomized Greedy with Local Improvement (RGLI) algorithm, which has a time
   * complexity O(n log n) and space complexity O(n).
   * @param proofs Array of Proof objects available to select from.
   * @param amountToSend The target amount to send.
   * @param includeFees Optional boolean to include fees; Default: false.
   * @param exactMatch Optional boolean to require exact match; Default: false.
   * @returns SendResponse containing proofs to keep and proofs to send.
   * @throws Throws an error if an exact match cannot be found within MAX_TIMEMS.
   * @see https://crypto.ethz.ch/publications/files/Przyda02.pdf
   */
  selectProofsToSend(t, e, n = !1, r = !1) {
    this.assertAmount(e, "selectProofsToSend");
    const { keep: i, send: o } = this._selectProofs(
      t,
      e,
      this._keyChain,
      n,
      r
    );
    return { keep: i, send: o };
  }
  /**
   * Prepares proofs for sending by signing P2PK-locked proofs.
   *
   * @remarks
   * Call this method before operations like send if the proofs are P2PK-locked and need unlocking.
   * This is a public wrapper for signing.
   * @param proofs The proofs to sign.
   * @param privkey The private key(s) for signing.
   * @param outputData Optional. For signing of SIG_ALL transactions.
   * @param quoteId Optional. For signing SIG_ALL melt transactions.
   * @returns Signed proofs.
   */
  signP2PKProofs(t, e, n, r) {
    if (!At(t))
      return Pe(t, e, this._logger);
    this.failIfNullish(n, "OutputData is required for SIG_ALL proof signing."), Is(t);
    const [i, ...o] = t;
    let a = i;
    const c = [
      xs(t, n, r),
      Cs(t, n, r),
      Ms(t, n, r)
    ];
    for (const u of c)
      a = Pe([a], e, this._logger, u)[0];
    return [a, ...o];
  }
  /**
   * Calculates the fees based on inputs (proofs)
   *
   * @param proofs Input proofs to calculate fees for.
   * @returns Fee amount.
   * @throws Throws an error if the proofs keyset is unknown.
   */
  getFeesForProofs(t) {
    const e = t.reduce((n, r) => n + this.getProofFeePPK(r), 0);
    return Math.ceil(e / 1e3);
  }
  /**
   * Returns the current fee PPK for a proof according to the cached keyset.
   *
   * @param proof {Proof} A single proof.
   * @returns FeePPK {number} The feePPK for the selected proof.
   * @throws Throws an error if the proofs keyset is unknown.
   */
  getProofFeePPK(t) {
    try {
      return this._keyChain.getKeyset(t.id).fee;
    } catch (e) {
      this.fail(`Could not get fee. No keyset found for keyset id: ${t.id}`, {
        e,
        keychain: this._keyChain.getKeysets()
      });
    }
  }
  /**
   * Calculates the fees based on inputs for a given keyset.
   *
   * @param nInputs Number of inputs.
   * @param keysetId KeysetId used to lookup `input_fee_ppk`
   * @returns Fee amount.
   */
  getFeesForKeyset(t, e) {
    try {
      const n = this._keyChain.getKeyset(e).fee;
      return Math.floor(Math.max((t * n + 999) / 1e3, 0));
    } catch (n) {
      this.fail(`No keyset found with ID ${e}`, { e: n });
    }
  }
  /**
   * Prepares inputs for a mint operation.
   *
   * @remarks
   * Internal method; strips DLEQ (NUT-12) and p2pk_e (NUT-26) for privacy and serializes witnesses.
   * Returns an array of new proof objects - does not mutate the originals.
   * @param proofs The proofs to prepare.
   * @param keepDleq Optional boolean to keep DLEQ (default: false, strips for privacy).
   * @returns Prepared proofs for mint payload.
   */
  _prepareInputsForMint(t, e = !1) {
    return t.map((n) => {
      const r = n.witness && typeof n.witness != "string" ? JSON.stringify(n.witness) : n.witness, { dleq: i, p2pk_e: o, ...a } = n;
      return e && i ? { ...a, dleq: i, witness: r } : { ...a, witness: r };
    });
  }
  /**
   * Decodes a string token.
   *
   * @remarks
   * Rehydrates a token from the space-saving CBOR format, including mapping short keyset ids to
   * their full representation.
   * @param token The token in string format (cashuB...)
   * @returns Token object.
   */
  decodeToken(t) {
    const e = this._keyChain.getAllKeysetIds();
    return cr(t, e);
  }
  // -----------------------------------------------------------------
  // Section: Restore
  // -----------------------------------------------------------------
  /**
   * Restores batches of deterministic proofs until no more signatures are returned from the mint.
   *
   * @param [gapLimit=300] The amount of empty counters that should be returned before restoring
   *   ends (defaults to 300). Default is `300`
   * @param [batchSize=100] The amount of proofs that should be restored at a time (defaults to
   *   100). Default is `100`
   * @param [counter=0] The counter that should be used as a starting point (defaults to 0). Default
   *   is `0`
   * @param [keysetId] Which keysetId to use for the restoration. If none is passed the instance's
   *   default one will be used.
   */
  async batchRestore(t = 300, e = 100, n = 0, r) {
    const i = Math.ceil(t / e), o = [];
    let a, c = 0;
    for (; c < i; ) {
      const u = await this.restore(n, e, { keysetId: r });
      u.proofs.length > 0 ? (c = 0, o.push(...u.proofs), a = u.lastCounterWithSignature) : c++, n += e;
    }
    return { proofs: o, lastCounterWithSignature: a };
  }
  /**
   * Regenerates.
   *
   * @param start Set starting point for count (first cycle for each keyset should usually be 0)
   * @param count Set number of blinded messages that should be generated.
   * @param options.keysetId Set a custom keysetId to restore from. @see `keyChain)`
   */
  async restore(t, e, n) {
    const { keysetId: r } = n || {}, i = this.getKeyset(r);
    this.failIfNullish(this._seed, "Cashu Wallet must be initialized with a seed to use restore");
    const o = Array(e).fill(0), a = K.createDeterministicData(0, this._seed, t, i, o), { outputs: c, signatures: u } = await this.mint.restore({
      outputs: a.map((f) => f.blindedMessage)
    }), h = {};
    c.forEach((f, p) => h[f.B_] = u[p]);
    const l = [];
    let d;
    for (let f = 0; f < a.length; f++) {
      const p = h[a[f].blindedMessage.B_];
      p && (d = t + f, a[f].blindedMessage.amount = p.amount, l.push(a[f].toProof(p, i)));
    }
    return {
      proofs: l,
      lastCounterWithSignature: d
    };
  }
  // -----------------------------------------------------------------
  // Section: Create Mint Quote
  // -----------------------------------------------------------------
  /**
   * @deprecated Use createMintQuoteBolt11()
   */
  async createMintQuote(t, e) {
    return this.createMintQuoteBolt11(t, e);
  }
  /**
   * Requests a mint quote from the mint. Response returns a Lightning payment request for the
   * requested given amount and unit.
   *
   * @param amount Amount requesting for mint.
   * @param description Optional description for the mint quote.
   * @param pubkey Optional public key to lock the quote to.
   * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the
   *   specified amount and unit.
   */
  async createMintQuoteBolt11(t, e) {
    this.assertAmount(t, "createMintQuoteBolt11"), e && (this.getMintInfo().supportsNut04Description("bolt11", this._unit) || this.fail("Mint does not support description for bolt11"));
    const n = {
      unit: this._unit,
      amount: t,
      description: e
    }, r = await this.mint.createMintQuoteBolt11(n);
    return { ...r, amount: r.amount || t, unit: r.unit || this._unit };
  }
  /**
   * Requests a mint quote from the mint that is locked to a public key.
   *
   * @param amount Amount requesting for mint.
   * @param pubkey Public key to lock the quote to.
   * @param description Optional description for the mint quote.
   * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the
   *   specified amount and unit. The quote will be locked to the specified `pubkey`.
   */
  async createLockedMintQuote(t, e, n) {
    this.assertAmount(t, "createLockedMintQuote");
    const { supported: r } = this.getMintInfo().isSupported(20);
    this.failIf(!r, "Mint does not support NUT-20");
    const i = {
      unit: this._unit,
      amount: t,
      description: n,
      pubkey: e
    }, o = await this.mint.createMintQuoteBolt11(i);
    this.failIf(typeof o.pubkey != "string", "Mint returned unlocked mint quote");
    const a = o.pubkey;
    return {
      ...o,
      pubkey: a,
      amount: o.amount || t,
      unit: o.unit || this._unit
    };
  }
  /**
   * Requests a mint quote from the mint. Response returns a Lightning BOLT12 offer for the
   * requested given amount and unit.
   *
   * @param pubkey Public key to lock the quote to.
   * @param options.amount BOLT12 offer amount requesting for mint. If not specified, the offer will
   *   be amountless.
   * @param options.description Description for the mint quote.
   * @returns The mint will return a mint quote with a BOLT12 offer for minting tokens of the
   *   specified amount and unit.
   */
  async createMintQuoteBolt12(t, e) {
    const n = this.getMintInfo();
    e?.description && !n.supportsNut04Description("bolt12", this._unit) && this.fail("Mint does not support description for bolt12");
    const r = {
      pubkey: t,
      unit: this._unit,
      amount: e?.amount,
      description: e?.description
    };
    return this.mint.createMintQuoteBolt12(r);
  }
  // -----------------------------------------------------------------
  // Section: Check Mint Quote
  // -----------------------------------------------------------------
  /**
   * @deprecated Use checkMintQuoteBolt11()
   */
  async checkMintQuote(t) {
    return this.checkMintQuoteBolt11(t);
  }
  /**
   * Gets an existing mint quote from the mint.
   *
   * @param quote Quote ID.
   * @returns The mint will create and return a Lightning invoice for the specified amount.
   */
  async checkMintQuoteBolt11(t) {
    const e = typeof t == "string" ? t : t.quote, n = await this.mint.checkMintQuoteBolt11(e);
    return typeof t == "string" ? n : { ...n, amount: n.amount || t.amount, unit: n.unit || t.unit };
  }
  /**
   * Gets an existing BOLT12 mint quote from the mint.
   *
   * @param quote Quote ID.
   * @returns The latest mint quote for the given quote ID.
   */
  async checkMintQuoteBolt12(t) {
    return this.mint.checkMintQuoteBolt12(t);
  }
  // -----------------------------------------------------------------
  // Section: Mint Proofs
  // -----------------------------------------------------------------
  /**
   * @deprecated Use mintProofsBolt11()
   */
  async mintProofs(t, e, n, r) {
    return this._mintProofs("bolt11", t, e, n, r);
  }
  /**
   * Mint proofs for a bolt11 quote.
   *
   * @param amount Amount to mint.
   * @param quote Mint quote ID or object (bolt11).
   * @param config Optional parameters (e.g. privkey for locked quotes).
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns Minted proofs.
   */
  async mintProofsBolt11(t, e, n, r) {
    return this._mintProofs("bolt11", t, e, n, r);
  }
  /**
   * Mints proofs for a bolt12 quote.
   *
   * @param amount Amount to mint.
   * @param quote Bolt12 mint quote.
   * @param privkey Private key to unlock the quote.
   * @param config Optional parameters (e.g. keysetId).
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns Minted proofs.
   */
  async mintProofsBolt12(t, e, n, r, i) {
    return this._mintProofs("bolt12", t, e, { ...r, privkey: n }, i);
  }
  /**
   * Internal helper for minting proofs with bolt11 or bolt12.
   *
   * @remarks
   * Handles blinded messages, signatures, and proof construction. Use public methods like
   * mintProofs or helpers for API access.
   * @param method 'bolt11' or 'bolt12'.
   * @param amount Amount to mint (must be positive).
   * @param quote Quote ID or object.
   * @param config Optional (privkey, keysetId).
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns Minted proofs.
   * @throws If params are invalid or mint returns errors.
   */
  async _mintProofs(t, e, n, r, i) {
    this.assertAmount(e, `_mintProofs: ${t}`), i = i ?? this.defaultOutputType();
    const { privkey: o, keysetId: a, proofsWeHave: c, onCountersReserved: u } = r ?? {}, h = this.getKeyset(a);
    let l = this.configureOutputs(
      e,
      h,
      i,
      !1,
      // no fees
      c
    );
    const d = this.preparedTotal(l), f = await this.addCountersToOutputTypes(h.id, l);
    [l] = f.outputTypes, f.used && this.safeCallback(u, f.used, { op: "mintProofs" }), this._logger.debug("mint counter", { counter: f.used, mintOT: l });
    const p = this.createOutputData(d, h, l), g = p.map((P) => P.blindedMessage), k = {
      outputs: g,
      quote: typeof n == "string" ? n : n.quote
    };
    if (typeof n != "string" && n.pubkey) {
      this.failIf(!o, "Can not sign locked quote without private key");
      const P = $s(o, n.quote, g);
      k.signature = P;
    }
    let S;
    return t === "bolt12" ? { signatures: S } = await this.mint.mintBolt12(k) : { signatures: S } = await this.mint.mintBolt11(k), this.failIf(
      S.length !== p.length,
      `Mint returned ${S.length} signatures, expected ${p.length}`
    ), this._logger.debug("MINT COMPLETED", { amounts: p.map((P) => P.blindedMessage.amount) }), p.map((P, O) => P.toProof(S[O], h));
  }
  // -----------------------------------------------------------------
  // Section: Create Melt Quote
  // -----------------------------------------------------------------
  /**
   * @deprecated Use createMeltQuoteBolt11.
   */
  async createMeltQuote(t, e) {
    return this.createMeltQuoteBolt11(t, e);
  }
  /**
   * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order
   * to pay a Lightning invoice.
   *
   * @param invoice LN invoice that needs to get a fee estimate.
   * @param amountMsat Optional amount in millisatoshis to attach for amountless invoices, must not
   *   be provided for invoices that already encode an amount.
   * @returns The mint will create and return a melt quote for the invoice with an amount and fee
   *   reserve.
   */
  async createMeltQuoteBolt11(t, e) {
    e !== void 0 && (this.failIf(
      pr(t),
      "amountMsat supplied but invoice already contains an amount. Leave amountMsat undefined for non-zero invoices."
    ), this.assertAmount(e, "createMeltQuoteBolt11"));
    const n = this._mintInfo?.supportsAmountless?.("bolt11", this._unit) ?? !1, r = {
      unit: this._unit,
      request: t,
      ...n && e !== void 0 ? {
        options: {
          amountless: {
            amount_msat: e
          }
        }
      } : {}
    }, i = await this.mint.createMeltQuoteBolt11(r);
    return {
      ...i,
      unit: i.unit || this._unit,
      request: i.request || t
    };
  }
  /**
   * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order
   * to pay a BOLT12 offer.
   *
   * @param offer BOLT12 offer that needs to get a fee estimate.
   * @param amountMsat Amount in millisatoshis for amount-less offers. If this is defined and the
   *   offer has an amount, they **MUST** be equal.
   * @returns The mint will create and return a melt quote for the offer with an amount and fee
   *   reserve.
   */
  async createMeltQuoteBolt12(t, e) {
    return this.mint.createMeltQuoteBolt12({
      unit: this._unit,
      request: t,
      options: e ? {
        amountless: {
          amount_msat: e
        }
      } : void 0
    });
  }
  /**
   * Requests a multi path melt quote from the mint.
   *
   * @remarks
   * Uses NUT-15 Partial multi-path payments for BOLT11.
   * @param invoice LN invoice that needs to get a fee estimate.
   * @param partialAmount The partial amount of the invoice's total to be paid by this instance.
   * @returns The mint will create and return a melt quote for the invoice with an amount and fee
   *   reserve.
   * @see https://github.com/cashubtc/nuts/blob/main/15.md
   */
  async createMultiPathMeltQuote(t, e) {
    this.assertAmount(e, "createMultiPathMeltQuote");
    const { supported: n, params: r } = this.getMintInfo().isSupported(15);
    this.failIf(!n, "Mint does not support NUT-15"), this.failIf(
      !r?.some((a) => a.method === "bolt11" && a.unit === this._unit),
      `Mint does not support MPP for bolt11 and ${this._unit}`
    );
    const i = {
      unit: this._unit,
      request: t,
      options: { mpp: { amount: e } }
    };
    return { ...await this.mint.createMeltQuoteBolt11(i), request: t, unit: this._unit };
  }
  // -----------------------------------------------------------------
  // Section: Check Melt Quote
  // -----------------------------------------------------------------
  /**
   * @deprecated Use checkMeltQuoteBolt11()
   */
  async checkMeltQuote(t) {
    return this.checkMeltQuoteBolt11(t);
  }
  /**
   * Returns an existing bolt11 melt quote from the mint.
   *
   * @param quote ID of the melt quote.
   * @returns The mint will return an existing melt quote.
   */
  async checkMeltQuoteBolt11(t) {
    const e = typeof t == "string" ? t : t.quote, n = await this.mint.checkMeltQuoteBolt11(e);
    return typeof t == "string" ? n : { ...n, request: t.request, unit: t.unit };
  }
  /**
   * Returns an existing bolt12 melt quote from the mint.
   *
   * @param quote ID of the melt quote.
   * @returns The mint will return an existing melt quote.
   */
  async checkMeltQuoteBolt12(t) {
    return this.mint.checkMeltQuoteBolt12(t);
  }
  // -----------------------------------------------------------------
  // Section: Melt Proofs
  // -----------------------------------------------------------------
  /**
   * @deprecated Use meltProofsBolt11()
   */
  async meltProofs(t, e, n, r) {
    return this.meltProofsBolt11(t, e, n, r);
  }
  /**
   * Melt proofs for a bolt11 melt quote.
   *
   * @remarks
   * ProofsToSend must be at least amount+fee_reserve from the melt quote. This function does not
   * perform coin selection!.
   * @param meltQuote ID of the melt quote.
   * @param proofsToSend Proofs to melt.
   * @param config Optional parameters.
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns MeltProofsResponse with quote and change proofs.
   */
  async meltProofsBolt11(t, e, n, r) {
    const i = await this.prepareMelt("bolt11", t, e, n, r), o = typeof n?.onChangeOutputsCreated == "function";
    return this.completeMelt(i, n?.privkey, o);
  }
  /**
   * Melt proofs for a bolt12 melt quote, returns change proofs using specified outputType.
   *
   * @remarks
   * ProofsToSend must be at least amount+fee_reserve from the melt quote. This function does not
   * perform coin selection!.
   * @param meltQuote ID of the melt quote.
   * @param proofsToSend Proofs to melt.
   * @param config Optional parameters.
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns MeltProofsResponse with quote and change proofs.
   */
  async meltProofsBolt12(t, e, n, r) {
    const i = await this.prepareMelt("bolt12", t, e, n, r), o = typeof n?.onChangeOutputsCreated == "function";
    return this.completeMelt(i, n?.privkey, o);
  }
  /**
   * Prepare A Melt Transaction.
   *
   * @remarks
   * Allows you to preview fees for a melt, get concrete outputs for P2PK SIG_ALL melts, and do any
   * pre-melt tasks (such as marking proofs in-flight etc). Creates NUT-08 blanks (1-sat) for
   * Lightning fee return and returns a MeltPreview, which you can melt using completeMelt.
   * @param method Payment method of the quote.
   * @param meltQuote The melt quote.
   * @param proofsToSend Proofs to melt.
   * @param config Optional (keysetId, onChangeOutputsCreated).
   * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
   * @returns MeltPreview.
   * @throws If params are invalid.
   * @see https://github.com/cashubtc/nuts/blob/main/08.md.
   */
  async prepareMelt(t, e, n, r, i) {
    i = i ?? this.defaultOutputType();
    const { keysetId: o, onChangeOutputsCreated: a, onCountersReserved: c } = r || {}, u = this.getKeyset(o), h = nt(n), l = h - e.amount;
    let d = [];
    if (this.failIf(l < 0, "Not enough proofs to cover amount + fee reserve", {
      sendAmount: h,
      quoteAmount: e.amount
    }), i.type === "custom")
      d = i.data;
    else if (l > 0) {
      let p = Math.ceil(Math.log2(l)) || 1;
      p < 0 && (p = 0);
      const g = p ? new Array(p).fill(0) : [];
      this._logger.debug("Creating NUT-08 blanks for fee reserve", {
        feeReserve: l,
        denominations: g
      });
      let k = { ...i, denominations: g };
      const S = await this.addCountersToOutputTypes(u.id, k);
      [k] = S.outputTypes, S.used && this.safeCallback(c, S.used, { op: "meltProofs" }), this._logger.debug("melt counter", { counter: S.used, meltOT: k }), d = this.createOutputData(0, u, k);
    }
    const f = {
      method: t,
      inputs: n,
      outputData: d,
      keysetId: u.id,
      quote: e
    };
    if (d.length > 0) {
      const p = {
        method: t,
        payload: {
          quote: e.quote,
          inputs: n,
          outputs: d.map((g) => g.blindedMessage)
        },
        outputData: d,
        keyset: u,
        quote: e
      };
      this.safeCallback(a, p, { op: "meltProofs" }), this.on._emitMeltBlanksCreated(p);
    }
    return f;
  }
  /**
   * Completes a pending melt by calling the melt endpoint and constructing change proofs.
   *
   * @remarks
   * Use with a MeltPreview returned from prepareMelt or the legacy MeltBlanks object returned by
   * the meltBlanksCreated or onChangeOutputsCreated callback. This method lets you sign P2PK locked
   * proofs before melting. If the payment is pending or unpaid, the change array will be empty.
   * @param meltPreview The preview from prepareMelt().
   * @param privkey The private key(s) for signing.
   * @param preferAsync Optional override to set 'respond-async' header.
   * @returns Updated MeltProofsResponse.
   * @throws If melt fails or signatures don't match output count.
   */
  async completeMelt(t, e, n) {
    t = this.maybeConvertMeltBlanks(t);
    let r = t.inputs;
    const i = t.outputData.map((d) => d.blindedMessage), o = t.quote.quote, a = this.getKeyset(t.keysetId);
    e && (r = this.signP2PKProofs(r, e, t.outputData, o)), r = this._prepareInputsForMint(r);
    const c = { quote: o, inputs: r, outputs: i }, u = t.method === "bolt11" ? await this.mint.meltBolt11(c, { preferAsync: n }) : await this.mint.melt(t.method, c, {
      preferAsync: n
    });
    this.failIf(
      (u.change?.length ?? 0) > t.outputData.length,
      `Mint returned ${u.change?.length ?? 0} signatures, but only ${t.outputData.length} blanks were provided`
    );
    const h = u.change?.map((d, f) => t.outputData[f].toProof(d, a)) ?? [];
    return n ? this._logger.debug("ASYNC MELT REQUESTED", u) : this._logger.debug("MELT COMPLETED", { changeAmounts: h.map((d) => d.amount) }), { quote: {
      ...t.quote,
      ...u
    }, change: h };
  }
  /**
   * Helper to ease transition from MeltBlanks to MeltPreview.
   */
  maybeConvertMeltBlanks(t) {
    if (!("payload" in t))
      return t;
    this._logger.warn(
      "MeltBlanks objects and the meltBlanksCreated / onChangeOutputsCreated events are deprecated. Please use wallet.prepareMelt() to create a MeltPreview instead."
    );
    const { method: e, payload: n, outputData: r, keyset: i, quote: o } = t;
    return {
      method: e,
      inputs: n.inputs,
      outputData: r,
      keysetId: i.id,
      quote: o
    };
  }
  // -----------------------------------------------------------------
  // Section: Proof States
  // -----------------------------------------------------------------
  /**
   * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)
   *
   * @param proofs (only the `secret` field is required)
   * @returns NUT-07 state for each proof, in same order.
   */
  async checkProofsStates(t) {
    const e = new TextEncoder(), n = t.map(
      (o) => pt(e.encode(o.secret)).toHex(!0)
    ), r = 100, i = [];
    for (let o = 0; o < n.length; o += r) {
      const a = n.slice(o, o + r), { states: c } = await this.mint.check({
        Ys: a
      }), u = {};
      c.forEach((h) => {
        u[h.Y] = h;
      });
      for (let h = 0; h < a.length; h++) {
        const l = u[a[h]];
        this.failIfNullish(l, "Could not find state for proof with Y: " + a[h]), i.push(l);
      }
    }
    return i;
  }
  /**
   * Groups proofs by their corresponding state, preserving order within each group.
   *
   * @param proofs (only the `secret` field is required)
   * @returns An object with arrays of proofs grouped by CheckStateEnum state.
   */
  async groupProofsByState(t) {
    const e = await this.checkProofsStates(t), n = {
      unspent: [],
      pending: [],
      spent: []
    };
    for (let r = 0; r < e.length; r++) {
      const i = t[r];
      switch (e[r].state) {
        case Nt.UNSPENT:
          n.unspent.push(i);
          break;
        case Nt.PENDING:
          n.pending.push(i);
          break;
        case Nt.SPENT:
          n.spent.push(i);
          break;
      }
    }
    return n;
  }
}
const It = class It {
  constructor(t, e) {
    this.tokens = {}, this.pool = [], this.desiredPoolSize = 10, this.maxPerMint = 10, this.mintUrl = t, this.req = e?.request ?? qe, this.logger = e?.logger ?? M, this.desiredPoolSize = Math.max(1, e?.desiredPoolSize ?? this.desiredPoolSize), this.maxPerMint = Math.max(1, e?.maxPerMint ?? this.maxPerMint);
  }
  // ------------------------------
  // Public API
  // ------------------------------
  /**
   * Attach an OIDCAuth instance so this manager can refresh CATs. Registers a listener to update
   * internal CAT/refresh state on new tokens.
   */
  attachOIDC(t) {
    return this.oidc = t, this.oidc.addTokenListener((e) => this.updateFromOIDC(e)), this;
  }
  get poolSize() {
    return this.pool.length;
  }
  get poolTarget() {
    return this.desiredPoolSize;
  }
  get activeAuthKeysetId() {
    try {
      return this.keychain?.getCheapestKeyset().id;
    } catch {
      return;
    }
  }
  get hasCAT() {
    return !!this.tokens.accessToken;
  }
  // ------------------------------
  // AuthProvider (NUT-21, Clear-auth)
  // ------------------------------
  getCAT() {
    return this.tokens.accessToken;
  }
  setCAT(t) {
    this.tokens.accessToken = t, t || (this.tokens.refreshToken = void 0, this.tokens.expiresAt = void 0);
  }
  /**
   * Ensure a valid CAT is available (refresh if expiring soon). Returns a token safe to send right
   * now, or undefined if unobtainable.
   */
  async ensureCAT(t) {
    return this.validForAtLeast(t) ? this.tokens.accessToken : !this.oidc || !this.tokens.refreshToken ? this.tokens.accessToken : (this.inflightRefresh || (this.inflightRefresh = (async () => {
      try {
        const e = await this.oidc.refresh(this.tokens.refreshToken);
        this.updateFromOIDC(e);
      } catch (e) {
        this.logger.warn("AuthManager: CAT refresh failed", { err: e });
      } finally {
        this.inflightRefresh = void 0;
      }
    })()), await this.inflightRefresh, this.validForAtLeast(0) ? this.tokens.accessToken : void 0);
  }
  // Returns true if expiry date is >minValidSecs away
  validForAtLeast(t = It.MIN_VALID_SECS) {
    const { accessToken: e, expiresAt: n } = this.tokens;
    return e ? n ? Date.now() + t * 1e3 < n : !0 : !1;
  }
  // Updates access and refresh tokens in our store, using either the explicit expires_in key or falling back to the JWT expiry.
  updateFromOIDC(t) {
    if (!t.access_token) return;
    const e = Date.now();
    if (this.tokens.accessToken = t.access_token, t.refresh_token && (this.tokens.refreshToken = t.refresh_token), typeof t.expires_in == "number" && t.expires_in > 0)
      this.tokens.expiresAt = e + t.expires_in * 1e3;
    else {
      const n = this.parseJwtExpSec(t.access_token);
      this.tokens.expiresAt = n ? n * 1e3 : void 0;
    }
    this.logger.debug("AuthManager: OIDC tokens updated", { expiresAt: this.tokens.expiresAt });
  }
  // ------------------------------
  // AuthProvider (NUT-22, Blind-auth)
  // ------------------------------
  /**
   * Ensure there are enough BAT tokens (topping up if needed)
   *
   * @param minTokens Minimum tokens needed.
   */
  async ensure(t) {
    if (await this.init(), this.pool.length >= t) return;
    const e = Math.max(this.desiredPoolSize, t), n = this.getBatMaxMint(), r = Math.min(e - this.pool.length, n);
    r <= 0 || await this.topUp(r);
  }
  /**
   * Gets a Blind Authentication Token (BAT)
   *
   * @param {method, path} to Call (not used in our implementation)
   * @returns The serialized BAT ready to insert into request header.
   */
  async getBlindAuthToken({
    method: t,
    path: e
  }) {
    return this.info && !this.info.requiresBlindAuthToken(t, e) && this.logger.warn("Endpoint is not marked as protected by NUT-22; still issuing BAT", {
      method: t,
      path: e
    }), this.withLock(async () => {
      if (await this.ensure(1), this.pool.length === 0)
        throw new Error("AuthManager: no BATs available and minting failed");
      const n = this.pool.pop();
      return this.logger.debug("AuthManager: BAT requested", {
        method: t,
        path: e,
        remaining: this.pool.length
      }), Mr(n);
    });
  }
  /**
   * Replace or merge the current BAT pool with previously persisted BATs.
   */
  importPool(t, e = "replace") {
    e === "replace" && (this.pool = []);
    const n = new Map(this.pool.map((r) => [r.secret, r]));
    for (const r of t)
      !r || !r.secret || !r.C || !r.id || n.has(r.secret) || (this.pool.push(r), n.set(r.secret, r));
  }
  /**
   * Return a deep-copied snapshot of the current BAT pool (full Proofs, including dleq).
   */
  exportPool() {
    return this.pool.map((t) => ({ ...t, dleq: t.dleq ? { ...t.dleq } : void 0 }));
  }
  // ------------------------------
  // Internals
  // ------------------------------
  /**
   * Extract exp, seconds since epoch, from a JWT access token.
   */
  parseJwtExpSec(t) {
    if (!t) return;
    const e = t.split(".");
    if (e.length === 3)
      try {
        const n = w.toString(w.fromBase64(e[1])), r = JSON.parse(n), i = typeof r.exp == "number" ? r.exp : Number(r.exp);
        if (Number.isFinite(i) && i > 0) return i;
      } catch {
        this.logger.warn("JWT access token was malformed.", {
          token: t
        });
      }
  }
  /**
   * Simple mutex lock - chains promises in order.
   */
  async withLock(t) {
    const e = this.lockChain ?? Promise.resolve();
    let n;
    const r = new Promise((o) => {
      n = o;
    }), i = e.then(() => r);
    this.lockChain = i;
    try {
      return await e, await t();
    } finally {
      n(), this.lockChain === i && (this.lockChain = void 0);
    }
  }
  /**
   * Initialise mint info and auth keysets/keys as needed.
   */
  async init() {
    if (!this.info) {
      const t = await this.req({
        endpoint: R(this.mintUrl, "/v1/info"),
        method: "GET"
      });
      this.info = new Et(t);
    }
    if (!this.keychain) {
      const [t, e] = await Promise.all([
        this.req({
          endpoint: R(this.mintUrl, "/v1/auth/blind/keysets"),
          method: "GET"
        }),
        this.req({
          endpoint: R(this.mintUrl, "/v1/auth/blind/keys"),
          method: "GET"
        })
      ]);
      this.keychain = new G(this.mintUrl, "auth", t.keysets, e.keysets), this.keychain.getCheapestKeyset();
    }
  }
  /**
   * Gets the BAT minting limit: lower of manager limit and Mints NUT-22 limit.
   */
  getBatMaxMint() {
    if (!this.info) throw new Error("AuthManager: mint info not loaded");
    const e = this.info.nuts[22]?.bat_max_mint ?? this.maxPerMint;
    return Math.max(1, Math.min(this.maxPerMint, e));
  }
  getActiveKeys() {
    if (!this.keychain) throw new Error("AuthManager: keyset not loaded for active keyset");
    return this.keychain.getCheapestKeyset();
  }
  /**
   * Mint a batch of BATs using the current CAT if the endpoint is protected by NUT-21.
   */
  async topUp(t) {
    if (!this.info) throw new Error("AuthManager: mint info not loaded");
    const e = this.info.requiresClearAuthToken("POST", "/v1/auth/blind/mint");
    let n;
    if (e && (n = await this.ensureCAT(), !n))
      throw new Error(
        "AuthManager: Clear-auth token required for /v1/auth/blind/mint but not available. Authenticate with the mint to obtain a CAT first."
      );
    const r = this.getActiveKeys(), i = K.createRandomData(t, r), o = { outputs: i.map((h) => h.blindedMessage) }, a = {};
    n && (a["Clear-auth"] = n);
    const c = await this.req({
      endpoint: R(this.mintUrl, "/v1/auth/blind/mint"),
      method: "POST",
      headers: a,
      requestBody: o
    });
    if (!Array.isArray(c?.signatures) || c.signatures.length !== i.length)
      throw new Error("AuthManager: bad BAT mint response");
    const u = i.map((h, l) => h.toProof(c.signatures[l], r));
    for (const h of u)
      if (!xn(h, r))
        throw new Error("AuthManager: mint returned BAT with invalid DLEQ");
    this.pool.push(...u), this.logger.debug("AuthManager: performed topUp", {
      minted: u.length,
      pool: this.pool.length
    });
  }
};
It.MIN_VALID_SECS = 30;
let zt = It;
function Mr(s) {
  const t = { id: s.id, secret: s.secret, C: s.C };
  return `authA${Re(t)}`;
}
async function mi(s, t) {
  const e = new zt(s, {
    desiredPoolSize: t?.authPool ?? 10,
    logger: t?.logger
  }), n = new ge(s, { authProvider: e, logger: t?.logger }), r = await n.oidcAuth({
    ...t?.oidc,
    logger: t?.logger,
    onTokens: (o) => e.setCAT(o.access_token)
    // set CAT automatically
  });
  e.attachOIDC(r);
  const i = new me(n, { authProvider: e, logger: t?.logger });
  return await i.loadMint(), { mint: n, auth: e, oidc: r, wallet: i };
}
export {
  zt as AuthManager,
  Nt as CheckStateEnum,
  Lr as ConsoleLogger,
  ut as HttpResponseError,
  G as KeyChain,
  dt as Keyset,
  Be as MeltBuilder,
  lt as MeltQuoteState,
  hr as MessageNode,
  lr as MessageQueue,
  ge as Mint,
  xe as MintBuilder,
  Et as MintInfo,
  Vt as MintOperationError,
  jt as MintQuoteState,
  Gt as NetworkError,
  pe as OIDCAuth,
  K as OutputData,
  Se as P2BK_DST,
  Dn as P2PKBuilder,
  vt as PaymentRequest,
  Pt as PaymentRequestTransportType,
  vr as ReceiveBuilder,
  Pr as SendBuilder,
  gr as WSConnection,
  me as Wallet,
  Ir as WalletCounters,
  Er as WalletEvents,
  Sr as WalletOps,
  Qe as assertSecretKind,
  Is as assertSigAllInputs,
  ai as bigIntStringify,
  yt as blindMessage,
  Cs as buildInterimP2PKSigAllMessage,
  xs as buildLegacyP2PKSigAllMessage,
  Ms as buildP2PKSigAllMessage,
  oi as bytesToNumber,
  li as checkResponse,
  gs as constructProofFromPromise,
  mi as createAuthWallet,
  Rr as createBlindSignature,
  ei as createDLEQProof,
  Us as createHTLCHash,
  ni as createHTLCsecret,
  Qr as createNewMintKeys,
  Vr as createP2PKsecret,
  $r as createRandomBlindedMessage,
  fs as createRandomRawBlindedMessage,
  ne as createRandomSecretKey,
  je as createSecret,
  di as decodePaymentRequest,
  Ee as deepEqual,
  Ls as deriveBlindingFactor,
  fe as deriveKeysetId,
  ks as deriveP2BKBlindedPubkeys,
  _s as deriveP2BKSecretKey,
  bs as deriveP2BKSecretKeys,
  Ns as deriveSecret,
  jr as deserializeMintKeys,
  Hr as deserializeProof,
  Ve as getDataField,
  cr as getDecodedToken,
  gi as getDecodedTokenBinary,
  ci as getEncodedToken,
  pi as getEncodedTokenBinary,
  or as getEncodedTokenV3,
  ar as getEncodedTokenV4,
  Rs as getHTLCWitnessPreimage,
  ir as getKeepAmounts,
  Sn as getKeysetAmounts,
  ds as getKeysetIdInt,
  Zr as getP2PKExpectedKWitnessPubkeys,
  Ze as getP2PKExpectedWitnessPubkeys,
  Dt as getP2PKLockState,
  As as getP2PKLocktime,
  Ss as getP2PKNSigs,
  Ps as getP2PKNSigsRefund,
  $t as getP2PKSigFlag,
  ie as getP2PKWitnessPubkeys,
  gt as getP2PKWitnessRefundkeys,
  oe as getP2PKWitnessSignatures,
  ws as getPubKeyFromPrivKey,
  Ge as getSecretData,
  ze as getSecretKind,
  se as getTag,
  re as getTagInt,
  Xe as getTagScalar,
  Je as getTags,
  ui as getTokenMetadata,
  Rt as getValidSigners,
  In as handleTokens,
  Pn as hasCorrespondingKey,
  le as hasNonHexId,
  Jr as hasP2PKSignedProof,
  Gr as hasTag,
  xn as hasValidDleq,
  pt as hashToCurve,
  He as hash_e,
  Tt as hexToNumber,
  Fr as injectWebSocketImpl,
  pr as invoiceHasAmountInHRP,
  ri as isHTLCSpendAuthorised,
  U as isObj,
  At as isP2PKSigAll,
  Ts as isP2PKSpendAuthorised,
  it as isValidHex,
  R as joinUrls,
  Es as maybeDeriveP2BKPrivateKeys,
  Wr as meetsSignerThreshold,
  ur as mergeUInt8Arrays,
  Wt as numberToHexPadded64,
  si as parseHTLCSecret,
  N as parseP2PKSecret,
  Ot as parseSecret,
  qr as pointFromBytes,
  Y as pointFromHex,
  Mn as sanitizeUrl,
  We as schnorrSignMessage,
  Bt as schnorrVerifyMessage,
  _r as selectProofsRGLI,
  ys as serializeMintKeys,
  ms as serializeProof,
  Ur as setGlobalRequestOptions,
  $s as signMintQuote,
  vs as signP2PKProof,
  Pe as signP2PKProofs,
  Xr as signP2PKSecret,
  hi as sortProofsById,
  z as splitAmount,
  Cn as stripDleq,
  nt as sumProofs,
  ps as unblindSignature,
  de as validateAmount,
  Os as verifyDLEQProof,
  Ds as verifyDLEQProof_reblind,
  Fs as verifyHTLCHash,
  qs as verifyHTLCSpendingConditions,
  fi as verifyKeysetId,
  ii as verifyMintQuoteSignature,
  Yr as verifyP2PKSecretSignature,
  ti as verifyP2PKSig,
  en as verifyP2PKSpendingConditions,
  zr as verifyProof
};
//# sourceMappingURL=cashu-ts.es.js.map
