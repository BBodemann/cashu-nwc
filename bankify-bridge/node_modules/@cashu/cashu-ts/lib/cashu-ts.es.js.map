{"version":3,"file":"cashu-ts.es.js","sources":["../src/model/Errors.ts","../src/logger/NullLogger.ts","../src/logger/helpers.ts","../src/logger/ConsoleLogger.ts","../src/transport/request.ts","../src/transport/ws.ts","../src/utils/Bytes.ts","../src/utils/base64.ts","../src/utils/bech32m.ts","../src/utils/cbor.ts","../src/crypto/core.ts","../src/crypto/NUT01.ts","../src/crypto/NUT10.ts","../src/crypto/NUT26.ts","../src/crypto/NUT11.ts","../src/crypto/NUT12.ts","../src/crypto/NUT13.ts","../src/crypto/NUT14.ts","../src/crypto/NUT20.ts","../src/wallet/types/payment-requests.ts","../src/utils/tlv.ts","../src/model/PaymentRequest.ts","../src/utils/core.ts","../src/transport/WSConnection.ts","../src/model/types/NUT04.ts","../src/model/types/NUT05.ts","../src/model/types/NUT07.ts","../src/legacy/nut-05.ts","../src/legacy/nut-04.ts","../src/legacy/nut-06.ts","../src/model/MintInfo.ts","../src/auth/OIDCAuth.ts","../src/mint/Mint.ts","../src/wallet/Keyset.ts","../src/wallet/KeyChain.ts","../src/model/BlindedMessage.ts","../src/model/OutputData.ts","../src/wallet/P2PKBuilder.ts","../src/wallet/SelectProofs.ts","../src/wallet/CounterSource.ts","../src/wallet/WalletOps.ts","../src/wallet/WalletEvents.ts","../src/wallet/WalletCounters.ts","../src/wallet/Wallet.ts","../src/auth/AuthManager.ts","../src/auth/createAuthWallet.ts"],"sourcesContent":["/**\n * This error is thrown when a HTTP response is not 2XX nor a protocol error.\n */\nexport class HttpResponseError extends Error {\n\tstatus: number;\n\tconstructor(message: string, status: number) {\n\t\tsuper(message);\n\t\tthis.status = status;\n\t\tthis.name = 'HttpResponseError';\n\t\tObject.setPrototypeOf(this, HttpResponseError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a network request fails.\n */\nexport class NetworkError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = 'NetworkError';\n\t\tObject.setPrototypeOf(this, NetworkError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a [protocol\n * error](https://github.com/cashubtc/nuts/blob/main/00.md#errors) occurs. See error codes\n * [here](https://github.com/cashubtc/nuts/blob/main/error_codes.md).\n */\nexport class MintOperationError extends HttpResponseError {\n\tcode: number;\n\tconstructor(code: number, detail: string) {\n\t\tsuper(detail || 'Unknown mint operation error', 400);\n\t\tthis.code = code;\n\t\tthis.name = 'MintOperationError';\n\t\tObject.setPrototypeOf(this, MintOperationError.prototype);\n\t}\n}\n","import type { Logger } from './Logger';\n\n// The default logger implementation - does nothing\n/* eslint-disable @typescript-eslint/no-empty-function */\nexport const NULL_LOGGER: Logger = {\n\terror() {},\n\twarn() {},\n\tinfo() {},\n\tdebug() {},\n\ttrace() {},\n\tlog() {},\n};\n/* eslint-enable @typescript-eslint/no-empty-function */\n","import { type Logger } from './Logger';\nimport { NULL_LOGGER } from './NullLogger';\n\n/**\n * Log at ERROR and throw. Always throws.\n *\n * @param message - Error message to log and throw.\n * @param logger - Logger to use, defaults to NULL_LOGGER.\n * @param context - Optional structured context for the log.\n * @throws {Error} Always throws with the given message.\n */\nexport function fail(\n\tmessage: string,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): never {\n\tlogger.error(message, context);\n\tthrow new Error(message);\n}\n\n/**\n * Throw if a Boolean condition is true. On return, the compiler knows the condition is false.\n *\n * @param condition - Condition that must be false to continue.\n * @param message - Error message if condition is true.\n * @param logger - Logger to use, defaults to NULL_LOGGER.\n * @param context - Optional structured context for the log.\n * @throws {Error} If condition is true, throws with the given message.\n */\nexport function failIf(\n\tcondition: boolean,\n\tmessage: string,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): asserts condition is false {\n\tif (condition) fail(message, logger, context);\n}\n\n/**\n * Throw if a value is null or undefined. Value is narrowed thereafter.\n *\n * @typeParam T - The value type to check.\n * @param value - The value to validate.\n * @param message - Error message if value is nullish.\n * @param logger - Logger to use, defaults to NULL_LOGGER.\n * @param context - Optional structured context for the log.\n * @throws {Error} If value is null or undefined.\n */\nexport function failIfNullish<T>(\n\tvalue: T,\n\tmessage: string,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): asserts value is Exclude<T, null | undefined> {\n\tif (value == null) fail(message, logger, context);\n}\n\n/**\n * Invoke a user-supplied callback safely in a fire-and-forget manner.\n *\n * Used for per-operation hooks (e.g. `onCountersReserved`) where user code must never break the\n * walletâ€™s control flow. The callback is invoked synchronously, exceptions are caught and logged\n * (as a warning), and then swallowed.\n *\n * The wallet never `await`s the callback.\n *\n * @example\n *\n * ```ts\n * if (autoCounters.used) {\n * \tsafeCallback(onCountersReserved, autoCounters.used, _logger, { keysetId });\n * }\n * ```\n *\n * @typeParam T Type of the payload passed to the callback.\n * @param cb The callback to invoke, or `undefined`.\n * @param payload The payload to pass to the callback.\n * @param logger Logger to use (defaults to NULL_LOGGER).\n * @param context Optional structured context for the log.\n */\nexport function safeCallback<T>(\n\tcb: ((p: T) => void | Promise<void>) | undefined,\n\tpayload: T,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): void {\n\tif (!cb) return;\n\n\ttry {\n\t\tconst maybePromise = cb(payload);\n\t\tif (maybePromise && typeof maybePromise.then === 'function') {\n\t\t\tmaybePromise.catch((error) => {\n\t\t\t\ttry {\n\t\t\t\t\tlogger.warn('callback failed', {\n\t\t\t\t\t\t...(context ?? {}),\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tcb: cb.name ?? '',\n\t\t\t\t\t});\n\t\t\t\t} catch {\n\t\t\t\t\t/* ignore logger errors */\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t} catch (error) {\n\t\ttry {\n\t\t\tlogger.warn('callback failed', {\n\t\t\t\t...(context ?? {}),\n\t\t\t\terror,\n\t\t\t\tcb: cb.name ?? '',\n\t\t\t});\n\t\t} catch {\n\t\t\t/* ignore logger errors */\n\t\t}\n\t}\n}\n","import { type Logger, type LogLevel } from './Logger';\n\nconst LEVEL_ORDER: Record<LogLevel, number> = {\n\terror: 0,\n\twarn: 1,\n\tinfo: 2,\n\tdebug: 3,\n\ttrace: 4,\n};\n\n/**\n * Outputs messages to the console based on the specified log level.\n *\n * Supports placeholder substitution in messages (e.g., `{key}`) using values from the optional\n * `context` object. Context keys not used in substitution are appended to the output as additional\n * data. Each log message is prefixed with the log level in square brackets (e.g., `[INFO]`).\n *\n * @example Const logger = new ConsoleLogger(LogLevel.DEBUG); logger.info('User {username} logged\n * in', { username: 'alice', ip: '127.0.0.1' }); // Output: [INFO] User alice logged in { ip:\n * \"127.0.0.1\" }\n */\nexport class ConsoleLogger implements Logger {\n\tprivate minLevel: LogLevel;\n\n\tconstructor(minLevel: LogLevel = 'info') {\n\t\tthis.minLevel = minLevel;\n\t}\n\n\tprivate should(level: LogLevel): boolean {\n\t\treturn LEVEL_ORDER[level] <= LEVEL_ORDER[this.minLevel];\n\t}\n\tprivate method(level: LogLevel): (msg: string, ...rest: unknown[]) => void {\n\t\tswitch (level) {\n\t\t\tcase 'error':\n\t\t\t\treturn console.error;\n\t\t\tcase 'warn':\n\t\t\t\treturn console.warn;\n\t\t\tcase 'info':\n\t\t\t\treturn console.info;\n\t\t\tcase 'debug':\n\t\t\t\treturn console.debug;\n\t\t\tcase 'trace':\n\t\t\t\treturn console.trace;\n\t\t\tdefault:\n\t\t\t\treturn console.log;\n\t\t}\n\t}\n\tprivate header(level: LogLevel, message: string): string {\n\t\treturn `[${level.toUpperCase()}] ${message}`;\n\t}\n\tprivate flattenContext(ctx?: Record<string, unknown>): Record<string, unknown> | undefined {\n\t\tif (!ctx) return undefined;\n\t\tconst out: Record<string, unknown> = {};\n\t\tfor (const [k, v] of Object.entries(ctx)) {\n\t\t\tout[k] = v instanceof Error ? { message: v.message, stack: v.stack } : v;\n\t\t}\n\t\treturn out;\n\t}\n\tprivate emit(level: LogLevel, message: string, context?: Record<string, unknown>) {\n\t\tif (!this.should(level)) return;\n\t\tconst line = this.header(level, message);\n\t\tconst ctx = this.flattenContext(context);\n\t\tconst fn = this.method(level);\n\t\tif (ctx && Object.keys(ctx).length) fn(line, ctx);\n\t\telse fn(line);\n\t}\n\n\terror(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('error', msg, ctx);\n\t}\n\twarn(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('warn', msg, ctx);\n\t}\n\tinfo(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('info', msg, ctx);\n\t}\n\tdebug(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('debug', msg, ctx);\n\t}\n\ttrace(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('trace', msg, ctx);\n\t}\n\n\tlog(level: LogLevel, message: string, context?: Record<string, unknown>) {\n\t\tthis.emit(level, message, context);\n\t}\n}\n\n/**\n * Creates a timer to measure elapsed time in milliseconds.\n *\n * @example Const timer = measureTime(); // ... some code ... const duration = timer.elapsed();\n *\n * @returns An object with an `elapsed` method to retrieve the duration since the timer started.\n */\nexport function measureTime() {\n\tconst start = Date.now();\n\treturn {\n\t\telapsed: () => {\n\t\t\treturn Date.now() - start;\n\t\t},\n\t};\n}\n","import { HttpResponseError, NetworkError, MintOperationError } from '../model/Errors';\nimport { type Logger, NULL_LOGGER } from '../logger';\n\n// Generic request function type so callers can do requestInstance<T>(...)\nexport type RequestFn = <T = unknown>(args: RequestOptions) => Promise<T>;\n\nexport type RequestArgs = {\n\tendpoint: string;\n\trequestBody?: Record<string, unknown>;\n\theaders?: Record<string, string>;\n\tlogger?: Logger;\n};\n\nexport type RequestOptions = RequestArgs & Omit<RequestInit, 'body' | 'headers'>;\n\n/**\n * Cashu api error.\n *\n * - Error: Brief error message.\n * - Code: HTTP error code.\n * - Detail: Detailed error message.\n */\nexport type ApiError = {\n\terror?: string;\n\tcode?: number;\n\tdetail?: string;\n};\n\nlet globalRequestOptions: Partial<RequestOptions> = {};\nlet requestLogger = NULL_LOGGER;\n\n/**\n * An object containing any custom settings that you want to apply to the global fetch method.\n *\n * @param options See possible options here:\n *   https://developer.mozilla.org/en-US/docs/Web/API/fetch#options.\n */\nexport function setGlobalRequestOptions(options: Partial<RequestOptions>): void {\n\tglobalRequestOptions = options;\n}\n\n/**\n * Allows a logger to be set.\n *\n * @param {Logger} logger The logger instance to use.\n */\nexport function setRequestLogger(logger: Logger): void {\n\trequestLogger = logger;\n}\n\nasync function _request({\n\tendpoint,\n\trequestBody,\n\theaders: requestHeaders,\n\t...options\n}: RequestOptions): Promise<unknown> {\n\tconst body = requestBody ? JSON.stringify(requestBody) : undefined;\n\tconst headers = {\n\t\t...{ Accept: 'application/json, text/plain, */*' },\n\t\t...(body ? { 'Content-Type': 'application/json' } : undefined),\n\t\t...requestHeaders,\n\t};\n\n\tlet response: Response;\n\ttry {\n\t\tresponse = await fetch(endpoint, { body, headers, ...options });\n\t} catch (err) {\n\t\t// A fetch() promise only rejects when the request fails,\n\t\t// for example, because of a badly-formed request URL or a network error.\n\t\tthrow new NetworkError(err instanceof Error ? err.message : 'Network request failed');\n\t}\n\n\tif (!response.ok) {\n\t\tlet errorData: ApiError;\n\t\ttry {\n\t\t\terrorData = (await response.json()) as ApiError;\n\t\t} catch {\n\t\t\terrorData = { error: 'bad response' };\n\t\t}\n\n\t\tif (\n\t\t\tresponse.status === 400 &&\n\t\t\t'code' in errorData &&\n\t\t\ttypeof errorData.code === 'number' &&\n\t\t\t'detail' in errorData &&\n\t\t\ttypeof errorData.detail === 'string'\n\t\t) {\n\t\t\tthrow new MintOperationError(errorData.code, errorData.detail);\n\t\t}\n\n\t\tlet errorMessage = 'HTTP request failed';\n\t\tif ('error' in errorData && typeof errorData.error === 'string') {\n\t\t\terrorMessage = errorData.error;\n\t\t} else if ('detail' in errorData && typeof errorData.detail === 'string') {\n\t\t\terrorMessage = errorData.detail;\n\t\t}\n\n\t\tthrow new HttpResponseError(errorMessage, response.status);\n\t}\n\n\ttry {\n\t\treturn await response.json();\n\t} catch (err) {\n\t\trequestLogger.error('Failed to parse HTTP response', { err });\n\t\tthrow new HttpResponseError('bad response', response.status);\n\t}\n}\n\nexport default async function request<T>(options: RequestOptions): Promise<T> {\n\tconst data = await _request({ ...options, ...globalRequestOptions });\n\treturn data as T;\n}\n","let _WS: typeof WebSocket | undefined;\n\nif (typeof WebSocket !== 'undefined') {\n\t_WS = WebSocket;\n}\n\nexport function injectWebSocketImpl(ws: typeof WebSocket) {\n\t_WS = ws;\n}\n\nexport function getWebSocketImpl() {\n\tif (_WS === undefined) {\n\t\tthrow new Error('WebSocket implementation not initialized');\n\t}\n\treturn _WS;\n}\n","export class Bytes {\n\tstatic fromHex(hex: string): Uint8Array {\n\t\thex = hex.trim();\n\t\tif (hex.length === 0) {\n\t\t\treturn new Uint8Array(0);\n\t\t}\n\t\tif (hex.length < 2 || hex.length & 1) {\n\t\t\tthrow new Error('Invalid hex string: odd length.');\n\t\t}\n\t\tif (hex.startsWith('0x') || hex.startsWith('0X')) {\n\t\t\thex = hex.slice(2);\n\t\t}\n\t\tconst match = hex.match(/^[0-9a-fA-F]*$/);\n\t\tif (!match) {\n\t\t\tthrow new Error('Invalid hex string: contains non-hex characters');\n\t\t}\n\t\tconst matches = hex.match(/.{1,2}/g);\n\t\tif (!matches) {\n\t\t\tthrow new Error('Invalid hex string');\n\t\t}\n\t\treturn new Uint8Array(matches.map((byte) => parseInt(byte, 16)));\n\t}\n\n\tstatic toHex(bytes: Uint8Array): string {\n\t\treturn Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0')).join('');\n\t}\n\n\tstatic fromString(str: string): Uint8Array {\n\t\tstr = str.trim();\n\t\treturn new TextEncoder().encode(str);\n\t}\n\n\tstatic toString(bytes: Uint8Array): string {\n\t\treturn new TextDecoder('utf-8').decode(bytes);\n\t}\n\n\tstatic concat(...arrays: Uint8Array[]): Uint8Array {\n\t\tconst totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);\n\t\tconst result = new Uint8Array(totalLength);\n\t\tlet offset = 0;\n\t\tfor (const arr of arrays) {\n\t\t\tresult.set(arr, offset);\n\t\t\toffset += arr.length;\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic alloc(size: number): Uint8Array {\n\t\treturn new Uint8Array(size);\n\t}\n\n\tstatic writeBigUint64BE(value: bigint): Uint8Array {\n\t\tconst buffer = new ArrayBuffer(8);\n\t\tnew DataView(buffer).setBigUint64(0, value, false);\n\t\treturn new Uint8Array(buffer);\n\t}\n\n\tstatic toBase64(bytes: Uint8Array): string {\n\t\tif (typeof Buffer !== 'undefined') {\n\t\t\treturn Buffer.from(bytes).toString('base64');\n\t\t}\n\t\t// preventing stack overflow by chunking\n\t\tif (bytes.length > 32768) {\n\t\t\tlet result = '';\n\t\t\tfor (let i = 0; i < bytes.length; i += 32768) {\n\t\t\t\tconst chunk = bytes.slice(i, i + 32768);\n\t\t\t\tresult += btoa(String.fromCharCode(...chunk));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn btoa(String.fromCharCode(...bytes));\n\t}\n\n\tstatic fromBase64(base64: string): Uint8Array {\n\t\tbase64 = base64.trim();\n\t\t// normalise base64url to base64 and pad\n\t\tlet normalizedBase64 = base64.replace(/-/g, '+').replace(/_/g, '/');\n\t\twhile (normalizedBase64.length % 4) {\n\t\t\tnormalizedBase64 += '=';\n\t\t}\n\t\tif (typeof Buffer !== 'undefined') {\n\t\t\treturn new Uint8Array(Buffer.from(normalizedBase64, 'base64'));\n\t\t}\n\t\treturn new Uint8Array([...atob(normalizedBase64)].map((c) => c.charCodeAt(0)));\n\t}\n\t// NOTE: MUST remain a constant-time implementation (full byte check)\n\t// because callers rely on it (e.g. deriveP2BKSecretKey).\n\tstatic equals(a: Uint8Array, b: Uint8Array): boolean {\n\t\tif (a.length !== b.length) return false;\n\t\tlet result = 0;\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tresult |= a[i] ^ b[i];\n\t\t}\n\t\treturn result === 0;\n\t}\n\n\tstatic compare(a: Uint8Array, b: Uint8Array): number {\n\t\tconst minLength = Math.min(a.length, b.length);\n\t\tfor (let i = 0; i < minLength; i++) {\n\t\t\tif (a[i] < b[i]) return -1;\n\t\t\tif (a[i] > b[i]) return 1;\n\t\t}\n\t\treturn a.length - b.length;\n\t}\n\n\tstatic toBigInt(bytes: Uint8Array): bigint {\n\t\tlet result = 0n;\n\t\tfor (const byte of bytes) {\n\t\t\tresult = (result << 8n) | BigInt(byte);\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic fromBigInt(value: bigint): Uint8Array {\n\t\tif (value < 0n) {\n\t\t\tthrow new RangeError('value must be non-negative');\n\t\t}\n\t\tif (value === 0n) {\n\t\t\treturn new Uint8Array([0]);\n\t\t}\n\t\t// Calculate Uint8Array length\n\t\tlet temp = value;\n\t\tlet length = 0;\n\t\twhile (temp > 0n) {\n\t\t\tlength++;\n\t\t\ttemp >>= 8n;\n\t\t}\n\t\t// Fill it from the end (big endian)\n\t\tconst out = new Uint8Array(length);\n\t\ttemp = value;\n\t\tfor (let i = length - 1; i >= 0; i--) {\n\t\t\tout[i] = Number(temp & 0xffn);\n\t\t\ttemp >>= 8n;\n\t\t}\n\t\treturn out;\n\t}\n}\n","import { Bytes } from './Bytes';\n\nfunction encodeUint8toBase64(uint8array: Uint8Array): string {\n\treturn Bytes.toBase64(uint8array);\n}\n\nfunction encodeUint8toBase64Url(bytes: Uint8Array): string {\n\treturn Bytes.toBase64(bytes)\n\t\t.replace(/\\+/g, '-') // Replace + with -\n\t\t.replace(/\\//g, '_') // Replace / with _\n\t\t.replace(/=+$/, ''); // Remove padding characters\n}\n\nfunction encodeBase64toUint8(base64String: string): Uint8Array {\n\treturn Bytes.fromBase64(base64String);\n}\n\nfunction encodeJsonToBase64(jsonObj: unknown): string {\n\tconst jsonString = JSON.stringify(jsonObj);\n\treturn base64urlFromBase64(Bytes.toBase64(Bytes.fromString(jsonString)));\n}\n\nfunction encodeBase64ToJson<T extends object>(base64String: string): T {\n\tconst jsonString = Bytes.toString(Bytes.fromBase64(base64urlToBase64(base64String)));\n\tconst jsonObj = JSON.parse(jsonString) as T;\n\treturn jsonObj;\n}\n\nfunction base64urlToBase64(str: string) {\n\treturn str.replace(/-/g, '+').replace(/_/g, '/').split('=')[0];\n\t// .replace(/./g, '=');\n}\n\nfunction base64urlFromBase64(str: string) {\n\treturn str.replace(/\\+/g, '-').replace(/\\//g, '_').split('=')[0];\n\t// .replace(/=/g, '.');\n}\n\nfunction isBase64String(s: string): boolean {\n\tif (typeof s !== 'string' || s.length === 0) return false;\n\n\t// Accept both base64 and base64url char sets\n\tconst base64url = /^[A-Za-z0-9\\-_]+={0,2}$/;\n\tconst base64 = /^[A-Za-z0-9+/]+={0,2}$/;\n\n\t// Quick character-set check\n\tif (!base64url.test(s) && !base64.test(s)) return false;\n\n\t// Normalize base64url to standard base64 for decoding\n\tconst normalized = s.replace(/-/g, '+').replace(/_/g, '/');\n\n\t// Padding: length must be multiple of 4. Add '=' padding if needed (but no more than 2)\n\tconst padLength = (4 - (normalized.length % 4)) % 4;\n\tif (padLength > 2) return false; // should never happen but keep safe\n\tconst padded = normalized + '='.repeat(padLength);\n\n\ttry {\n\t\tconst decoded = Bytes.fromBase64(padded);\n\n\t\t// Re-encode and compare to the original (allowing either standard or url-safe representation)\n\t\tconst reStandard = Bytes.toBase64(decoded);\n\t\tconst reUrl = reStandard.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n\n\t\t// Also compare against original normalized-without-padding variant\n\t\tconst originalNoPad = normalized.replace(/=+$/, '');\n\n\t\tif (reStandard.replace(/=+$/, '') === originalNoPad) return true;\n\t\tif (reUrl === originalNoPad) return true;\n\n\t\treturn false;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport {\n\tencodeUint8toBase64,\n\tencodeUint8toBase64Url,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeBase64ToJson,\n\tisBase64String,\n};\n","import { bech32m } from '@scure/base';\n\ntype Bech32mString = `${string}1${string}`;\n\nconst LIMIT_LENGTH = 1023;\n\n/**\n * Asserts that a string has valid bech32m format (contains separator '1' with content on both\n * sides). Per BIP-173/BIP-350, the last '1' in the string is the separator between HRP and data.\n *\n * @param str - The string to validate.\n * @throws Error if the string doesn't have a valid bech32m separator structure.\n */\nfunction assertBech32mFormat(str: string): asserts str is Bech32mString {\n\tconst separatorIndex = str.lastIndexOf('1');\n\tif (separatorIndex < 1 || separatorIndex === str.length - 1) {\n\t\tthrow new Error('Invalid bech32m string: missing or misplaced separator');\n\t}\n}\n\n/**\n * Encodes a Uint8Array to a bech32m string with the given human-readable part (HRP).\n *\n * @param hrp - The human-readable prefix (e.g., 'cashu', 'bc')\n * @param data - The data to encode.\n * @returns The bech32m encoded string.\n */\nfunction encodeBech32m(hrp: string, data: Uint8Array, limitLength = LIMIT_LENGTH): string {\n\tconst words = bech32m.toWords(data);\n\treturn bech32m.encode(hrp, words, limitLength);\n}\n\n/**\n * Decodes a bech32m string back to its components.\n *\n * @param encoded - The bech32m encoded string.\n * @returns An object containing the human-readable part (hrp) and the decoded data.\n */\nfunction decodeBech32m(\n\tencoded: string,\n\tlimitLength = LIMIT_LENGTH,\n): { hrp: string; data: Uint8Array } {\n\tassertBech32mFormat(encoded);\n\tconst { prefix, words } = bech32m.decode(encoded, limitLength);\n\tconst data = bech32m.fromWords(words);\n\treturn { hrp: prefix, data };\n}\n\n/**\n * Decodes a bech32m string and returns only the data portion.\n *\n * @param encoded - The bech32m encoded string.\n * @returns The decoded data as Uint8Array.\n */\nfunction decodeBech32mToBytes(encoded: string, limitLength = LIMIT_LENGTH): Uint8Array {\n\treturn decodeBech32m(encoded, limitLength).data;\n}\n\n/**\n * Checks if a string is a valid bech32m encoded string.\n *\n * @param str - The string to check.\n * @param expectedHrp - Optional: verify the HRP matches this value.\n * @returns True if the string is valid bech32m (and matches expectedHrp if provided)\n */\nfunction isBech32m(str: string, expectedHrp?: string, limitLength = LIMIT_LENGTH): boolean {\n\ttry {\n\t\tconst { hrp } = decodeBech32m(str, limitLength);\n\t\tif (expectedHrp !== undefined && hrp !== expectedHrp) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport { encodeBech32m, decodeBech32m, decodeBech32mToBytes, isBech32m };\n","/*\n * Lightweight CBOR encoder/decoder (purpose and limitations)\n *\n * Supported\n * - Major types: 0 (unsigned), 1 (negative), 2 (byte string), 3 (text string),\n *   4 (array), 5 (map), 7 (simple values & floats).\n * - Additional-info lengths: short (0..23), 1-, 2- and 4-byte length forms are\n *   encoded by the encoder. The decoder understands 8-byte length fields\n *   (additional-info 27) and will decode them into a JavaScript Number\n *   (hi * 2**32 + lo) but the encoder intentionally does not emit 8-byte\n *   integer forms (see 'Not implemented' below).\n * - Floating point: decoder supports float16/float32/float64. Encoder emits\n *   float64 for non-integers.\n * - Guardrails: explicit throws for unsupported types and sizes (e.g. huge\n *   strings/byte arrays/arrays/maps > 2**32-1, integers larger than 32-bit for\n *   encoding). DataView out-of-bounds reads are normalized to\n *   \"Unexpected end of data\" for clearer errors.\n *\n * Not implemented / intentionally out of scope\n * - Indefinite-length (streaming) containers (indefinite-length arrays,\n *   maps, byte/text strings) are not supported. Test vectors with streaming\n *   markers are skipped in the test harness.\n * - Semantic tags (major type 6) are not interpreted; tagged values are\n *   skipped in encode-roundtrip tests. Implementing tags should return a\n *   wrapper object or otherwise surface the tag + value.\n * - Big integers / bignum handling: this implementation does not return\n *   BigInt for values outside Number.isSafeInteger nor emit CBOR bignum tags\n *   (tag 2/3). Decode may parse 8-byte unsigned/negative integers into a\n *   Number which can overflow JS precision; callers who need accurate bignum\n *   support should add BigInt decoding and encoder support.\n * - Encoder does not emit float16/float32 or 8-byte integer (additional-info\n *   27) forms. It intentionally limits integer encoding to <= 32-bit and\n *   uses float64 for non-integers to keep the implementation small.\n *\n * Guidance for contributors\n * - To add streaming support, implement indefinite-length decoders that\n *   concatenate chunks until the break byte (0xff) and update decodeItem\n *   accordingly.\n * - To add BigInt/bignum support, change decode paths to return BigInt when\n *   required, add fixture representation for BigInt in tests, and emit proper\n *   tag-2/3 bignum encodings or 8-byte integer forms in the encoder.\n */\n\n/* Reference: CBOR specification (RFC 8949) https://www.rfc-editor.org/rfc/rfc8949.html */\n\ntype SimpleValue = boolean | null | undefined;\n\nexport type ResultObject = { [key: string]: ResultValue };\nexport type ResultValue = SimpleValue | number | string | Uint8Array | ResultValue[] | ResultObject;\n\ntype ResultKeyType = Extract<ResultValue, number | string>;\nexport type ValidDecodedType = Extract<ResultValue, ResultObject>;\n\nfunction isResultKeyType(value: ResultValue): value is ResultKeyType {\n\treturn typeof value === 'number' || typeof value === 'string';\n}\n\ntype DecodeResult<T extends ResultValue> = {\n\tvalue: T;\n\toffset: number;\n};\n\nexport function encodeCBOR(value: unknown): Uint8Array {\n\tconst buffer: number[] = [];\n\tencodeItem(value, buffer);\n\treturn new Uint8Array(buffer);\n}\n\nfunction encodeItem(value: unknown, buffer: number[]) {\n\tif (value === null) {\n\t\tbuffer.push(0xf6);\n\t} else if (value === undefined) {\n\t\tbuffer.push(0xf7);\n\t} else if (typeof value === 'boolean') {\n\t\tbuffer.push(value ? 0xf5 : 0xf4);\n\t} else if (typeof value === 'number') {\n\t\tencodeNumber(value, buffer);\n\t} else if (typeof value === 'string') {\n\t\tencodeString(value, buffer);\n\t} else if (Array.isArray(value)) {\n\t\tencodeArray(value, buffer);\n\t} else if (value instanceof Uint8Array) {\n\t\tencodeByteString(value, buffer);\n\t} else if (\n\t\t// Defensive: POJO only (null/array handled above)\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t!Array.isArray(value)\n\t) {\n\t\tencodeObject(value as Record<string, unknown>, buffer);\n\t} else {\n\t\tthrow new Error('Unsupported type');\n\t}\n}\n\nfunction encodeUnsigned(value: number, buffer: number[]) {\n\tif (value < 24) {\n\t\tbuffer.push(value);\n\t} else if (value < 256) {\n\t\tbuffer.push(0x18, value);\n\t} else if (value < 65536) {\n\t\tbuffer.push(0x19, (value >>> 8) & 0xff, value & 0xff);\n\t} else if (value < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x1a,\n\t\t\t(value >>> 24) & 0xff,\n\t\t\t(value >>> 16) & 0xff,\n\t\t\t(value >>> 8) & 0xff,\n\t\t\tvalue & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Unsupported integer size');\n\t}\n}\n\nfunction encodeSigned(value: number, buffer: number[]) {\n\t// CBOR negative integer encoding: store -1 - value as unsigned under major type 1\n\tconst unsigned = -1 - value;\n\tif (unsigned < 24) {\n\t\tbuffer.push(0x20 | unsigned);\n\t} else if (unsigned < 256) {\n\t\tbuffer.push(0x38, unsigned & 0xff);\n\t} else if (unsigned < 65536) {\n\t\tbuffer.push(0x39, (unsigned >>> 8) & 0xff, unsigned & 0xff);\n\t} else if (unsigned < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x3a,\n\t\t\t(unsigned >>> 24) & 0xff,\n\t\t\t(unsigned >>> 16) & 0xff,\n\t\t\t(unsigned >>> 8) & 0xff,\n\t\t\tunsigned & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Unsupported integer size');\n\t}\n}\n\nfunction encodeFloat64(value: number, buffer: number[]) {\n\t// major type 7, additional info 27 (0xfb) followed by 8 bytes IEEE 754 big-endian\n\tconst ab = new ArrayBuffer(8);\n\tconst dv = new DataView(ab);\n\tdv.setFloat64(0, value, false);\n\tbuffer.push(0xfb);\n\tfor (let i = 0; i < 8; i++) buffer.push(dv.getUint8(i));\n}\n\nfunction encodeNumber(value: number, buffer: number[]) {\n\tif (Number.isInteger(value)) {\n\t\tif (value >= 0) {\n\t\t\t// unsigned\n\t\t\tencodeUnsigned(value, buffer);\n\t\t} else {\n\t\t\t// negative integer\n\t\t\tencodeSigned(value, buffer);\n\t\t}\n\t} else {\n\t\t// encode non-integer numbers as float64 for simplicity\n\t\tencodeFloat64(value, buffer);\n\t}\n}\n\nfunction encodeByteString(value: Uint8Array, buffer: number[]) {\n\tconst length = value.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x40 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x58, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x59, (length >> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x5a,\n\t\t\t(length >>> 24) & 0xff,\n\t\t\t(length >>> 16) & 0xff,\n\t\t\t(length >>> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Byte string too long to encode');\n\t}\n\n\tfor (let i = 0; i < value.length; i++) {\n\t\tbuffer.push(value[i]);\n\t}\n}\n\nfunction encodeString(value: string, buffer: number[]) {\n\tconst utf8 = new TextEncoder().encode(value);\n\tconst length = utf8.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x60 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x78, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x79, (length >>> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x7a,\n\t\t\t(length >>> 24) & 0xff,\n\t\t\t(length >>> 16) & 0xff,\n\t\t\t(length >>> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('String too long to encode');\n\t}\n\n\tfor (let i = 0; i < utf8.length; i++) {\n\t\tbuffer.push(utf8[i]);\n\t}\n}\n\nfunction encodeArray(value: unknown[], buffer: number[]) {\n\tconst length = value.length;\n\tif (length < 24) {\n\t\tbuffer.push(0x80 | length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x98, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x99, (length >>> 8) & 0xff, length & 0xff);\n\t} else {\n\t\tthrow new Error('Unsupported array length');\n\t}\n\n\tfor (const item of value) {\n\t\tencodeItem(item, buffer);\n\t}\n}\n\nfunction encodeObject(value: Record<string, unknown>, buffer: number[]) {\n\tconst keys = Object.keys(value);\n\tconst length = keys.length;\n\n\t// Guardrail: we only support map lengths up to 2^32-1 (same as encodeUnsigned max)\n\tif (length >= 4294967296) {\n\t\tthrow new Error('Object has too many keys to encode');\n\t}\n\n\t// Write initial byte for major type 5 (map) and additional info based on length\n\tif (length < 24) {\n\t\tbuffer.push(0xa0 | length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0xb8, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0xb9, (length >> 8) & 0xff, length & 0xff);\n\t} else {\n\t\tbuffer.push(\n\t\t\t0xba,\n\t\t\t(length >> 24) & 0xff,\n\t\t\t(length >> 16) & 0xff,\n\t\t\t(length >> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t}\n\tfor (const key of keys) {\n\t\tencodeString(key, buffer);\n\t\tencodeItem(value[key], buffer);\n\t}\n}\n\nexport function decodeCBOR(data: Uint8Array): ResultValue {\n\tconst view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\tconst result = decodeItem(view, 0);\n\treturn result.value;\n}\n\nfunction decodeItem(view: DataView, offset: number): DecodeResult<ResultValue> {\n\tif (offset >= view.byteLength) {\n\t\tthrow new Error('Unexpected end of data');\n\t}\n\tconst initialByte = view.getUint8(offset++);\n\tconst majorType = initialByte >> 5;\n\tconst additionalInfo = initialByte & 0x1f;\n\n\tswitch (majorType) {\n\t\tcase 0:\n\t\t\treturn decodeUnsigned(view, offset, additionalInfo);\n\t\tcase 1:\n\t\t\treturn decodeSigned(view, offset, additionalInfo);\n\t\tcase 2:\n\t\t\treturn decodeByteString(view, offset, additionalInfo);\n\t\tcase 3:\n\t\t\treturn decodeString(view, offset, additionalInfo);\n\t\tcase 4:\n\t\t\treturn decodeArray(view, offset, additionalInfo);\n\t\tcase 5:\n\t\t\treturn decodeMap(view, offset, additionalInfo);\n\t\tcase 7:\n\t\t\treturn decodeSimpleAndFloat(view, offset, additionalInfo);\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported major type: ${majorType}`);\n\t}\n}\n\nfunction ensureAvailable(view: DataView, offset: number, needed: number) {\n\tif (offset + needed > view.byteLength) {\n\t\tthrow new Error('Unexpected end of data');\n\t}\n}\n\nfunction decodeLength(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tif (additionalInfo < 24) return { value: additionalInfo, offset };\n\tif (additionalInfo === 24) {\n\t\tensureAvailable(view, offset, 1);\n\t\treturn { value: view.getUint8(offset++), offset };\n\t}\n\tif (additionalInfo === 25) {\n\t\tensureAvailable(view, offset, 2);\n\t\tconst value = view.getUint16(offset, false);\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tensureAvailable(view, offset, 4);\n\t\tconst value = view.getUint32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tensureAvailable(view, offset, 8);\n\t\tconst hi = view.getUint32(offset, false);\n\t\tconst lo = view.getUint32(offset + 4, false);\n\t\toffset += 8;\n\t\treturn { value: hi * 2 ** 32 + lo, offset };\n\t}\n\tthrow new Error(`Unsupported length: ${additionalInfo}`);\n}\n\nfunction decodeUnsigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value, offset: newOffset };\n}\n\nfunction decodeSigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value: -1 - value, offset: newOffset };\n}\n\nfunction decodeByteString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<Uint8Array> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('Byte string length exceeds data length');\n\t}\n\tconst value = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<string> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('String length exceeds data length');\n\t}\n\tconst bytes = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\tconst value = new TextDecoder().decode(bytes);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeArray(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<ResultValue[]> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst array = [];\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst result = decodeItem(view, currentOffset);\n\t\tarray.push(result.value);\n\t\tcurrentOffset = result.offset;\n\t}\n\treturn { value: array, offset: currentOffset };\n}\n\nfunction decodeMap(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<Record<string, ResultValue>> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst map: { [key: string]: ResultValue } = {};\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst keyResult = decodeItem(view, currentOffset);\n\t\tif (!isResultKeyType(keyResult.value)) {\n\t\t\tthrow new Error('Invalid key type');\n\t\t}\n\t\tconst valueResult = decodeItem(view, keyResult.offset);\n\t\tmap[keyResult.value] = valueResult.value;\n\t\tcurrentOffset = valueResult.offset;\n\t}\n\treturn { value: map, offset: currentOffset };\n}\n\nfunction decodeFloat16(uint16: number): number {\n\tconst exponent = (uint16 & 0x7c00) >> 10;\n\tconst fraction = uint16 & 0x03ff;\n\tconst sign = uint16 & 0x8000 ? -1 : 1;\n\n\tif (exponent === 0) {\n\t\treturn sign * 2 ** -14 * (fraction / 1024);\n\t} else if (exponent === 0x1f) {\n\t\treturn fraction ? NaN : sign * Infinity;\n\t}\n\treturn sign * 2 ** (exponent - 15) * (1 + fraction / 1024);\n}\n\nfunction decodeSimpleAndFloat(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<SimpleValue | number> {\n\tif (additionalInfo < 24) {\n\t\tswitch (additionalInfo) {\n\t\t\tcase 20:\n\t\t\t\treturn { value: false, offset };\n\t\t\tcase 21:\n\t\t\t\treturn { value: true, offset };\n\t\t\tcase 22:\n\t\t\t\treturn { value: null, offset };\n\t\t\tcase 23:\n\t\t\t\treturn { value: undefined, offset };\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown simple value: ${additionalInfo}`);\n\t\t}\n\t}\n\tif (additionalInfo === 24) {\n\t\tensureAvailable(view, offset, 1);\n\t\treturn { value: view.getUint8(offset++), offset };\n\t}\n\tif (additionalInfo === 25) {\n\t\tensureAvailable(view, offset, 2);\n\t\tconst value = decodeFloat16(view.getUint16(offset, false));\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tensureAvailable(view, offset, 4);\n\t\tconst value = view.getFloat32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tensureAvailable(view, offset, 8);\n\t\tconst value = view.getFloat64(offset, false);\n\t\toffset += 8;\n\t\treturn { value, offset };\n\t}\n\tthrow new Error(`Unknown simple or float value: ${additionalInfo}`);\n}\n","import { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass.js';\nimport { schnorr, secp256k1 } from '@noble/curves/secp256k1.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { utf8ToBytes } from '@noble/hashes/utils.js';\nimport { randomBytes, bytesToHex, hexToBytes } from '@noble/curves/utils.js';\n\n/**\n * Private key type - can be hex string or Uint8Array.\n */\nexport type PrivKey = Uint8Array | string;\nimport { Bytes, hexToNumber, encodeBase64toUint8 } from '../utils';\nimport { type P2PKWitness } from '../model/types';\n\nexport type BlindSignature = {\n\tC_: WeierstrassPoint<bigint>;\n\tamount: number;\n\tid: string;\n};\n\nexport type RawBlindedMessage = {\n\tB_: WeierstrassPoint<bigint>;\n\tr: bigint;\n\tsecret: Uint8Array;\n};\n\n/**\n * @deprecated - Use {@link RawBlindedMessage}.\n */\nexport type BlindedMessage = RawBlindedMessage;\n\nexport type DLEQ = {\n\ts: Uint8Array; // signature\n\te: Uint8Array; // challenge\n\tr?: bigint; // optional: blinding factor\n};\n\nexport type RawProof = {\n\tC: WeierstrassPoint<bigint>;\n\tsecret: Uint8Array;\n\tamount: number;\n\tid: string;\n\twitness?: P2PKWitness;\n};\n\nexport type SerializedProof = {\n\tC: string;\n\tsecret: string;\n\tamount: number;\n\tid: string;\n\twitness?: string;\n};\n\nconst DOMAIN_SEPARATOR = utf8ToBytes('Secp256k1_HashToCurve_Cashu_');\n\nexport function hashToCurve(secret: Uint8Array): WeierstrassPoint<bigint> {\n\tconst msgToHash = sha256(Bytes.concat(DOMAIN_SEPARATOR, secret));\n\tconst counter = new Uint32Array(1);\n\tconst maxIterations = 2 ** 16;\n\tfor (let i = 0; i < maxIterations; i++) {\n\t\tconst counterBytes = new Uint8Array(counter.buffer);\n\t\tconst hash = sha256(Bytes.concat(msgToHash, counterBytes));\n\t\ttry {\n\t\t\treturn pointFromHex(bytesToHex(Bytes.concat(new Uint8Array([0x02]), hash)));\n\t\t} catch {\n\t\t\tcounter[0]++;\n\t\t}\n\t}\n\tthrow new Error('No valid point found');\n}\n\nexport function hash_e(pubkeys: Array<WeierstrassPoint<bigint>>): Uint8Array {\n\tconst hexStrings = pubkeys.map((p) => p.toHex(false));\n\tconst e_ = hexStrings.join('');\n\treturn sha256(new TextEncoder().encode(e_));\n}\n\nexport function pointFromBytes(bytes: Uint8Array) {\n\treturn secp256k1.Point.fromHex(bytesToHex(bytes));\n}\n\nexport function pointFromHex(hex: string) {\n\treturn secp256k1.Point.fromHex(hex);\n}\n\nexport const getKeysetIdInt = (keysetId: string): bigint => {\n\tlet keysetIdInt: bigint;\n\tif (/^[a-fA-F0-9]+$/.test(keysetId)) {\n\t\tkeysetIdInt = hexToNumber(keysetId) % BigInt(2 ** 31 - 1);\n\t} else {\n\t\t//legacy keyset compatibility\n\t\tkeysetIdInt = Bytes.toBigInt(encodeBase64toUint8(keysetId)) % BigInt(2 ** 31 - 1);\n\t}\n\treturn keysetIdInt;\n};\n\nexport function createRandomSecretKey() {\n\treturn secp256k1.utils.randomSecretKey();\n}\n\nexport function createBlindSignature(\n\tB_: WeierstrassPoint<bigint>,\n\tprivateKey: Uint8Array,\n\tamount: number,\n\tid: string,\n): BlindSignature {\n\tconst a = secp256k1.Point.Fn.fromBytes(privateKey);\n\tconst C_: WeierstrassPoint<bigint> = B_.multiply(a);\n\treturn { C_, amount, id };\n}\n\n/**\n * @deprecated - Use {@link createRandomRawBlindedMessage}\n */\nexport function createRandomBlindedMessage(_deprecated?: PrivKey): RawBlindedMessage {\n\tvoid _deprecated; // intentionally unused\n\treturn createRandomRawBlindedMessage();\n}\n\n/**\n * Creates a random blinded message.\n *\n * @remarks\n * The secret is a UTF-8 encoded 64-character lowercase hex string, generated from 32 random bytes\n * as recommended by NUT-00.\n * @returns A RawBlindedMessage: {B_, r, secret}\n */\nexport function createRandomRawBlindedMessage(): RawBlindedMessage {\n\tconst secretStr = bytesToHex(randomBytes(32)); // 64 char ASCII hex string\n\tconst secretBytes = new TextEncoder().encode(secretStr); // UTF-8 of the hex\n\treturn blindMessage(secretBytes);\n}\n\n/**\n * Blind a secret message.\n *\n * @param secret A UTF-8 byte encoded string.\n * @param r Optional. Deterministic blinding scalar to use (eg: for testing / seeded)\n * @returns A RawBlindedMessage: {B_, r, secret}\n */\nexport function blindMessage(secret: Uint8Array, r?: bigint): RawBlindedMessage {\n\tconst Y = hashToCurve(secret);\n\tif (!r) {\n\t\tr = secp256k1.Point.Fn.fromBytes(createRandomSecretKey());\n\t}\n\tconst rG = secp256k1.Point.BASE.multiply(r);\n\tconst B_ = Y.add(rG);\n\treturn { B_, r, secret };\n}\n\nexport function unblindSignature(\n\tC_: WeierstrassPoint<bigint>,\n\tr: bigint,\n\tA: WeierstrassPoint<bigint>,\n): WeierstrassPoint<bigint> {\n\tconst C = C_.subtract(A.multiply(r));\n\treturn C;\n}\n\nexport function constructProofFromPromise(\n\tpromise: BlindSignature,\n\tr: bigint,\n\tsecret: Uint8Array,\n\tkey: WeierstrassPoint<bigint>,\n): RawProof {\n\tconst A = key;\n\tconst C = unblindSignature(promise.C_, r, A);\n\tconst proof = {\n\t\tid: promise.id,\n\t\tamount: promise.amount,\n\t\tsecret,\n\t\tC,\n\t};\n\treturn proof;\n}\n\nexport const serializeProof = (proof: RawProof): SerializedProof => {\n\treturn {\n\t\tamount: proof.amount,\n\t\tC: proof.C.toHex(true),\n\t\tid: proof.id,\n\t\tsecret: new TextDecoder().decode(proof.secret),\n\t\twitness: JSON.stringify(proof.witness),\n\t};\n};\n\nexport const deserializeProof = (proof: SerializedProof): RawProof => {\n\treturn {\n\t\tamount: proof.amount,\n\t\tC: pointFromHex(proof.C),\n\t\tid: proof.id,\n\t\tsecret: new TextEncoder().encode(proof.secret),\n\t\twitness: proof.witness ? (JSON.parse(proof.witness) as P2PKWitness) : undefined,\n\t};\n};\n\n// ------------------------------\n// Schnorr Signing / Verififcaton\n// ------------------------------\n\n/**\n * Signs a message string using Schnorr.\n *\n * @remarks\n * Signatures are non-deterministic because schnorr.sign() generates a new random auxiliary value\n * (auxRand) each time it is called.\n * @param message - The message to sign.\n * @param privateKey - The private key to sign with (hex string or Uint8Array).\n * @returns The signature in hex format.\n */\nexport const schnorrSignMessage = (message: string, privateKey: PrivKey): string => {\n\tconst msghash = sha256(new TextEncoder().encode(message));\n\tconst privKeyBytes = typeof privateKey === 'string' ? hexToBytes(privateKey) : privateKey;\n\tconst sig = schnorr.sign(msghash, privKeyBytes); // auxRand is random by default\n\treturn bytesToHex(sig);\n};\n\n/**\n * Verifies a Schnorr signature on a message.\n *\n * @remarks\n * This function swallows Schnorr verification errors (eg invalid signature / pubkey format) and\n * treats them as false. If you want to throw such errors, use the throws param.\n * @param signature - The Schnorr signature (hex-encoded).\n * @param message - The message to verify.\n * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).\n * @param throws - True: throws on error, False: swallows errors and returns false.\n * @returns True if the signature is valid, false otherwise.\n * @throws If throws param is true and error is encountered.\n */\nexport const schnorrVerifyMessage = (\n\tsignature: string,\n\tmessage: string,\n\tpubkey: string,\n\tthrows: boolean = false,\n): boolean => {\n\ttry {\n\t\tconst msghash = sha256(new TextEncoder().encode(message));\n\t\t// Use X-only pubkey: strip 02/03 prefix if pubkey is 66 hex chars (33 bytes)\n\t\tconst pubkeyX = pubkey.length === 66 ? pubkey.slice(2) : pubkey;\n\t\treturn schnorr.verify(hexToBytes(signature), msghash, hexToBytes(pubkeyX));\n\t} catch (e) {\n\t\tif (throws) {\n\t\t\tthrow e;\n\t\t}\n\t}\n\treturn false; // default fail\n};\n\n/**\n * Returns the set of unique public keys that have produced a valid Schnorr signature for a given\n * message.\n *\n * @param signatures - The Schnorr signature(s) (hex-encoded).\n * @param message - The message to verify.\n * @param pubkeys - The Cashu P2PK public key(s) (hex-encoded, X-only or with 02/03 prefix) to\n *   check.\n * @returns Array of public keys who validly signed, duplicates removed.\n */\nexport function getValidSigners(\n\tsignatures: string[],\n\tmessage: string,\n\tpubkeys: string[],\n): string[] {\n\tconst uniquePubs = Array.from(new Set(pubkeys));\n\treturn uniquePubs.filter((pubkey) =>\n\t\tsignatures.some((sig) => schnorrVerifyMessage(sig, message, pubkey)),\n\t);\n}\n\n/**\n * Checks enough unique pubkeys have signed a message.\n *\n * @param signatures - The Schnorr signature(s) (hex-encoded).\n * @param message - The message to verify.\n * @param pubkeys - The Cashu P2PK public key(s) (hex-encoded, X-only or with 02/03 prefix) to\n *   check.\n * @param threshold - The minimum number of unique witnesses required.\n * @returns True if the witness threshold was reached, false otherwise.\n */\nexport const meetsSignerThreshold = (\n\tsignatures: string[],\n\tmessage: string,\n\tpubkeys: string[],\n\tthreshold: number = 1,\n): boolean => {\n\tconst validSigners = getValidSigners(signatures, message, pubkeys);\n\treturn validSigners.length >= threshold;\n};\n","import { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass.js';\nimport { bytesToHex, hexToBytes } from '@noble/curves/utils.js';\nimport { secp256k1 } from '@noble/curves/secp256k1.js';\nimport { type RawProof, createRandomSecretKey, hashToCurve } from './core';\nimport { HDKey } from '@scure/bip32';\nimport { deriveKeysetId } from '../utils';\n\nconst DERIVATION_PATH = \"m/0'/0'/0'\";\n\nexport type RawMintKeys = { [k: string]: Uint8Array };\n\nexport type SerializedMintKeys = {\n\t[k: string]: string;\n};\n\nexport type Enumerate<N extends number, Acc extends number[] = []> = Acc['length'] extends N\n\t? Acc[number]\n\t: Enumerate<N, [...Acc, Acc['length']]>;\n\nexport type IntRange<F extends number, T extends number> = Exclude<Enumerate<T>, Enumerate<F>>;\n\nexport type KeysetPair = {\n\tkeysetId: string;\n\tpubKeys: RawMintKeys;\n\tprivKeys: RawMintKeys;\n};\n\nexport function serializeMintKeys(mintKeys: RawMintKeys): SerializedMintKeys {\n\tconst serializedMintKeys: SerializedMintKeys = {};\n\tObject.keys(mintKeys).forEach((p) => {\n\t\tserializedMintKeys[p] = bytesToHex(mintKeys[p]);\n\t});\n\treturn serializedMintKeys;\n}\n\nexport function deserializeMintKeys(serializedMintKeys: SerializedMintKeys): RawMintKeys {\n\tconst mintKeys: RawMintKeys = {};\n\tObject.keys(serializedMintKeys).forEach((p) => {\n\t\tmintKeys[p] = hexToBytes(serializedMintKeys[p]);\n\t});\n\treturn mintKeys;\n}\n\nexport function getPubKeyFromPrivKey(privKey: Uint8Array) {\n\treturn secp256k1.getPublicKey(privKey, true);\n}\n\n/**\n * Creates new mint keys.\n *\n * @param pow2height Number of powers of 2 to create (Max 65).\n * @param seed (Optional). Seed for key derivation.\n * @param options.expiry (optional) expiry of the keyset.\n * @param options.input_fee_ppk (optional) Input fee for keyset (in ppk)\n * @param options.unit (optional) the unit of the keyset. Default: sat.\n * @param options.versionByte (optional) version of the keyset ID. Default: 1.\n * @returns KeysetPair object.\n * @throws If keyset versionByte is not valid.\n */\nexport function createNewMintKeys(\n\tpow2height: IntRange<0, 65>,\n\tseed?: Uint8Array,\n\toptions?: {\n\t\texpiry?: number;\n\t\tinput_fee_ppk?: number;\n\t\tunit?: string;\n\t\tversionByte?: number;\n\t},\n): KeysetPair {\n\tconst { expiry, input_fee_ppk, unit = 'sat', versionByte = 1 } = options || {};\n\tlet counter = 0n;\n\tconst pubKeys: RawMintKeys = {};\n\tconst privKeys: RawMintKeys = {};\n\tlet masterKey;\n\tif (seed) {\n\t\tmasterKey = HDKey.fromMasterSeed(seed);\n\t}\n\twhile (counter < pow2height) {\n\t\tconst index: string = (2n ** counter).toString();\n\t\tif (masterKey) {\n\t\t\tconst k = masterKey.derive(`${DERIVATION_PATH}/${counter}`).privateKey;\n\t\t\tif (k) {\n\t\t\t\tprivKeys[index] = k;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Could not derive Private key from: ${DERIVATION_PATH}/${counter}`);\n\t\t\t}\n\t\t} else {\n\t\t\tprivKeys[index] = createRandomSecretKey();\n\t\t}\n\n\t\tpubKeys[index] = getPubKeyFromPrivKey(privKeys[index]);\n\t\tcounter++;\n\t}\n\tconst keysetId = deriveKeysetId(serializeMintKeys(pubKeys), {\n\t\texpiry,\n\t\tinput_fee_ppk,\n\t\tunit,\n\t\tversionByte,\n\t});\n\treturn { pubKeys, privKeys, keysetId };\n}\n\nexport function verifyProof(proof: RawProof, privKey: Uint8Array): boolean {\n\tconst Y: WeierstrassPoint<bigint> = hashToCurve(proof.secret);\n\tconst a = secp256k1.Point.Fn.fromBytes(privKey);\n\tconst aY: WeierstrassPoint<bigint> = Y.multiply(a);\n\treturn aY.equals(proof.C);\n}\n","import { bytesToHex, randomBytes } from '@noble/curves/utils.js';\n\nexport type SecretKind = 'P2PK' | 'HTLC' | (string & {}); // union with any string\n\nexport interface SecretData {\n\tnonce: string;\n\tdata: string;\n\ttags?: string[][];\n}\n\nexport type Secret = [SecretKind, SecretData];\n\n// ------------------------------\n// NUT-10 Secrets\n// ------------------------------\n\n/**\n * Create a NUT-10 well known secret.\n *\n * @param kind - The secret kind (P2PK, HTLC, etc)\n * @param pubkey - The pubkey to add to Secret.data.\n * @param tags - Optional. Additional P2PK tags.\n */\nexport function createSecret(kind: SecretKind, data: string, tags?: string[][]): string {\n\tconst newSecret: Secret = [\n\t\tkind,\n\t\t{\n\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\tdata,\n\t\t\ttags,\n\t\t},\n\t];\n\treturn JSON.stringify(newSecret);\n}\n\n/**\n * Parse a secret string and validate NUT-10 shape.\n *\n * @param secret - The Proof secret.\n * @returns Secret object.\n * @throws If the JSON is invalid or NUT-10 secret is malformed.\n */\nexport function parseSecret(secret: string | Secret): Secret {\n\tlet parsed: unknown;\n\ttry {\n\t\tif (typeof secret === 'string') {\n\t\t\tparsed = JSON.parse(secret) as Secret;\n\t\t} else {\n\t\t\tparsed = secret; // Pass through\n\t\t}\n\t} catch {\n\t\tthrow new Error(\"Can't parse secret\");\n\t}\n\n\t// Validate NUT-10 shape\n\tif (\n\t\t!Array.isArray(parsed) ||\n\t\tparsed.length !== 2 ||\n\t\ttypeof parsed[0] !== 'string' || // kind\n\t\ttypeof parsed[1] !== 'object' || // data\n\t\tparsed[0].trim().length === 0 ||\n\t\tparsed[1] === null\n\t) {\n\t\tthrow new Error('Invalid NUT-10 secret');\n\t}\n\tconst [kind, data] = parsed as [SecretKind, Record<string, unknown>];\n\tif (typeof data.nonce !== 'string' || typeof data.data !== 'string') {\n\t\tthrow new Error('Invalid NUT-10 secret nonce / data');\n\t}\n\tif (data.tags) {\n\t\t// Check data.tags is an array\n\t\tif (!Array.isArray(data.tags)) {\n\t\t\tthrow new Error('Invalid NUT-10 secret tags');\n\t\t}\n\t\t// Check individual tags are non-empty arrays of strings\n\t\tconst invalid = data.tags.some(\n\t\t\t(t) =>\n\t\t\t\t!Array.isArray(t) || t.length === 0 || t.some((tt) => typeof tt !== 'string' || !tt.length),\n\t\t);\n\t\tif (invalid) {\n\t\t\tthrow new Error('Invalid NUT-10 tag(s)');\n\t\t}\n\t}\n\n\treturn [\n\t\tkind,\n\t\t{\n\t\t\tnonce: data.nonce,\n\t\t\tdata: data.data,\n\t\t\ttags: data.tags,\n\t\t} as SecretData,\n\t];\n}\n\n// ------------------------------\n// Secret Kind / Data\n// ------------------------------\n\n/**\n * Assert that a Secret is of the expected kind.\n *\n * @param allowed - NUT-10 Kind(s) allowed.\n * @param secret - The Proof secret.\n * @returns Parsed Secret if the kind matches.\n * @throws If secret kind is not as expected.\n */\nexport function assertSecretKind(\n\tallowed: SecretKind | SecretKind[],\n\tsecret: Secret | string,\n): Secret {\n\tconst kinds = Array.isArray(allowed) ? allowed : [allowed];\n\tconst parsed = parseSecret(secret);\n\tconst actual = parsed[0];\n\tif (!kinds.includes(actual)) {\n\t\tthrow new Error(`Invalid secret kind: ${actual} Allowed: ${kinds.join(', ')}`);\n\t}\n\treturn parsed;\n}\n\n/**\n * Get the kind (first element) of a Secret.\n *\n * @param secret - The Proof secret.\n */\nexport function getSecretKind(secret: Secret | string): SecretKind {\n\treturn parseSecret(secret)[0];\n}\n\n/**\n * Get the SecretData payload (second element) of a Secret.\n *\n * @param secret - The Proof secret.\n */\nexport function getSecretData(secret: Secret | string): SecretData {\n\treturn parseSecret(secret)[1];\n}\n\n/**\n * Get data field value from a secret.\n *\n * @param secret - The Proof secret.\n * @returns - SecretData.data.\n */\nexport function getDataField(secret: Secret | string): string {\n\tconst { data } = getSecretData(secret);\n\treturn data;\n}\n\n// ------------------------------\n// Secret Tags\n// ------------------------------\n\n/**\n * Get all tags from a secret.\n *\n * @param secret - The Proof secret.\n * @returns - Array of tag arrays.\n */\nexport function getTags(secret: Secret | string): string[][] {\n\tconst { tags } = getSecretData(secret);\n\treturn tags ?? [];\n}\n\n/**\n * Check if a secret has a tag with the given key.\n *\n * @param secret - The Proof secret.\n * @param key - Tag key to lookup.\n * @returns - True if tag exists, False otherwise.\n */\nexport function hasTag(secret: Secret | string, key: string): boolean {\n\treturn getTags(secret).some((t) => t[0] === key);\n}\n\n/**\n * Get the values of a tag by key, excluding the key itself.\n *\n * @param secret - The Proof secret.\n * @param key - Tag key to lookup.\n * @returns - Array of Tag values or undefined if not present.\n */\nexport function getTag(secret: Secret | string, key: string): string[] | undefined {\n\tconst tag = getTags(secret).find((t) => t[0] === key);\n\tif (!tag || tag.length <= 1) return undefined;\n\treturn tag.slice(1);\n}\n\n/**\n * Get the first scalar value of a tag as a string, or undefined if missing.\n *\n * @param secret - The Proof secret.\n * @param key - Tag key to lookup.\n * @returns - Tag value or undefined if not present.\n */\nexport function getTagScalar(secret: Secret | string, key: string): string | undefined {\n\tconst vals = getTag(secret, key);\n\treturn vals && vals.length > 0 ? vals[0] : undefined;\n}\n\n/**\n * Get the first scalar value of a tag parsed as base-10 integer, or undefined.\n *\n * @param secret - The Proof secret.\n * @param key - Tag key to lookup.\n * @returns - Tag value as an integer, undefined if not present or invalid.\n */\nexport function getTagInt(secret: Secret | string, key: string): number | undefined {\n\tconst v = getTagScalar(secret, key);\n\tif (v === undefined) return undefined;\n\tconst n = Number.parseInt(v, 10);\n\treturn Number.isFinite(n) ? n : undefined;\n}\n","import { secp256k1 } from '@noble/curves/secp256k1.js';\nimport { Bytes, hexToNumber, numberToHexPadded64 } from '../utils';\nimport { pointFromHex } from './core';\nimport { bytesToHex, hexToBytes, utf8ToBytes } from '@noble/hashes/utils.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass.js';\n\n/**\n * BIP340-style domain separation tag (DST) for P2BK.\n *\n * @experimental\n */\nexport const P2BK_DST = utf8ToBytes('Cashu_P2BK_v1');\n\n/**\n * Blind a sequence of public keys using ECDH derived tweaks, one tweak per slot.\n *\n * @remarks\n * Security note: \"Ehex\" must never be reused. Doing so would create linkability and leak privacy.\n * The only exception is for SIG_ALL proofs, as all secret tags must match.\n *\n * This is the Sender side API.\n * @param pubkeys Ordered SEC1 compressed pubkeys, [data, ...pubkeys, ...refund]\n * @param keysetId Hex keyset identifier, bound into the tweak.\n * @param eBytes Optional. Fixed ephemeral secret key to use (eg for SIG_ALL / testing)\n * @returns Blinded pubkeys in the same order, and Ehex as SEC1 compressed hex, 33 bytes.\n * @throws If a blinded key is at infinity.\n * @experimental\n */\nexport function deriveP2BKBlindedPubkeys(\n\tpubkeys: string[],\n\tkeysetId: string,\n\teBytes?: Uint8Array,\n): { blinded: string[]; Ehex: string } {\n\tif (!pubkeys.length) return { blinded: [], Ehex: '' };\n\t// Create fresh ephemeral secret (e) if not supplied, and calculate pubkey (E)\n\teBytes = eBytes ?? secp256k1.utils.randomSecretKey(); // 32 bytes\n\tconst e = secp256k1.Point.Fn.fromBytes(eBytes); // bigint in [1..n-1]\n\tconst E = secp256k1.getPublicKey(eBytes, true); // SEC1 compressed (bytes)\n\tconst kid = hexToBytes(keysetId);\n\t// Blind each pubkey in turn\n\tconst blinded = pubkeys.map((pubkey, i) => {\n\t\tconst P = pointFromHex(pubkey);\n\t\tconst r = deriveP2BKBlindingTweakFromECDH(P, e, kid, i);\n\t\tconst P_ = P.add(secp256k1.Point.BASE.multiply(r));\n\t\tif (P_.equals(secp256k1.Point.ZERO)) throw new Error('Blinded key at infinity');\n\t\treturn P_.toHex(true);\n\t});\n\treturn { blinded, Ehex: bytesToHex(E) };\n}\n\n/**\n * Derive blinded secret keys that correspond to given P2BK blinded pubkeys.\n *\n * Pubkeys are processed in order, for a proof that is [data, ...pubkeys, ...refund]. Private key\n * order does not matter.\n *\n * @remarks\n * Security note, this operates on long lived secrets. JavaScript BigInt arithmetic in a JIT is not\n * guaranteed constant time. Do not expose this function on a server that holds private keys.\n *\n * This is the Receiver side API.\n * @param Ehex Ephemeral public key (E) as SEC1 hex.\n * @param privateKey Secret key or array of secret keys, hex.\n * @param blindPubKey Blinded public key or array of blinded public keys, hex.\n * @param keysetIdHex Keyset identifier as hex.\n * @returns Array of derived secret keys as 64 char hex.\n * @experimental\n */\nexport function deriveP2BKSecretKeys(\n\tEhex: string,\n\tprivateKey: string | string[],\n\tblindPubKey: string | string[],\n\tkeysetIdHex: string,\n): string[] {\n\tconst privs = Array.isArray(privateKey) ? privateKey : [privateKey];\n\tconst pubs = Array.isArray(blindPubKey) ? blindPubKey : [blindPubKey];\n\tconst out = new Set<string>();\n\tconst E = secp256k1.Point.fromHex(Ehex);\n\tconst kid = hexToBytes(keysetIdHex);\n\tfor (const privHex of privs) {\n\t\tconst p = secp256k1.Point.Fn.fromBytes(hexToBytes(privHex));\n\t\tconst P = secp256k1.getPublicKey(hexToBytes(privHex), true); // 33 bytes, validates on curve\n\t\tpubs.forEach((hexP_, i) => {\n\t\t\tconst r = deriveP2BKBlindingTweakFromECDH(E, p, kid, i);\n\t\t\tconst P_ = hexToBytes(hexP_);\n\t\t\tconst kHex = deriveP2BKSecretKey(privHex, r, P_, P);\n\t\t\tif (kHex) out.add(kHex); // add only when this priv matches this Pâ€²\n\t\t});\n\t}\n\treturn Array.from(out);\n}\n\n/**\n * Derive a blinded secret key per NUT-26.\n *\n * Unblinds the pubkey (P = P_ - rÂ·G), verifies x-coord against the naturalPub x(P) == x(pÂ·G), then\n * choose skStd = (p + ráµ¢) mod n if parity(P) == parity(pÂ·G), otherwise skNeg = (-p + ráµ¢) mod n.\n * Returns skStd if no blindPubkey is provided.\n *\n * @remarks\n * Security note, this operates on long lived secrets. JavaScript BigInt arithmetic in a JIT is not\n * guaranteed constant time. Do not expose this function on a server that holds private keys.\n * @param privkey Unblinded private key (p), hex or bigint.\n * @param rBlind Blinding scalar (r), hex or bigint.\n * @param blindPubkey Optional. Blinded pubkey (P_) to match, 33 byte hex.\n * @param naturalPub Optional. Pubkey calculated from private key (P = pÂ·G), 33 byte hex.\n * @returns Derived blinded secret key as 64 char hex.\n * @throws If inputs are out of range, or the derived key would be zero.\n * @experimental\n */\nexport function deriveP2BKSecretKey(\n\tprivkey: string | bigint,\n\trBlind: string | bigint,\n\tblindPubkey?: Uint8Array,\n\tnaturalPub?: Uint8Array,\n): string | null {\n\t// Implementation note: must keep algorithmic constant time!\n\tconst n = secp256k1.Point.CURVE().n;\n\tconst p = typeof privkey === 'string' ? hexToNumber(privkey) : privkey;\n\tconst r = typeof rBlind === 'string' ? hexToNumber(rBlind) : rBlind;\n\tif (p <= 0n || p >= n) throw new Error('Invalid private key');\n\tif (r <= 0n || r >= n) throw new Error('Invalid scalar r');\n\t// If caller didn't provide P = pÂ·G, compute it in compressed form (33 bytes)\n\tnaturalPub = naturalPub ?? secp256k1.Point.BASE.multiply(p).toBytes(true);\n\tif (naturalPub.length !== 33) throw new Error('naturalPub must be 33 bytes');\n\t// Calculate both sk candidates for constant time (add/subtract is cheap)\n\tconst skStd: bigint = (p + r) % n;\n\tconst skNeg: bigint = (n - p + r) % n;\n\t// Return skStd if no blinded pubkey was provided to verify against\n\tif (!blindPubkey) {\n\t\tif (skStd === 0n) throw new Error('Derived secret key is zero');\n\t\treturn numberToHexPadded64(skStd);\n\t}\n\tif (blindPubkey.length !== 33) throw new Error('blindPubkey must be 33 bytes');\n\t// Decode Pâ€², compute R and unblind\n\tconst P_ = secp256k1.Point.fromHex(bytesToHex(blindPubkey)); // valid point\n\tconst R = secp256k1.Point.BASE.multiply(r); // R = rÂ·G\n\tconst P = P_.subtract(R); // P = P_ - R\n\tif (P.equals(secp256k1.Point.ZERO)) return null;\n\t// Check x only equality, using constant time compare\n\tconst xP = P.toBytes(true).slice(1);\n\tconst xNaturalPub = naturalPub.slice(1);\n\tif (!Bytes.equals(xP, xNaturalPub)) {\n\t\treturn null; // this P' is not for this privkey\n\t}\n\t// Select by parity, comparing the low bit only\n\tconst yP = P.toBytes(true)[0] & 1;\n\tconst yNaturalPub = naturalPub[0] & 1;\n\tconst out = yP === yNaturalPub ? skStd : skNeg;\n\tif (out === 0n) throw new Error('Derived secret key is zero');\n\treturn numberToHexPadded64(out);\n}\n\n/**\n * Internal helper, derive P2BK blinding tweak using ECDH.\n *\n * @remarks\n * Computes the shared point Z = scalarÂ·point, takes its 32 byte x coordinate Zx, then derives:\n *\n *     ráµ¢ = SHA - 256(P2BK_DST || Zx || keysetId || i); // all inputs as raw bytes\n *\n * If the result reduces to zero, or is >= curve order (n), retries once with an extra 0xff byte\n * appended to the message. Throws if the retry also reduces to zero.\n *\n * This function is symmetric. It can be called with either.\n *\n * - The receiver's private key (p) and the sender's ephemeral public key (E)\n * - The sender's ephemeral secret (e) and the receiver's public key (P)\n *\n * Both yield the same Z and therefore the same r thanks to the magic of ECDH!\n * @param point Ephemeral public key (E) or recipient public key (P)\n * @param scalar Private scalar (p) or ephemeral scalar (e) in [1, n âˆ’ 1]\n * @param keysetId Keyset identifier as raw bytes.\n * @param slotIndex Zero based slot index, only lowest 8 bits (0â€“255) are used.\n * @returns Tweak (r) in [1, n âˆ’ 1]\n * @throws If r reduces to zero after the retry.\n * @experimental\n */\nfunction deriveP2BKBlindingTweakFromECDH(\n\tpoint: WeierstrassPoint<bigint>, // E or P\n\tscalar: bigint, // p or e\n\tkeysetId: Uint8Array, // kid\n\tslotIndex: number, // i\n): bigint {\n\t// Calculate x-only ECDH shared point (Zx)\n\tconst Zx = point.multiply(scalar).toBytes(true).slice(1);\n\tconst iByte = new Uint8Array([slotIndex & 0xff]);\n\t// Derive deterministic blinding factor (r):\n\t// Note: Bytes.toBigInt is safe here because we explicitly guard against\n\t// out-of-range values below, throwing rather than silently normalizing.\n\tlet r = Bytes.toBigInt(sha256(Bytes.concat(P2BK_DST, Zx, keysetId, iByte)));\n\tif (r === 0n || r >= secp256k1.Point.CURVE().n) {\n\t\t// Very unlikely to get here!\n\t\tr = Bytes.toBigInt(sha256(Bytes.concat(P2BK_DST, Zx, keysetId, iByte, new Uint8Array([0xff]))));\n\t\tif (r === 0n || r >= secp256k1.Point.CURVE().n) {\n\t\t\tthrow new Error('P2BK: tweak derivation failed');\n\t\t}\n\t}\n\treturn r;\n}\n","import { bytesToHex, hexToBytes } from '@noble/curves/utils.js';\nimport { schnorr } from '@noble/curves/secp256k1.js';\nimport { type HTLCWitness, type P2PKWitness, type Proof } from '../model/types';\nimport { getValidSigners, schnorrSignMessage, schnorrVerifyMessage, type PrivKey } from './core';\nimport { deriveP2BKSecretKeys } from './NUT26';\nimport { type Logger, NULL_LOGGER } from '../logger';\nimport { type OutputDataLike } from '../model/OutputData';\nimport {\n\tgetTagInt,\n\tgetTagScalar,\n\tgetDataField,\n\tgetTag,\n\tassertSecretKind,\n\tcreateSecret,\n\ttype Secret,\n\tgetSecretKind,\n} from './NUT10';\n\nexport type SigFlag = 'SIG_INPUTS' | 'SIG_ALL';\n\nexport type LockState = 'PERMANENT' | 'ACTIVE' | 'EXPIRED';\n\nexport type P2PKSpendingPath = 'MAIN' | 'REFUND' | 'UNLOCKED' | 'FAILED';\n\nexport interface P2PKVerificationResult {\n\tsuccess: boolean;\n\tpath: P2PKSpendingPath;\n\tlockState: LockState;\n\trequiredSigners: number;\n\teligibleSigners: number;\n\treceivedSigners: string[]; // hex pubkeys that actually signed\n}\n\n/**\n * @internal\n */\ntype WitnessData = {\n\tpreimage?: string;\n\tsignatures: string[];\n};\n\n// ------------------------------\n// NUT-11 Secrets\n// ------------------------------\n\n/**\n * Create a P2PK secret.\n *\n * @param pubkey - The pubkey to add to Secret.data.\n * @param tags - Optional. Additional P2PK tags.\n */\nexport function createP2PKsecret(pubkey: string, tags?: string[][]): string {\n\treturn createSecret('P2PK', pubkey, tags);\n}\n\n/**\n * Parse a P2PK Secret and validate NUT-10 shape.\n *\n * @param secret - The Proof secret.\n * @returns Secret object.\n * @throws If the JSON is invalid or NUT-10 secret is malformed.\n */\nexport function parseP2PKSecret(secret: string | Secret): Secret;\n/**\n * @deprecated Pass a string or Secret instead.\n */\nexport function parseP2PKSecret(secret: Uint8Array): Secret;\nexport function parseP2PKSecret(secret: string | Uint8Array | Secret): Secret {\n\t// Handle deprecated format\n\tif (secret instanceof Uint8Array) {\n\t\tsecret = new TextDecoder().decode(secret);\n\t}\n\t// HTLC extends P2PK, so we include it in our expected list.\n\treturn assertSecretKind(['P2PK', 'HTLC'], secret);\n}\n\n// ------------------------------\n// Spending Condition Helpers\n// ------------------------------\n\n/**\n * Returns the expected witness public keys from a NUT-11 P2PK secret.\n *\n * @remarks\n * Does not tell you the pathway (Locktime or Refund MultiSig), only the keys that CAN currently\n * sign. If no keys are returned, the proof is unlocked.\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns Array of public keys or empty array.\n * @throws If secret is not P2PK.\n */\nexport function getP2PKExpectedWitnessPubkeys(secretStr: string | Secret): string[] {\n\ttry {\n\t\tconst secret: Secret = parseP2PKSecret(secretStr); // decode JSON once\n\t\tconst lockState: LockState = getP2PKLockState(secret);\n\t\tconst locktimeKeys = getP2PKWitnessPubkeys(secret);\n\t\tconst refundKeys = getP2PKWitnessRefundkeys(secret);\n\n\t\t// Locktime pathway active?\n\t\tif (lockState === 'ACTIVE' || lockState === 'PERMANENT') {\n\t\t\treturn locktimeKeys;\n\t\t}\n\n\t\t// Refund pathway active?\n\t\tif (lockState === 'EXPIRED' && refundKeys.length) {\n\t\t\tconst allKeys = [...locktimeKeys, ...refundKeys];\n\t\t\treturn Array.from(new Set(allKeys));\n\t\t}\n\t} catch {\n\t\t// do nothing\n\t}\n\treturn []; // Unlocked, malformed or expired with no refund keys\n}\n\n/**\n * Returns ALL locktime witnesses from a NUT-11 P2PK secret NB: Does not specify if they are\n * expected to sign - see: getP2PKExpectedWitnessPubkeys()\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns Array of public key(s or empty array.\n * @throws If secret is not P2PK.\n */\nexport function getP2PKWitnessPubkeys(secretStr: string | Secret): string[] {\n\tconst secret = parseP2PKSecret(secretStr); // decode JSON once\n\n\t// Add data field if P2PK\n\tlet data: string = '';\n\tif (getSecretKind(secret) === 'P2PK') {\n\t\tdata = getDataField(secret);\n\t}\n\n\t// Add pubkeys\n\tconst pubkeys = getTag(secret, 'pubkeys') ?? [];\n\tconst allKeys = [data, ...pubkeys].filter(Boolean); // filter empty\n\treturn Array.from(new Set(allKeys)); // unique keys\n}\n\n/**\n * Returns ALL refund witnesses from a NUT-11 P2PK secret NB: Does not specify if they are expected\n * to sign - see: getP2PKExpectedWitnessPubkeys()\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns Array of public keys or empty array.\n * @throws If secret is not P2PK.\n */\nexport function getP2PKWitnessRefundkeys(secretStr: string | Secret): string[] {\n\tconst secret = parseP2PKSecret(secretStr);\n\treturn getTag(secret, 'refund') ?? [];\n}\n\n/**\n * Returns the locktime from a NUT-11 P2PK secret or Infinity if no locktime.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns The locktime unix timestamp or Infinity (permanent lock)\n * @throws If secret is not P2PK.\n */\nexport function getP2PKLocktime(secretStr: string | Secret): number {\n\tconst secret = parseP2PKSecret(secretStr);\n\tconst ts = getTagInt(secret, 'locktime');\n\tif (ts === undefined || !Number.isFinite(ts) || ts <= 0) {\n\t\treturn Infinity;\n\t}\n\treturn ts;\n}\n\n/**\n * Interpret the Secret's locktime relative to a given time.\n *\n * - PERMANENT: no valid locktime tag.\n * - ACTIVE: now < locktime.\n * - EXPIRED: now >= locktime.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @param nowSeconds - Optional. The unix timestamp in seconds (Default: now)\n */\nexport function getP2PKLockState(\n\tsecretStr: Secret | string,\n\tnowSeconds: number = Math.floor(Date.now() / 1000),\n): LockState {\n\tconst secret = parseP2PKSecret(secretStr);\n\tconst locktime = getP2PKLocktime(secret);\n\tif (!Number.isFinite(locktime)) {\n\t\treturn 'PERMANENT';\n\t}\n\treturn nowSeconds < locktime ? 'ACTIVE' : 'EXPIRED';\n}\n\n/**\n * Returns the number of Locktime signatures required for a NUT-11 P2PK secret.\n *\n * @remarks\n * Returns `0` if the proof is unlocked and spendable by anyone (locktime EXPIRED, no refund keys).\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns Number of Locktime signatories (n_sigs) required or `0` if unlocked.\n * @throws If secret is not P2PK.\n */\nexport function getP2PKNSigs(secretStr: string | Secret): number {\n\tconst secret = parseP2PKSecret(secretStr);\n\tconst lockState: LockState = getP2PKLockState(secret);\n\tconst refundKeys = getP2PKWitnessRefundkeys(secret);\n\t// Locking applies except when NO refund keys AND lock is expired\n\tif (!refundKeys.length && lockState === 'EXPIRED') {\n\t\treturn 0; // proof unlocked\n\t}\n\treturn getTagInt(secret, 'n_sigs') ?? 1;\n}\n\n/**\n * Returns the number of Refund signatures required for a NUT-11 P2PK secret.\n *\n * @remarks\n * Returns `0` if the refund lock is currently inactive.\n *\n * Proof may still be locked - use: getP2PKNSigs() to check!\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns Number of Refund signatories (n_sigs_refund) required, or `0` if lock is inactive.\n * @throws If secret is not P2PK.\n */\nexport function getP2PKNSigsRefund(secretStr: string | Secret): number {\n\tconst secret = parseP2PKSecret(secretStr);\n\tconst lockState: LockState = getP2PKLockState(secret);\n\tconst refundKeys = getP2PKWitnessRefundkeys(secret);\n\t// Refund lock applies if there are refund keys AND lock is expired\n\tif (refundKeys.length && lockState === 'EXPIRED') {\n\t\treturn getTagInt(secret, 'n_sigs_refund') ?? 1;\n\t}\n\treturn 0; // refund lock inactive\n}\n\n/**\n * Returns the sigflag from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns The sigflag or 'SIG_INPUTS' (default)\n * @throws If secret is not P2PK.\n */\nexport function getP2PKSigFlag(secretStr: string | Secret): SigFlag {\n\tconst secret = parseP2PKSecret(secretStr);\n\tconst flag = getTagScalar(secret, 'sigflag');\n\treturn flag === 'SIG_ALL' ? 'SIG_ALL' : 'SIG_INPUTS';\n}\n\n/**\n * Gets witness signatures as an array.\n *\n * @param witness From Proof.\n * @returns Array of witness signatures.\n */\nexport function getP2PKWitnessSignatures(witness: Proof['witness']): string[] {\n\treturn parseWitnessData(witness)?.signatures ?? [];\n}\n\n/**\n * Normalise Proof.witness into a WitnessData object.\n *\n * @param witness From Proof.\n * @returns WitnessData object or undefined.\n * @internal\n */\nfunction parseWitnessData(witness: Proof['witness']): WitnessData | undefined {\n\tif (!witness) return undefined;\n\tlet parsed: Partial<HTLCWitness & P2PKWitness>;\n\ttry {\n\t\tparsed =\n\t\t\ttypeof witness === 'string'\n\t\t\t\t? (JSON.parse(witness) as Partial<HTLCWitness & P2PKWitness>)\n\t\t\t\t: witness;\n\t} catch (e) {\n\t\tconsole.error('Failed to parse witness string:', e);\n\t\treturn undefined;\n\t}\n\tconst data: WitnessData = {\n\t\t// always normalise signatures to an array\n\t\tsignatures: parsed.signatures ?? [],\n\t};\n\n\t// Only set preimage if it is a non empty string\n\tif (typeof parsed.preimage === 'string' && parsed.preimage.length > 0) {\n\t\tdata.preimage = parsed.preimage;\n\t}\n\treturn data;\n}\n\n// ------------------------------\n// Signing and Verifying Proofs\n// ------------------------------\n\n/**\n * Signs proofs with provided private key(s) if required.\n *\n * @remarks\n * NB: Will only sign if the proof requires a signature from the key.\n * @param proofs - An array of proofs to sign.\n * @param privateKey - A single private key or array of private keys (hex string or Uint8Array).\n * @param logger - Optional logger (default: NULL_LOGGER)\n * @param message - Optional. The message to sign (for SIG_ALL)\n * @returns Signed proofs.\n * @throws On general errors.\n */\nexport function signP2PKProofs(\n\tproofs: Proof[],\n\tprivateKey: PrivKey | PrivKey[],\n\tlogger: Logger = NULL_LOGGER,\n\tmessage?: string,\n): Proof[] {\n\t// Convert to hex strings for maybeDeriveP2BKPrivateKeys\n\tconst toHex = (k: PrivKey): string => (typeof k === 'string' ? k : bytesToHex(k));\n\tconst privateKeyHex = Array.isArray(privateKey) ? privateKey.map(toHex) : toHex(privateKey);\n\treturn proofs.map((proof, index) => {\n\t\tconst privateKeys: string[] = maybeDeriveP2BKPrivateKeys(privateKeyHex, proof);\n\t\tlet signedProof = proof;\n\t\tfor (const priv of privateKeys) {\n\t\t\ttry {\n\t\t\t\tsignedProof = signP2PKProof(signedProof, priv, message);\n\t\t\t} catch (error: unknown) {\n\t\t\t\t// Log signature failures only - these are not fatal, just informational\n\t\t\t\t// as not all keys will be needed for some proofs (eg P2BK, NIP60 etc)\n\t\t\t\tconst message = error instanceof Error ? error.message : 'Unknown error';\n\t\t\t\tlogger.warn(`Proof #${index + 1}: ${message}`);\n\t\t\t}\n\t\t}\n\t\treturn signedProof;\n\t});\n}\n\n/**\n * Signs a single proof with the provided private key if required.\n *\n * @remarks\n * Will only sign if the proof requires a signature from the key.\n * @param proof - A proof to sign.\n * @param privateKey - A single private key (hex string or Uint8Array).\n * @param message - Optional. The message to sign (for SIG_ALL)\n * @returns Signed proofs.\n * @throws Error if signature is not required or proof is already signed.\n */\nexport function signP2PKProof(proof: Proof, privateKey: PrivKey, message?: string): Proof {\n\tconst secret: Secret = parseP2PKSecret(proof.secret);\n\tmessage = message ?? proof.secret; // default message is secret\n\n\t// Check if the private key is required to sign by checking its\n\t// X-only pubkey (no 02/03 prefix) against the expected witness pubkeys\n\t// NB: Nostr pubkeys prepend 02 by convention, ignoring actual Y-parity\n\tconst privKeyBytes = typeof privateKey === 'string' ? hexToBytes(privateKey) : privateKey;\n\tconst pubkey = bytesToHex(schnorr.getPublicKey(privKeyBytes)); // x-only\n\tconst witnesses = getP2PKExpectedWitnessPubkeys(secret);\n\tif (!witnesses.length || !witnesses.some((w) => w.includes(pubkey))) {\n\t\tthrow new Error(`Signature not required from [02|03]${pubkey}`);\n\t}\n\n\t// Check if the public key has already signed\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\tconst alreadySigned = signatures.some((sig) => {\n\t\treturn schnorrVerifyMessage(sig, message, pubkey);\n\t});\n\n\tif (alreadySigned) {\n\t\tthrow new Error(`Proof already signed by [02|03]${pubkey}`);\n\t}\n\n\t// Add new signature\n\tconst signature = schnorrSignMessage(message, privateKey);\n\tconst witness = parseWitnessData(proof.witness);\n\tconst newWitness: WitnessData = {\n\t\t...(witness && witness.preimage !== undefined ? { preimage: witness.preimage } : {}),\n\t\tsignatures: [...(witness?.signatures ?? []), signature],\n\t};\n\treturn { ...proof, witness: newWitness };\n}\n\n/**\n * Verifies a pubkey has signed a P2PK Proof.\n *\n * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).\n * @param proof - A Cashu proof.\n * @param message - Optional. The message that was signed (for SIG_ALL)\n * @returns True if one of the signatures is theirs, false otherwise.\n */\nexport function hasP2PKSignedProof(pubkey: string, proof: Proof, message?: string): boolean {\n\tif (!proof.witness) {\n\t\treturn false;\n\t}\n\t// Check if message is needed\n\tif (isP2PKSigAll([proof]) && !message) {\n\t\tthrow new Error('Cannot verify a SIG_ALL proof without the message to sign');\n\t}\n\tmessage = message ?? proof.secret; // default message is secret\n\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\t// See if any of the signatures belong to this pubkey. We need to do this\n\t// as Schnorr signatures are non-deterministic (see: signMessage)\n\treturn signatures.some((sig) => {\n\t\treturn schnorrVerifyMessage(sig, message, pubkey);\n\t});\n}\n\n/**\n * Verify P2PK spending conditions for a single input.\n *\n * Two spending paths are available:\n *\n * 1. Normal path: signatures from the main pubkeys (always valid)\n * 2. Refund path: signatures from refund pubkeys (only valid after locktime)\n *\n * In addition, if the lock has expired and no refund keys are present, the proof is considered\n * unlocked and spendable without witness signatures.\n *\n * @remarks\n * Returns a detailed P2PKVerificationResult showing the conditions. If you just want a boolean\n * result, use isP2PKSpendAuthorised().\n * @param proof - The Proof to check.\n * @param logger - Optional logger (default: NULL_LOGGER)\n * @param message - Optional. The message to sign (for SIG_ALL)\n * @returns A P2PKVerificationResult describing the spending outcome.\n * @throws If verification is impossible.\n */\nexport function verifyP2PKSpendingConditions(\n\tproof: Proof,\n\tlogger: Logger = NULL_LOGGER,\n\tmessage?: string,\n): P2PKVerificationResult {\n\t// Check if message is needed\n\tif (isP2PKSigAll([proof]) && !message) {\n\t\tlogger.error('Cannot verify a SIG_ALL proof without the message to sign');\n\t\tthrow new Error('Cannot verify a SIG_ALL proof without the message to sign');\n\t}\n\n\t// Init\n\tmessage = message ?? proof.secret; // default message is proof secret\n\tconst secret: Secret = parseP2PKSecret(proof.secret);\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\tconst lockState: LockState = getP2PKLockState(secret);\n\tconst mainKeys = getP2PKWitnessPubkeys(secret);\n\tconst nsigs = getP2PKNSigs(secret);\n\tconst mainSigners = getValidSigners(signatures, message, mainKeys);\n\tconst resultBase = {\n\t\tsuccess: true,\n\t\tpath: 'MAIN' as P2PKSpendingPath,\n\t\tlockState,\n\t\trequiredSigners: nsigs,\n\t\teligibleSigners: mainKeys.length,\n\t\treceivedSigners: mainSigners,\n\t};\n\tlet result: P2PKVerificationResult = resultBase;\n\n\t// Verify the normal pathway (main pubkeys)\n\tif (mainKeys.length && nsigs > 0 && mainSigners.length >= nsigs) {\n\t\tlogger.debug('Spending condition satisfied via main pubkeys', { result });\n\t\treturn result; // success, MAIN pathway\n\t}\n\n\t// Check locktime status, continue only if expired\n\tif (lockState !== 'EXPIRED') {\n\t\tresult = { ...resultBase, success: false, path: 'FAILED' };\n\t\tlogger.debug('P2PK lock enabled, but threshold not met by main pubkeys', { result });\n\t\treturn result; // failed, MAIN pathway\n\t}\n\n\t// Verify the refund pathway\n\tlogger.debug('P2PK lock expired. Checking refund path.', { lockState });\n\tconst refundKeys = getP2PKWitnessRefundkeys(secret);\n\tif (refundKeys.length) {\n\t\tconst nSigsRefund = getP2PKNSigsRefund(secret);\n\t\tconst refundSigners = getValidSigners(signatures, message, refundKeys);\n\t\tconst refundBase: P2PKVerificationResult = {\n\t\t\t...resultBase,\n\t\t\tpath: 'REFUND',\n\t\t\trequiredSigners: nSigsRefund,\n\t\t\teligibleSigners: refundKeys.length,\n\t\t\treceivedSigners: refundSigners,\n\t\t};\n\t\tif (nSigsRefund > 0 && refundSigners.length >= nSigsRefund) {\n\t\t\tresult = refundBase;\n\t\t\tlogger.debug('Spending condition satisfied via refund pubkeys', { result });\n\t\t\treturn result; // success, REFUND pathway\n\t\t}\n\t\t// Still here?\n\t\tresult = { ...refundBase, success: false, path: 'FAILED' };\n\t\tlogger.debug('Spending threshold not met by refund pubkeys', { result });\n\t\treturn result; // failed, REFUND pathway\n\t}\n\n\t// No spending conditions\n\tresult = { ...resultBase, path: 'UNLOCKED' };\n\tlogger.debug('No refund pubkeys, anyone can spend.', { result });\n\treturn result; // success, UNLOCKED\n}\n\n/**\n * Verify P2PK spending conditions for a single input.\n *\n * @param proof - The Proof to check.\n * @param logger - Optional logger (default: NULL_LOGGER)\n * @param message - Optional. The message to sign (for SIG_ALL)\n * @returns True if the witness threshold was reached, false otherwise.\n * @throws If verification is impossible.\n */\nexport function isP2PKSpendAuthorised(\n\tproof: Proof,\n\tlogger: Logger = NULL_LOGGER,\n\tmessage?: string,\n): boolean {\n\treturn verifyP2PKSpendingConditions(proof, logger, message).success;\n}\n\n// ------------------------------\n// P2BK - Pay To Blinded Key\n// ------------------------------\n\n/**\n * Derives blinded secret keys for a P2BK proof.\n *\n * @remarks\n * Calculates the deterministic blinding factor for each P2PK pubkey (data, pubkeys, refund) and\n * calling our parity-aware derivation.\n * @param privateKey Secret key (or array of secret keys)\n * @param proof The proof.\n * @returns Deduplicated list of derived secret keys (hex, 64 chars)\n * @experimental\n */\nexport function maybeDeriveP2BKPrivateKeys(privateKey: string | string[], proof: Proof): string[] {\n\tconst privs = Array.isArray(privateKey) ? privateKey : [privateKey];\n\tconst Ehex: string | undefined = proof?.p2pk_e;\n\tif (!Ehex) {\n\t\treturn Array.from(new Set(privs));\n\t}\n\t// Extract pubkeys and keyset ID from proof\n\tconst secret = parseP2PKSecret(proof.secret);\n\tconst pubs = [...getP2PKWitnessPubkeys(secret), ...getP2PKWitnessRefundkeys(secret)];\n\tconst kid = proof.id; // keyset id is hex\n\treturn deriveP2BKSecretKeys(Ehex, privs, pubs, kid);\n}\n\n// ------------------------------\n// SIG_ALL Handling\n// ------------------------------\n\n/**\n * Validates SIG_ALL inputs have matching secrets and tags.\n *\n * @param inputs Array of Proofs.\n * @throws If proofs are not valid for SIG_ALL.\n * @internal\n */\nexport function assertSigAllInputs(inputs: Proof[]): void {\n\tif (inputs.length === 0) throw new Error('No proofs');\n\t// Check first proof\n\tconst first = parseP2PKSecret(inputs[0].secret);\n\tif (getP2PKSigFlag(first) !== 'SIG_ALL') throw new Error('First proof is not SIG_ALL');\n\tconst data0 = first[1].data;\n\tconst tags0 = JSON.stringify(first[1].tags ?? []);\n\t// Compare remaining proofs\n\tfor (let i = 1; i < inputs.length; i++) {\n\t\tconst si = parseP2PKSecret(inputs[i].secret);\n\t\tif (si[0] !== first[0]) throw new Error(`Proof #${i + 1} is not ${first[0]}`);\n\t\tif (getP2PKSigFlag(si) !== 'SIG_ALL') throw new Error(`Proof #${i + 1} is not SIG_ALL`);\n\t\tif (si[1].data !== data0) throw new Error('SIG_ALL inputs must share identical Secret.data');\n\t\tif (JSON.stringify(si[1].tags ?? []) !== tags0)\n\t\t\tthrow new Error('SIG_ALL inputs must share identical Secret.tags');\n\t}\n}\n\n/**\n * Message aggregation for SIG_ALL.\n *\n * NOTE: Use `assertSigAllInputs()` to ensure valid message inputs.\n *\n * @remarks\n * Melt transactions MUST include the quoteId.\n * @param inputs Array of Proofs.\n * @param outputs Array of OutputDataLike objects (OutputData, Factory etc).\n * @param quoteId Optional. Quote id for Melt transactions.\n * @internal\n */\nexport function buildP2PKSigAllMessage(\n\tinputs: Proof[],\n\toutputs: OutputDataLike[],\n\tquoteId?: string,\n): string {\n\tconst parts: string[] = [];\n\t// Concat inputs: secret_0 || C_0 ...\n\tfor (const p of inputs) {\n\t\tparts.push(p.secret, p.C);\n\t}\n\t// Concat outputs: amount_0 ||  B_0 ...\n\tfor (const o of outputs) {\n\t\tparts.push(String(o.blindedMessage.amount), o.blindedMessage.B_);\n\t}\n\t// Add quoteId for melts\n\tif (quoteId) {\n\t\tparts.push(quoteId);\n\t}\n\treturn parts.join('');\n}\n\n/**\n * Check if proofs are SIG_ALL.\n *\n * @remarks\n * Returns true if ANY proof has SIG_ALL, false otherwise.\n * @param inputs Array of Proofs.\n * @internal\n */\nexport function isP2PKSigAll(inputs: Proof[]): boolean {\n\treturn inputs.some((p) => {\n\t\ttry {\n\t\t\treturn getP2PKSigFlag(p.secret) === 'SIG_ALL';\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t});\n}\n\n// ------------------------------\n// Deprecated\n// ------------------------------\n\n/**\n * Message aggregation for SIG_ALL (interim format).\n *\n * @remarks\n * Melt transactions MUST include the quoteId.\n * @deprecated - For compatibility with NutShell < v18.2.\n * @internal\n */\nexport function buildInterimP2PKSigAllMessage(\n\tinputs: Proof[],\n\toutputs: OutputDataLike[],\n\tquoteId?: string,\n): string {\n\tconst parts: string[] = [];\n\t// Concat inputs: secret_0 || C_0 ...\n\tfor (const p of inputs) {\n\t\tparts.push(p.secret, p.C);\n\t}\n\t// Concat outputs: amount_0 || id_0 || B_0 ...\n\tfor (const o of outputs) {\n\t\tparts.push(String(o.blindedMessage.amount), o.blindedMessage.id, o.blindedMessage.B_);\n\t}\n\t// Add quoteId for melts\n\tif (quoteId) {\n\t\tparts.push(quoteId);\n\t}\n\treturn parts.join('');\n}\n\n/**\n * Message aggregation for SIG_ALL (legacy format).\n *\n * @remarks\n * Melt transactions MUST include the quoteId.\n * @deprecated - For compatibility with NutShell < v18.0, CDK < v0.14.1.\n * @internal\n */\nexport function buildLegacyP2PKSigAllMessage(\n\tinputs: Proof[],\n\toutputs: OutputDataLike[],\n\tquoteId?: string,\n): string {\n\tconst parts: string[] = [];\n\t// Concat inputs: secret_0 ...\n\tfor (const p of inputs) {\n\t\tparts.push(p.secret);\n\t}\n\t// Concat outputs: B_0 ...\n\tfor (const o of outputs) {\n\t\tparts.push(o.blindedMessage.B_);\n\t}\n\t// Add quoteId for melts\n\tif (quoteId) {\n\t\tparts.push(quoteId);\n\t}\n\treturn parts.join('');\n}\n\n/**\n * @deprecated - Use SecretKind for NUT-10 kinds.\n */\nexport type WellKnownSecret = 'P2PK';\n\n/**\n * Signs a P2PK secret using Schnorr.\n *\n * @deprecated Use {@link schnorrSignMessage}\n */\nexport const signP2PKSecret = (secret: string, privateKey: PrivKey): string => {\n\treturn schnorrSignMessage(secret, privateKey);\n};\n\n/**\n * Verifies a Schnorr signature on a P2PK secret.\n *\n * @deprecated Use {@link schnorrVerifyMessage}\n */\nexport const verifyP2PKSecretSignature = (\n\tsignature: string,\n\tsecret: string,\n\tpubkey: string,\n): boolean => {\n\treturn schnorrVerifyMessage(signature, secret, pubkey);\n};\n\n/**\n * @deprecated - Typo: use {@link getP2PKExpectedWitnessPubkeys} instead.\n */\nexport function getP2PKExpectedKWitnessPubkeys(secretStr: string | Secret): string[] {\n\treturn getP2PKExpectedWitnessPubkeys(secretStr);\n}\n\n/**\n * @deprecated Use {@link isP2PKSpendAuthorised} or {@link verifyP2PKSpendingConditions} instead.\n */\nexport function verifyP2PKSig(proof: Proof): boolean {\n\treturn isP2PKSpendAuthorised(proof);\n}\n","import { type DLEQ, hash_e, hashToCurve, createRandomSecretKey } from './core';\nimport { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass.js';\nimport { numberToBytesBE } from '@noble/curves/utils.js';\nimport { secp256k1 } from '@noble/curves/secp256k1.js';\n\nfunction arraysEqual(arr1: Uint8Array, arr2: Uint8Array) {\n\tif (arr1.length !== arr2.length) return false;\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (arr1[i] !== arr2[i]) return false;\n\t}\n\treturn true;\n}\n\nexport const verifyDLEQProof = (\n\tdleq: DLEQ,\n\tB_: WeierstrassPoint<bigint>,\n\tC_: WeierstrassPoint<bigint>,\n\tA: WeierstrassPoint<bigint>,\n) => {\n\tconst s = secp256k1.Point.Fn.fromBytes(dleq.s);\n\tconst e = secp256k1.Point.Fn.fromBytes(dleq.e);\n\tconst sG = secp256k1.Point.BASE.multiply(s);\n\tconst eA = A.multiply(e);\n\tconst sB_ = B_.multiply(s);\n\tconst eC_ = C_.multiply(e);\n\tconst R_1 = sG.subtract(eA); // R1 = sG - eA\n\tconst R_2 = sB_.subtract(eC_); // R2 = sB' - eC'\n\tconst hash = hash_e([R_1, R_2, A, C_]); // e == hash(R1, R2, A, C')\n\treturn arraysEqual(hash, dleq.e);\n};\n\nexport const verifyDLEQProof_reblind = (\n\tsecret: Uint8Array, // secret\n\tdleq: DLEQ,\n\tC: WeierstrassPoint<bigint>, // unblinded e-cash signature point\n\tA: WeierstrassPoint<bigint>, // mint public key point\n) => {\n\tif (dleq.r === undefined) throw new Error('verifyDLEQProof_reblind: Undefined blinding factor');\n\tconst Y = hashToCurve(secret);\n\tconst C_ = C.add(A.multiply(dleq.r)); // Re-blind the e-cash signature\n\tconst bG = secp256k1.Point.BASE.multiply(dleq.r);\n\tconst B_ = Y.add(bG); // Re-blind the message\n\treturn verifyDLEQProof(dleq, B_, C_, A);\n};\n\n/**\n * !!! WARNING !!! Not recommended for production use, due to non-constant time operations See:\n * https://github.com/cashubtc/cashu-crypto-ts/pull/2 for more details See:\n * https://en.wikipedia.org/wiki/Timing_attack for information about timing attacks.\n */\nexport const createDLEQProof = (B_: WeierstrassPoint<bigint>, a: Uint8Array): DLEQ => {\n\tconst r = secp256k1.Point.Fn.fromBytes(createRandomSecretKey()); // r <- random (Uint8Array)\n\tconst R_1 = secp256k1.Point.BASE.multiply(r); // R1 = rG\n\tconst R_2 = B_.multiply(r); // R2 = rB_\n\tconst scalar_a = secp256k1.Point.Fn.fromBytes(a);\n\tconst C_ = B_.multiply(scalar_a); // C_ = aB_\n\tconst A = secp256k1.Point.BASE.multiply(scalar_a); // A = aG\n\tconst e = hash_e([R_1, R_2, A, C_]); // e = hash(R1, R2, A, C_)\n\tconst scalar_e = secp256k1.Point.Fn.fromBytes(e);\n\t// Use field operations for constant-time addition and multiplication\n\tconst s_scalar = secp256k1.Point.Fn.add(r, secp256k1.Point.Fn.mul(scalar_e, scalar_a));\n\tconst s = numberToBytesBE(s_scalar, 32); // s = (r + e * a) mod n\n\treturn { s, e };\n};\n","import { hmac } from '@noble/hashes/hmac.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { getKeysetIdInt } from './core';\nimport { HDKey } from '@scure/bip32';\nimport { Bytes, isBase64String } from '../utils';\n\nconst STANDARD_DERIVATION_PATH = `m/129372'/0'`;\n\nconst SECP256K1_N = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141');\n\nenum DerivationType {\n\tSECRET = 0,\n\tBLINDING_FACTOR = 1,\n}\n\nexport const deriveSecret = (seed: Uint8Array, keysetId: string, counter: number): Uint8Array => {\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keysetId);\n\tif (!isValidHex && isBase64String(keysetId)) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.SECRET);\n\t}\n\n\tif (isValidHex && keysetId.startsWith('00')) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.SECRET);\n\t} else if (isValidHex && keysetId.startsWith('01')) {\n\t\treturn derive(seed, keysetId, counter, DerivationType.SECRET);\n\t}\n\tthrow new Error(`Unrecognized keyset ID version ${keysetId.slice(0, 2)}`);\n};\n\nexport const deriveBlindingFactor = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n): Uint8Array => {\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keysetId);\n\tif (!isValidHex && isBase64String(keysetId)) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t}\n\n\tif (isValidHex && keysetId.startsWith('00')) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t} else if (isValidHex && keysetId.startsWith('01')) {\n\t\treturn derive(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t}\n\tthrow new Error(`Unrecognized keyset ID version ${keysetId.slice(0, 2)}`);\n};\n\nconst derive = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n\tsecretOrBlinding: DerivationType,\n): Uint8Array => {\n\tlet message = Bytes.concat(\n\t\tBytes.fromString('Cashu_KDF_HMAC_SHA256'),\n\t\tBytes.fromHex(keysetId),\n\t\tBytes.writeBigUint64BE(BigInt(counter)),\n\t);\n\n\tswitch (secretOrBlinding) {\n\t\tcase DerivationType.SECRET:\n\t\t\tmessage = Bytes.concat(message, Bytes.fromHex('00'));\n\t\t\tbreak;\n\t\tcase DerivationType.BLINDING_FACTOR:\n\t\t\tmessage = Bytes.concat(message, Bytes.fromHex('01'));\n\t}\n\n\tconst hmacDigest = hmac(sha256, seed, message);\n\n\tif (secretOrBlinding === DerivationType.BLINDING_FACTOR) {\n\t\tconst x = Bytes.toBigInt(hmacDigest);\n\t\t// Optimization: single subtraction instead of modulo\n\t\t// Probability of HMAC >= SECP256K1_N is ~2^-128\n\t\tif (x >= SECP256K1_N) {\n\t\t\treturn Bytes.fromBigInt(x - SECP256K1_N);\n\t\t}\n\t\tif (x === 0n) {\n\t\t\tthrow new Error('Derived invalid blinding scalar r == 0');\n\t\t}\n\t\treturn hmacDigest;\n\t}\n\n\treturn hmacDigest;\n};\n\nconst derive_deprecated = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n\tsecretOrBlinding: DerivationType,\n): Uint8Array => {\n\tconst hdkey = HDKey.fromMasterSeed(seed);\n\tconst keysetIdInt = getKeysetIdInt(keysetId);\n\tconst derivationPath = `${STANDARD_DERIVATION_PATH}/${keysetIdInt}'/${counter}'/${secretOrBlinding}`;\n\tconst derived = hdkey.derive(derivationPath);\n\tif (derived.privateKey === null) {\n\t\tthrow new Error('Could not derive private key');\n\t}\n\treturn derived.privateKey;\n};\n","import { bytesToHex, hexToBytes, randomBytes } from '@noble/curves/utils.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { type HTLCWitness, type Proof } from '../model/types';\nimport { type Logger, NULL_LOGGER } from '../logger';\nimport { type P2PKVerificationResult, verifyP2PKSpendingConditions } from './NUT11';\nimport {\n\tassertSecretKind,\n\tcreateSecret,\n\ttype Secret,\n\tgetDataField,\n\tparseSecret,\n\tgetSecretKind,\n} from './NUT10';\n\n// ------------------------------\n// NUT-14 Secrets\n// ------------------------------\n\n/**\n * Create an HTLC secret.\n *\n * @remarks\n * Use `createHTLCHash()` for hash creation.\n * @param hash - The HTLC hash to add to Secret.data.\n * @param tags - Optional. Additional P2PK tags.\n */\nexport function createHTLCsecret(hash: string, tags?: string[][]): string {\n\treturn createSecret('HTLC', hash, tags);\n}\n\n/**\n * Parse an HTLC Secret and validate NUT-10 shape.\n *\n * @param secret - The Proof secret.\n * @returns Secret object.\n * @throws If the JSON is invalid or NUT-10 secret is malformed.\n */\nexport function parseHTLCSecret(secret: string | Secret): Secret {\n\treturn assertSecretKind('HTLC', secret);\n}\n\n// ------------------------------\n// Creating and Verifying Hashes\n// ------------------------------\n\n/**\n * Create an HTLC hash/preimage pair.\n *\n * @param preimage - Optional. Preimage to use (Default: random preimage)\n * @returns Hash and preimage pair.\n * @throws If the preimage supplied is not a 64-char hex string.\n */\nexport function createHTLCHash(preimage?: string): { hash: string; preimage: string } {\n\tconst hasPreimage = preimage !== undefined;\n\tif (hasPreimage && !/^[0-9a-f]{64}$/i.test(preimage)) {\n\t\tthrow new Error('Preimage must be a 64 character hexadecimal string (32 bytes).');\n\t}\n\t// Create hash\n\tconst piBytes = hasPreimage ? hexToBytes(preimage) : randomBytes(32);\n\tconst hash = bytesToHex(sha256(piBytes));\n\treturn { hash, preimage: bytesToHex(piBytes) };\n}\n\n/**\n * Verify an HTLC hash/preimage pair.\n *\n * @param preimage - As a 64-character lowercase hexadecimal string.\n * @param hash - As a 64-character lowercase hexadecimal string.\n * @returns True if preimage calculates the same hash, False otherwise.\n */\nexport function verifyHTLCHash(preimage: string, hash: string): boolean {\n\tconst { hash: valid } = createHTLCHash(preimage);\n\treturn hash === valid;\n}\n\n/**\n * Verify HTLC spending conditions for a single input.\n *\n * Two spending paths are available:\n *\n * 1. Hashlock path: Preimage + signatures from the main pubkeys (always valid)\n * 2. Refund path: signatures from refund pubkeys (only valid after locktime)\n *\n * In addition, if the lock has expired and no refund keys are present, the proof is considered\n * unlocked and spendable without witness signatures.\n *\n * @remarks\n * Returns a detailed P2PKVerificationResult showing the conditions. If you just want a boolean\n * result, use isP2PKSpendAuthorised().\n * @param proof - The Proof to check.\n * @param logger - Optional logger (default: NULL_LOGGER)\n * @param message - Optional. The message to sign (for SIG_ALL)\n * @returns A P2PKVerificationResult describing the spending outcome.\n * @throws If verification is impossible.\n */\nexport function verifyHTLCSpendingConditions(\n\tproof: Proof,\n\tlogger: Logger = NULL_LOGGER,\n\tmessage?: string,\n): P2PKVerificationResult {\n\t// Init\n\tlet result: P2PKVerificationResult;\n\tmessage = message ?? proof.secret; // default message is proof secret\n\n\t// Check P2PK locking conditions are satisfied first\n\t// We are only interested in 'MAIN' pathway spends on HTLC proofs\n\tconst secret = parseSecret(proof.secret); // no assert\n\tconst p2pkResult = verifyP2PKSpendingConditions(proof, logger, message);\n\tif (p2pkResult.path != 'MAIN' || getSecretKind(secret) !== 'HTLC') {\n\t\treturn p2pkResult; // not an hashlock spend\n\t}\n\n\t// Ensure proof has a preimage\n\tconst preimage = getHTLCWitnessPreimage(proof.witness);\n\tif (!preimage) {\n\t\tresult = { ...p2pkResult, success: false, path: 'FAILED' };\n\t\tlogger.debug('Hashlock spend failed, no preimage found', { result });\n\t\treturn result;\n\t}\n\n\t// Check preimage and hash correspond if main pathway was used\n\tconst hash = getDataField(secret);\n\tif (verifyHTLCHash(preimage, hash)) {\n\t\tresult = p2pkResult;\n\t\tlogger.debug('Spending condition satisfied via hashlock (receiver) pathway', { result });\n\t\treturn result; // success, MAIN pathway\n\t}\n\n\t// Still here? Bad news...\n\tresult = { ...p2pkResult, success: false, path: 'FAILED' };\n\tlogger.debug('Hashlock spend failed, wrong preimage for hash', { result });\n\treturn result; // failed, wrong preimage\n}\n\n/**\n * Verify HTLC spending conditions for a single input.\n *\n * @param proof - The Proof to check.\n * @param logger - Optional logger (default: NULL_LOGGER)\n * @param message - Optional. The message to sign (for SIG_ALL)\n * @returns True if spending conditions are satisfied, false otherwise.\n * @throws If verification is impossible.\n */\nexport function isHTLCSpendAuthorised(\n\tproof: Proof,\n\tlogger: Logger = NULL_LOGGER,\n\tmessage?: string,\n): boolean {\n\treturn verifyHTLCSpendingConditions(proof, logger, message).success;\n}\n\n/**\n * Get preimage from a witness if present.\n *\n * @param witness From a Proof.\n * @returns Preimage if present.\n */\nexport function getHTLCWitnessPreimage(witness: Proof['witness']): string | undefined {\n\tif (!witness) return undefined;\n\tlet parsed: Partial<HTLCWitness>;\n\ttry {\n\t\tparsed = typeof witness === 'string' ? (JSON.parse(witness) as Partial<HTLCWitness>) : witness;\n\t} catch (e) {\n\t\tconsole.error('Failed to parse HTLC witness string:', e);\n\t\treturn undefined;\n\t}\n\t// Check preimage is a non-empty string\n\tconst preimage = parsed.preimage;\n\treturn typeof preimage === 'string' && preimage.length > 0 ? preimage : undefined;\n}\n","import { schnorr } from '@noble/curves/secp256k1.js';\nimport { type SerializedBlindedMessage } from '../model/types';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\n\nfunction constructMessage(quote: string, blindedMessages: SerializedBlindedMessage[]): Uint8Array {\n\tlet message = quote;\n\tfor (const blindedMessage of blindedMessages) {\n\t\tmessage += blindedMessage.B_;\n\t}\n\tconst msgbytes = new TextEncoder().encode(message);\n\treturn sha256(msgbytes);\n}\n\nexport function signMintQuote(\n\tprivkey: string,\n\tquote: string,\n\tblindedMessages: SerializedBlindedMessage[],\n): string {\n\tconst message = constructMessage(quote, blindedMessages);\n\tconst privkeyBytes = hexToBytes(privkey);\n\tconst signature = schnorr.sign(message, privkeyBytes);\n\treturn bytesToHex(signature);\n}\n\nexport function verifyMintQuoteSignature(\n\tpubkey: string,\n\tquote: string,\n\tblindedMessages: SerializedBlindedMessage[],\n\tsignature: string,\n): boolean {\n\tconst sigbytes = hexToBytes(signature);\n\tlet pubkeyBytes = hexToBytes(pubkey);\n\tif (pubkeyBytes.length !== 33) return false;\n\tpubkeyBytes = pubkeyBytes.slice(1);\n\tconst message = constructMessage(quote, blindedMessages);\n\treturn schnorr.verify(sigbytes, message, pubkeyBytes);\n}\n","import { type Proof } from '../../model/types/proof';\n\nexport type RawTransport = {\n\tt: PaymentRequestTransportType; // type\n\ta: string; // target\n\tg?: string[][]; // tags\n};\n\nexport type RawNUT10Option = {\n\tk: string; // kind\n\td: string; // data\n\tt: string[][]; // tags\n};\n\nexport type RawPaymentRequest = {\n\ti?: string; // id\n\ta?: number; // amount\n\tu?: string; // unit\n\ts?: boolean; // single use\n\tm?: string[]; // mints\n\td?: string; // description\n\tt?: RawTransport[]; // transports\n\tnut10?: RawNUT10Option;\n\tnut26?: boolean; // P2BK\n};\n\nexport type PaymentRequestTransport = {\n\ttype: PaymentRequestTransportType;\n\ttarget: string;\n\ttags?: string[][];\n};\n\nexport enum PaymentRequestTransportType {\n\tPOST = 'post',\n\tNOSTR = 'nostr',\n}\n\nexport type PaymentRequestPayload = {\n\tid?: string;\n\tmemo?: string;\n\tunit: string;\n\tmint: string;\n\tproofs: Proof[];\n};\n\n/**\n * Used to express a spending condition that proofs should be encumbered with.\n */\nexport type NUT10Option = {\n\t/**\n\t * The kind of spending condition.\n\t */\n\tkind: string;\n\t/**\n\t * Expresses the spending condition relative to the kind.\n\t */\n\tdata: string;\n\t/**\n\t * Tags associated with the spending condition for additional data.\n\t */\n\ttags: string[][];\n};\n","import { bech32 } from '@scure/base';\nimport type { PaymentRequestTransport } from '../wallet/types/payment-requests';\nimport { PaymentRequestTransportType } from '../wallet/types/payment-requests';\n\n/**\n * NUT-10 Spending Condition structure.\n */\nexport type Nut10SpendingCondition = {\n\tkind: string;\n\tdata: string;\n\ttags?: string[][];\n};\n\n/**\n * Decoded TLV Payment Request structure.\n */\nexport type DecodedTLVPaymentRequest = {\n\tid?: string;\n\tamount?: bigint;\n\tunit?: string;\n\tsingleUse?: boolean;\n\tmints?: string[];\n\tdescription?: string;\n\ttransports?: PaymentRequestTransport[];\n\tnut10?: Nut10SpendingCondition[];\n};\n\n/**\n * TLV Tag definitions for Payment Request (NUT-18 version B).\n *\n * | Tag  | Field       | Type      | Description                                      |\n * | ---- | ----------- | --------- | ------------------------------------------------ |\n * | 0x01 | id          | string    | Payment identifier                               |\n * | 0x02 | amount      | u64       | Amount in base units                             |\n * | 0x03 | unit        | u8/string | Currency unit (0x00 = 'sat')                     |\n * | 0x04 | single_use  | u8        | Single-use flag: 0=false, 1=true                 |\n * | 0x05 | mint        | string    | Mint URL (repeatable)                            |\n * | 0x06 | description | string    | Human-readable description                       |\n * | 0x07 | transport   | sub-TLV   | Transport configuration (repeatable)             |\n * | 0x08 | nut10       | sub-TLV   | NUT-10 spending conditions (not yet implemented) |\n */\nconst TAG_ID = 0x01;\nconst TAG_AMOUNT = 0x02;\nconst TAG_UNIT = 0x03;\nconst TAG_SINGLE_USE = 0x04;\nconst TAG_MINT = 0x05;\nconst TAG_DESCRIPTION = 0x06;\nconst TAG_TRANSPORT = 0x07;\nconst TAG_NUT10 = 0x08;\n\n/**\n * Transport Sub-TLV Tag definitions.\n *\n * | Sub-Tag | Field     | Type    | Description                                       |\n * | ------- | --------- | ------- | ------------------------------------------------- |\n * | 0x01    | kind      | u8      | Transport type: 0=nostr, 1=http_post              |\n * | 0x02    | target    | bytes   | Transport target (pubkey for nostr, URL for post) |\n * | 0x03    | tag_tuple | sub-TLV | Generic tag tuple (repeatable)                    |\n */\nconst TRANSPORT_TAG_KIND = 0x01;\nconst TRANSPORT_TAG_TARGET = 0x02;\nconst TRANSPORT_TAG_TAG_TUPLE = 0x03;\n\nconst TRANSPORT_KIND_NOSTR = 0;\nconst TRANSPORT_KIND_HTTP_POST = 1;\n\n/**\n * NUT-10 Sub-TLV Tag definitions.\n *\n * | Sub-Tag | Field     | Type        | Description                        |\n * | ------- | --------- | ----------- | ---------------------------------- |\n * | 0x01    | kind      | u8          | Secret kind (0=P2PK, 1=HTLC, etc.) |\n * | 0x02    | data      | bytes       | Kind-specific data (UTF-8 encoded) |\n * | 0x03    | tag_tuple | sub-sub-TLV | Tag tuple (repeatable)             |\n */\nconst NUT10_TAG_KIND = 0x01;\nconst NUT10_TAG_DATA = 0x02;\nconst NUT10_TAG_TAG_TUPLE = 0x03;\n\nconst NUT10_KIND_P2PK = 0;\nconst NUT10_KIND_HTLC = 1;\n\ntype TLVPart = {\n\ttag: number;\n\tlength: number;\n\tvalue: Uint8Array;\n};\n\n/**\n * Decodes a TLV-encoded Payment Request.\n *\n * @param data - The TLV-encoded data as Uint8Array.\n * @returns Decoded payment request object.\n */\nexport function decodeTLV(data: Uint8Array): DecodedTLVPaymentRequest {\n\tconst parts = decodeAllParts(data);\n\tconst result: DecodedTLVPaymentRequest = {};\n\n\tfor (const part of parts) {\n\t\tswitch (part.tag) {\n\t\t\tcase TAG_ID:\n\t\t\t\tresult.id = parseString(part.value);\n\t\t\t\tbreak;\n\t\t\tcase TAG_AMOUNT:\n\t\t\t\tresult.amount = parseU64(part.value);\n\t\t\t\tbreak;\n\t\t\tcase TAG_UNIT:\n\t\t\t\tif (part.value.length === 1 && part.value[0] === 0) {\n\t\t\t\t\tresult.unit = 'sat';\n\t\t\t\t} else {\n\t\t\t\t\tresult.unit = parseString(part.value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TAG_SINGLE_USE:\n\t\t\t\tresult.singleUse = parseU8(part.value) === 1;\n\t\t\t\tbreak;\n\t\t\tcase TAG_MINT:\n\t\t\t\tif (!result.mints) {\n\t\t\t\t\tresult.mints = [];\n\t\t\t\t}\n\t\t\t\tresult.mints.push(parseString(part.value));\n\t\t\t\tbreak;\n\t\t\tcase TAG_DESCRIPTION:\n\t\t\t\tresult.description = parseString(part.value);\n\t\t\t\tbreak;\n\t\t\tcase TAG_TRANSPORT:\n\t\t\t\tif (!result.transports) {\n\t\t\t\t\tresult.transports = [];\n\t\t\t\t}\n\t\t\t\tresult.transports.push(parseTransport(part.value));\n\t\t\t\tbreak;\n\t\t\tcase TAG_NUT10:\n\t\t\t\tif (!result.nut10) {\n\t\t\t\t\tresult.nut10 = [];\n\t\t\t\t}\n\t\t\t\tresult.nut10.push(parseNut10(part.value));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Ignore unknown tags for forward compatibility\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Decodes all TLV parts from the data.\n */\nfunction decodeAllParts(data: Uint8Array): TLVPart[] {\n\tconst parts: TLVPart[] = [];\n\tlet offset = 0;\n\n\twhile (offset < data.length) {\n\t\tconst part = decodeNextPart(data.subarray(offset));\n\t\tparts.push(part);\n\t\t// Tag (1 byte) + Length (2 bytes) + Value\n\t\toffset += 1 + 2 + part.length;\n\t}\n\n\treturn parts;\n}\n\n/**\n * Decodes the next TLV part from the data.\n *\n * Wire format:\n *\n * - Tag: 1 byte (uint8)\n * - Length: 2 bytes (uint16, big-endian)\n * - Value: `length` bytes.\n */\nfunction decodeNextPart(data: Uint8Array): TLVPart {\n\tif (data.length < 3) {\n\t\tthrow new Error('TLV data too short: need at least 3 bytes for tag and length');\n\t}\n\n\tconst dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\tconst tag = dataView.getUint8(0);\n\tconst length = dataView.getUint16(1, false); // big-endian\n\n\tif (data.length < 3 + length) {\n\t\tthrow new Error(`TLV data too short: expected ${3 + length} bytes, got ${data.length}`);\n\t}\n\n\tconst value = data.subarray(3, 3 + length);\n\treturn { tag, length, value };\n}\n\nfunction parseString(value: Uint8Array): string {\n\treturn new TextDecoder().decode(value);\n}\n\nfunction parseU64(value: Uint8Array): bigint {\n\tif (value.length !== 8) {\n\t\tthrow new Error(`Invalid u64: expected 8 bytes, got ${value.length}`);\n\t}\n\treturn new DataView(value.buffer, value.byteOffset, value.byteLength).getBigUint64(0, false);\n}\n\nfunction parseU8(value: Uint8Array): number {\n\tif (value.length !== 1) {\n\t\tthrow new Error(`Invalid u8: expected 1 byte, got ${value.length}`);\n\t}\n\treturn value[0];\n}\n\nfunction transportKindToType(kind: number): PaymentRequestTransportType {\n\tswitch (kind) {\n\t\tcase TRANSPORT_KIND_NOSTR:\n\t\t\treturn 'nostr' as PaymentRequestTransportType;\n\t\tcase TRANSPORT_KIND_HTTP_POST:\n\t\t\treturn 'post' as PaymentRequestTransportType;\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported transport kind: ${kind}`);\n\t}\n}\n\nfunction nut10KindToType(kind: number): string {\n\tswitch (kind) {\n\t\tcase NUT10_KIND_P2PK:\n\t\t\treturn 'P2PK';\n\t\tcase NUT10_KIND_HTLC:\n\t\t\treturn 'HTLC';\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported NUT-10 kind: ${kind}`);\n\t}\n}\n\nfunction parseTransport(value: Uint8Array): PaymentRequestTransport {\n\tconst parts = decodeAllParts(value);\n\n\tlet kind: number | undefined;\n\tlet targetBytes: Uint8Array | undefined;\n\tlet tags: string[][] | undefined;\n\n\tfor (const part of parts) {\n\t\tswitch (part.tag) {\n\t\t\tcase TRANSPORT_TAG_KIND:\n\t\t\t\tkind = parseU8(part.value);\n\t\t\t\tbreak;\n\t\t\tcase TRANSPORT_TAG_TARGET:\n\t\t\t\ttargetBytes = part.value;\n\t\t\t\tbreak;\n\t\t\tcase TRANSPORT_TAG_TAG_TUPLE:\n\t\t\t\tif (!tags) {\n\t\t\t\t\ttags = [];\n\t\t\t\t}\n\t\t\t\ttags.push(parseTagTuple(part.value));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (kind === undefined) {\n\t\tthrow new Error('Transport missing required kind field');\n\t}\n\tif (targetBytes === undefined) {\n\t\tthrow new Error('Transport missing required target field');\n\t}\n\n\t// Parse target based on kind\n\tlet target: string;\n\tif (kind === TRANSPORT_KIND_NOSTR) {\n\t\t// For nostr, encode as nprofile with pubkey and relay URLs from tag tuples (key \"r\")\n\t\tconst relayUrls =\n\t\t\ttags?.filter((tuple) => tuple[0] === 'r').flatMap((tuple) => tuple.slice(1)) ?? [];\n\t\ttarget = encodeNprofile(targetBytes, relayUrls);\n\t\t// Remove relay tags since they're now embedded in the nprofile\n\t\ttags = tags?.filter((tuple) => tuple[0] !== 'r');\n\t} else {\n\t\ttarget = parseString(targetBytes);\n\t}\n\n\t// Return undefined for tags if empty\n\tconst finalTags = tags && tags.length > 0 ? tags : undefined;\n\n\treturn {\n\t\ttype: transportKindToType(kind),\n\t\ttarget,\n\t\ttags: finalTags,\n\t};\n}\n\n/**\n * Parses a NUT-10 spending condition from its TLV value.\n *\n * @param value - The NUT-10 sub-TLV value bytes.\n * @returns Parsed NUT-10 spending condition.\n */\nfunction parseNut10(value: Uint8Array): Nut10SpendingCondition {\n\tconst parts = decodeAllParts(value);\n\n\tlet kindNum: number | undefined;\n\tlet data: string | undefined;\n\tlet tags: string[][] | undefined;\n\n\tfor (const part of parts) {\n\t\tswitch (part.tag) {\n\t\t\tcase NUT10_TAG_KIND:\n\t\t\t\tkindNum = parseU8(part.value);\n\t\t\t\tbreak;\n\t\t\tcase NUT10_TAG_DATA:\n\t\t\t\tdata = parseString(part.value);\n\t\t\t\tbreak;\n\t\t\tcase NUT10_TAG_TAG_TUPLE:\n\t\t\t\tif (!tags) {\n\t\t\t\t\ttags = [];\n\t\t\t\t}\n\t\t\t\ttags.push(parseTagTuple(part.value));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (kindNum === undefined) {\n\t\tthrow new Error('NUT-10 spending condition missing required kind field');\n\t}\n\tif (data === undefined) {\n\t\tthrow new Error('NUT-10 spending condition missing required data field');\n\t}\n\n\t// Return undefined for tags if empty\n\tconst finalTags = tags && tags.length > 0 ? tags : undefined;\n\n\treturn {\n\t\tkind: nut10KindToType(kindNum),\n\t\tdata,\n\t\ttags: finalTags,\n\t};\n}\n\n/**\n * Parses a tag tuple from its TLV value.\n *\n * Tag tuple encoding:\n *\n * 1. Key length (1 byte)\n * 2. Key string (UTF-8)\n * 3. For each value:\n *\n *    - Value length (1 byte)\n *    - Value string (UTF-8)\n *\n * @param value - The tag tuple value bytes.\n * @returns Array of strings representing the tuple [key, value1, value2, ...].\n */\nfunction parseTagTuple(value: Uint8Array): string[] {\n\tconst tuple: string[] = [];\n\tlet offset = 0;\n\n\twhile (offset < value.length) {\n\t\tconst length = value[offset];\n\t\toffset += 1;\n\n\t\tif (value.length - offset < length) {\n\t\t\tthrow new Error(\n\t\t\t\t`Tag tuple data too short: expected ${length} bytes, got ${value.length - offset}`,\n\t\t\t);\n\t\t}\n\n\t\tconst str = parseString(value.subarray(offset, offset + length));\n\t\ttuple.push(str);\n\t\toffset += length;\n\t}\n\n\treturn tuple;\n}\n\n/**\n * Encodes a Payment Request into TLV format.\n *\n * @param request - The payment request object to encode.\n * @returns TLV-encoded data as Uint8Array.\n */\nexport function encodeTLV(request: DecodedTLVPaymentRequest): Uint8Array {\n\tconst parts: Uint8Array[] = [];\n\n\t// Encode fields in sequential tag order\n\tif (request.id) {\n\t\tparts.push(encodeTLVPart(TAG_ID, encodeString(request.id)));\n\t}\n\n\tif (request.amount !== undefined) {\n\t\tparts.push(encodeTLVPart(TAG_AMOUNT, encodeU64(request.amount)));\n\t}\n\n\tif (request.unit) {\n\t\tif (request.unit === 'sat') {\n\t\t\tparts.push(encodeTLVPart(TAG_UNIT, new Uint8Array([0x00])));\n\t\t} else {\n\t\t\tparts.push(encodeTLVPart(TAG_UNIT, encodeString(request.unit)));\n\t\t}\n\t}\n\n\tif (request.singleUse !== undefined) {\n\t\tparts.push(encodeTLVPart(TAG_SINGLE_USE, encodeU8(request.singleUse ? 1 : 0)));\n\t}\n\n\t// Repeatable: mint\n\tif (request.mints && request.mints.length > 0) {\n\t\tfor (const mint of request.mints) {\n\t\t\tparts.push(encodeTLVPart(TAG_MINT, encodeString(mint)));\n\t\t}\n\t}\n\n\tif (request.description) {\n\t\tparts.push(encodeTLVPart(TAG_DESCRIPTION, encodeString(request.description)));\n\t}\n\n\t// Repeatable: transport\n\tif (request.transports && request.transports.length > 0) {\n\t\tfor (const transport of request.transports) {\n\t\t\tparts.push(encodeTLVPart(TAG_TRANSPORT, encodeTransport(transport)));\n\t\t}\n\t}\n\n\t// Repeatable: nut10\n\tif (request.nut10 && request.nut10.length > 0) {\n\t\tfor (const nut10 of request.nut10) {\n\t\t\tparts.push(encodeTLVPart(TAG_NUT10, encodeNut10(nut10)));\n\t\t}\n\t}\n\n\t// Concatenate all parts\n\tconst totalLength = parts.reduce((sum, part) => sum + part.length, 0);\n\tconst result = new Uint8Array(totalLength);\n\tlet offset = 0;\n\tfor (const part of parts) {\n\t\tresult.set(part, offset);\n\t\toffset += part.length;\n\t}\n\n\treturn result;\n}\n\n/**\n * Encodes a single TLV part.\n *\n * @param tag - The tag byte.\n * @param value - The value bytes.\n * @returns Encoded TLV part (tag + length + value).\n */\nfunction encodeTLVPart(tag: number, value: Uint8Array): Uint8Array {\n\tconst length = value.length;\n\tif (length > 0xffff) {\n\t\tthrow new Error(`TLV value too long: ${length} bytes (max 65535)`);\n\t}\n\n\tconst result = new Uint8Array(3 + length);\n\tresult[0] = tag;\n\t// Write length as big-endian uint16\n\tresult[1] = (length >> 8) & 0xff;\n\tresult[2] = length & 0xff;\n\tresult.set(value, 3);\n\n\treturn result;\n}\n\nfunction encodeString(str: string): Uint8Array {\n\treturn new TextEncoder().encode(str);\n}\n\nfunction encodeU64(value: bigint): Uint8Array {\n\tconst buffer = new ArrayBuffer(8);\n\tconst view = new DataView(buffer);\n\tview.setBigUint64(0, value, false); // big-endian\n\treturn new Uint8Array(buffer);\n}\n\nfunction encodeU8(value: number): Uint8Array {\n\treturn new Uint8Array([value]);\n}\n\nfunction transportTypeToKind(type: PaymentRequestTransportType): number {\n\tswitch (type) {\n\t\tcase PaymentRequestTransportType.NOSTR:\n\t\t\treturn TRANSPORT_KIND_NOSTR;\n\t\tcase PaymentRequestTransportType.POST:\n\t\t\treturn TRANSPORT_KIND_HTTP_POST;\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported transport type: ${type as string}`);\n\t}\n}\n\nfunction nut10TypeToKind(type: string): number {\n\tswitch (type) {\n\t\tcase 'P2PK':\n\t\t\treturn NUT10_KIND_P2PK;\n\t\tcase 'HTLC':\n\t\t\treturn NUT10_KIND_HTLC;\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported NUT-10 type: ${type}`);\n\t}\n}\n\n/**\n * Encodes a transport into its TLV sub-structure.\n *\n * @param transport - The transport to encode.\n * @returns Encoded transport sub-TLV.\n */\nfunction encodeTransport(transport: PaymentRequestTransport): Uint8Array {\n\tconst parts: Uint8Array[] = [];\n\tconst kind = transportTypeToKind(transport.type);\n\n\t// Encode kind\n\tparts.push(encodeTLVPart(TRANSPORT_TAG_KIND, encodeU8(kind)));\n\n\t// Handle target based on transport type\n\tlet targetBytes: Uint8Array;\n\tlet relayTags: string[][] = [];\n\n\tif (transport.type === PaymentRequestTransportType.NOSTR) {\n\t\t// Decode nprofile to extract pubkey and relays\n\t\tconst { pubkey, relays } = decodeNprofile(transport.target);\n\t\ttargetBytes = pubkey;\n\t\t// Create relay tags\n\t\trelayTags = relays.map((relay) => ['r', relay]);\n\t} else {\n\t\ttargetBytes = encodeString(transport.target);\n\t}\n\n\t// Encode target\n\tparts.push(encodeTLVPart(TRANSPORT_TAG_TARGET, targetBytes));\n\n\t// Merge relay tags with existing tags (for nostr) and encode\n\tconst allTags = [...relayTags, ...(transport.tags || [])];\n\tif (allTags.length > 0) {\n\t\tfor (const tag of allTags) {\n\t\t\tparts.push(encodeTLVPart(TRANSPORT_TAG_TAG_TUPLE, encodeTagTuple(tag)));\n\t\t}\n\t}\n\n\t// Concatenate all sub-parts\n\tconst totalLength = parts.reduce((sum, part) => sum + part.length, 0);\n\tconst result = new Uint8Array(totalLength);\n\tlet offset = 0;\n\tfor (const part of parts) {\n\t\tresult.set(part, offset);\n\t\toffset += part.length;\n\t}\n\n\treturn result;\n}\n\n/**\n * Encodes a NUT-10 spending condition into its TLV sub-structure.\n *\n * @param nut10 - The NUT-10 spending condition to encode.\n * @returns Encoded NUT-10 sub-TLV.\n */\nfunction encodeNut10(nut10: Nut10SpendingCondition): Uint8Array {\n\tconst parts: Uint8Array[] = [];\n\tconst kind = nut10TypeToKind(nut10.kind);\n\n\t// Encode kind\n\tparts.push(encodeTLVPart(NUT10_TAG_KIND, encodeU8(kind)));\n\n\t// Encode data\n\tparts.push(encodeTLVPart(NUT10_TAG_DATA, encodeString(nut10.data)));\n\n\t// Encode tags if present\n\tif (nut10.tags && nut10.tags.length > 0) {\n\t\tfor (const tag of nut10.tags) {\n\t\t\tparts.push(encodeTLVPart(NUT10_TAG_TAG_TUPLE, encodeTagTuple(tag)));\n\t\t}\n\t}\n\n\t// Concatenate all sub-parts\n\tconst totalLength = parts.reduce((sum, part) => sum + part.length, 0);\n\tconst result = new Uint8Array(totalLength);\n\tlet offset = 0;\n\tfor (const part of parts) {\n\t\tresult.set(part, offset);\n\t\toffset += part.length;\n\t}\n\n\treturn result;\n}\n\n/**\n * Encodes a tag tuple into its TLV value format.\n *\n * @param tuple - Array of strings [key, value1, value2, ...].\n * @returns Encoded tag tuple.\n */\nfunction encodeTagTuple(tuple: string[]): Uint8Array {\n\tconst encoder = new TextEncoder();\n\tconst parts: Uint8Array[] = [];\n\n\tfor (const str of tuple) {\n\t\tconst encoded = encoder.encode(str);\n\t\tif (encoded.length > 255) {\n\t\t\tthrow new Error(`Tag tuple string too long: ${str} (max 255 bytes)`);\n\t\t}\n\t\t// 1-byte length prefix + string bytes\n\t\tconst part = new Uint8Array(1 + encoded.length);\n\t\tpart[0] = encoded.length;\n\t\tpart.set(encoded, 1);\n\t\tparts.push(part);\n\t}\n\n\t// Concatenate all parts\n\tconst totalLength = parts.reduce((sum, part) => sum + part.length, 0);\n\tconst result = new Uint8Array(totalLength);\n\tlet offset = 0;\n\tfor (const part of parts) {\n\t\tresult.set(part, offset);\n\t\toffset += part.length;\n\t}\n\n\treturn result;\n}\n\n/**\n * Decodes an nprofile string to extract the pubkey and relay URLs.\n *\n * @param nprofile - Bech32m encoded nprofile string.\n * @returns Object containing pubkey (32 bytes) and array of relay URLs.\n */\nexport function decodeNprofile(nprofile: string): { pubkey: Uint8Array; relays: string[] } {\n\t// Decode bech32m\n\tconst decoded = bech32.decode(nprofile as `${string}1${string}`, 1024);\n\tif (decoded.prefix !== 'nprofile') {\n\t\tthrow new Error(`Invalid nprofile: expected prefix 'nprofile', got '${decoded.prefix}'`);\n\t}\n\n\tconst tlvData = bech32.fromWords(decoded.words);\n\tconst data = new Uint8Array(tlvData);\n\n\t// Parse TLV structure (1-byte T, 1-byte L format)\n\tlet pubkey: Uint8Array | undefined;\n\tconst relays: string[] = [];\n\tlet offset = 0;\n\n\twhile (offset < data.length) {\n\t\tif (offset + 2 > data.length) {\n\t\t\tthrow new Error('Nprofile TLV data too short');\n\t\t}\n\n\t\tconst tag = data[offset];\n\t\tconst length = data[offset + 1];\n\t\toffset += 2;\n\n\t\tif (offset + length > data.length) {\n\t\t\tthrow new Error(`Nprofile TLV value too short: expected ${length} bytes`);\n\t\t}\n\n\t\tconst value = data.subarray(offset, offset + length);\n\t\toffset += length;\n\n\t\tif (tag === 0x00) {\n\t\t\t// Pubkey\n\t\t\tif (value.length !== 32) {\n\t\t\t\tthrow new Error(`Invalid pubkey length: expected 32 bytes, got ${value.length}`);\n\t\t\t}\n\t\t\tpubkey = value;\n\t\t} else if (tag === 0x01) {\n\t\t\t// Relay URL\n\t\t\trelays.push(new TextDecoder().decode(value));\n\t\t}\n\t\t// Ignore unknown tags\n\t}\n\n\tif (!pubkey) {\n\t\tthrow new Error('Nprofile missing required pubkey');\n\t}\n\n\treturn { pubkey, relays };\n}\n\n/**\n * Encodes a 32-byte public key and a list of relay URLs into a bech32m encoded string.\n *\n * @param pubkey - 32-byte public key as Uint8Array.\n * @param relays - Array of relay URLs.\n * @returns Bech32m encoded string.\n */\nexport function encodeNprofile(pubkey: Uint8Array, relays: string[]): string {\n\tconst tlv = encodePubkeyRelaysTLV(pubkey, relays);\n\tconst words = bech32.toWords(tlv);\n\treturn bech32.encode('nprofile', words, 1024);\n}\n\n/**\n * Encodes a 32-byte public key and a list of relay URLs into a TLV structure.\n *\n * Wire format (1-byte T, 1-byte L):\n *\n * - T=0x00: 32-byte public key.\n * - T=0x01: relay URL (repeatable)\n *\n * @param pubkey - 32-byte public key as Uint8Array.\n * @param relays - Array of relay URLs.\n * @returns TLV-encoded Uint8Array.\n */\nfunction encodePubkeyRelaysTLV(pubkey: Uint8Array, relays: string[]): Uint8Array {\n\tif (pubkey.length !== 32) {\n\t\tthrow new Error(`Invalid pubkey: expected 32 bytes, got ${pubkey.length}`);\n\t}\n\n\tconst encoder = new TextEncoder();\n\tconst encodedRelays = relays.map((relay) => encoder.encode(relay));\n\n\t// Validate relay lengths fit in 1 byte\n\tfor (let i = 0; i < encodedRelays.length; i++) {\n\t\tif (encodedRelays[i].length > 255) {\n\t\t\tthrow new Error(`Relay URL too long: ${relays[i]} (max 255 bytes)`);\n\t\t}\n\t}\n\n\t// Calculate total size: pubkey (1 + 1 + 32) + relays (1 + 1 + len each)\n\tconst totalSize = 2 + 32 + encodedRelays.reduce((sum, r) => sum + 2 + r.length, 0);\n\tconst result = new Uint8Array(totalSize);\n\n\tlet offset = 0;\n\n\t// Write pubkey: T=0x00, L=32, V=<32 bytes>\n\tresult[offset++] = 0x00;\n\tresult[offset++] = 32;\n\tresult.set(pubkey, offset);\n\toffset += 32;\n\n\t// Write each relay: T=0x01, L=<len>, V=<UTF-8 string>\n\tfor (const relay of encodedRelays) {\n\t\tresult[offset++] = 0x01;\n\t\tresult[offset++] = relay.length;\n\t\tresult.set(relay, offset);\n\t\toffset += relay.length;\n\t}\n\n\treturn result;\n}\n","import { encodeBase64toUint8, decodeCBOR, encodeCBOR, Bytes } from '../utils';\nimport { decodeBech32mToBytes, encodeBech32m } from '../utils/bech32m';\nimport { decodeTLV, encodeTLV } from '../utils/tlv';\nimport type { DecodedTLVPaymentRequest, Nut10SpendingCondition } from '../utils/tlv';\nimport type {\n\tRawPaymentRequest,\n\tRawTransport,\n\tNUT10Option,\n\tPaymentRequestTransport,\n\tPaymentRequestTransportType,\n} from '../wallet/types';\n\nexport class PaymentRequest {\n\tconstructor(\n\t\tpublic transport?: PaymentRequestTransport[],\n\t\tpublic id?: string,\n\t\tpublic amount?: number,\n\t\tpublic unit?: string,\n\t\tpublic mints?: string[],\n\t\tpublic description?: string,\n\t\tpublic singleUse: boolean = false,\n\t\tpublic nut10?: NUT10Option,\n\t\tpublic nut26: boolean = false,\n\t) {}\n\n\ttoRawRequest() {\n\t\tconst rawRequest: RawPaymentRequest = {};\n\t\tif (this.transport) {\n\t\t\trawRequest.t = this.transport.map((t: PaymentRequestTransport) => ({\n\t\t\t\tt: t.type,\n\t\t\t\ta: t.target,\n\t\t\t\tg: t.tags,\n\t\t\t}));\n\t\t}\n\t\tif (this.id) {\n\t\t\trawRequest.i = this.id;\n\t\t}\n\t\tif (this.amount) {\n\t\t\trawRequest.a = this.amount;\n\t\t}\n\t\tif (this.unit) {\n\t\t\trawRequest.u = this.unit;\n\t\t}\n\t\tif (this.mints) {\n\t\t\trawRequest.m = this.mints;\n\t\t}\n\t\tif (this.description) {\n\t\t\trawRequest.d = this.description;\n\t\t}\n\t\tif (this.singleUse) {\n\t\t\trawRequest.s = this.singleUse;\n\t\t}\n\t\tif (this.nut10) {\n\t\t\trawRequest.nut10 = {\n\t\t\t\tk: this.nut10.kind,\n\t\t\t\td: this.nut10.data,\n\t\t\t\tt: this.nut10.tags,\n\t\t\t};\n\t\t}\n\t\tif (this.nut26) {\n\t\t\trawRequest.nut26 = this.nut26;\n\t\t}\n\t\treturn rawRequest;\n\t}\n\n\ttoEncodedRequest(): string {\n\t\tconst rawRequest: RawPaymentRequest = this.toRawRequest();\n\t\tconst data = encodeCBOR(rawRequest);\n\t\tconst encodedData = Bytes.toBase64(data);\n\t\treturn 'creq' + 'A' + encodedData;\n\t}\n\n\t/**\n\t * Encodes the payment request to creqA format (CBOR).\n\t *\n\t * @returns A base64 encoded payment request string with 'creqA' prefix.\n\t */\n\ttoEncodedCreqA(): string {\n\t\treturn this.toEncodedRequest();\n\t}\n\n\t/**\n\t * Encodes the payment request to creqB format (TLV + bech32m).\n\t *\n\t * @returns A bech32m encoded payment request string with 'CREQB' prefix.\n\t * @experimental\n\t */\n\ttoEncodedCreqB(): string {\n\t\tconst tlvRequest: DecodedTLVPaymentRequest = {\n\t\t\tid: this.id,\n\t\t\tamount: this.amount !== undefined ? BigInt(this.amount) : undefined,\n\t\t\tunit: this.unit,\n\t\t\tsingleUse: this.singleUse,\n\t\t\tmints: this.mints,\n\t\t\tdescription: this.description,\n\t\t\ttransports: this.transport,\n\t\t\tnut10: this.nut10\n\t\t\t\t? [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkind: this.nut10.kind,\n\t\t\t\t\t\t\tdata: this.nut10.data,\n\t\t\t\t\t\t\ttags: this.nut10.tags,\n\t\t\t\t\t\t} as Nut10SpendingCondition,\n\t\t\t\t\t]\n\t\t\t\t: undefined,\n\t\t};\n\n\t\tconst tlvBytes = encodeTLV(tlvRequest);\n\t\treturn encodeBech32m('creqb', tlvBytes).toUpperCase();\n\t}\n\n\tgetTransport(type: PaymentRequestTransportType) {\n\t\treturn this.transport?.find((t: PaymentRequestTransport) => t.type === type);\n\t}\n\n\t/**\n\t * Creates a PaymentRequest from a raw payment request. Supports both creqA and creqB versions.\n\t *\n\t * @param rawPaymentRequest - The raw payment request string to create a PaymentRequest from.\n\t * @returns A PaymentRequest object.\n\t * @throws An error if the raw payment request is not supported.\n\t */\n\tstatic fromRawRequest(rawPaymentRequest: RawPaymentRequest): PaymentRequest {\n\t\tconst transports = rawPaymentRequest.t\n\t\t\t? rawPaymentRequest.t.map((t: RawTransport) => ({\n\t\t\t\t\ttype: t.t,\n\t\t\t\t\ttarget: t.a,\n\t\t\t\t\ttags: t.g,\n\t\t\t\t}))\n\t\t\t: undefined;\n\t\tconst nut10 = rawPaymentRequest.nut10\n\t\t\t? {\n\t\t\t\t\tkind: rawPaymentRequest.nut10.k,\n\t\t\t\t\tdata: rawPaymentRequest.nut10.d,\n\t\t\t\t\ttags: rawPaymentRequest.nut10.t,\n\t\t\t\t}\n\t\t\t: undefined;\n\t\treturn new PaymentRequest(\n\t\t\ttransports,\n\t\t\trawPaymentRequest.i,\n\t\t\trawPaymentRequest.a,\n\t\t\trawPaymentRequest.u,\n\t\t\trawPaymentRequest.m,\n\t\t\trawPaymentRequest.d,\n\t\t\trawPaymentRequest.s,\n\t\t\tnut10,\n\t\t\trawPaymentRequest.nut26,\n\t\t);\n\t}\n\n\tstatic fromEncodedRequest(encodedRequest: string): PaymentRequest {\n\t\tconst lowerRequest = encodedRequest.toLowerCase();\n\n\t\t// Version B: bech32m + TLV encoding (creqb...)\n\t\tif (lowerRequest.startsWith('creqb')) {\n\t\t\tconst data = decodeBech32mToBytes(lowerRequest);\n\t\t\tconst decoded = decodeTLV(data);\n\t\t\treturn new PaymentRequest(\n\t\t\t\tdecoded.transports,\n\t\t\t\tdecoded.id,\n\t\t\t\tdecoded.amount !== undefined ? Number(decoded.amount) : undefined,\n\t\t\t\tdecoded.unit,\n\t\t\t\tdecoded.mints,\n\t\t\t\tdecoded.description,\n\t\t\t\tdecoded.singleUse ?? false,\n\t\t\t\tundefined,\n\t\t\t\tfalse,\n\t\t\t);\n\t\t}\n\n\t\t// Version A: CBOR encoding (creqA...)\n\t\tif (!encodedRequest.startsWith('creq')) {\n\t\t\tthrow new Error('unsupported pr: invalid prefix');\n\t\t}\n\t\tconst version = encodedRequest[4];\n\t\tif (version !== 'A') {\n\t\t\tthrow new Error('unsupported pr version');\n\t\t}\n\t\tconst encodedData = encodedRequest.slice(5);\n\t\tconst data = encodeBase64toUint8(encodedData);\n\t\tconst decoded = decodeCBOR(data) as RawPaymentRequest;\n\t\treturn this.fromRawRequest(decoded);\n\t}\n}\n","import { type DLEQ, pointFromHex, verifyDLEQProof_reblind } from '../crypto';\nimport { bytesToHex, hexToBytes } from '@noble/curves/utils.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport {\n\tencodeBase64ToJson,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeUint8toBase64Url,\n\tisBase64String,\n} from './base64';\nimport { decodeCBOR, encodeCBOR } from './cbor';\nimport { PaymentRequest } from '../model/PaymentRequest';\nimport type {\n\tTokenMetadata,\n\tDeprecatedToken,\n\tKeys,\n\tMintKeys,\n\tProof,\n\tSerializedDLEQ,\n\tToken,\n\tTokenV4Template,\n\tV4DLEQTemplate,\n\tV4InnerToken,\n\tV4ProofTemplate,\n\tHasKeysetKeys,\n\tHasKeysetId,\n} from '../model/types';\nimport { Bytes } from './Bytes';\n\n/**\n * Splits the amount into denominations of the provided keyset.\n *\n * @remarks\n * Partial splits will be filled up to value using minimum splits required. Sorting is only applied\n * if a fill was made - exact custom splits are always returned in the same order.\n * @param value Amount to split.\n * @param keyset Keys to look up split amounts.\n * @param split? Optional custom split amounts.\n * @param order? Optional order for split amounts (if fill was required)\n * @returns Array of split amounts.\n * @throws Error if split sum is greater than value or mint does not have keys for requested split.\n */\nexport function splitAmount(\n\tvalue: number,\n\tkeyset: Keys,\n\tsplit?: number[],\n\torder?: 'desc' | 'asc',\n): number[] {\n\tif (split) {\n\t\tconst totalSplitAmount = sumArray(split);\n\n\t\t// Special case: explicit \"zero-total\" outputs (restore or NUT-08 blanks)\n\t\tif (value === 0 && totalSplitAmount === 0) {\n\t\t\treturn split;\n\t\t}\n\n\t\t// Normal positive-value paths: ignore zeros for validation and totals\n\t\tconst positive = split.filter((amt) => amt > 0);\n\t\tconst totalPositive = sumArray(positive);\n\t\tif (totalPositive > value) {\n\t\t\tthrow new Error(`Split is greater than total amount: ${totalPositive} > ${value}`);\n\t\t}\n\t\tif (positive.some((amt) => !hasCorrespondingKey(amt, keyset))) {\n\t\t\tthrow new Error('Provided amount preferences do not match the amounts of the mint keyset.');\n\t\t}\n\n\t\t// if caller supplied an exact custom split, preserve their order\n\t\tif (totalPositive === value) {\n\t\t\treturn positive;\n\t\t}\n\n\t\t// Work only with validated positive amounts from here on\n\t\tsplit = positive;\n\t\tvalue -= totalPositive;\n\t} else {\n\t\tsplit = [];\n\t}\n\n\t// Denomination fill for the remaining value\n\tconst sortedKeyAmounts = getKeysetAmounts(keyset, 'desc');\n\tif (!sortedKeyAmounts || sortedKeyAmounts.length === 0) {\n\t\tthrow new Error('Cannot split amount, keyset is inactive or contains no keys');\n\t}\n\tfor (const amt of sortedKeyAmounts) {\n\t\tif (amt <= 0) continue;\n\t\t// Calculate how many of amt fit into remaining value\n\t\tconst requireCount = Math.floor(value / amt);\n\t\t// Add them to the split and reduce the target value by added amounts\n\t\tsplit.push(...Array<number>(requireCount).fill(amt));\n\t\tvalue -= amt * requireCount;\n\t\t// Break early once target is satisfied\n\t\tif (value === 0) break;\n\t}\n\tif (value !== 0) {\n\t\tthrow new Error(`Unable to split remaining amount: ${value}`);\n\t}\n\n\t// Only sort when we performed a fill and it was requested\n\t// Exact custom splits were returned unsorted earlier\n\tif (order) {\n\t\treturn split.sort((a, b) => (order === 'desc' ? b - a : a - b));\n\t}\n\treturn split;\n}\n\n/**\n * Creates a list of amounts to keep based on the proofs we have and the proofs we want to reach.\n *\n * @param proofsWeHave Complete set of proofs stored (from current mint)\n * @param amountToKeep Amount to keep.\n * @param keys Keys of current keyset.\n * @param targetCount The target number of proofs to reach.\n * @returns An array of amounts to keep.\n */\nexport function getKeepAmounts(\n\tproofsWeHave: Proof[],\n\tamountToKeep: number,\n\tkeys: Keys,\n\ttargetCount: number,\n): number[] {\n\t// determines amounts we need to reach the targetCount for each amount based on the amounts of the proofs we have\n\t// it tries to select amounts so that the proofs we have and the proofs we want reach the targetCount\n\tconst amountsWeWant: number[] = [];\n\tconst amountsWeHave = proofsWeHave.map((p: Proof) => p.amount);\n\tconst sortedKeyAmounts = getKeysetAmounts(keys, 'asc');\n\tsortedKeyAmounts.forEach((amt) => {\n\t\tconst countWeHave = amountsWeHave.filter((a) => a === amt).length;\n\t\tconst countWeWant = Math.max(targetCount - countWeHave, 0);\n\t\tfor (let i = 0; i < countWeWant; ++i) {\n\t\t\tif (amountsWeWant.reduce((a, b) => a + b, 0) + amt > amountToKeep) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tamountsWeWant.push(amt);\n\t\t}\n\t});\n\t// use splitAmount to fill the rest between the sum of amountsWeHave and amountToKeep\n\tconst amountDiff = amountToKeep - amountsWeWant.reduce((a, b) => a + b, 0);\n\tif (amountDiff) {\n\t\tconst remainingAmounts = splitAmount(amountDiff, keys);\n\t\tremainingAmounts.forEach((amt: number) => {\n\t\t\tamountsWeWant.push(amt);\n\t\t});\n\t}\n\treturn amountsWeWant.sort((a, b) => a - b);\n}\n/**\n * Returns the amounts in the keyset sorted by the order specified.\n *\n * @param keyset To search in.\n * @param order Order to sort the amounts in.\n * @returns The amounts in the keyset sorted by the order specified.\n */\nexport function getKeysetAmounts(keyset: Keys, order: 'asc' | 'desc' = 'desc'): number[] {\n\tif (order == 'desc') {\n\t\treturn Object.keys(keyset)\n\t\t\t.map((k: string) => parseInt(k))\n\t\t\t.sort((a: number, b: number) => b - a);\n\t}\n\treturn Object.keys(keyset)\n\t\t.map((k: string) => parseInt(k))\n\t\t.sort((a: number, b: number) => a - b);\n}\n\n/**\n * Checks if the provided amount is in the keyset.\n *\n * @param amount Amount to check.\n * @param keyset To search in.\n * @returns True if the amount is in the keyset, false otherwise.\n */\nexport function hasCorrespondingKey(amount: number, keyset: Keys): boolean {\n\treturn amount in keyset;\n}\n\n/**\n * Converts a bytes array to a number.\n *\n * @deprecated We now use Bytes.toBigInt internally for better performance. This function is kept\n *   public for backward compatibility.\n * @param bytes To convert to number.\n * @returns Number as bigint.\n */\nexport function bytesToNumber(bytes: Uint8Array): bigint {\n\treturn Bytes.toBigInt(bytes);\n}\n\n/**\n * Converts a hex string to a number.\n *\n * @param hex To convert to number.\n * @returns Number.\n */\nexport function hexToNumber(hex: string): bigint {\n\treturn BigInt(`0x${hex}`);\n}\n\n/**\n * Converts a number to a hex string of 64 characters.\n *\n * @param number (bigint) to conver to hex.\n * @returns Hex string start-padded to 64 characters.\n */\nexport function numberToHexPadded64(number: bigint): string {\n\treturn number.toString(16).padStart(64, '0');\n}\n\nexport function isValidHex(str: string) {\n\treturn /^[a-f0-9]*$/i.test(str);\n}\n\n/**\n * Checks wether a proof or a list of proofs contains a non-hex id.\n *\n * @param p Proof or list of proofs.\n * @returns Boolean.\n */\nexport function hasNonHexId(p: Proof | Proof[]) {\n\tif (Array.isArray(p)) {\n\t\treturn p.some((proof) => !isValidHex(proof.id));\n\t}\n\treturn !isValidHex(p.id);\n}\n\n//used for json serialization\nexport function bigIntStringify<T>(_key: unknown, value: T) {\n\treturn typeof value === 'bigint' ? value.toString() : value;\n}\n\n/**\n * Helper function to encode a v3 cashu token.\n *\n * @param token To encode.\n * @returns Encoded token.\n */\nexport function getEncodedTokenV3(token: Token, removeDleq?: boolean): string {\n\tif (!hasNonHexId(token.proofs)) {\n\t\ttoken.proofs = convertToShortKeysetId(token.proofs);\n\t}\n\tif (removeDleq) {\n\t\ttoken.proofs = stripDleq(token.proofs);\n\t}\n\tconst v3TokenObj: DeprecatedToken = { token: [{ mint: token.mint, proofs: token.proofs }] };\n\tif (token.unit) {\n\t\tv3TokenObj.unit = token.unit;\n\t}\n\tif (token.memo) {\n\t\tv3TokenObj.memo = token.memo;\n\t}\n\tconst prefix = 'cashu';\n\tconst version = 'A';\n\treturn prefix + version + encodeJsonToBase64(v3TokenObj);\n}\n\n/*\n * Convert a keyset ID into short form\n */\nfunction convertToShortKeysetId(proofs: Proof[]) {\n\treturn proofs.map((p) => {\n\t\tconst newP = { ...p };\n\t\tnewP.id = newP.id.slice(0, 16);\n\t\treturn newP;\n\t});\n}\n\n/**\n * Helper function to encode a cashu token (defaults to v4 if keyset id allows it)\n *\n * @param token\n * @param [opts]\n */\nexport function getEncodedToken(\n\ttoken: Token,\n\topts?: { version?: 3 | 4; removeDleq?: boolean },\n): string {\n\t// Find out if it's a base64 keyset\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex || opts?.version === 3) {\n\t\tif (opts?.version === 4) {\n\t\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t\t}\n\t\treturn getEncodedTokenV3(token, opts?.removeDleq);\n\t}\n\treturn getEncodedTokenV4(token, opts?.removeDleq);\n}\n\nexport function getEncodedTokenV4(token: Token, removeDleq?: boolean): string {\n\tif (removeDleq) {\n\t\ttoken.proofs = stripDleq(token.proofs);\n\t}\n\t// Make sure each DLEQ has its blinding factor\n\ttoken.proofs.forEach((p) => {\n\t\tif (p.dleq && p.dleq.r == undefined) {\n\t\t\tthrow new Error('Missing blinding factor in included DLEQ proof');\n\t\t}\n\t});\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex) {\n\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t}\n\t// Map keyset IDs to short IDs\n\ttoken.proofs = convertToShortKeysetId(token.proofs);\n\n\tconst tokenTemplate = templateFromToken(token);\n\n\tconst encodedData = encodeCBOR(tokenTemplate);\n\tconst prefix = 'cashu';\n\tconst version = 'B';\n\tconst base64Data = encodeUint8toBase64Url(encodedData);\n\treturn prefix + version + base64Data;\n}\n\nfunction templateFromToken(token: Token): TokenV4Template {\n\tconst idMap: { [id: string]: Proof[] } = {};\n\tconst mint = token.mint;\n\tfor (let i = 0; i < token.proofs.length; i++) {\n\t\tconst proof = token.proofs[i];\n\t\tif (idMap[proof.id]) {\n\t\t\tidMap[proof.id].push(proof);\n\t\t} else {\n\t\t\tidMap[proof.id] = [proof];\n\t\t}\n\t}\n\tconst tokenTemplate: TokenV4Template = {\n\t\tm: mint,\n\t\tu: token.unit || 'sat',\n\t\tt: Object.keys(idMap).map(\n\t\t\t(id: string): V4InnerToken => ({\n\t\t\t\ti: hexToBytes(id),\n\t\t\t\tp: idMap[id].map(\n\t\t\t\t\t(p: Proof): V4ProofTemplate => ({\n\t\t\t\t\t\ta: p.amount,\n\t\t\t\t\t\ts: p.secret,\n\t\t\t\t\t\tc: hexToBytes(p.C),\n\t\t\t\t\t\t...(p.dleq && {\n\t\t\t\t\t\t\td: {\n\t\t\t\t\t\t\t\te: hexToBytes(p.dleq.e),\n\t\t\t\t\t\t\t\ts: hexToBytes(p.dleq.s),\n\t\t\t\t\t\t\t\tr: hexToBytes(p.dleq.r ?? '00'),\n\t\t\t\t\t\t\t} as V4DLEQTemplate,\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t...(p.p2pk_e && {\n\t\t\t\t\t\t\tpe: hexToBytes(p.p2pk_e),\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t...(p.witness && {\n\t\t\t\t\t\t\tw: JSON.stringify(p.witness),\n\t\t\t\t\t\t}),\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t}),\n\t\t),\n\t} as TokenV4Template;\n\tif (token.memo) {\n\t\ttokenTemplate.d = token.memo;\n\t}\n\treturn tokenTemplate;\n}\n\n/**\n * Asserts amount is a valid, safe integer.\n *\n * @param amount Value to check.\n * @param allowZero If false, requires amount > 0 (default: false).\n */\n/**\n * @internal\n */\nexport function validateAmount(amount: unknown, allowZero = false): asserts amount is number {\n\tif (typeof amount !== 'number' || !Number.isFinite(amount) || !Number.isInteger(amount)) {\n\t\tthrow new Error(`Invalid amount: ${String(amount)}`);\n\t}\n\tif (!Number.isSafeInteger(amount)) {\n\t\tthrow new Error(`Amount must be a safe integer: ${amount}`);\n\t}\n\tif (allowZero ? amount < 0 : amount <= 0) {\n\t\tthrow new Error(`Amount must be ${allowZero ? 'non-negative' : 'positive'}: ${amount}`);\n\t}\n}\n\nfunction tokenFromTemplate(template: TokenV4Template): Token {\n\tconst proofs: Proof[] = [];\n\ttemplate.t.forEach((t) =>\n\t\tt.p.forEach((p) => {\n\t\t\tvalidateAmount(p.a, true);\n\t\t\tproofs.push({\n\t\t\t\tsecret: p.s,\n\t\t\t\tC: bytesToHex(p.c),\n\t\t\t\tamount: p.a,\n\t\t\t\tid: bytesToHex(t.i),\n\t\t\t\t...(p.d && {\n\t\t\t\t\tdleq: {\n\t\t\t\t\t\tr: bytesToHex(p.d.r),\n\t\t\t\t\t\ts: bytesToHex(p.d.s),\n\t\t\t\t\t\te: bytesToHex(p.d.e),\n\t\t\t\t\t} as SerializedDLEQ,\n\t\t\t\t}),\n\t\t\t\t...(p.pe && {\n\t\t\t\t\tp2pk_e: bytesToHex(p.pe),\n\t\t\t\t}),\n\t\t\t\t...(p.w && {\n\t\t\t\t\twitness: p.w,\n\t\t\t\t}),\n\t\t\t});\n\t\t}),\n\t);\n\tconst decodedToken: Token = { mint: template.m, proofs, unit: template.u || 'sat' };\n\tif (template.d) {\n\t\tdecodedToken.memo = template.d;\n\t}\n\treturn decodedToken;\n}\n\n/**\n * Helper function to decode cashu tokens into object.\n *\n * @param token An encoded cashu token (cashuB...)\n * @param keysets Optional. Array of full keyset IDs, eg: from KeyChain.getAllKeysetIds()\n * @returns Cashu token object.\n */\nexport function getDecodedToken(tokenString: string, keysetIds?: readonly string[]): Token;\n/**\n * @deprecated Pass keyset ids as `string[]` instead, eg: using KeyChain.getAllKeysetIds()\n */\nexport function getDecodedToken(tokenString: string, keysetIds?: readonly HasKeysetId[]): Token;\nexport function getDecodedToken(\n\ttokenString: string,\n\tkeysetOrIds?: ReadonlyArray<string | HasKeysetId>,\n): Token {\n\t// normalize to array of strings\n\tconst keysetIds = (keysetOrIds ?? []).map((ks) => (typeof ks === 'string' ? ks : ks.id));\n\t// remove prefixes\n\tconst tokenStr = removePrefix(tokenString);\n\tconst token: Token = handleTokens(tokenStr);\n\ttoken.proofs = mapShortKeysetIds(token.proofs, keysetIds);\n\treturn token;\n}\n\n/**\n * Returns the metadata of a cashu token.\n *\n * @param token An encoded cashu token (cashuB...)\n * @returns Token metadata.\n */\nexport function getTokenMetadata(token: string): TokenMetadata {\n\ttoken = removePrefix(token);\n\tconst tokenObj = handleTokens(token);\n\treturn {\n\t\tunit: tokenObj.unit || 'sat',\n\t\tmint: tokenObj.mint,\n\t\tamount: sumProofs(tokenObj.proofs),\n\t\t...(tokenObj.memo && { memo: tokenObj.memo }),\n\t\tincompleteProofs: tokenObj.proofs.map((p) => ({\n\t\t\tsecret: p.secret,\n\t\t\tC: p.C,\n\t\t\tamount: p.amount,\n\t\t\t...(p.dleq && {\n\t\t\t\tdleq: p.dleq,\n\t\t\t}),\n\t\t\t...(p.witness && {\n\t\t\t\twitness: p.witness,\n\t\t\t}),\n\t\t})),\n\t};\n}\n\n/**\n * Helper function to decode different versions of cashu tokens into an object.\n *\n * @param token An encoded cashu token (cashuB...)\n * @returns Cashu Token object.\n */\nexport function handleTokens(token: string): Token {\n\tconst version = token.slice(0, 1);\n\tconst encodedToken = token.slice(1);\n\tif (version === 'A') {\n\t\tconst parsedV3Token = encodeBase64ToJson<DeprecatedToken>(encodedToken);\n\t\tif (parsedV3Token.token.length > 1) {\n\t\t\tthrow new Error('Multi entry token are not supported');\n\t\t}\n\t\tconst entry = parsedV3Token.token[0];\n\t\tfor (const p of entry.proofs) {\n\t\t\tvalidateAmount(p.amount, true);\n\t\t}\n\t\tconst tokenObj: Token = {\n\t\t\tmint: entry.mint,\n\t\t\tproofs: entry.proofs,\n\t\t\tunit: parsedV3Token.unit || 'sat',\n\t\t};\n\t\tif (parsedV3Token.memo) {\n\t\t\ttokenObj.memo = parsedV3Token.memo;\n\t\t}\n\t\treturn tokenObj;\n\t} else if (version === 'B') {\n\t\tconst uInt8Token = encodeBase64toUint8(encodedToken);\n\t\tconst tokenData = decodeCBOR(uInt8Token) as TokenV4Template;\n\t\treturn tokenFromTemplate(tokenData);\n\t}\n\tthrow new Error('Token version is not supported');\n}\n\nexport type DeriveKeysetIdOptions = {\n\texpiry?: number;\n\tinput_fee_ppk?: number;\n\tunit?: string;\n\tversionByte?: number;\n\tisDeprecatedBase64?: boolean;\n};\n\n/**\n * Returns the keyset id of a set of keys.\n *\n * @param keys Keys object to derive keyset id from.\n * @param options.expiry (optional) expiry of the keyset.\n * @param options.input_fee_ppk (optional) Input fee for keyset (in ppk)\n * @param options.unit (optional) the unit of the keyset. Default: sat.\n * @param options.versionByte (optional) version of the keyset ID. Default: 1.\n * @param options.isDeprecatedBase64 (optional) version of the keyset ID. Default: false.\n * @returns Keyset id of the keys.\n * @throws If keyset versionByte is not valid.\n */\nexport function deriveKeysetId(keys: Keys, options?: DeriveKeysetIdOptions): string;\n/**\n * @deprecated Use the new options signature, which also adds keysets v2 support:\n *\n *       deriveKeysetId(keys, { unit, expiry, versionByte, input_fee_ppk });\n */\nexport function deriveKeysetId(\n\tkeys: Keys,\n\tunit?: string,\n\texpiry?: number,\n\tversionByte?: number,\n\tisDeprecatedBase64?: boolean,\n): string;\nexport function deriveKeysetId(\n\tkeys: Keys,\n\targ2?: string | DeriveKeysetIdOptions,\n\texpiry?: number,\n\tversionByte?: number,\n\tisDeprecatedBase64?: boolean,\n\tinput_fee_ppk?: number,\n): string {\n\tlet unit: string = 'sat';\n\tif (arg2 && typeof arg2 === 'object') {\n\t\t// New signature\n\t\tunit = arg2.unit ?? 'sat'; // default: sat\n\t\texpiry = arg2.expiry;\n\t\tversionByte = arg2.versionByte ?? 1; // default: 1\n\t\tinput_fee_ppk = arg2.input_fee_ppk;\n\t\tisDeprecatedBase64 = arg2.isDeprecatedBase64 ?? false; // default: false\n\t} else {\n\t\t// Deprecated signature\n\t\tunit = arg2 ?? 'sat'; // default: sat\n\t\tversionByte = versionByte ?? 0; // default: 0\n\t\tisDeprecatedBase64 = isDeprecatedBase64 ?? false; // default: false\n\t}\n\n\tif (isDeprecatedBase64) {\n\t\tconst pubkeysConcat = Object.entries(keys)\n\t\t\t.sort(([amountA], [amountB]) => Number(amountA) - Number(amountB))\n\t\t\t.map(([, pubKey]) => pubKey)\n\t\t\t.reduce((prev: string, curr: string) => prev + curr, '');\n\t\tconst hash = sha256(Bytes.fromString(pubkeysConcat));\n\t\tconst b64 = Bytes.toBase64(hash);\n\t\treturn b64.slice(0, 12);\n\t}\n\n\tswitch (versionByte) {\n\t\tcase 0: {\n\t\t\tconst pubkeysConcat = Object.entries(keys)\n\t\t\t\t.sort(([amountA], [amountB]) => Number(amountA) - Number(amountB))\n\t\t\t\t.map(([, pubKey]) => hexToBytes(pubKey))\n\t\t\t\t.reduce(\n\t\t\t\t\t(prev: Uint8Array, curr: Uint8Array) => mergeUInt8Arrays(prev, curr),\n\t\t\t\t\tnew Uint8Array(),\n\t\t\t\t);\n\t\t\tconst hash = sha256(pubkeysConcat);\n\t\t\tconst hashHex = Bytes.toHex(hash).slice(0, 14);\n\t\t\treturn '00' + hashHex;\n\t\t}\n\t\tcase 1: {\n\t\t\tif (!unit) {\n\t\t\t\tthrow new Error('Cannot compute keyset ID version 01: unit is required.');\n\t\t\t}\n\t\t\tconst sortedEntries = Object.entries(keys).sort(\n\t\t\t\t([amountA], [amountB]) => Number(amountA) - Number(amountB),\n\t\t\t);\n\t\t\tlet preimage = sortedEntries.map(([amount, pubkey]) => `${amount}:${pubkey}`).join(',');\n\t\t\tpreimage += `|unit:${unit}`;\n\t\t\tif (input_fee_ppk) {\n\t\t\t\tpreimage += `|input_fee_ppk:${input_fee_ppk}`;\n\t\t\t}\n\t\t\tif (expiry) {\n\t\t\t\tpreimage += `|final_expiry:${expiry}`;\n\t\t\t}\n\t\t\tconst hash = sha256(Bytes.fromString(preimage));\n\t\t\tconst hashHex = Bytes.toHex(hash);\n\t\t\treturn '01' + hashHex;\n\t\t}\n\t\tdefault:\n\t\t\tthrow new Error(`Unrecognized keyset ID version: ${versionByte}`);\n\t}\n}\n\nexport function mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n\t// sum of individual array lengths\n\tconst mergedArray = new Uint8Array(a1.length + a2.length);\n\tmergedArray.set(a1);\n\tmergedArray.set(a2, a1.length);\n\treturn mergedArray;\n}\n\nexport function sortProofsById(proofs: Proof[]) {\n\treturn proofs.sort((a: Proof, b: Proof) => a.id.localeCompare(b.id));\n}\n\nexport function isObj(v: unknown): v is object {\n\treturn typeof v === 'object';\n}\n\nexport function checkResponse(data: { error?: string; detail?: string }) {\n\tif (!isObj(data)) return;\n\tif ('error' in data && data.error) {\n\t\tthrow new Error(data.error);\n\t}\n\tif ('detail' in data && data.detail) {\n\t\tthrow new Error(data.detail);\n\t}\n}\n\nexport function joinUrls(...parts: string[]): string {\n\treturn parts.map((part: string) => part.replace(/(^\\/+|\\/+$)/g, '')).join('/');\n}\n\nexport function sanitizeUrl(url: string): string {\n\treturn url.replace(/\\/$/, '');\n}\n\nexport function sumProofs(proofs: Proof[]) {\n\treturn proofs.reduce((acc: number, proof: Proof) => acc + proof.amount, 0);\n}\n\nexport function decodePaymentRequest(paymentRequest: string) {\n\treturn PaymentRequest.fromEncodedRequest(paymentRequest);\n}\n\nexport class MessageNode {\n\tprivate _value: string;\n\tprivate _next: MessageNode | null;\n\n\tpublic get value(): string {\n\t\treturn this._value;\n\t}\n\tpublic set value(message: string) {\n\t\tthis._value = message;\n\t}\n\tpublic get next(): MessageNode | null {\n\t\treturn this._next;\n\t}\n\tpublic set next(node: MessageNode | null) {\n\t\tthis._next = node;\n\t}\n\n\tconstructor(message: string) {\n\t\tthis._value = message;\n\t\tthis._next = null;\n\t}\n}\n\nexport class MessageQueue {\n\tprivate _first: MessageNode | null;\n\tprivate _last: MessageNode | null;\n\n\tpublic get first(): MessageNode | null {\n\t\treturn this._first;\n\t}\n\tpublic set first(messageNode: MessageNode | null) {\n\t\tthis._first = messageNode;\n\t}\n\tpublic get last(): MessageNode | null {\n\t\treturn this._last;\n\t}\n\tpublic set last(messageNode: MessageNode | null) {\n\t\tthis._last = messageNode;\n\t}\n\tprivate _size: number;\n\tpublic get size(): number {\n\t\treturn this._size;\n\t}\n\tpublic set size(v: number) {\n\t\tthis._size = v;\n\t}\n\n\tconstructor() {\n\t\tthis._first = null;\n\t\tthis._last = null;\n\t\tthis._size = 0;\n\t}\n\tenqueue(message: string): boolean {\n\t\tconst newNode = new MessageNode(message);\n\t\tif (this._size === 0 || !this._last) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\t\t} else {\n\t\t\tthis._last.next = newNode;\n\t\t\tthis._last = newNode;\n\t\t}\n\t\tthis._size++;\n\t\treturn true;\n\t}\n\tdequeue(): string | null {\n\t\tif (this._size === 0 || !this._first) return null;\n\n\t\tconst prev = this._first;\n\t\tthis._first = prev.next;\n\t\tprev.next = null;\n\n\t\tthis._size--;\n\t\treturn prev.value;\n\t}\n}\n/**\n * Removes all traces of DLEQs from a list of proofs.\n *\n * @param proofs The list of proofs that dleq should be stripped from.\n */\nexport function stripDleq(proofs: Proof[]): Array<Omit<Proof, 'dleq'>> {\n\treturn proofs.map((p) => {\n\t\tconst newP = { ...p };\n\t\tdelete newP['dleq'];\n\t\treturn newP;\n\t});\n}\n\n/**\n * @deprecated Use Keyset.verifyKeysetId(keys), or init a Keyset and call keyset.verify().\n */\nexport function verifyKeysetId(keys: MintKeys): boolean {\n\t// Note: we are NOT redirecting to Keyset.verifyKeysetId() here as that would\n\t// couple the utils class to Keyset, and risks circular dependencies.\n\tconst isBase64 = isBase64String(keys.id);\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keys.id);\n\tconst versionByte = isValidHex ? hexToBytes(keys.id)[0] : 0;\n\treturn (\n\t\tderiveKeysetId(keys.keys, {\n\t\t\texpiry: keys.final_expiry,\n\t\t\tinput_fee_ppk: keys.input_fee_ppk,\n\t\t\tunit: keys.unit,\n\t\t\tversionByte,\n\t\t\tisDeprecatedBase64: isBase64 && !isValidHex,\n\t\t}) === keys.id\n\t);\n}\n\n/**\n * Maps the short keyset IDs stored in the token to actual keyset IDs that were fetched from the\n * Mint.\n *\n * @param proofs Array of Proofs.\n * @param keysets Optional. Array of full keyset IDs, eg: from KeyChain.getAllKeysetIds()\n * @returns Array of Proofs with full keyset IDs.\n */\nfunction mapShortKeysetIds(proofs: Proof[], keysetIds?: readonly string[]): Proof[];\n/**\n * @deprecated Pass keyset ids as `string[]` instead.\n */\nfunction mapShortKeysetIds(proofs: Proof[], keysetIds?: readonly HasKeysetId[]): Proof[];\nfunction mapShortKeysetIds(\n\tproofs: Proof[],\n\tkeysetOrIds?: ReadonlyArray<string | HasKeysetId>,\n): Proof[] {\n\t// normalize to array of keyset ids\n\tconst keysetIds = (keysetOrIds ?? []).map((ks) => (typeof ks === 'string' ? ks : ks.id));\n\tconst newProofs: Proof[] = [];\n\tfor (const proof of proofs) {\n\t\tlet idBytes: Uint8Array;\n\t\ttry {\n\t\t\tidBytes = hexToBytes(proof.id);\n\t\t} catch {\n\t\t\t// Base64 keysets don't need conversion\n\t\t\tnewProofs.push(proof);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (idBytes[0] === 0x00) {\n\t\t\tnewProofs.push(proof);\n\t\t} else if (idBytes[0] === 0x01) {\n\t\t\tif (!keysetIds) {\n\t\t\t\tthrow new Error('A short keyset ID v2 was encountered, but got no keysets to map it to.');\n\t\t\t}\n\t\t\t// Look for a match: prefix(keyset ID) == short ID\n\t\t\tconst matches = keysetIds.filter((keyset) => proof.id === keyset.slice(0, proof.id.length));\n\t\t\tif (matches.length > 1) {\n\t\t\t\tthrow new Error(`Short keyset ID ${proof.id} is ambiguous.`);\n\t\t\t}\n\t\t\tif (matches.length === 0) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Couldn't map short keyset ID ${proof.id} to any known keysets of the current Mint`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tproof.id = matches[0];\n\t\t\tnewProofs.push(proof);\n\t\t} else {\n\t\t\tthrow new Error(`Unknown keyset ID version: ${idBytes[0]}`);\n\t\t}\n\t}\n\n\treturn newProofs;\n}\n\n/**\n * Checks that the proof has a valid DLEQ proof according to keyset `keys`\n *\n * @param proof The proof subject to verification.\n * @param keyset Object containing keyset keys (eg: Keyset, MintKeys, KeysetCache)\n * @returns True if verification succeeded, false otherwise.\n * @throws Throws if the proof amount does not match any key in the provided keyset.\n */\nexport function hasValidDleq(proof: Proof, keyset: HasKeysetKeys): boolean {\n\tif (proof.dleq == undefined) {\n\t\treturn false;\n\t}\n\tconst dleq = {\n\t\te: hexToBytes(proof.dleq.e),\n\t\ts: hexToBytes(proof.dleq.s),\n\t\tr: hexToNumber(proof.dleq.r ?? '00'),\n\t} as DLEQ;\n\tif (!hasCorrespondingKey(proof.amount, keyset.keys)) {\n\t\tthrow new Error(`Undefined key for amount ${proof.amount} in keyset ${keyset.id}`);\n\t}\n\tconst key = keyset.keys[proof.amount];\n\treturn verifyDLEQProof_reblind(\n\t\tnew TextEncoder().encode(proof.secret),\n\t\tdleq,\n\t\tpointFromHex(proof.C),\n\t\tpointFromHex(key),\n\t);\n}\n\nfunction concatByteArrays(...arrays: Uint8Array[]): Uint8Array {\n\tconst totalLength = arrays.reduce((a, c) => a + c.length, 0);\n\tconst byteArray = new Uint8Array(totalLength);\n\tlet pointer = 0;\n\tfor (let i = 0; i < arrays.length; i++) {\n\t\tbyteArray.set(arrays[i], pointer);\n\t\tpointer = pointer + arrays[i].length;\n\t}\n\treturn byteArray;\n}\n\nexport function getEncodedTokenBinary(token: Token): Uint8Array {\n\tconst utf8Encoder = new TextEncoder();\n\tconst template = templateFromToken(token);\n\tconst binaryTemplate = encodeCBOR(template);\n\tconst prefix = utf8Encoder.encode('craw');\n\tconst version = utf8Encoder.encode('B');\n\treturn concatByteArrays(prefix, version, binaryTemplate);\n}\n\nexport function getDecodedTokenBinary(bytes: Uint8Array): Token {\n\tconst utfDecoder = new TextDecoder();\n\tconst prefix = utfDecoder.decode(bytes.slice(0, 4));\n\tconst version = utfDecoder.decode(new Uint8Array([bytes[4]]));\n\tif (prefix !== 'craw' || version !== 'B') {\n\t\tthrow new Error('not a valid binary token');\n\t}\n\tconst binaryToken = bytes.slice(5);\n\tconst decoded = decodeCBOR(binaryToken) as TokenV4Template;\n\treturn tokenFromTemplate(decoded);\n}\n\nfunction sumArray(arr: number[]) {\n\treturn arr.reduce((a, c) => a + c, 0);\n}\n\n/**\n * Utility function for deep equality comparison of objects.\n */\nexport function deepEqual<T>(a: T, b: T): boolean {\n\tif (a === b) return true;\n\tif (a == null || b == null) return false;\n\tif (typeof a !== 'object' || typeof b !== 'object') return false;\n\n\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\tif (a.length !== b.length) return false;\n\t\treturn a.every((item, index) => deepEqual(item, b[index]));\n\t}\n\n\tif (Array.isArray(a) || Array.isArray(b)) return false;\n\n\tconst keysA = Object.keys(a) as Array<keyof T>;\n\tconst keysB = Object.keys(b) as Array<keyof T>;\n\tif (keysA.length !== keysB.length) return false;\n\n\treturn keysA.every((key) => keysB.includes(key) && deepEqual(a[key], b[key]));\n}\n\nfunction removePrefix(token: string): string {\n\tconst uriPrefixes = ['web+cashu://', 'cashu://', 'cashu:', 'cashu'];\n\turiPrefixes.forEach((prefix: string) => {\n\t\tif (!token.startsWith(prefix)) {\n\t\t\treturn;\n\t\t}\n\t\ttoken = token.slice(prefix.length);\n\t});\n\treturn token;\n}\n\n/**\n * Detects whether a BOLT-11 Lightning invoice encodes a non-zero amount in the Human-Readable Part\n * (HRP).\n */\nexport function invoiceHasAmountInHRP(invoice: string): boolean {\n\treturn /^ln[a-z]{2,}[1-9][0-9]*(?:[mun]|0p)?1/i.test(invoice);\n}\n","import { MessageQueue } from '../utils';\nimport { type JsonRpcMessage, type JsonRpcReqParams, type RpcSubId } from '../model/types';\nimport { getWebSocketImpl } from './ws';\nimport { type Logger, NULL_LOGGER } from '../logger';\n\n// Internal interface for RPC listeners\ninterface RpcListener {\n\tcallback: () => void;\n\terrorCallback: (e: Error) => void;\n}\n\ntype OnOpenSuccess = () => void;\ntype OnOpenError = (err: Error) => void;\n\nexport class ConnectionManager {\n\tprivate static instance: ConnectionManager;\n\tprivate connectionMap: Map<string, WSConnection> = new Map();\n\n\tstatic getInstance() {\n\t\tif (!ConnectionManager.instance) {\n\t\t\tConnectionManager.instance = new ConnectionManager();\n\t\t}\n\t\treturn ConnectionManager.instance;\n\t}\n\n\tgetConnection(url: string, logger?: Logger): WSConnection {\n\t\tconst existing = this.connectionMap.get(url);\n\t\tif (existing) {\n\t\t\tif (logger) existing.setLogger(logger);\n\t\t\treturn existing;\n\t\t}\n\t\tconst newConn = new WSConnection(url, logger);\n\t\tthis.connectionMap.set(url, newConn);\n\t\treturn newConn;\n\t}\n}\n\nexport class WSConnection {\n\tpublic readonly url: URL;\n\tprivate readonly _WS: typeof WebSocket;\n\tprivate ws: WebSocket | undefined;\n\tprivate connectionPromise: Promise<void> | undefined;\n\tprivate subListeners: { [subId: string]: Array<(payload: unknown) => void> } = {};\n\tprivate rpcListeners: { [rpcSubId: string]: RpcListener } = {};\n\tprivate messageQueue: MessageQueue;\n\tprivate handlingInterval?: ReturnType<typeof setInterval>;\n\tprivate rpcId = 0;\n\tprivate _logger: Logger;\n\tprivate onCloseCallbacks: Array<(e: CloseEvent) => void> = [];\n\n\tconstructor(url: string, logger?: Logger) {\n\t\tthis._WS = getWebSocketImpl();\n\t\tthis.url = new URL(url);\n\t\tthis.messageQueue = new MessageQueue();\n\t\tthis._logger = logger ?? NULL_LOGGER;\n\t}\n\n\tsetLogger(logger: Logger) {\n\t\tthis._logger = logger;\n\t}\n\n\tconnect(timeoutMs = 10_000): Promise<void> {\n\t\tif (this.connectionPromise) return this.connectionPromise;\n\n\t\tthis.connectionPromise = new Promise((resolve: OnOpenSuccess, reject: OnOpenError) => {\n\t\t\tlet opened = false;\n\t\t\tlet settled = false;\n\t\t\tlet timer: ReturnType<typeof setTimeout> | null = null;\n\n\t\t\tconst settle = (fn: () => void) => {\n\t\t\t\tif (settled) return;\n\t\t\t\tsettled = true;\n\t\t\t\tif (timer) clearTimeout(timer);\n\t\t\t\tfn();\n\t\t\t};\n\n\t\t\tconst cleanupSocket = () => {\n\t\t\t\tif (!this.ws) return;\n\t\t\t\ttry {\n\t\t\t\t\tthis.ws.onopen = null;\n\t\t\t\t\tthis.ws.onerror = null;\n\t\t\t\t\tthis.ws.onmessage = null;\n\t\t\t\t\tthis.ws.onclose = null;\n\t\t\t\t} catch {\n\t\t\t\t\t// silence\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tthis.ws.close();\n\t\t\t\t} catch {\n\t\t\t\t\t// silence\n\t\t\t\t}\n\t\t\t\tthis.ws = undefined;\n\t\t\t\tthis.stopMessageHandling();\n\t\t\t};\n\n\t\t\tconst fail = (e: unknown) => {\n\t\t\t\tthis.connectionPromise = undefined;\n\t\t\t\tcleanupSocket();\n\t\t\t\tconst err = e instanceof Error ? e : new Error(String(e));\n\t\t\t\tthis.failPendingRpc(err);\n\t\t\t\tsettle(() => reject(err));\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tthis.ws = new this._WS(this.url.toString());\n\t\t\t} catch (e) {\n\t\t\t\tfail(e);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttimer = setTimeout(() => {\n\t\t\t\tfail(new Error(`WebSocket connect timeout after ${timeoutMs}ms`));\n\t\t\t}, timeoutMs);\n\n\t\t\tthis.ws.onopen = () => {\n\t\t\t\topened = true;\n\t\t\t\tsettle(resolve);\n\t\t\t};\n\n\t\t\tthis.ws.onerror = (ev) => {\n\t\t\t\tif (!opened) {\n\t\t\t\t\tfail(new Error('Failed to open WebSocket'));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._logger.error('WebSocket error after open', { ev });\n\t\t\t\t// do not call fail(), onclose will follow in most implementations\n\t\t\t};\n\n\t\t\tthis.ws.onmessage = (e: MessageEvent) => {\n\t\t\t\tthis.messageQueue.enqueue(e.data as string);\n\t\t\t\tif (!this.handlingInterval) {\n\t\t\t\t\tthis.handlingInterval = setInterval(this.handleNextMessage.bind(this), 0);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.ws.onclose = (e: CloseEvent) => {\n\t\t\t\tthis.connectionPromise = undefined;\n\n\t\t\t\tif (!opened) {\n\t\t\t\t\tconst reason = e?.reason ? `, ${e.reason}` : '';\n\t\t\t\t\tfail(new Error(`WebSocket closed before open (code ${e?.code ?? 0}${reason})`));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.stopMessageHandling();\n\n\t\t\t\t// If the socket closed unexpectedly, fail any in flight RPC acks.\n\t\t\t\t// Otherwise just clear them to avoid leaks, but don't spam errors.\n\t\t\t\tconst reason = e?.reason ? `, ${e.reason}` : '';\n\t\t\t\tconst code = e?.code ?? 0;\n\t\t\t\tconst wasClean = typeof e.wasClean === 'boolean' ? e.wasClean : true;\n\n\t\t\t\tconst abnormal = !wasClean || (code !== 1000 && code !== 1001);\n\t\t\t\tif (abnormal) {\n\t\t\t\t\tthis.failPendingRpc(new Error(`WebSocket closed (code ${code}${reason})`));\n\t\t\t\t} else {\n\t\t\t\t\tthis.rpcListeners = {};\n\t\t\t\t}\n\n\t\t\t\tthis.onCloseCallbacks.forEach((cb) => cb(e));\n\t\t\t};\n\t\t});\n\n\t\treturn this.connectionPromise;\n\t}\n\n\tsendRequest(method: 'subscribe', params: JsonRpcReqParams): void;\n\tsendRequest(method: 'unsubscribe', params: { subId: string }): void;\n\tsendRequest(method: 'subscribe' | 'unsubscribe', params: Partial<JsonRpcReqParams>): void {\n\t\tif (this.ws?.readyState !== this._WS.OPEN) {\n\t\t\tif (method === 'unsubscribe') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._logger.error('Attempted sendRequest, but socket was not open');\n\t\t\tthrow new Error('Socket not open');\n\t\t}\n\n\t\tconst id = this.rpcId;\n\t\tthis.rpcId++;\n\t\tthis.sendRpcMessage(method, params, id);\n\t}\n\n\t/**\n\t * @deprecated Use cancelSubscription for JSONRPC compliance.\n\t */\n\tcloseSubscription(subId: string) {\n\t\tthis.ws?.send(JSON.stringify(['CLOSE', subId]));\n\t}\n\n\taddSubListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void) {\n\t\t(this.subListeners[subId] = this.subListeners[subId] || []).push(\n\t\t\tcallback as (payload: unknown) => void,\n\t\t);\n\t}\n\n\tprivate stopMessageHandling() {\n\t\tif (this.handlingInterval) {\n\t\t\tclearInterval(this.handlingInterval);\n\t\t\tthis.handlingInterval = undefined;\n\t\t}\n\t\t// Drain any queued messages so we don't process stale frames after teardown.\n\t\twhile (this.messageQueue.size > 0) {\n\t\t\tthis.messageQueue.dequeue();\n\t\t}\n\t}\n\n\tprivate failPendingRpc(err: Error) {\n\t\tconst listeners = this.rpcListeners;\n\t\tthis.rpcListeners = {};\n\t\tfor (const key of Object.keys(listeners)) {\n\t\t\ttry {\n\t\t\t\tlisteners[key].errorCallback(err);\n\t\t\t} catch {\n\t\t\t\t// ignore user error callbacks throwing\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate sendRpcMessage(\n\t\tmethod: 'subscribe' | 'unsubscribe',\n\t\tparams: Partial<JsonRpcReqParams>,\n\t\tid: number,\n\t): void {\n\t\tif (this.ws?.readyState !== this._WS.OPEN) {\n\t\t\tthrow new Error('Socket not open');\n\t\t}\n\n\t\tconst message = JSON.stringify({ jsonrpc: '2.0', method, params, id });\n\n\t\ttry {\n\t\t\tthis.ws.send(message);\n\t\t} catch (e) {\n\t\t\tthis._logger.error('WebSocket send failed', { e });\n\t\t\t// allow retry\n\t\t\tthis.connectionPromise = undefined;\n\n\t\t\t// Ensure the failed socket is closed and queues are flushed.\n\t\t\ttry {\n\t\t\t\tthis.ws.close();\n\t\t\t} catch {\n\t\t\t\t// silence\n\t\t\t}\n\t\t\tthis.ws = undefined;\n\t\t\tthis.stopMessageHandling();\n\n\t\t\tconst err = e instanceof Error ? e : new Error(String(e));\n\t\t\tthis.failPendingRpc(err);\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tprivate addRpcListener(\n\t\tcallback: () => void,\n\t\terrorCallback: (e: Error) => void,\n\t\tid: Exclude<RpcSubId, null>,\n\t) {\n\t\tthis.rpcListeners[id] = { callback, errorCallback };\n\t}\n\n\tprivate removeRpcListener(id: Exclude<RpcSubId, null>) {\n\t\tdelete this.rpcListeners[id];\n\t}\n\n\tprivate removeListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void) {\n\t\tif (!this.subListeners[subId]) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.subListeners[subId].length === 1) {\n\t\t\tdelete this.subListeners[subId];\n\t\t\treturn;\n\t\t}\n\t\tthis.subListeners[subId] = this.subListeners[subId].filter(\n\t\t\t(fn) => fn !== (callback as (payload: unknown) => void),\n\t\t);\n\t}\n\n\tasync ensureConnection(timeoutMs?: number) {\n\t\tif (this.ws?.readyState !== this._WS.OPEN) {\n\t\t\tawait this.connect(timeoutMs);\n\t\t}\n\t}\n\n\tprivate handleNextMessage() {\n\t\tif (this.messageQueue.size === 0) {\n\t\t\tif (this.handlingInterval) {\n\t\t\t\tclearInterval(this.handlingInterval);\n\t\t\t\tthis.handlingInterval = undefined;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tconst message = this.messageQueue.dequeue() as string;\n\n\t\ttry {\n\t\t\tconst parsed = JSON.parse(message) as JsonRpcMessage;\n\n\t\t\tif ('result' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].callback();\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('error' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].errorCallback(new Error(parsed.error.message));\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('method' in parsed) {\n\t\t\t\tif ('id' in parsed) {\n\t\t\t\t\t// Do nothing as mints should not send requests\n\t\t\t\t} else {\n\t\t\t\t\tconst subId = parsed.params?.subId;\n\t\t\t\t\tif (!subId) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.subListeners[subId]?.length > 0) {\n\t\t\t\t\t\tconst notification = parsed;\n\t\t\t\t\t\tthis.subListeners[subId].forEach((cb) => {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tcb(notification.params?.payload);\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tthis._logger.error('Subscription handler threw', { e });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis._logger.error('Error doing handleNextMessage', { e });\n\t\t}\n\t}\n\n\tcreateSubscription<TPayload = unknown>(\n\t\tparams: Omit<JsonRpcReqParams, 'subId'>,\n\t\tcallback: (payload: TPayload) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): string {\n\t\tif (this.ws?.readyState !== this._WS.OPEN) {\n\t\t\tthis._logger.error('Attempted createSubscription, but socket was not open');\n\t\t\tthrow new Error('Socket is not open');\n\t\t}\n\n\t\tconst subId = (Math.random() + 1).toString(36).substring(7);\n\t\tconst rpcId = this.rpcId; // this is the id sendRequest will use next\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis.addSubListener(subId, callback);\n\t\t\t},\n\t\t\terrorCallback,\n\t\t\trpcId as Exclude<RpcSubId, null>,\n\t\t);\n\n\t\ttry {\n\t\t\tthis.sendRequest('subscribe', { ...params, subId });\n\t\t} catch (e) {\n\t\t\tthis.removeRpcListener(rpcId as Exclude<RpcSubId, null>);\n\t\t\tthrow e;\n\t\t}\n\n\t\treturn subId;\n\t}\n\n\t/**\n\t * Cancels a subscription, sending an unsubscribe request and handling responses.\n\t *\n\t * @param subId The subscription ID to cancel.\n\t * @param callback The original payload callback to remove.\n\t * @param errorCallback Optional callback for unsubscribe errors (defaults to logging).\n\t */\n\tcancelSubscription<TPayload = unknown>(\n\t\tsubId: string,\n\t\tcallback: (payload: TPayload) => void,\n\t\terrorCallback?: (e: Error) => void,\n\t) {\n\t\tthis.removeListener(subId, callback);\n\n\t\tif (this.ws?.readyState !== this._WS.OPEN) {\n\t\t\tthis._logger.info('Socket not open, removed listener locally {subId}', { subId });\n\t\t\treturn;\n\t\t}\n\n\t\tconst id = this.rpcId;\n\t\tthis.rpcId++;\n\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis._logger.info('Unsubscribed {subId}', { subId });\n\t\t\t},\n\t\t\terrorCallback || ((e: Error) => this._logger.error('Unsubscribe failed', { e })),\n\t\t\tid as Exclude<RpcSubId, null>,\n\t\t);\n\n\t\ttry {\n\t\t\tthis.sendRpcMessage('unsubscribe', { subId }, id);\n\t\t} catch (e) {\n\t\t\tthis.removeRpcListener(id as Exclude<RpcSubId, null>);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\tget activeSubscriptions() {\n\t\treturn Object.keys(this.subListeners);\n\t}\n\n\tclose() {\n\t\tif (this.ws) {\n\t\t\ttry {\n\t\t\t\tthis.ws.close();\n\t\t\t} catch {\n\t\t\t\t// silence\n\t\t\t}\n\t\t\tthis.ws = undefined;\n\t\t}\n\t\tthis.connectionPromise = undefined;\n\t\tthis.stopMessageHandling();\n\t}\n\n\tonClose(callback: (e: CloseEvent) => void) {\n\t\tthis.onCloseCallbacks.push(callback);\n\t}\n}\n","import { type SerializedBlindedMessage, type SerializedBlindedSignature } from './blinded';\n\nexport const MintQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPAID: 'PAID',\n\tISSUED: 'ISSUED',\n} as const;\nexport type MintQuoteState = (typeof MintQuoteState)[keyof typeof MintQuoteState];\n\n/**\n * Base mint quote request - all mint quote requests have these fields (NUT-04) and may have\n * optional fields (NUT-20)\n */\nexport type MintQuoteBaseRequest = {\n\t/**\n\t * Unit to be minted.\n\t */\n\tunit: string;\n\t/**\n\t * Optional. Public key to lock the quote to (NUT-20).\n\t */\n\tpubkey?: string;\n};\n\n/**\n * Base mint quote response - all mint quotes have these fields (NUT-04) and may have optional\n * fields (NUT-20)\n */\nexport type MintQuoteBaseResponse = {\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * Payment request.\n\t */\n\trequest: string;\n\t/**\n\t * Unit of the melt quote.\n\t */\n\tunit: string;\n\t/**\n\t * Optional. Public key the quote is locked to (NUT-20)\n\t */\n\tpubkey?: string;\n};\n\n/**\n * Payload that needs to be sent to the mint when requesting a mint.\n */\nexport type MintRequest = {\n\t/**\n\t * Quote ID received from the mint.\n\t */\n\tquote: string;\n\t/**\n\t * Outputs (blinded messages) to be signed by the mint.\n\t */\n\toutputs: SerializedBlindedMessage[];\n\t/**\n\t * Optional. Signature for the Public key the quote is locked to (NUT-20)\n\t */\n\tsignature?: string;\n};\n\n/**\n * Response from the mint after requesting a mint.\n */\nexport type MintResponse = {\n\tsignatures: SerializedBlindedSignature[];\n};\n","import { type SerializedBlindedMessage, type SerializedBlindedSignature } from './blinded';\nimport { type Proof } from './proof';\n\nexport const MeltQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPENDING: 'PENDING',\n\tPAID: 'PAID',\n} as const;\nexport type MeltQuoteState = (typeof MeltQuoteState)[keyof typeof MeltQuoteState];\n\n/**\n * Base melt quote request - all melt quote requests have these fields (NUT-05)\n */\nexport type MeltQuoteBaseRequest = {\n\t/**\n\t * Unit to be melted.\n\t */\n\tunit: string;\n\t/**\n\t * Request to be melted to.\n\t */\n\trequest: string;\n};\n\n/**\n * Base melt quote response - all melt quotes have these fields (NUT-05)\n */\nexport type MeltQuoteBaseResponse = {\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * Amount to be melted.\n\t */\n\tamount: number;\n\t/**\n\t * Unit of the melt quote.\n\t */\n\tunit: string;\n\t/**\n\t * State of the melt quote.\n\t */\n\tstate: MeltQuoteState;\n\t/**\n\t * Timestamp of when the quote expires.\n\t */\n\texpiry: number;\n\t/**\n\t * Optional change from overpaid fees. If blanks were provided in `outputs`, the mint may return\n\t * signatures here.\n\t */\n\tchange?: SerializedBlindedSignature[];\n};\n\n/**\n * Generic Melt request payload.\n *\n * NUT-05 core fields plus optional blanks for overpayment change.\n */\nexport type MeltRequest = {\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * Proofs to melt.\n\t */\n\tinputs: Proof[];\n\t/**\n\t * Optional blanks for fee change. If present, the mint may return signatures in `change`.\n\t */\n\toutputs?: SerializedBlindedMessage[];\n} & Record<string, unknown>;\n","/**\n * Entries of CheckStateResponse with state of the proof.\n */\nexport type ProofState = {\n\tY: string;\n\tstate: CheckStateEnum;\n\twitness: string | null;\n};\n\n/**\n * Enum for the state of a proof.\n */\nexport const CheckStateEnum = {\n\tUNSPENT: 'UNSPENT',\n\tPENDING: 'PENDING',\n\tSPENT: 'SPENT',\n} as const;\nexport type CheckStateEnum = (typeof CheckStateEnum)[keyof typeof CheckStateEnum];\n\n/**\n * Response when checking proofs if they are spendable. Should not rely on this for receiving, since\n * it can be easily cheated.\n */\nexport type CheckStateResponse = {\n\tstates: ProofState[];\n};\n","import { MeltQuoteState, type MeltQuoteBaseResponse } from '../model/types';\nimport type { Logger } from '../logger';\n\nexport type MeltQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMeltQuoteResponseDeprecated<TQuote extends MeltQuoteBaseResponse>(\n\tresponse: TQuote & MeltQuoteResponsePaidDeprecated,\n\tlogger: Logger,\n): TQuote {\n\t// if the response has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tlogger.warn(\n\t\t\t\"Field 'state' not found in Melt quote response. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)\",\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MeltQuoteState.PAID : MeltQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import { type MintQuoteBolt11Response, MintQuoteState } from '../model/types';\nimport type { Logger } from '../logger';\n\nexport type MintQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMintQuoteResponseDeprecated(\n\tresponse: MintQuoteBolt11Response & MintQuoteResponsePaidDeprecated,\n\tlogger: Logger,\n): MintQuoteBolt11Response {\n\t// if the response has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tlogger.warn(\n\t\t\t\"Field 'state' not found in Mint quote response. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)\",\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MintQuoteState.PAID : MintQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import type { Logger } from '../logger';\nimport { type GetInfoResponse, type MintContactInfo } from '../model/types';\n\nexport function handleMintInfoContactFieldDeprecated(data: GetInfoResponse, logger: Logger) {\n\t// Monkey patch old contact field [\"email\", \"me@mail.com\"] Array<[string, string]>; to new contact field [{method: \"email\", info: \"me@mail.com\"}] Array<MintContactInfo>\n\t// This is to maintain backwards compatibility with older versions of the mint\n\tif (Array.isArray(data?.contact) && data?.contact.length > 0) {\n\t\tdata.contact = data.contact.map((contact: MintContactInfo) => {\n\t\t\tif (\n\t\t\t\tArray.isArray(contact) &&\n\t\t\t\tcontact.length === 2 &&\n\t\t\t\ttypeof contact[0] === 'string' &&\n\t\t\t\ttypeof contact[1] === 'string'\n\t\t\t) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117`,\n\t\t\t\t);\n\t\t\t\treturn { method: contact[0], info: contact[1] } as MintContactInfo;\n\t\t\t}\n\t\t\treturn contact;\n\t\t});\n\t}\n\treturn data;\n}\n","import {\n\ttype GetInfoResponse,\n\ttype MPPMethod,\n\ttype SwapMethod,\n\ttype WebSocketSupport,\n} from './types';\n\ntype Method = 'GET' | 'POST';\ntype Endpoint = { method: Method; path: string };\n\ntype ProtectedIndex = {\n\tcache: Record<string, boolean>; // \"METHOD /v1/foo\"\n\texact: Array<{ method: Method; path: string }>;\n\tprefix: Array<{ method: Method; path: string }>;\n};\n\nexport class MintInfo {\n\t// Full mint info response\n\tprivate readonly _mintInfo: GetInfoResponse;\n\t// NUT-22, Blind-auth protected endpoints\n\tprivate readonly _protected22?: ProtectedIndex;\n\t// NUT-21, Clear-auth protected endpoints\n\tprivate readonly _protected21?: ProtectedIndex;\n\n\tconstructor(info: GetInfoResponse) {\n\t\tthis._mintInfo = info;\n\n\t\tconst pe22 = this.toEndpoints(info?.nuts?.[22]?.protected_endpoints);\n\t\tthis._protected22 = this.buildIndex(pe22);\n\n\t\tconst pe21 = this.toEndpoints(info?.nuts?.[21]?.protected_endpoints);\n\t\tthis._protected21 = this.buildIndex(pe21);\n\t}\n\n\tisSupported(num: 4 | 5): { disabled: boolean; params: SwapMethod[] };\n\tisSupported(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20): { supported: boolean };\n\tisSupported(num: 17): { supported: boolean; params?: WebSocketSupport[] };\n\tisSupported(num: 15): { supported: boolean; params?: MPPMethod[] };\n\tisSupported(num: number) {\n\t\tswitch (num) {\n\t\t\tcase 4:\n\t\t\tcase 5: {\n\t\t\t\treturn this.checkMintMelt(num);\n\t\t\t}\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\tcase 9:\n\t\t\tcase 10:\n\t\t\tcase 11:\n\t\t\tcase 12:\n\t\t\tcase 14:\n\t\t\tcase 20: {\n\t\t\t\treturn this.checkGenericNut(num);\n\t\t\t}\n\t\t\tcase 17: {\n\t\t\t\treturn this.checkNut17();\n\t\t\t}\n\t\t\tcase 15: {\n\t\t\t\treturn this.checkNut15();\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error('nut is not supported by cashu-ts');\n\t\t\t}\n\t\t}\n\t}\n\n\trequiresBlindAuthToken(method: 'GET' | 'POST', path: string): boolean {\n\t\treturn this.matchesProtected(this._protected22, method, path);\n\t}\n\n\trequiresClearAuthToken(method: 'GET' | 'POST', path: string): boolean {\n\t\treturn this.matchesProtected(this._protected21, method, path);\n\t}\n\n\tprivate matchesProtected(idx: ProtectedIndex | undefined, method: Method, path: string): boolean {\n\t\tif (!idx) return false;\n\n\t\tconst cacheKey = `${method} ${path}`;\n\t\tconst cached = idx.cache[cacheKey];\n\t\tif (typeof cached === 'boolean') return cached;\n\n\t\tconst exactHit = idx.exact.some((e) => e.method === method && e.path === path);\n\t\tconst prefixHit = exactHit\n\t\t\t? false\n\t\t\t: idx.prefix.some((e) => e.method === method && path.startsWith(e.path));\n\n\t\tconst res = exactHit || prefixHit;\n\t\tidx.cache[cacheKey] = res;\n\t\treturn res;\n\t}\n\n\tprivate checkGenericNut(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20) {\n\t\treturn this._mintInfo.nuts[num]?.supported ? { supported: true } : { supported: false };\n\t}\n\n\tprivate checkMintMelt(num: 4 | 5) {\n\t\tconst mintMeltInfo = this._mintInfo.nuts[num];\n\t\tif (mintMeltInfo && mintMeltInfo.methods.length > 0 && !mintMeltInfo.disabled) {\n\t\t\treturn { disabled: false, params: mintMeltInfo.methods };\n\t\t}\n\t\treturn { disabled: true, params: mintMeltInfo?.methods ?? [] };\n\t}\n\n\tprivate checkNut17() {\n\t\tif (this._mintInfo.nuts[17] && this._mintInfo.nuts[17].supported.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[17].supported };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\n\tprivate checkNut15() {\n\t\tif (this._mintInfo.nuts[15] && this._mintInfo.nuts[15].methods.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[15].methods };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\n\t// ---------- private helpers ----------\n\n\tprivate toEndpoints(maybe: unknown): Endpoint[] {\n\t\tif (!Array.isArray(maybe)) return [];\n\t\tconst out: Endpoint[] = [];\n\t\tfor (const e of maybe) {\n\t\t\tif (e && typeof e === 'object') {\n\t\t\t\tconst rec = e as Record<string, unknown>;\n\t\t\t\tconst mm = rec.method;\n\t\t\t\tconst pp = rec.path;\n\t\t\t\tif (typeof mm === 'string' && typeof pp === 'string') {\n\t\t\t\t\tconst method = mm.toUpperCase();\n\t\t\t\t\tif (method === 'GET' || method === 'POST') {\n\t\t\t\t\t\tout.push({ method, path: pp });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\n\tprivate buildIndex(endpoints?: Endpoint[]): ProtectedIndex | undefined {\n\t\tif (!endpoints || endpoints.length === 0) return undefined;\n\n\t\tconst exact: ProtectedIndex['exact'] = [];\n\t\tconst prefix: ProtectedIndex['prefix'] = [];\n\n\t\tfor (const e of endpoints) {\n\t\t\tlet p = e.path;\n\t\t\tif (p.startsWith('^')) p = p.slice(1);\n\t\t\tif (p.endsWith('$')) p = p.slice(0, -1);\n\t\t\tif (p.endsWith('.*')) {\n\t\t\t\tprefix.push({ method: e.method, path: p.slice(0, -2) });\n\t\t\t} else {\n\t\t\t\texact.push({ method: e.method, path: p });\n\t\t\t}\n\t\t}\n\n\t\tconst cache: Record<string, boolean> = {};\n\t\treturn { cache, exact, prefix };\n\t}\n\n\t// ---------- getters ----------\n\n\tget cache(): GetInfoResponse {\n\t\treturn this._mintInfo;\n\t}\n\tget contact() {\n\t\treturn this._mintInfo.contact;\n\t}\n\tget description() {\n\t\treturn this._mintInfo.description;\n\t}\n\tget description_long() {\n\t\treturn this._mintInfo.description_long;\n\t}\n\tget name() {\n\t\treturn this._mintInfo.name;\n\t}\n\tget pubkey() {\n\t\treturn this._mintInfo.pubkey;\n\t}\n\tget nuts() {\n\t\treturn this._mintInfo.nuts;\n\t}\n\tget version() {\n\t\treturn this._mintInfo.version;\n\t}\n\tget motd() {\n\t\treturn this._mintInfo.motd;\n\t}\n\n\t/**\n\t * @deprecated Use supportsNut04Description(method, unit)\n\t */\n\tget supportsBolt12Description(): boolean {\n\t\treturn this.supportsNut04Description('bolt12');\n\t}\n\n\t/**\n\t * Checks if the mint supports creating invoices/offers with a description for the specified\n\t * payment method.\n\t *\n\t * @param method - The payment method to check ('bolt11' or 'bolt12')\n\t * @returns True if the mint supports description for the method, false otherwise.\n\t */\n\tsupportsNut04Description(method: 'bolt11' | 'bolt12', unit?: string): boolean {\n\t\treturn this._mintInfo.nuts[4]?.methods.some(\n\t\t\t(met) =>\n\t\t\t\tmet.method === method &&\n\t\t\t\t(unit ? met.unit === unit : true) &&\n\t\t\t\t(met.options?.description === true || met.description === true),\n\t\t);\n\t}\n\n\tsupportsAmountless(method: string = 'bolt11', unit: string = 'sat'): boolean {\n\t\tconst meltMethods = this._mintInfo?.nuts?.[5]?.methods ?? [];\n\n\t\tif (!Array.isArray(meltMethods)) return false;\n\n\t\treturn meltMethods.some(\n\t\t\t(met) => met.method === method && met.unit === unit && met.options?.amountless === true,\n\t\t);\n\t}\n}\n","import { randomBytes } from '@noble/curves/utils.js';\nimport { type Logger, NULL_LOGGER, safeCallback } from '../logger';\nimport { Bytes, encodeUint8toBase64Url } from '../utils';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { type GetInfoResponse } from '../model/types';\n\nexport type OIDCConfig = {\n\tissuer: string;\n\tauthorization_endpoint?: string;\n\ttoken_endpoint: string;\n\tdevice_authorization_endpoint?: string;\n};\n\nexport type TokenResponse = {\n\taccess_token?: string;\n\ttoken_type?: string;\n\texpires_in?: number;\n\trefresh_token?: string;\n\tid_token?: string;\n\tscope?: string;\n\terror?: string;\n\terror_description?: string;\n};\n\nexport type DeviceStartResponse = {\n\tdevice_code: string;\n\tuser_code: string;\n\tverification_uri: string;\n\tverification_uri_complete?: string;\n\tinterval?: number;\n\texpires_in?: number;\n};\n\nexport type OIDCAuthOptions = {\n\tclientId?: string;\n\tscope?: string;\n\tlogger?: Logger;\n\tonTokens?: (t: TokenResponse) => void | Promise<void>;\n};\n\nexport class OIDCAuth {\n\tprivate readonly discoveryUrl: string;\n\tprivate readonly logger: Logger;\n\n\tprivate clientId: string;\n\tprivate scope: string;\n\tprivate config?: OIDCConfig;\n\tprivate onTokens?: (t: TokenResponse) => void | Promise<void>;\n\n\t// External listeners, notified after onTokens fires\n\tprivate tokenListeners: Array<(t: TokenResponse) => void | Promise<void>> = [];\n\n\tstatic fromMintInfo(info: { nuts: GetInfoResponse['nuts'] }, opts?: OIDCAuthOptions): OIDCAuth {\n\t\tconst n21 = info?.nuts?.['21'];\n\t\tif (!n21?.openid_discovery) {\n\t\t\tthrow new Error('OIDCAuth: mint does not advertise NUT-21 openid_discovery');\n\t\t}\n\t\tconst clientId = opts?.clientId ?? n21.client_id ?? 'cashu-client';\n\t\treturn new OIDCAuth(n21.openid_discovery, { ...opts, clientId });\n\t}\n\n\tconstructor(discoveryUrl: string, opts?: OIDCAuthOptions) {\n\t\tthis.discoveryUrl = discoveryUrl;\n\t\tthis.logger = opts?.logger ?? NULL_LOGGER;\n\t\tthis.clientId = opts?.clientId ?? 'cashu-client';\n\t\tthis.scope = opts?.scope ?? 'openid';\n\t\tthis.onTokens = opts?.onTokens;\n\t}\n\n\tsetClient(id: string): void {\n\t\tthis.clientId = id;\n\t}\n\n\tsetScope(scope?: string): void {\n\t\tthis.scope = scope ?? 'openid';\n\t}\n\n\t/**\n\t * Subscribe to token updates. Listeners are called after the primary onTokens callback.\n\t */\n\taddTokenListener(fn: (t: TokenResponse) => void | Promise<void>): void {\n\t\tthis.tokenListeners.push(fn);\n\t}\n\n\t// ---- Discovery ----\n\n\tasync loadConfig(): Promise<OIDCConfig> {\n\t\tif (this.config) return this.config;\n\t\tconst res = await fetch(this.discoveryUrl, {\n\t\t\tmethod: 'GET',\n\t\t\theaders: { Accept: 'application/json' },\n\t\t});\n\t\tconst text = await res.text();\n\t\tlet json: unknown;\n\t\ttry {\n\t\t\tjson = text ? JSON.parse(text) : undefined;\n\t\t} catch (err) {\n\t\t\tthis.logger.warn('OIDCAuth: bad discovery JSON', { err });\n\t\t}\n\t\tif (!res.ok || !json) {\n\t\t\tthrow new Error('OIDCAuth: invalid discovery document');\n\t\t}\n\t\tconst cfg = json as OIDCConfig;\n\t\tif (typeof cfg.token_endpoint !== 'string' || cfg.token_endpoint.length === 0) {\n\t\t\tthrow new Error('OIDCAuth: invalid discovery document, missing token_endpoint');\n\t\t}\n\t\tthis.config = cfg;\n\t\treturn cfg;\n\t}\n\n\t// --- Authorization Code with PKCE ---\n\n\t/**\n\t * Generate a PKCE verifier and S256 challenge.\n\t *\n\t * - Verifier: base64url of random bytes, length >= 43, RFC 7636 compliant.\n\t * - Challenge: base64url(sha256(verifier))\n\t */\n\tgeneratePKCE(): { verifier: string; challenge: string } {\n\t\t// 48 bytes->base64url is typically 64 chars without padding, comfortably >= 43\n\t\tconst rnd = randomBytes(48);\n\t\tconst verifier = encodeUint8toBase64Url(rnd);\n\n\t\t// RFC 7636, challenge = BASE64URL-ENCODE( SHA256( ASCII(verifier) ) )\n\t\tconst vBytes = Bytes.fromString(verifier);\n\t\tconst chBytes = sha256(vBytes);\n\t\tconst challenge = encodeUint8toBase64Url(chBytes);\n\n\t\treturn { verifier, challenge };\n\t}\n\n\t/**\n\t * Build an Authorization Code + PKCE URL.\n\t */\n\tasync buildAuthCodeUrl(input: {\n\t\tredirectUri: string;\n\t\tcodeChallenge: string;\n\t\tcodeChallengeMethod?: 'S256' | 'plain'; // default S256\n\t\tstate?: string; // optional state to pass back to redirectUrl\n\t\tscope?: string; // default this.scope\n\t}): Promise<string> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst scope = input.scope ?? this.scope;\n\t\tconst params = new URLSearchParams({\n\t\t\tresponse_type: 'code',\n\t\t\tclient_id: this.clientId,\n\t\t\tredirect_uri: input.redirectUri,\n\t\t\tscope,\n\t\t\tcode_challenge_method: input.codeChallengeMethod ?? 'S256',\n\t\t\tcode_challenge: input.codeChallenge,\n\t\t});\n\t\tif (input.state) params.set('state', input.state);\n\n\t\tif (!cfg.authorization_endpoint) {\n\t\t\tthrow new Error('OIDCAuth: discovery lacks authorization_endpoint');\n\t\t}\n\t\treturn `${cfg.authorization_endpoint}?${params.toString()}`;\n\t}\n\n\t/**\n\t * Exchange an auth code for tokens, using the PKCE verifier.\n\t */\n\tasync exchangeAuthCode(input: { code: string; redirectUri: string; codeVerifier: string }) {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst form = this.toForm({\n\t\t\tgrant_type: 'authorization_code',\n\t\t\tcode: input.code,\n\t\t\tredirect_uri: input.redirectUri,\n\t\t\tclient_id: this.clientId,\n\t\t\tcode_verifier: input.codeVerifier,\n\t\t});\n\t\tconst tok = await this.postFormStrict<TokenResponse>(cfg.token_endpoint, form);\n\t\tthis.handleTokens(tok);\n\t\treturn tok;\n\t}\n\n\t// ---- Device Code (recommended for CLIs) ----\n\n\tasync deviceStart(): Promise<DeviceStartResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst ep = cfg.device_authorization_endpoint;\n\t\tif (!ep) throw new Error('OIDCAuth: provider lacks device_authorization_endpoint');\n\n\t\tconst form = this.toForm({ client_id: this.clientId, scope: this.scope });\n\t\treturn this.postFormStrict<DeviceStartResponse>(ep, form);\n\t}\n\n\tasync devicePoll(device_code: string, intervalSec = 5): Promise<TokenResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\t// Clamp to a sensible minimum to avoid hot loops\n\t\tlet delay = Math.max(1, intervalSec);\n\t\twhile (true) {\n\t\t\tawait this.sleep(delay * 1000);\n\t\t\tconst form = this.toForm({\n\t\t\t\tgrant_type: 'urn:ietf:params:oauth:grant-type:device_code',\n\t\t\t\tdevice_code,\n\t\t\t\tclient_id: this.clientId,\n\t\t\t});\n\t\t\tconst res = await this.postFormLoose<TokenResponse>(cfg.token_endpoint, form);\n\t\t\tif (res.access_token) {\n\t\t\t\tthis.handleTokens(res);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\tconst err = (res.error ?? '').toString();\n\t\t\tif (err === 'authorization_pending') continue;\n\t\t\tif (err === 'slow_down') {\n\t\t\t\tdelay = Math.max(delay + 5, delay * 2);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst msg = res.error_description || err || 'device authorization failed';\n\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t}\n\t}\n\n\t/**\n\t * One call convenience for Device Code flow.\n\t *\n\t * @remarks\n\t * Polling interval will be the MAX of intervalSec and Mint interval.\n\t * @param intervalSec Desired polling interval in seconds.\n\t * @returns The start fields and helpers to poll or cancel.\n\t */\n\tasync startDeviceAuth(intervalSec: number = 5): Promise<\n\t\tDeviceStartResponse & {\n\t\t\tpoll: () => Promise<TokenResponse>;\n\t\t\tcancel: () => void;\n\t\t}\n\t> {\n\t\tconst start = await this.deviceStart();\n\t\tconst interval = Math.max(start.interval ?? 1, intervalSec);\n\t\tlet aborted = false;\n\n\t\tconst poll = async (): Promise<TokenResponse> => {\n\t\t\tconst cfg = await this.loadConfig();\n\t\t\tlet delay = Math.max(1, interval);\n\t\t\twhile (true) {\n\t\t\t\tif (aborted) throw new Error('OIDCAuth: device polling cancelled');\n\t\t\t\tawait this.sleep(delay * 1000);\n\t\t\t\tconst form = this.toForm({\n\t\t\t\t\tgrant_type: 'urn:ietf:params:oauth:grant-type:device_code',\n\t\t\t\t\tdevice_code: start.device_code,\n\t\t\t\t\tclient_id: this.clientId,\n\t\t\t\t});\n\t\t\t\tconst res = await this.postFormLoose<TokenResponse>(cfg.token_endpoint, form);\n\t\t\t\tif (res.access_token) {\n\t\t\t\t\tthis.handleTokens(res);\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tconst err = (res.error ?? '').toString();\n\t\t\t\tif (err === 'authorization_pending') continue;\n\t\t\t\tif (err === 'slow_down') {\n\t\t\t\t\tdelay = Math.max(delay + 5, delay * 2);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst msg = res.error_description || err || 'device authorization failed';\n\t\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t\t}\n\t\t};\n\n\t\tconst cancel = (): void => {\n\t\t\taborted = true;\n\t\t};\n\n\t\treturn { ...start, poll, cancel };\n\t}\n\n\t// ---- Refresh ----\n\n\tasync refresh(refresh_token: string): Promise<TokenResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst form = this.toForm({\n\t\t\tgrant_type: 'refresh_token',\n\t\t\trefresh_token,\n\t\t\tclient_id: this.clientId,\n\t\t});\n\t\tconst tok = await this.postFormStrict<TokenResponse>(cfg.token_endpoint, form);\n\t\tthis.handleTokens(tok);\n\t\treturn tok;\n\t}\n\n\t// ---- ROPC (discouraged, but some mints allow it) ----\n\n\tasync passwordGrant(username: string, password: string): Promise<TokenResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst form = this.toForm({\n\t\t\tgrant_type: 'password',\n\t\t\tclient_id: this.clientId,\n\t\t\tusername,\n\t\t\tpassword,\n\t\t\tscope: this.scope,\n\t\t});\n\t\tconst tok = await this.postFormStrict<TokenResponse>(cfg.token_endpoint, form);\n\t\tthis.handleTokens(tok);\n\t\treturn tok;\n\t}\n\n\t// ---- internals ----\n\n\t/**\n\t * Fire and forget token fan out. Any listener errors are logged inside safeCallback. Nothing\n\t * thrown here will come from listeners.\n\t */\n\tprivate handleTokens(t: TokenResponse): void {\n\t\tif (!t.access_token) {\n\t\t\tconst msg = t.error_description || t.error || 'token response missing access_token';\n\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t}\n\t\t// Schedule on microtask queue so we never block the caller and we avoid sync throws leaking.\n\t\tqueueMicrotask(() =>\n\t\t\tsafeCallback(this.onTokens, t, this.logger, { where: 'OIDCAuth.handleTokens' }),\n\t\t);\n\n\t\tfor (const listener of this.tokenListeners) {\n\t\t\tqueueMicrotask(() =>\n\t\t\t\tsafeCallback(listener, t, this.logger, {\n\t\t\t\t\twhere: 'OIDCAuth.handleTokens.listener',\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate toForm(params: Record<string, string>): string {\n\t\tconst enc = (v: string) => encodeURIComponent(v).replace(/%20/g, '+');\n\t\treturn Object.entries(params)\n\t\t\t.map(([k, v]) => `${enc(k)}=${enc(v)}`)\n\t\t\t.join('&');\n\t}\n\n\t// Strict, throws on non 2xx\n\tprivate async postFormStrict<TSuccess extends object>(\n\t\tendpoint: string,\n\t\tformBody: string,\n\t): Promise<TSuccess> {\n\t\ttry {\n\t\t\tthis.logger.debug('OIDCAuth Request', { formBody });\n\t\t\tconst res = await fetch(endpoint, {\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/x-www-form-urlencoded',\n\t\t\t\t\tAccept: 'application/json',\n\t\t\t\t},\n\t\t\t\tbody: formBody,\n\t\t\t});\n\t\t\tconst text = await res.text();\n\t\t\tlet json: unknown;\n\t\t\ttry {\n\t\t\t\tjson = text ? JSON.parse(text) : undefined;\n\t\t\t} catch (err) {\n\t\t\t\tthis.logger.warn('OIDCAuth: bad JSON (strict)', { err });\n\t\t\t}\n\t\t\tif (!res.ok) {\n\t\t\t\tconst err = (json ?? {}) as TokenResponse;\n\t\t\t\tconst msg = err.error_description || err.error || `HTTP ${res.status}`;\n\t\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t\t}\n\t\t\tthis.logger.debug('OIDCAuth Response', { json });\n\t\t\treturn (json ?? {}) as TSuccess;\n\t\t} catch (err) {\n\t\t\tthis.logger.error('OIDCAuth: postFormStrict failed', { err });\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t// Loose, returns JSON payload even on non 2xx\n\tprivate async postFormLoose<T extends object>(\n\t\tendpoint: string,\n\t\tformBody: string,\n\t): Promise<T | TokenResponse> {\n\t\ttry {\n\t\t\tthis.logger.debug('OIDCAuth Request', { formBody });\n\t\t\tconst res = await fetch(endpoint, {\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/x-www-form-urlencoded',\n\t\t\t\t\tAccept: 'application/json',\n\t\t\t\t},\n\t\t\t\tbody: formBody,\n\t\t\t});\n\t\t\tconst text = await res.text();\n\t\t\tlet json: unknown;\n\t\t\ttry {\n\t\t\t\tjson = text ? JSON.parse(text) : undefined;\n\t\t\t} catch (err) {\n\t\t\t\tthis.logger.warn('OIDCAuth: bad JSON (loose)', { err });\n\t\t\t}\n\t\t\tthis.logger.debug('OIDCAuth Response', { json });\n\t\t\treturn (json ?? {}) as T | TokenResponse;\n\t\t} catch (err) {\n\t\t\tthis.logger.error('OIDCAuth: postFormLoose network error', { err });\n\t\t\treturn { error: 'network_error', error_description: String(err) };\n\t\t}\n\t}\n\n\tprivate sleep(ms: number): Promise<void> {\n\t\treturn new Promise<void>((resolve) => setTimeout(resolve, ms));\n\t}\n}\n","/**\n * Cashu Mint Class.\n *\n * @remarks\n * You should ordinarily not need to instantiate a Mint, as it will be auto-instantiated by the\n * Wallet class when you pass in the mint url.\n */\nimport type {\n\tPostRestoreResponse,\n\tSwapResponse,\n\tCheckStatePayload,\n\tPostRestorePayload,\n} from './types';\nimport type { GetKeysResponse, GetKeysetsResponse } from '../model/types/keyset';\nimport request, {\n\tConnectionManager,\n\ttype WSConnection,\n\tsetRequestLogger,\n\ttype RequestFn,\n\ttype RequestOptions,\n} from '../transport';\nimport { isObj, joinUrls, sanitizeUrl } from '../utils';\nimport {\n\ttype MeltQuoteResponsePaidDeprecated,\n\thandleMeltQuoteResponseDeprecated,\n} from '../legacy/nut-05';\nimport {\n\ttype MintQuoteResponsePaidDeprecated,\n\thandleMintQuoteResponseDeprecated,\n} from '../legacy/nut-04';\nimport { handleMintInfoContactFieldDeprecated } from '../legacy/nut-06';\nimport { MintInfo } from '../model/MintInfo';\nimport { type Logger, NULL_LOGGER, failIf } from '../logger';\nimport type { AuthProvider } from '../auth/AuthProvider';\nimport { OIDCAuth, type OIDCAuthOptions } from '../auth/OIDCAuth';\nimport {\n\ttype MintQuoteBolt11Response,\n\ttype MintQuoteBolt12Response,\n\ttype MeltQuoteBaseResponse,\n\ttype MeltQuoteBolt11Response,\n\ttype MeltQuoteBolt12Response,\n\tMeltQuoteState,\n\ttype MintResponse,\n\ttype GetInfoResponse,\n\ttype MeltRequest,\n\ttype CheckStateResponse,\n\ttype MeltQuoteBolt11Request,\n\ttype MeltQuoteBolt12Request,\n\ttype MintRequest,\n\ttype MintQuoteBolt11Request,\n\ttype MintQuoteBolt12Request,\n\ttype SwapRequest,\n} from '../model/types';\n\n/**\n * Class represents Cashu Mint API.\n *\n * @remarks\n * This class contains lower-level functions that are implemented by Wallet.\n */\nclass Mint {\n\tprivate ws?: WSConnection;\n\tprivate _mintUrl: string;\n\tprivate _request: RequestFn;\n\tprivate _logger: Logger;\n\tprivate _mintInfo?: MintInfo;\n\tprivate _authProvider?: AuthProvider;\n\n\t/**\n\t * @param mintUrl Requires mint URL to create this object.\n\t * @param customRequest Optional, for custom network communication with the mint.\n\t * @param authTokenGetter Optional. Function to obtain a NUT-22 BlindedAuthToken (e.g. from a\n\t *   database or localstorage)\n\t */\n\tconstructor(\n\t\tmintUrl: string,\n\t\toptions?: {\n\t\t\tcustomRequest?: RequestFn;\n\t\t\tauthProvider?: AuthProvider;\n\t\t\tlogger?: Logger;\n\t\t},\n\t) {\n\t\tthis._mintUrl = sanitizeUrl(mintUrl);\n\t\tthis._request = options?.customRequest ?? request;\n\t\tthis._authProvider = options?.authProvider;\n\t\tthis._logger = options?.logger ?? NULL_LOGGER;\n\t\tsetRequestLogger(this._logger);\n\t}\n\n\tget mintUrl() {\n\t\treturn this._mintUrl;\n\t}\n\n\t/**\n\t * Create an OIDC client using this mintâ€™s NUT-21 metadata.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const oidc = await mint.oidcAuth({ onTokens: (t) => authMgr.setCAT(t.access_token!) });\n\t * const start = await oidc.deviceStart();\n\t * // show start.user_code / start.verification_uri to the user\n\t * const token = await oidc.devicePoll(start.device_code, start.interval ?? 5);\n\t * // token.access_token is your CAT\n\t * ```\n\t */\n\tasync oidcAuth(opts?: OIDCAuthOptions): Promise<OIDCAuth> {\n\t\tconst n21 = (await this.getLazyMintInfo()).nuts['21'];\n\t\tif (!n21?.openid_discovery) {\n\t\t\tthrow new Error('Mint: no NUT-21 openid_discovery');\n\t\t}\n\t\treturn new OIDCAuth(n21.openid_discovery, {\n\t\t\t...opts,\n\t\t\tclientId: opts?.clientId ?? n21.client_id ?? 'cashu-client',\n\t\t});\n\t}\n\n\t/**\n\t * Fetches mint's info at the /info endpoint.\n\t *\n\t * @param customRequest Optional override for the request function.\n\t * @returns The mint's information response.\n\t */\n\tasync getInfo(customRequest?: RequestFn): Promise<GetInfoResponse> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\tconst response = await requestInstance<GetInfoResponse>({\n\t\t\tendpoint: joinUrls(this._mintUrl, '/v1/info'),\n\t\t});\n\t\tconst data = handleMintInfoContactFieldDeprecated(response, this._logger);\n\t\treturn data;\n\t}\n\n\t/**\n\t * Lazily fetches and caches the mint's info if not already loaded.\n\t *\n\t * @returns The parsed MintInfo object.\n\t */\n\tasync getLazyMintInfo(): Promise<MintInfo> {\n\t\tif (this._mintInfo) {\n\t\t\treturn this._mintInfo;\n\t\t}\n\t\tconst data = await this.getInfo();\n\t\tthis._mintInfo = new MintInfo(data);\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Performs a swap operation with ecash inputs and outputs.\n\t *\n\t * @param swapPayload Payload containing inputs and outputs.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Signed outputs.\n\t */\n\tasync swap(swapPayload: SwapRequest, customRequest?: RequestFn): Promise<SwapResponse> {\n\t\tconst data = await this.requestWithAuth<SwapResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/swap',\n\t\t\t{ requestBody: swapPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'swap' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new mint quote from the mint.\n\t *\n\t * @param mintQuotePayload Payload for creating a new mint quote.\n\t * @param customRequest Optional override for the request function.\n\t * @returns A new mint quote containing a payment request for the specified amount and unit.\n\t */\n\tasync createMintQuoteBolt11(\n\t\tmintQuotePayload: MintQuoteBolt11Request,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MintQuoteBolt11Response> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tMintQuoteBolt11Response & MintQuoteResponsePaidDeprecated\n\t\t>('POST', '/v1/mint/quote/bolt11', { requestBody: mintQuotePayload }, customRequest);\n\t\tconst data = handleMintQuoteResponseDeprecated(response, this._logger);\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new BOLT12 mint quote from the mint using Lightning Network offers.\n\t *\n\t * @param mintQuotePayload Payload containing amount, unit, optional description, and required\n\t *   pubkey.\n\t * @param customRequest Optional override for the request function.\n\t * @returns A mint quote containing a BOLT12 offer.\n\t */\n\tasync createMintQuoteBolt12(\n\t\tmintQuotePayload: MintQuoteBolt12Request,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MintQuoteBolt12Response> {\n\t\tconst response = await this.requestWithAuth<MintQuoteBolt12Response>(\n\t\t\t'POST',\n\t\t\t'/v1/mint/quote/bolt12',\n\t\t\t{ requestBody: mintQuotePayload },\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The status of the mint quote, including payment details and state.\n\t */\n\tasync checkMintQuoteBolt11(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MintQuoteBolt11Response> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tMintQuoteBolt11Response & MintQuoteResponsePaidDeprecated\n\t\t>('GET', `/v1/mint/quote/bolt11/${quote}`, {}, customRequest);\n\n\t\tconst data = handleMintQuoteResponseDeprecated(response, this._logger);\n\t\treturn data;\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 mint quote from the mint.\n\t *\n\t * @param quote Quote ID to check.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Updated quote with current payment and issuance amounts.\n\t */\n\tasync checkMintQuoteBolt12(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MintQuoteBolt12Response> {\n\t\tconst response = await this.requestWithAuth<MintQuoteBolt12Response>(\n\t\t\t'GET',\n\t\t\t`/v1/mint/quote/bolt12/${quote}`,\n\t\t\t{},\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Mints new tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Serialized blinded signatures.\n\t */\n\tasync mintBolt11(mintPayload: MintRequest, customRequest?: RequestFn): Promise<MintResponse> {\n\t\tconst data = await this.requestWithAuth<MintResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/mint/bolt11',\n\t\t\t{ requestBody: mintPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'mintBolt11' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Mints new tokens using a BOLT12 quote by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the quote ID and outputs to get blind signatures on.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Serialized blinded signatures for the requested outputs.\n\t */\n\tasync mintBolt12(mintPayload: MintRequest, customRequest?: RequestFn): Promise<MintResponse> {\n\t\tconst data = await this.requestWithAuth<MintResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/mint/bolt12',\n\t\t\t{ requestBody: mintPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'mintBolt12' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new melt quote from the mint.\n\t *\n\t * @param meltQuotePayload Payload for creating a new melt quote.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The melt quote response.\n\t */\n\tasync createMeltQuoteBolt11(\n\t\tmeltQuotePayload: MeltQuoteBolt11Request,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MeltQuoteBolt11Response> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tMeltQuoteBolt11Response & MeltQuoteResponsePaidDeprecated\n\t\t>('POST', '/v1/melt/quote/bolt11', { requestBody: meltQuotePayload }, customRequest);\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, this._logger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string'\n\t\t) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'createMeltQuoteBolt11' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new BOLT12 melt quote from the mint for paying a Lightning Network offer. For\n\t * amount-less offers, specify the amount in options.amountless.amount_msat.\n\t *\n\t * @param meltQuotePayload Payload containing the BOLT12 offer to pay and unit.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Melt quote with amount, fee reserve, and payment state.\n\t */\n\tasync createMeltQuoteBolt12(\n\t\tmeltQuotePayload: MeltQuoteBolt12Request,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MeltQuoteBolt12Response> {\n\t\tconst response = await this.requestWithAuth<MeltQuoteBolt12Response>(\n\t\t\t'POST',\n\t\t\t'/v1/melt/quote/bolt12',\n\t\t\t{ requestBody: meltQuotePayload },\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Gets an existing melt quote.\n\t *\n\t * @param quote Quote ID.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The melt quote response.\n\t */\n\tasync checkMeltQuoteBolt11(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MeltQuoteBolt11Response> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tMeltQuoteBolt11Response & MeltQuoteResponsePaidDeprecated\n\t\t>('GET', `/v1/melt/quote/bolt11/${quote}`, {}, customRequest);\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, this._logger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string' ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'checkMeltQuoteBolt11' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 melt quote from the mint. Returns current payment state (UNPAID,\n\t * PENDING, or PAID) and payment preimage if paid.\n\t *\n\t * @param quote Quote ID to check.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Updated quote with current payment state and preimage if available.\n\t */\n\tasync checkMeltQuoteBolt12(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MeltQuoteBolt12Response> {\n\t\tconst response = await this.requestWithAuth<MeltQuoteBolt12Response>(\n\t\t\t'GET',\n\t\t\t`/v1/melt/quote/bolt12/${quote}`,\n\t\t\t{},\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Generic method to melt tokens using any payment method endpoint.\n\t *\n\t * @remarks\n\t * This method enables support for custom payment methods without modifying the Mint class. It\n\t * constructs the endpoint as `/v1/melt/{method}` and POSTs the payload. The response must contain\n\t * the common fields: quote, amount, fee_reserve, state, expiry.\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await mint.melt('bolt11', { quote: 'q1', inputs: [...], outputs: [...] });\n\t * const response = await mint.melt('custom-payment', { quote: 'c1', inputs: [...], outputs: [...] });\n\t * ```\n\t *\n\t * @param method The payment method (e.g., 'bolt11', 'bolt12', or custom method name).\n\t * @param meltPayload The melt payload containing inputs and optional outputs.\n\t * @param options.customRequest Optional override for the request function.\n\t * @param options.preferAsync Optional override to set 'respond-async' header.\n\t * @returns A response object with at least the required melt quote fields.\n\t */\n\tasync melt<TRes extends Record<string, unknown> = Record<string, unknown>>(\n\t\tmethod: string,\n\t\tmeltPayload: MeltRequest,\n\t\toptions?: {\n\t\t\tcustomRequest?: RequestFn;\n\t\t\tpreferAsync?: boolean;\n\t\t},\n\t): Promise<MeltQuoteBaseResponse & TRes> {\n\t\t// Set headers as needed\n\t\tconst headers: Record<string, string> = {\n\t\t\t...(options?.preferAsync ? { Prefer: 'respond-async' } : {}),\n\t\t};\n\t\t// Validate method string and make request\n\t\tfailIf(!this.isValidMethodString(method), `Invalid melt method: ${method}`, this._logger);\n\t\tconst data = await this.requestWithAuth<MeltQuoteBaseResponse & TRes>(\n\t\t\t'POST',\n\t\t\t`/v1/melt/${method}`,\n\t\t\t{ requestBody: meltPayload, headers },\n\t\t\toptions?.customRequest,\n\t\t);\n\n\t\t// Runtime shape check for basic MeltQuoteBaseResponse\n\t\t// TODO: - Tests need updating before we can do full shape check!\n\t\tif (\n\t\t\t!isObj(data) //||\n\t\t\t// typeof data.quote !== 'string' ||\n\t\t\t// typeof data.amount !== 'number' ||\n\t\t\t// typeof data.unit !== 'string' ||\n\t\t\t// typeof data.expiry !== 'number' ||\n\t\t\t// !Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'melt' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests the mint to pay for a Bolt11 payment request by providing ecash as inputs to be spent.\n\t * The inputs contain the amount and the fee_reserves for a Lightning payment. The payload can\n\t * also contain blank outputs in order to receive back overpaid Lightning fees.\n\t *\n\t * @param meltPayload The melt payload containing inputs and optional outputs.\n\t * @param options.customRequest Optional override for the request function.\n\t * @param options.preferAsync Optional override to set 'respond-async' header.\n\t * @returns The melt response.\n\t */\n\tasync meltBolt11(\n\t\tmeltPayload: MeltRequest,\n\t\toptions?: {\n\t\t\tcustomRequest?: RequestFn;\n\t\t\tpreferAsync?: boolean;\n\t\t},\n\t): Promise<MeltQuoteBolt11Response> {\n\t\tconst response = await this.melt<MeltQuoteBolt11Response>('bolt11', meltPayload, options);\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, this._logger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'meltBolt11' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests the mint to pay a BOLT12 offer by providing ecash inputs to be spent. The inputs must\n\t * cover the amount plus fee reserves. Optional outputs can be included to receive change for\n\t * overpaid Lightning fees.\n\t *\n\t * @param meltPayload Payload containing quote ID, inputs, and optional outputs for change.\n\t * @param options.customRequest Optional override for the request function.\n\t * @param options.preferAsync Optional override to set 'respond-async' header.\n\t * @returns Payment result with state and optional change signatures.\n\t */\n\tasync meltBolt12(\n\t\tmeltPayload: MeltRequest,\n\t\toptions?: {\n\t\t\tcustomRequest?: RequestFn;\n\t\t\tpreferAsync?: boolean;\n\t\t},\n\t): Promise<MeltQuoteBolt12Response> {\n\t\treturn this.melt<MeltQuoteBolt12Response>('bolt12', meltPayload, options);\n\t}\n\n\t/**\n\t * Checks if specific proofs have already been redeemed.\n\t *\n\t * @param checkPayload The payload containing proofs to check.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Redeemed and unredeemed ordered list of booleans.\n\t */\n\tasync check(\n\t\tcheckPayload: CheckStatePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<CheckStateResponse> {\n\t\tconst data = await this.requestWithAuth<CheckStateResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/checkstate',\n\t\t\t{ requestBody: checkPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.states)) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'check' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Get the mint's public keys.\n\t *\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @param mintUrl Optional alternative mint URL to use for this request.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The mint's public keys.\n\t */\n\tasync getKeys(\n\t\tkeysetId?: string,\n\t\tmintUrl?: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<GetKeysResponse> {\n\t\tconst targetUrl = mintUrl || this._mintUrl;\n\t\t// backwards compatibility for base64 encoded keyset ids\n\t\tif (keysetId) {\n\t\t\t// make the keysetId url safe\n\t\t\tkeysetId = keysetId.replace(/\\//g, '_').replace(/\\+/g, '-');\n\t\t}\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\tconst data = await requestInstance<GetKeysResponse>({\n\t\t\tendpoint: keysetId\n\t\t\t\t? joinUrls(targetUrl, '/v1/keys', keysetId)\n\t\t\t\t: joinUrls(targetUrl, '/v1/keys'),\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data.keysets)) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'getKeys' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Get the mint's keysets in no specific order.\n\t *\n\t * @param customRequest Optional override for the request function.\n\t * @returns All the mint's past and current keysets.\n\t */\n\tasync getKeySets(customRequest?: RequestFn): Promise<GetKeysetsResponse> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\treturn requestInstance<GetKeysetsResponse>({\n\t\t\tendpoint: joinUrls(this._mintUrl, '/v1/keysets'),\n\t\t});\n\t}\n\n\t/**\n\t * Restores proofs from the provided blinded messages.\n\t *\n\t * @param restorePayload The payload containing outputs to restore.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The restore response with outputs and signatures.\n\t */\n\tasync restore(\n\t\trestorePayload: PostRestorePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<PostRestoreResponse> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\tconst data = await requestInstance<PostRestoreResponse>({\n\t\t\tendpoint: joinUrls(this._mintUrl, '/v1/restore'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: restorePayload,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.outputs) || !Array.isArray(data?.signatures)) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'restore' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Tries to establish a websocket connection with the websocket mint url according to NUT-17.\n\t */\n\tasync connectWebSocket() {\n\t\ttry {\n\t\t\tconst mintUrl = new URL(this._mintUrl);\n\t\t\tconst wsSegment = 'v1/ws';\n\n\t\t\tif (mintUrl.pathname.endsWith('/')) mintUrl.pathname += wsSegment;\n\t\t\telse mintUrl.pathname += '/' + wsSegment;\n\n\t\t\t// preserve query params if any, and avoid manual string building\n\t\t\tmintUrl.protocol = mintUrl.protocol === 'https:' ? 'wss:' : 'ws:';\n\t\t\tconst wsUrl = mintUrl.toString();\n\n\t\t\tif (!this.ws) {\n\t\t\t\tthis.ws = ConnectionManager.getInstance().getConnection(wsUrl, this._logger);\n\t\t\t}\n\n\t\t\tawait this.ws.ensureConnection();\n\t\t} catch (e) {\n\t\t\tthis._logger.error('Failed to connect to WebSocket...', { e });\n\t\t\ttry {\n\t\t\t\tthis.ws?.close();\n\t\t\t} catch {\n\t\t\t\t// silence\n\t\t\t}\n\t\t\tthis.ws = undefined;\n\t\t\tthrow new Error('Failed to connect to WebSocket...');\n\t\t}\n\t}\n\n\t/**\n\t * Closes a websocket connection.\n\t */\n\tdisconnectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tthis.ws.close();\n\t\t}\n\t}\n\n\tget webSocketConnection() {\n\t\treturn this.ws;\n\t}\n\n\t/**\n\t * Returns the Clear Authentication Token (CAT) to use in the 'Clear-auth' header, or undefined if\n\t * not required for the given path and method.\n\t *\n\t * @param method The method to call on the path.\n\t * @param path The API path to check for blind auth requirement.\n\t * @returns The blind auth token if required, otherwise undefined.\n\t */\n\tprivate async handleClearAuth(method: 'GET' | 'POST', path: string): Promise<string | undefined> {\n\t\tif (!this._authProvider) return undefined;\n\t\tconst info = await this.getLazyMintInfo();\n\t\tif (!info.requiresClearAuthToken(method, path)) return undefined;\n\t\tthis._logger.error('Clear Authentication Token...', { cat: this._authProvider.getCAT() });\n\t\treturn this._authProvider.getCAT();\n\t}\n\n\t/**\n\t * Returns a serialized Blind Authentication Token (BAT) to use in the 'Blind-auth' header, or\n\t * undefined if not required for the given path and method.\n\t *\n\t * @param method The method to call on the path.\n\t * @param path The API path to check for blind auth requirement.\n\t * @returns The blind auth token if required, otherwise undefined.\n\t */\n\tprivate async handleBlindAuth(method: 'GET' | 'POST', path: string): Promise<string | undefined> {\n\t\tif (!this._authProvider) return undefined;\n\t\tconst info = await this.getLazyMintInfo();\n\t\tif (!info.requiresBlindAuthToken(method, path)) return undefined;\n\t\tconst bat = await this._authProvider.getBlindAuthToken({ method, path });\n\t\tthis._logger.error('Blind Authentication Token...', { bat });\n\t\treturn bat;\n\t}\n\n\tprivate async requestWithAuth<T>(\n\t\tmethod: 'GET' | 'POST',\n\t\tpath: string,\n\t\tinit: Omit<RequestOptions, 'endpoint' | 'method' | 'headers' | 'requestBody'> & {\n\t\t\trequestBody?: Record<string, unknown>;\n\t\t\theaders?: Record<string, string>;\n\t\t} = {},\n\t\tcustomRequest?: RequestFn,\n\t): Promise<T> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\t// Get BAT/CAT token if this endpoint is protected\n\t\tconst bat = await this.handleBlindAuth(method, path);\n\t\tconst cat = await this.handleClearAuth(method, path);\n\t\tconst headers: Record<string, string> = {\n\t\t\t...(init.headers ?? {}),\n\t\t\t...(bat ? { 'Blind-auth': bat } : {}),\n\t\t\t...(cat ? { 'Clear-auth': cat } : {}),\n\t\t};\n\t\treturn requestInstance<T>({\n\t\t\t...init,\n\t\t\tendpoint: joinUrls(this._mintUrl, path),\n\t\t\tmethod,\n\t\t\theaders,\n\t\t});\n\t}\n\n\tprivate isValidMethodString(method: unknown): boolean {\n\t\t// Is a string at least one character long, containing only 0-9, a-z, _ or -\n\t\tif (typeof method === 'string' && /^[a-z0-9_-]+$/.test(method)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nexport { Mint };\n","import { isValidHex, deriveKeysetId, isBase64String } from '../utils';\nimport { type MintKeyset, type MintKeys } from '../model/types';\nimport { hexToBytes } from '@noble/curves/utils.js';\n\nexport class Keyset {\n\tprivate _id: string;\n\tprivate _unit: string;\n\tprivate _active: boolean;\n\tprivate _keys: Record<number, string> = {};\n\tprivate _input_fee_ppk?: number;\n\tprivate _final_expiry?: number;\n\n\tconstructor(\n\t\tid: string,\n\t\tunit: string,\n\t\tactive: boolean,\n\t\tinput_fee_ppk?: number,\n\t\tfinal_expiry?: number,\n\t) {\n\t\tthis._id = id;\n\t\tthis._unit = unit;\n\t\tthis._active = active;\n\t\tthis._input_fee_ppk = input_fee_ppk;\n\t\tthis._final_expiry = final_expiry;\n\t}\n\n\tget id(): string {\n\t\treturn this._id;\n\t}\n\n\tget unit(): string {\n\t\treturn this._unit;\n\t}\n\n\tget isActive(): boolean {\n\t\treturn this._active;\n\t}\n\n\tget fee(): number {\n\t\treturn this._input_fee_ppk ?? 0;\n\t}\n\n\tget expiry(): number | undefined {\n\t\treturn this._final_expiry;\n\t}\n\n\tget hasKeys(): boolean {\n\t\treturn Object.keys(this._keys).length > 0;\n\t}\n\n\tget hasHexId(): boolean {\n\t\treturn isValidHex(this._id);\n\t}\n\n\tget keys(): Record<number, string> {\n\t\treturn this._keys;\n\t}\n\n\tset keys(keys: Record<number, string>) {\n\t\tthis._keys = keys;\n\t}\n\n\t/**\n\t * @deprecated Use `isActive` instead.\n\t */\n\tget active(): boolean {\n\t\treturn this.isActive;\n\t}\n\n\t/**\n\t * @deprecated Use `fee` instead.\n\t */\n\tget input_fee_ppk(): number {\n\t\treturn this.fee;\n\t}\n\n\t/**\n\t * @deprecated Use `expiry` instead.\n\t */\n\tget final_expiry(): number | undefined {\n\t\treturn this.expiry;\n\t}\n\n\t/**\n\t * To Mint API MintKeyset format.\n\t *\n\t * @returns MintKeyset object.\n\t */\n\ttoMintKeyset(): MintKeyset {\n\t\treturn {\n\t\t\tid: this._id,\n\t\t\tunit: this._unit,\n\t\t\tactive: this._active,\n\t\t\tinput_fee_ppk: this._input_fee_ppk,\n\t\t\tfinal_expiry: this._final_expiry,\n\t\t};\n\t}\n\n\t/**\n\t * To Mint API MintKeys format.\n\t *\n\t * @returns MintKeys object.\n\t */\n\ttoMintKeys(): MintKeys | null {\n\t\tif (!this.hasKeys) {\n\t\t\treturn null;\n\t\t}\n\t\treturn {\n\t\t\tid: this._id,\n\t\t\tunit: this._unit,\n\t\t\tactive: this._active,\n\t\t\tinput_fee_ppk: this._input_fee_ppk,\n\t\t\tfinal_expiry: this._final_expiry,\n\t\t\tkeys: this._keys,\n\t\t};\n\t}\n\n\t/**\n\t * Verifies that the keyset's ID matches the derived ID from its keys, unit, and expiry.\n\t *\n\t * @returns True if verification succeeds, false otherwise (e.g: no keys or mismatch).\n\t */\n\tverify(): boolean {\n\t\tif (!this.hasKeys) {\n\t\t\treturn false;\n\t\t}\n\t\treturn Keyset.verifyKeysetId(this.toMintKeys()!);\n\t}\n\n\t/**\n\t * Verifies that a MintKeys DTO has a correct id for its keys/unit/expiry.\n\t *\n\t * @returns True if verification succeeds, false otherwise (e.g: no keys or mismatch).\n\t */\n\tstatic verifyKeysetId(keys: MintKeys): boolean {\n\t\tif (!keys.keys || Object.keys(keys.keys).length === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tconst isDeprecatedBase64 = isBase64String(keys.id) && !isValidHex(keys.id);\n\t\tconst versionByte = isValidHex(keys.id) ? hexToBytes(keys.id)[0] : 0;\n\t\tconst derivedId = deriveKeysetId(keys.keys, {\n\t\t\tinput_fee_ppk: keys.input_fee_ppk,\n\t\t\texpiry: keys.final_expiry,\n\t\t\tunit: keys.unit,\n\t\t\tversionByte,\n\t\t\tisDeprecatedBase64,\n\t\t});\n\t\treturn derivedId === keys.id;\n\t}\n\n\t/**\n\t * Create a Keyset from Mint API DTOs.\n\t *\n\t * @param meta The MintKeyset metadata from GetKeysetsResponse.\n\t * @param keys The MintKeys from GetKeysResponse.\n\t * @returns Keyset instance.\n\t */\n\tstatic fromMintApi(meta: MintKeyset, keys?: MintKeys): Keyset {\n\t\tconst ks = new Keyset(meta.id, meta.unit, meta.active, meta.input_fee_ppk, meta.final_expiry);\n\n\t\t// Sanity checks\n\t\tif (keys) {\n\t\t\tif (keys.id !== meta.id) {\n\t\t\t\tthrow new Error(`Mismatched keyset ids: meta=${meta.id}, keys=${keys.id}`);\n\t\t\t}\n\t\t\tif (keys.unit !== meta.unit) {\n\t\t\t\tthrow new Error(`Mismatched keyset units: meta=${meta.unit}, keys=${keys.unit}`);\n\t\t\t}\n\t\t\tif (\n\t\t\t\tkeys.final_expiry !== undefined &&\n\t\t\t\tmeta.final_expiry !== undefined &&\n\t\t\t\tkeys.final_expiry !== meta.final_expiry\n\t\t\t) {\n\t\t\t\tthrow new Error(`Mismatched keyset expiry for id=${meta.id}`);\n\t\t\t}\n\t\t\t// All good\n\t\t\tks.keys = keys.keys;\n\t\t}\n\t\treturn ks;\n\t}\n}\n","import { Keyset } from './Keyset';\nimport { Mint } from '../mint';\nimport type {\n\tMintKeyset,\n\tMintKeys,\n\tGetKeysetsResponse,\n\tGetKeysResponse,\n\tKeyChainCache,\n\tKeysetCache,\n} from '../model/types/keyset';\nimport { isValidHex } from '../utils';\n\n/**\n * Manages the unit-specific keysets for a Mint.\n *\n * @remarks\n * Will ONLY load keysets in the KeyChain unit.\n */\nexport class KeyChain {\n\tprivate mint: Mint;\n\tprivate unit: string;\n\tprivate keysets: { [id: string]: Keyset } = {};\n\n\tconstructor(\n\t\tmint: string | Mint,\n\t\tunit: string,\n\t\tcachedKeysets?: MintKeyset[],\n\t\tcachedKeys?: MintKeys[] | MintKeys,\n\t) {\n\t\tthis.mint = typeof mint === 'string' ? new Mint(mint) : mint;\n\t\tthis.unit = unit;\n\n\t\t// Legacy preload path using Mint API DTOs\n\t\tif (cachedKeysets && cachedKeys) {\n\t\t\tconst arrayOfKeys = Array.isArray(cachedKeys) ? cachedKeys : [cachedKeys];\n\t\t\tthis.buildKeychain(cachedKeysets, arrayOfKeys);\n\n\t\t\t// Smoke test, fail fast on bad cache\n\t\t\tthis.getCheapestKeyset();\n\t\t}\n\t}\n\n\t// ---------------------------------------------------------------------\n\t// Static helpers\n\t// ---------------------------------------------------------------------\n\n\t/**\n\t * Construct a KeyChain from previously cached data.\n\t *\n\t * @remarks\n\t * Does not hit the network. The cache should have been produced by `keyChain.cache`.\n\t */\n\tstatic fromCache(mint: string | Mint, cache: KeyChainCache): KeyChain {\n\t\tconst chain = new KeyChain(mint, cache.unit);\n\t\tchain.loadFromCache(cache);\n\t\treturn chain;\n\t}\n\n\t/**\n\t * Convert Mint API DTOs into a consolidated KeyChainCache.\n\t *\n\t * @remarks\n\t * This is symmetrical to {@link KeyChain.cacheToMintDTO}. It is used by the `cache` getter and any\n\t * code that wants to move from raw Mint DTOs to the new cache shape.\n\t */\n\tstatic mintToCacheDTO(\n\t\tunit: string,\n\t\tmintUrl: string,\n\t\tallKeysets: MintKeyset[],\n\t\tallKeys: MintKeys[],\n\t): KeyChainCache {\n\t\tconst keysById = new Map<string, MintKeys>(allKeys.map((k) => [k.id, k]));\n\t\tconst cacheKeysets: KeysetCache[] = allKeysets.map((meta) => {\n\t\t\tconst maybeKeys = keysById.get(meta.id);\n\t\t\tconst kc: KeysetCache = { ...meta };\n\t\t\tif (maybeKeys) {\n\t\t\t\tkc.keys = maybeKeys.keys;\n\t\t\t}\n\t\t\treturn kc;\n\t\t});\n\t\treturn {\n\t\t\tkeysets: cacheKeysets,\n\t\t\tunit,\n\t\t\tmintUrl,\n\t\t};\n\t}\n\n\t/**\n\t * Convert a KeyChainCache back into Mint API DTOs.\n\t *\n\t * @remarks\n\t * This is the inverse of {@link KeyChain.mintToCacheDTO} and is used by `loadFromCache` and the\n\t * deprecated `getCache()` wrapper.\n\t */\n\tstatic cacheToMintDTO(cache: KeyChainCache): {\n\t\tkeysets: MintKeyset[];\n\t\tkeys: MintKeys[];\n\t} {\n\t\tconst keysets: MintKeyset[] = cache.keysets.map((k) => ({\n\t\t\tid: k.id,\n\t\t\tunit: k.unit,\n\t\t\tactive: k.active,\n\t\t\tinput_fee_ppk: k.input_fee_ppk,\n\t\t\tfinal_expiry: k.final_expiry,\n\t\t}));\n\n\t\tconst keys: MintKeys[] = cache.keysets\n\t\t\t.filter((k): k is KeysetCache & { keys: NonNullable<KeysetCache['keys']> } => !!k.keys)\n\t\t\t.map((k) => ({\n\t\t\t\tid: k.id,\n\t\t\t\tunit: k.unit,\n\t\t\t\tactive: k.active,\n\t\t\t\tinput_fee_ppk: k.input_fee_ppk,\n\t\t\t\tfinal_expiry: k.final_expiry,\n\t\t\t\tkeys: k.keys,\n\t\t\t}));\n\n\t\treturn { keysets, keys };\n\t}\n\n\t// ---------------------------------------------------------------------\n\t// Mint loading\n\t// ---------------------------------------------------------------------\n\n\t/**\n\t * Asynchronously load keysets and keys from the mint.\n\t *\n\t * @remarks\n\t * Intended for callers that want the freshest data from the mint and can use an asynchronous\n\t * path.\n\t * @param forceRefresh If true, re-fetches data even if already loaded.\n\t */\n\tasync init(forceRefresh?: boolean): Promise<void> {\n\t\t// Skip if already loaded, unless force\n\t\tif (Object.keys(this.keysets).length > 0 && !forceRefresh) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fetch keys and keysets in parallel\n\t\tconst [allKeysetsResponse, allKeysResponse]: [GetKeysetsResponse, GetKeysResponse] =\n\t\t\tawait Promise.all([this.mint.getKeySets(), this.mint.getKeys()]);\n\n\t\tthis.buildKeychain(allKeysetsResponse.keysets, allKeysResponse.keysets);\n\n\t\t// Smoke test (will throw if init was unsuccessful)\n\t\tthis.getCheapestKeyset();\n\t}\n\n\t/**\n\t * Synchronously load keysets and keys from cached data.\n\t *\n\t * @remarks\n\t * Does not hit the network. Intended for callers that already have a KeyChainCache and want a\n\t * synchronous path.\n\t */\n\tloadFromCache(cache: KeyChainCache): void {\n\t\tif (cache.unit !== this.unit) {\n\t\t\tthrow new Error(\n\t\t\t\t`KeyChain unit mismatch in cache, expected '${this.unit}', got '${cache.unit}' from ${cache.mintUrl}`,\n\t\t\t);\n\t\t}\n\n\t\tconst { keysets, keys } = KeyChain.cacheToMintDTO(cache);\n\t\tthis.buildKeychain(keysets, keys);\n\n\t\t// Smoke test\n\t\tthis.getCheapestKeyset();\n\t}\n\n\t/**\n\t * Builds keychain from Mint Keyset and Keys data.\n\t *\n\t * @param allKeysets Keyset data from mint.getKeySets() API.\n\t * @param allKeys Keys data from mint.getKeys() API.\n\t */\n\tprivate buildKeychain(allKeysets: MintKeyset[], allKeys: MintKeys[]): void {\n\t\t// Clear existing keysets to avoid stale data\n\t\tthis.keysets = {};\n\n\t\t// Filter Keysets / Keys by unit\n\t\tconst unitKeysets = allKeysets.filter((k) => k.unit === this.unit);\n\t\tif (!unitKeysets.length) {\n\t\t\tthrow new Error(`No Keysets found for unit: ${this.unit}`);\n\t\t}\n\t\tconst keysMap = new Map<string, MintKeys>(\n\t\t\tallKeys.filter((k) => k.unit === this.unit).map((k) => [k.id, k]),\n\t\t);\n\n\t\t// Build keysets\n\t\tfor (const meta of unitKeysets) {\n\t\t\tlet keyset: Keyset;\n\n\t\t\t// Only active hex keysets should have keys\n\t\t\tif (meta.active && isValidHex(meta.id)) {\n\t\t\t\tconst mk = keysMap.get(meta.id);\n\t\t\t\tkeyset = Keyset.fromMintApi(meta, mk);\n\t\t\t} else {\n\t\t\t\tkeyset = Keyset.fromMintApi(meta);\n\t\t\t}\n\n\t\t\t// Validate active keysets with keys\n\t\t\tif (keyset.hasKeys && !keyset.verify()) {\n\t\t\t\tthrow new Error(`Keyset verification failed for ID ${keyset.id}`);\n\t\t\t}\n\n\t\t\t// Add to keychain\n\t\t\tthis.keysets[keyset.id] = keyset;\n\t\t}\n\t}\n\n\t// ---------------------------------------------------------------------\n\t// Queries\n\t// ---------------------------------------------------------------------\n\n\t/**\n\t * Get a keyset by ID or the cheapest keyset if no ID is provided.\n\t *\n\t * @param id Optional keyset ID.\n\t * @returns Keyset with keys.\n\t * @throws If keyset not found or uninitialized.\n\t */\n\tgetKeyset(id?: string): Keyset {\n\t\tconst keyset = id ? this.keysets[id] : this.getCheapestKeyset();\n\t\tif (!keyset) {\n\t\t\tthrow new Error(`Keyset '${id}' not found`);\n\t\t}\n\t\treturn keyset;\n\t}\n\n\t/**\n\t * Get the cheapest active keyset.\n\t *\n\t * @remarks\n\t * Selects active keyset with lowest fee and hex ID.\n\t * @returns Active Keyset.\n\t * @throws If none found or uninitialized.\n\t */\n\tgetCheapestKeyset(): Keyset {\n\t\tif (Object.keys(this.keysets).length === 0) {\n\t\t\tthrow new Error('KeyChain not initialized');\n\t\t}\n\t\tconst activeKeysets = Object.values(this.keysets).filter(\n\t\t\t(k) => k.isActive && k.hasHexId && k.hasKeys,\n\t\t);\n\t\tif (activeKeysets.length === 0) {\n\t\t\tthrow new Error('No active keyset found');\n\t\t}\n\t\treturn activeKeysets.sort((a, b) => a.fee - b.fee)[0];\n\t}\n\n\t/**\n\t * Get list of all keysets for the unit.\n\t *\n\t * @returns Array of Keysets.\n\t * @throws If uninitialized.\n\t */\n\tgetKeysets(): Keyset[] {\n\t\tif (Object.keys(this.keysets).length === 0) {\n\t\t\tthrow new Error('KeyChain not initialized');\n\t\t}\n\t\treturn Object.values(this.keysets);\n\t}\n\n\t/**\n\t * Returns all the keys in this KeyChain.\n\t *\n\t * @remarks\n\t * This mirrors the old `wallet.getAllKeys()` behaviour and is the preferred replacement in v3.\n\t * @returns Array of MintKeys objects.\n\t * @throws If uninitialized.\n\t */\n\tgetAllKeys(): MintKeys[] {\n\t\treturn this.getKeysets()\n\t\t\t.map((k) => k.toMintKeys())\n\t\t\t.filter((mk): mk is MintKeys => mk !== null);\n\t}\n\n\t/**\n\t * Returns all the keyset IDs in this KeyChain.\n\t *\n\t * @returns Array of keyset IDs.\n\t * @throws If uninitialized.\n\t */\n\tgetAllKeysetIds(): string[] {\n\t\treturn this.getKeysets().map((k) => k.id);\n\t}\n\n\t// ---------------------------------------------------------------------\n\t// Caching\n\t// ---------------------------------------------------------------------\n\n\t/**\n\t * Preferred consolidated cache representation.\n\t *\n\t * @remarks\n\t * Built from the live Keyset instances via their Mint DTO exporters. This is the canonical cache\n\t * API going forward.\n\t */\n\tget cache(): KeyChainCache {\n\t\tconst allKeysets: Keyset[] = this.getKeysets();\n\t\tconst metaList: MintKeyset[] = allKeysets.map((k) => k.toMintKeyset());\n\t\tconst keysList: MintKeys[] = allKeysets\n\t\t\t.map((k) => k.toMintKeys())\n\t\t\t.filter((mk): mk is MintKeys => mk !== null);\n\t\treturn KeyChain.mintToCacheDTO(this.unit, this.mint.mintUrl, metaList, keysList);\n\t}\n\n\t/**\n\t * Legacy Mint API cache format.\n\t *\n\t * @remarks\n\t * Useful for instantiating new wallets / keychains without repeatedly calling the mint API.\n\t * @deprecated Use the `cache` getter which returns a consolidated KeyChainCache.\n\t */\n\tgetCache(): {\n\t\tkeysets: MintKeyset[];\n\t\tkeys: MintKeys[];\n\t\tunit: string;\n\t\tmintUrl: string;\n\t} {\n\t\tconst cache = this.cache;\n\t\tconst { keysets, keys } = KeyChain.cacheToMintDTO(cache);\n\t\treturn {\n\t\t\tkeysets,\n\t\t\tkeys,\n\t\t\tunit: cache.unit,\n\t\t\tmintUrl: cache.mintUrl,\n\t\t};\n\t}\n}\n","import { type SerializedBlindedMessage } from './types/index';\nimport { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass.js';\n\nclass BlindedMessage {\n\tamount: number;\n\tB_: WeierstrassPoint<bigint>;\n\tid: string;\n\tconstructor(amount: number, B_: WeierstrassPoint<bigint>, id: string) {\n\t\tthis.amount = amount;\n\t\tthis.B_ = B_;\n\t\tthis.id = id;\n\t}\n\tgetSerializedBlindedMessage(): SerializedBlindedMessage {\n\t\treturn { amount: this.amount, B_: this.B_.toHex(true), id: this.id };\n\t}\n}\nexport { BlindedMessage };\n","import {\n\ttype HasKeysetKeys,\n\ttype Proof,\n\ttype SerializedBlindedMessage,\n\ttype SerializedBlindedSignature,\n\ttype SerializedDLEQ,\n} from './types';\nimport { type P2PKOptions } from '../wallet';\nimport {\n\tblindMessage,\n\tconstructProofFromPromise,\n\tderiveP2BKBlindedPubkeys,\n\tderiveBlindingFactor,\n\tderiveSecret,\n\tpointFromHex,\n\tserializeProof,\n\ttype DLEQ,\n} from '../crypto';\nimport { BlindedMessage } from './BlindedMessage';\nimport { bytesToHex, hexToBytes, randomBytes } from '@noble/hashes/utils.js';\nimport { Bytes, numberToHexPadded64, splitAmount } from '../utils';\n\n// TODO(v4): Consider removing the generic and fixing `keyset` to `HasKeysetKeys`.\n// For now the generic preserves the relationship between factory input type and `toProof` keyset type,\n// and keeps narrower implementations assignable under `strictFunctionTypes`.\n\n/**\n * Note: OutputData helpers only require keyset `id` and `keys`. If you want richer keyset typing at\n * the call site, use `OutputDataLike<YourType>`.\n *\n * @remarks\n * WARNING: In v4 we may simplify this further by fixing the keyset type to `HasKeysetKeys` and\n * removing the generic.\n */\nexport interface OutputDataLike<TKeyset extends HasKeysetKeys = HasKeysetKeys> {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\ttoProof: (signature: SerializedBlindedSignature, keyset: TKeyset) => Proof;\n}\n\n/**\n * Note: OutputData helpers only require keyset `id` and `keys`. If you want richer keyset typing at\n * the call site, use `OutputDataLike<YourType>`.\n *\n * @remarks\n * WARNING: In v4 we may simplify this further by fixing the keyset type to `HasKeysetKeys` and\n * removing the generic.\n */\nexport type OutputDataFactory<TKeyset extends HasKeysetKeys = HasKeysetKeys> = (\n\tamount: number,\n\tkeys: TKeyset,\n) => OutputDataLike<TKeyset>;\n\n/**\n * Core P2PK tags that must not be settable in additional tags.\n *\n * @internal\n */\nexport const RESERVED_P2PK_TAGS = new Set([\n\t'locktime',\n\t'pubkeys',\n\t'n_sigs',\n\t'refund',\n\t'n_sigs_refund',\n]);\n\n/**\n * Asserts P2PK Tag key is valid.\n *\n * @param key Tag Key.\n * @throws If not a string, or is a reserved string.\n */\nexport function assertValidTagKey(key: string) {\n\tif (!key || typeof key !== 'string') throw new Error('tag key must be a non empty string');\n\tif (RESERVED_P2PK_TAGS.has(key)) {\n\t\tthrow new Error(`additionalTags must not use reserved key \"${key}\"`);\n\t}\n}\n\n/**\n * Maximum secret length.\n *\n * @remarks\n * Based on the Nutshell default mint_max_secret_length.\n * @internal\n */\nexport const MAX_SECRET_LENGTH = 1024;\n\nexport function isOutputDataFactory(\n\tvalue: OutputData[] | OutputDataFactory,\n): value is OutputDataFactory {\n\treturn typeof value === 'function';\n}\n\n// Holds the map of Pubkey blinding factors for a given OutputData\n// This avoids changing the shape of the OutputDataLike interface\nconst EPHEMERAL_E = new WeakMap<OutputData, string>(); // one-shot\nfunction setEphemeralE(target: OutputData, Ehex?: string) {\n\tif (Ehex) EPHEMERAL_E.set(target, Ehex);\n}\nfunction takeEphemeralE(target: OutputData): string | undefined {\n\tconst e = EPHEMERAL_E.get(target);\n\tif (!e) return;\n\tEPHEMERAL_E.delete(target); // one-shot to avoid leakage\n\treturn e;\n}\n\nexport class OutputData implements OutputDataLike<HasKeysetKeys> {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\tconstructor(\n\t\tblindedMessage: SerializedBlindedMessage,\n\t\tblindingFactor: bigint,\n\t\tsecret: Uint8Array,\n\t) {\n\t\tthis.secret = secret;\n\t\tthis.blindingFactor = blindingFactor;\n\t\tthis.blindedMessage = blindedMessage;\n\t}\n\n\ttoProof(sig: SerializedBlindedSignature, keyset: HasKeysetKeys) {\n\t\tlet dleq: DLEQ | undefined;\n\t\tif (sig.dleq) {\n\t\t\tdleq = {\n\t\t\t\ts: hexToBytes(sig.dleq.s),\n\t\t\t\te: hexToBytes(sig.dleq.e),\n\t\t\t\tr: this.blindingFactor,\n\t\t\t};\n\t\t}\n\t\tconst blindSignature = {\n\t\t\tid: sig.id,\n\t\t\tamount: sig.amount,\n\t\t\tC_: pointFromHex(sig.C_),\n\t\t\tdleq: dleq,\n\t\t};\n\t\tconst A = pointFromHex(keyset.keys[sig.amount]);\n\t\tconst proof = constructProofFromPromise(blindSignature, this.blindingFactor, this.secret, A);\n\t\tconst serializedProof = {\n\t\t\t...serializeProof(proof),\n\t\t\t...(dleq && {\n\t\t\t\tdleq: {\n\t\t\t\t\ts: bytesToHex(dleq.s),\n\t\t\t\t\te: bytesToHex(dleq.e),\n\t\t\t\t\tr: numberToHexPadded64(dleq.r ?? BigInt(0)),\n\t\t\t\t} as SerializedDLEQ,\n\t\t\t}),\n\t\t} as Proof;\n\n\t\t// Add P2BK (Pay to Blinded Key) blinding factors if needed\n\t\tconst Ehex = takeEphemeralE(this);\n\t\tif (Ehex) serializedProof.p2pk_e = Ehex;\n\n\t\treturn serializedProof;\n\t}\n\n\tstatic createP2PKData<T extends HasKeysetKeys>(\n\t\tp2pk: P2PKOptions,\n\t\tamount: number,\n\t\tkeyset: T,\n\t\tcustomSplit?: number[],\n\t) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleP2PKData(p2pk, a, keyset.id));\n\t}\n\n\tstatic createSingleP2PKData(p2pk: P2PKOptions, amount: number, keysetId: string) {\n\t\t// normalise keys and clamp required signature counts to available keys\n\t\tconst lockKeys: string[] = Array.isArray(p2pk.pubkey) ? p2pk.pubkey : [p2pk.pubkey];\n\t\tconst refundKeys: string[] = p2pk.refundKeys ?? [];\n\t\tconst reqLock = Math.max(1, Math.min(p2pk.requiredSignatures ?? 1, lockKeys.length));\n\t\tconst reqRefund = Math.max(\n\t\t\t1,\n\t\t\tMath.min(p2pk.requiredRefundSignatures ?? 1, refundKeys.length || 1),\n\t\t);\n\t\t// Sanity check - we always need at least one locking key\n\t\tif (lockKeys.length === 0) {\n\t\t\tthrow new Error('P2PK requires at least one pubkey');\n\t\t}\n\n\t\t// Init vars\n\t\tconst isHTLC = typeof p2pk.hashlock === 'string' && p2pk.hashlock.length > 0;\n\t\tlet data = isHTLC ? (p2pk.hashlock as string) : lockKeys[0];\n\t\tlet pubkeys = isHTLC ? lockKeys : lockKeys.slice(1);\n\t\tlet refund = refundKeys;\n\n\t\t// Optional key blinding (P2BK)\n\t\tlet Ehex: string | undefined;\n\t\tif (p2pk.blindKeys) {\n\t\t\tconst ordered = [...lockKeys, ...refundKeys];\n\t\t\tconst { blinded, Ehex: _E } = deriveP2BKBlindedPubkeys(ordered, keysetId);\n\t\t\tif (isHTLC) {\n\t\t\t\t// hashlock is in data, all locking keys into pubkeys\n\t\t\t\tpubkeys = blinded.slice(0, lockKeys.length);\n\t\t\t} else {\n\t\t\t\t// first locking key in data, rest into pubkeys\n\t\t\t\tdata = blinded[0];\n\t\t\t\tpubkeys = blinded.slice(1, lockKeys.length);\n\t\t\t}\n\t\t\trefund = blinded.slice(lockKeys.length);\n\t\t\tEhex = _E;\n\t\t}\n\n\t\t// build P2PK Tags (NUT-11)\n\t\tconst tags: string[][] = [];\n\n\t\tconst ts = p2pk.locktime ?? NaN;\n\t\tif (Number.isSafeInteger(ts) && ts >= 0) {\n\t\t\ttags.push(['locktime', String(ts)]);\n\t\t}\n\n\t\tif (pubkeys.length > 0) {\n\t\t\ttags.push(['pubkeys', ...pubkeys]);\n\t\t\tif (reqLock > 1) {\n\t\t\t\ttags.push(['n_sigs', String(reqLock)]);\n\t\t\t}\n\t\t}\n\n\t\tif (refund.length > 0) {\n\t\t\ttags.push(['refund', ...refund]);\n\t\t\tif (reqRefund > 1) {\n\t\t\t\ttags.push(['n_sigs_refund', String(reqRefund)]);\n\t\t\t}\n\t\t}\n\n\t\tif (p2pk.sigFlag == 'SIG_ALL') {\n\t\t\ttags.push(['sigflag', 'SIG_ALL']);\n\t\t}\n\n\t\t// Append additional tags if any\n\t\tif (p2pk.additionalTags?.length) {\n\t\t\tconst normalized = p2pk.additionalTags.map(([k, ...vals]) => {\n\t\t\t\tassertValidTagKey(k); // Validate key\n\t\t\t\treturn [k, ...vals.map(String)]; // all to strings\n\t\t\t});\n\t\t\ttags.push(...normalized);\n\t\t}\n\n\t\t// Construct secret\n\t\tconst kind = isHTLC ? 'HTLC' : 'P2PK';\n\t\tconst newSecret: [string, { nonce: string; data: string; tags: string[][] }] = [\n\t\t\tkind,\n\t\t\t{\n\t\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\t\tdata,\n\t\t\t\ttags,\n\t\t\t},\n\t\t];\n\n\t\t// blind the message\n\t\tconst parsed = JSON.stringify(newSecret);\n\n\t\t// Check secret length, counting Unicode code points\n\t\t// Same semantics as Nutshell python: len(str)\n\t\tconst charCount = [...parsed].length;\n\t\tif (charCount > MAX_SECRET_LENGTH) {\n\t\t\tthrow new Error(`Secret too long (${charCount} characters), maximum is ${MAX_SECRET_LENGTH}`);\n\t\t}\n\t\t// blind the message\n\t\tconst secretBytes = new TextEncoder().encode(parsed);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\n\t\t// create OutputData\n\t\tconst od = new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\n\t\t// stash Ehex - we add it to Proof later @see: toProof()\n\t\tif (p2pk.blindKeys && Ehex) setEphemeralE(od, Ehex);\n\n\t\treturn od;\n\t}\n\n\tstatic createRandomData<T extends HasKeysetKeys>(\n\t\tamount: number,\n\t\tkeyset: T,\n\t\tcustomSplit?: number[],\n\t) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleRandomData(a, keyset.id));\n\t}\n\n\tstatic createSingleRandomData(amount: number, keysetId: string) {\n\t\tconst randomHex = bytesToHex(randomBytes(32));\n\t\tconst secretBytes = new TextEncoder().encode(randomHex);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\t}\n\n\tstatic createDeterministicData<T extends HasKeysetKeys>(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeyset: T,\n\t\tcustomSplit?: number[],\n\t): OutputData[] {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a, i) =>\n\t\t\tthis.createSingleDeterministicData(a, seed, counter + i, keyset.id),\n\t\t);\n\t}\n\n\t/**\n\t * @throws May throw if blinding factor is out of range. Caller should catch, increment counter,\n\t *   and retry per BIP32-style derivation.\n\t */\n\tstatic createSingleDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeysetId: string,\n\t) {\n\t\tconst secretBytes = deriveSecret(seed, keysetId, counter);\n\t\tconst secretBytesAsHex = bytesToHex(secretBytes);\n\t\tconst utf8SecretBytes = new TextEncoder().encode(secretBytesAsHex);\n\t\t// Note: Bytes.toBigInt is used here so invalid values bubble up as throws\n\t\t// for BIP32-style retry logic (caller increments counter and retries).\n\t\tconst deterministicR = Bytes.toBigInt(deriveBlindingFactor(seed, keysetId, counter));\n\t\tconst { r, B_ } = blindMessage(utf8SecretBytes, deterministicR);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tutf8SecretBytes,\n\t\t);\n\t}\n\n\t/**\n\t * Calculates the sum of amounts in an array of OutputDataLike objects.\n\t *\n\t * @param outputs Array of OutputDataLike objects.\n\t * @returns The total sum of amounts.\n\t */\n\tstatic sumOutputAmounts(outputs: OutputDataLike[]): number {\n\t\treturn outputs.reduce((sum, output) => sum + output.blindedMessage.amount, 0);\n\t}\n}\n","import { assertValidTagKey, OutputData } from '../model/OutputData';\nimport { type P2PKOptions, type P2PKTag } from './types/config';\nimport { type SigFlag } from '../crypto';\n\n// Accept 33 byte compressed (02|03...), or 32 byte x-only,\n// normalised to lowercase 33 byte with 02 prefix for x only\nfunction normalisePubkey(pk: string): string {\n\tconst hex = pk.toLowerCase();\n\tif (hex.length === 66 && (hex.startsWith('02') || hex.startsWith('03'))) return hex;\n\tif (hex.length === 64) return `02${hex}`;\n\tthrow new Error(\n\t\t`Invalid pubkey, expected 33 byte compressed or 32 byte x only, got length ${hex.length}`,\n\t);\n}\n\nfunction toUnixSeconds(input: Date | number): number {\n\tif (input instanceof Date) return Math.floor(input.getTime() / 1000);\n\treturn input < 1e12 ? Math.floor(input) : Math.floor(input / 1000); // > 1e12 = ms\n}\n\nexport class P2PKBuilder {\n\t// A Set enforces uniqueness and preserves insertion order, which means\n\t// the first added lock key also becomes primary (data) pubkey\n\tprivate lockSet = new Set<string>();\n\tprivate refundSet = new Set<string>();\n\tprivate locktime?: number;\n\tprivate nSigs?: number;\n\tprivate nSigsRefund?: number;\n\tprivate extraTags: P2PKTag[] = [];\n\tprivate _blindKeys?: boolean;\n\tprivate sigFlag?: SigFlag;\n\tprivate hashlock?: string;\n\n\taddLockPubkey(pk: string | string[]) {\n\t\tconst arr = Array.isArray(pk) ? pk : [pk];\n\t\tfor (const k of arr) this.lockSet.add(normalisePubkey(k));\n\t\treturn this;\n\t}\n\n\taddRefundPubkey(pk: string | string[]) {\n\t\tconst arr = Array.isArray(pk) ? pk : [pk];\n\t\tfor (const k of arr) this.refundSet.add(normalisePubkey(k));\n\t\treturn this;\n\t}\n\n\tlockUntil(when: Date | number) {\n\t\tthis.locktime = toUnixSeconds(when);\n\t\treturn this;\n\t}\n\n\trequireLockSignatures(n: number) {\n\t\tthis.nSigs = Math.max(1, Math.trunc(n));\n\t\treturn this;\n\t}\n\n\trequireRefundSignatures(n: number) {\n\t\tthis.nSigsRefund = Math.max(1, Math.trunc(n));\n\t\treturn this;\n\t}\n\n\taddTag(key: string, values?: string[] | string) {\n\t\tassertValidTagKey(key); //  Validate key\n\t\tconst vals = values === undefined ? [] : Array.isArray(values) ? values : [values];\n\t\tthis.extraTags.push([key, ...vals.map(String)]); // all to strings\n\t\treturn this;\n\t}\n\n\taddTags(tags: P2PKTag[]) {\n\t\tfor (const [k, ...vals] of tags) this.addTag(k, vals);\n\t\treturn this;\n\t}\n\t/**\n\t * @experimental\n\t */\n\tblindKeys() {\n\t\tthis._blindKeys = true;\n\t\treturn this;\n\t}\n\n\tsigAll() {\n\t\tthis.sigFlag = 'SIG_ALL';\n\t\treturn this;\n\t}\n\n\t/**\n\t * Converts a `P2PK` output into a NUT-14 `HTLC` kind output.\n\t */\n\taddHashlock(hashlock: string) {\n\t\tthis.hashlock = hashlock;\n\t\treturn this;\n\t}\n\n\ttoOptions(): P2PKOptions {\n\t\tconst locks = Array.from(this.lockSet);\n\t\tconst refunds = Array.from(this.refundSet);\n\n\t\tif (locks.length === 0) throw new Error('At least one lock pubkey is required');\n\t\tif (refunds.length > 0 && this.locktime === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t'Refund pubkeys require a locktime, add lockUntil(...) or remove refund keys',\n\t\t\t);\n\t\t}\n\n\t\tconst total = locks.length + refunds.length;\n\t\tif (total > 10)\n\t\t\tthrow new Error(`Too many pubkeys, ${total} provided, maximum allowed is 10 in total`);\n\n\t\t// Clamp required signatures to available keys\n\t\tconst reqLock = this.nSigs ? Math.min(Math.max(1, this.nSigs), locks.length) : undefined;\n\t\tconst reqRefund = this.nSigsRefund\n\t\t\t? Math.min(Math.max(1, this.nSigsRefund), Math.max(1, refunds.length))\n\t\t\t: undefined;\n\n\t\tconst pubkey: string | string[] = locks.length === 1 ? locks[0] : locks;\n\n\t\tconst p2pk: P2PKOptions = {\n\t\t\tpubkey,\n\t\t\t...(this.locktime !== undefined ? { locktime: this.locktime } : {}),\n\t\t\t...(refunds.length ? { refundKeys: refunds } : {}),\n\t\t\t...(reqLock && reqLock > 1 ? { requiredSignatures: reqLock } : {}),\n\t\t\t...(reqRefund && reqRefund > 1 ? { requiredRefundSignatures: reqRefund } : {}),\n\t\t\t...(this.extraTags.length ? { additionalTags: this.extraTags.slice() } : {}),\n\t\t\t...(this._blindKeys ? { blindKeys: true } : {}),\n\t\t\t...(this.sigFlag == 'SIG_ALL' ? { sigFlag: 'SIG_ALL' } : {}),\n\t\t\t...(this.hashlock ? { hashlock: this.hashlock } : {}),\n\t\t};\n\n\t\t// Ensure the secret is valid (not too long etc)\n\t\tconst smokeTest = OutputData.createSingleP2PKData(p2pk, 1, 'deedbeef');\n\t\tvoid smokeTest; // intentionally unused\n\n\t\treturn p2pk;\n\t}\n\n\tstatic fromOptions(opts: P2PKOptions): P2PKBuilder {\n\t\tconst b = new P2PKBuilder();\n\t\tconst locks = Array.isArray(opts.pubkey) ? opts.pubkey : [opts.pubkey];\n\t\tb.addLockPubkey(locks);\n\t\tif (opts.locktime !== undefined) b.lockUntil(opts.locktime);\n\t\tif (opts.refundKeys?.length) b.addRefundPubkey(opts.refundKeys);\n\t\tif (opts.requiredSignatures !== undefined) b.requireLockSignatures(opts.requiredSignatures);\n\t\tif (opts.requiredRefundSignatures !== undefined)\n\t\t\tb.requireRefundSignatures(opts.requiredRefundSignatures);\n\t\tif (opts.additionalTags?.length) b.addTags(opts.additionalTags);\n\t\tif (opts.blindKeys) b.blindKeys();\n\t\tif (opts.sigFlag == 'SIG_ALL') b.sigAll();\n\t\tif (opts.hashlock) b.addHashlock(opts.hashlock);\n\t\treturn b;\n\t}\n}\n","// Minimal types to avoid importing the whole wallet, keeps this module independent\nimport type { Proof } from '../model/types/proof';\nimport { fail, failIf, failIfNullish, type Logger, NULL_LOGGER, measureTime } from '../logger';\nimport { type SendResponse } from './types';\nimport { type KeyChain } from './KeyChain';\n\nexport type SelectProofs = (\n\tproofs: Proof[],\n\tamountToSend: number,\n\tkeyChain: KeyChain,\n\tincludeFees?: boolean,\n\texactMatch?: boolean,\n\tlogger?: Logger,\n) => SendResponse;\n\nexport const selectProofsRGLI: SelectProofs = (\n\tproofs: Proof[],\n\tamountToSend: number,\n\tkeyChain: KeyChain,\n\tincludeFees: boolean = false,\n\texactMatch: boolean = false,\n\t_logger: Logger = NULL_LOGGER,\n): SendResponse => {\n\t// Init vars\n\tconst MAX_TRIALS = 60; // 40-80 is optimal (per RGLI paper)\n\tconst MAX_OVRPCT = 0; // Acceptable close match overage (percent)\n\tconst MAX_OVRAMT = 0; // Acceptable close match overage (absolute)\n\tconst MAX_TIMEMS = 1000; // Halt new trials if over time (in ms)\n\tconst MAX_P2SWAP = 5000; // Max number of Phase 2 improvement swaps\n\tconst timer = measureTime(); // start the clock\n\tlet bestSubset: ProofWithFee[] | null = null;\n\tlet bestDelta = Infinity;\n\tlet bestAmount = 0;\n\tlet bestFeePPK = 0;\n\n\t/**\n\t * Helper Functions.\n\t */\n\tinterface ProofWithFee {\n\t\tproof: Proof;\n\t\texFee: number;\n\t\tppkfee: number;\n\t}\n\t// Looks up fee for a proof\n\tconst feeForProof = (proof: Proof): number => {\n\t\ttry {\n\t\t\treturn keyChain.getKeyset(proof.id).fee;\n\t\t} catch (e) {\n\t\t\tfail(`Could not get fee. No keyset found for keyset id: ${proof.id}`, _logger, {\n\t\t\t\terror: e,\n\t\t\t\tkeychain: keyChain.getKeysets(),\n\t\t\t});\n\t\t}\n\t};\n\t// Calculate net amount after fees\n\tconst sumExFees = (amount: number, feePPK: number): number => {\n\t\treturn amount - (includeFees ? Math.ceil(feePPK / 1000) : 0);\n\t};\n\t// Shuffle array for randomization\n\tconst shuffleArray = <T>(array: T[]): T[] => {\n\t\tconst shuffled = [...array];\n\t\tfor (let i = shuffled.length - 1; i > 0; i--) {\n\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n\t\t}\n\t\treturn shuffled;\n\t};\n\t// Performs a binary search on a sorted (ascending) array of ProofWithFee objects by exFee.\n\t// If lessOrEqual=true, returns the rightmost index where exFee <= value\n\t// If lessOrEqual=false, returns the leftmost index where exFee >= value\n\tconst binarySearchIndex = (\n\t\tarr: ProofWithFee[],\n\t\tvalue: number,\n\t\tlessOrEqual: boolean,\n\t): number | null => {\n\t\tlet left = 0,\n\t\t\tright = arr.length - 1,\n\t\t\tresult: number | null = null;\n\t\twhile (left <= right) {\n\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\tconst midValue = arr[mid].exFee;\n\t\t\tif (lessOrEqual ? midValue <= value : midValue >= value) {\n\t\t\t\tresult = mid;\n\t\t\t\tif (lessOrEqual) left = mid + 1;\n\t\t\t\telse right = mid - 1;\n\t\t\t} else {\n\t\t\t\tif (lessOrEqual) right = mid - 1;\n\t\t\t\telse left = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn lessOrEqual ? result : left < arr.length ? left : null;\n\t};\n\t// Insert into array of ProofWithFee objects sorted by exFee\n\tconst insertSorted = (arr: ProofWithFee[], obj: ProofWithFee): void => {\n\t\tconst value = obj.exFee;\n\t\tlet left = 0,\n\t\t\tright = arr.length;\n\t\twhile (left < right) {\n\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\tif (arr[mid].exFee < value) left = mid + 1;\n\t\t\telse right = mid;\n\t\t}\n\t\tarr.splice(left, 0, obj);\n\t};\n\t// \"Delta\" is the excess over amountToSend including fees\n\t// plus a tiebreaker to favour lower PPK keysets\n\t// NB: Solutions under amountToSend are invalid (delta: Infinity)\n\tconst calculateDelta = (amount: number, feePPK: number): number => {\n\t\tconst netSum = sumExFees(amount, feePPK);\n\t\tif (netSum < amountToSend) return Infinity; // no good\n\t\treturn amount + feePPK / 1000 - amountToSend;\n\t};\n\n\t/**\n\t * Pre-processing.\n\t */\n\tlet totalAmount = 0;\n\tlet totalFeePPK = 0;\n\tconst proofWithFees = proofs.map((p) => {\n\t\tconst ppkfee = feeForProof(p);\n\t\tconst exFee = includeFees ? p.amount - ppkfee / 1000 : p.amount;\n\t\tconst obj = { proof: p, exFee, ppkfee };\n\t\t// Sum all economical proofs (filtered below)\n\t\tif (!includeFees || exFee > 0) {\n\t\t\ttotalAmount += p.amount;\n\t\t\ttotalFeePPK += ppkfee;\n\t\t}\n\t\treturn obj;\n\t});\n\n\t// Filter uneconomical proofs (totals computed above)\n\tlet spendableProofs = includeFees ? proofWithFees.filter((obj) => obj.exFee > 0) : proofWithFees;\n\n\t// Sort by exFee ascending\n\tspendableProofs.sort((a, b) => a.exFee - b.exFee);\n\n\t// Remove proofs too large to be useful and adjust totals\n\t// Exact Match: Keep proofs where exFee <= amountToSend\n\t// Close Match: Keep proofs where exFee <= nextBiggerExFee\n\tif (spendableProofs.length > 0) {\n\t\tlet endIndex;\n\t\tif (exactMatch) {\n\t\t\tconst rightIndex = binarySearchIndex(spendableProofs, amountToSend, true);\n\t\t\tendIndex = rightIndex !== null ? rightIndex + 1 : 0;\n\t\t} else {\n\t\t\tconst biggerIndex = binarySearchIndex(spendableProofs, amountToSend, false);\n\t\t\tif (biggerIndex !== null) {\n\t\t\t\tconst nextBiggerExFee = spendableProofs[biggerIndex].exFee;\n\t\t\t\tconst rightIndex = binarySearchIndex(spendableProofs, nextBiggerExFee, true);\n\t\t\t\tfailIfNullish(rightIndex, 'Unexpected null rightIndex in binary search', _logger);\n\t\t\t\tendIndex = rightIndex + 1;\n\t\t\t} else {\n\t\t\t\t// Keep all proofs if all exFee < amountToSend\n\t\t\t\tendIndex = spendableProofs.length;\n\t\t\t}\n\t\t}\n\t\t// Adjust totals for removed proofs\n\t\tfor (let i = endIndex; i < spendableProofs.length; i++) {\n\t\t\ttotalAmount -= spendableProofs[i].proof.amount;\n\t\t\ttotalFeePPK -= spendableProofs[i].ppkfee;\n\t\t}\n\t\tspendableProofs = spendableProofs.slice(0, endIndex);\n\t}\n\n\t// Validate using precomputed totals\n\tconst totalNetSum = sumExFees(totalAmount, totalFeePPK);\n\tif (amountToSend <= 0 || amountToSend > totalNetSum) {\n\t\treturn { keep: proofs, send: [] };\n\t}\n\n\t// Max acceptable amount for non-exact matches\n\tconst maxOverAmount = Math.min(\n\t\tMath.ceil(amountToSend * (1 + MAX_OVRPCT / 100)),\n\t\tamountToSend + MAX_OVRAMT,\n\t\ttotalNetSum,\n\t);\n\n\t/**\n\t * RGLI algorithm: Runs multiple trials (up to MAX_TRIALS) Each trial starts with randomized\n\t * greedy subset (S) and then tries to improve that subset to get a valid solution. NOTE: Fees are\n\t * dynamic, based on number of proofs (PPK), so we perform all calculations based on net amounts.\n\t */\n\tfor (let trial = 0; trial < MAX_TRIALS; trial++) {\n\t\t// PHASE 1: Randomized Greedy Selection\n\t\t// Add proofs up to amountToSend (after adjusting for fees)\n\t\t// for exact match or the first amount over target otherwise\n\t\tconst S: ProofWithFee[] = [];\n\t\tlet amount = 0;\n\t\tlet feePPK = 0;\n\t\tfor (const obj of shuffleArray(spendableProofs)) {\n\t\t\tconst newAmount = amount + obj.proof.amount;\n\t\t\tconst newFeePPK = feePPK + obj.ppkfee;\n\t\t\tconst netSum = sumExFees(newAmount, newFeePPK);\n\t\t\tif (exactMatch && netSum > amountToSend) break;\n\t\t\tS.push(obj);\n\t\t\tamount = newAmount;\n\t\t\tfeePPK = newFeePPK;\n\t\t\tif (netSum >= amountToSend) break;\n\t\t}\n\n\t\t// PHASE 2: Local Improvement\n\t\t// Examine all the amounts found in the first phase, and find the\n\t\t// amount not in the current solution (others), which would get us\n\t\t// closest to the amountToSend.\n\n\t\t// Calculate the \"others\" array (note: spendableProofs is sorted ASC)\n\t\t// Using set.has() for filtering gives faster lookups: O(n+m)\n\t\t// Using array.includes() would be way slower: O(n*m)\n\t\tconst SSet = new Set(S);\n\t\tconst others = spendableProofs.filter((obj) => !SSet.has(obj));\n\t\t// Generate a random order for accessing the trial subset ('S')\n\t\tconst indices = shuffleArray(Array.from({ length: S.length }, (_, i) => i)).slice(\n\t\t\t0,\n\t\t\tMAX_P2SWAP,\n\t\t);\n\t\tfor (const i of indices) {\n\t\t\t// Exact or acceptable close match solution found?\n\t\t\tconst netSum = sumExFees(amount, feePPK);\n\t\t\tif (\n\t\t\t\tnetSum === amountToSend ||\n\t\t\t\t(!exactMatch && netSum >= amountToSend && netSum <= maxOverAmount)\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Get details for proof being replaced (objP), and temporarily\n\t\t\t// calculate the subset amount/fee with that proof removed.\n\t\t\tconst objP = S[i];\n\t\t\tconst tempAmount = amount - objP.proof.amount;\n\t\t\tconst tempFeePPK = feePPK - objP.ppkfee;\n\t\t\tconst tempNetSum = sumExFees(tempAmount, tempFeePPK);\n\t\t\tconst target = amountToSend - tempNetSum;\n\n\t\t\t// Find a better replacement proof (objQ) and swap it in\n\t\t\t// Exact match can only replace larger to close on the target\n\t\t\t// Close match can replace larger or smaller as needed, but will\n\t\t\t// not replace larger unless it closes on the target\n\t\t\tconst qIndex = binarySearchIndex(others, target, exactMatch);\n\t\t\tif (qIndex !== null) {\n\t\t\t\tconst objQ = others[qIndex];\n\t\t\t\tif (!exactMatch || objQ.exFee > objP.exFee) {\n\t\t\t\t\tif (target >= 0 || objQ.exFee <= objP.exFee) {\n\t\t\t\t\t\tS[i] = objQ;\n\t\t\t\t\t\tamount = tempAmount + objQ.proof.amount;\n\t\t\t\t\t\tfeePPK = tempFeePPK + objQ.ppkfee;\n\t\t\t\t\t\tothers.splice(qIndex, 1);\n\t\t\t\t\t\tinsertSorted(others, objP);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Update best solution\n\t\tconst delta = calculateDelta(amount, feePPK);\n\t\tif (delta < bestDelta) {\n\t\t\t_logger.debug(\n\t\t\t\t`selectProofsToSend: best solution found in trial #${trial} - amount: ${amount}, delta: ${delta}`,\n\t\t\t);\n\t\t\tbestSubset = [...S].sort((a, b) => b.exFee - a.exFee); // copy & sort\n\t\t\tbestDelta = delta;\n\t\t\tbestAmount = amount;\n\t\t\tbestFeePPK = feePPK;\n\n\t\t\t// \"PHASE 3\": Final check to make sure we haven't overpaid fees\n\t\t\t// and see if we can improve the solution. This is an adaptation\n\t\t\t// to the original RGLI, which helps us identify close match and\n\t\t\t// optimal fee solutions more consistently\n\t\t\tconst tempS = [...bestSubset]; // copy\n\t\t\twhile (tempS.length > 1 && bestDelta > 0) {\n\t\t\t\tconst objP = tempS.pop() as ProofWithFee;\n\t\t\t\tconst tempAmount = amount - objP.proof.amount;\n\t\t\t\tconst tempFeePPK = feePPK - objP.ppkfee;\n\t\t\t\tconst tempDelta = calculateDelta(tempAmount, tempFeePPK);\n\t\t\t\tif (tempDelta == Infinity) break;\n\t\t\t\tif (tempDelta < bestDelta) {\n\t\t\t\t\tbestSubset = [...tempS];\n\t\t\t\t\tbestDelta = tempDelta;\n\t\t\t\t\tbestAmount = tempAmount;\n\t\t\t\t\tbestFeePPK = tempFeePPK;\n\t\t\t\t\tamount = tempAmount;\n\t\t\t\t\tfeePPK = tempFeePPK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Check if solution is acceptable\n\t\tif (bestSubset && bestDelta < Infinity) {\n\t\t\tconst bestSum = sumExFees(bestAmount, bestFeePPK);\n\t\t\tif (\n\t\t\t\tbestSum === amountToSend ||\n\t\t\t\t(!exactMatch && bestSum >= amountToSend && bestSum <= maxOverAmount)\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Time limit reached?\n\t\tif (timer.elapsed() > MAX_TIMEMS) {\n\t\t\tfailIf(\n\t\t\t\texactMatch,\n\t\t\t\t'Proof selection took too long. Try again with a smaller proof set.',\n\t\t\t\t_logger,\n\t\t\t);\n\t\t\t_logger.warn('Proof selection took too long. Returning best selection so far.');\n\t\t\tbreak;\n\t\t}\n\t}\n\t// Return Result\n\tif (bestSubset && bestDelta < Infinity) {\n\t\tconst bestProofs = bestSubset.map((obj) => obj.proof);\n\t\tconst bestSubsetSet = new Set(bestProofs);\n\t\tconst keep = proofs.filter((p) => !bestSubsetSet.has(p));\n\t\t_logger.info(`Proof selection took ${timer.elapsed()}ms`);\n\t\treturn { keep, send: bestProofs };\n\t}\n\treturn { keep: proofs, send: [] };\n};\n","/**\n * Usable counters in range is [start, start+count-1]\n *\n * @example // Start: 5, count: 3 => 5,6,7.\n */\nexport interface CounterRange {\n\tstart: number;\n\tcount: number;\n}\n\n// CounterSource.ts\nexport interface CounterSource {\n\t/**\n\t * Reserve n counters for a keyset.\n\t *\n\t * N may be 0. In that case the call MUST NOT mutate state and MUST return { start: currentNext,\n\t * count: 0 }, effectively a read only peek of the cursor.\n\t */\n\treserve(keysetId: string, n: number): Promise<CounterRange>;\n\t/**\n\t * Monotonic bump, ensure the next counter is at least minNext.\n\t */\n\tadvanceToAtLeast(keysetId: string, minNext: number): Promise<void>;\n\t/**\n\t * Optional introspection.\n\t */\n\tsnapshot?(): Promise<Record<string, number>>;\n\t/**\n\t * Optional hard set, useful for tests or migrations.\n\t */\n\tsetNext?(keysetId: string, next: number): Promise<void>;\n}\n\n/**\n * Counter summary for an operation.\n *\n * - `keysetId` - of the transaction.\n * - `start` - beginning of reservation.\n * - `count` - number of reservations.\n * - `next` - counter available after reservation.\n *\n * @example // Start: 5, Count: 3 => 5,6,7. Next: 8.\n */\nexport type OperationCounters = {\n\tkeysetId: string;\n\tstart: number;\n\tcount: number;\n\tnext: number;\n};\n\n/**\n * In memory implementation with per keyset locks for atomic counters.\n */\nexport class EphemeralCounterSource implements CounterSource {\n\tprivate next = new Map<string, number>();\n\tprivate locks = new Map<string, Promise<void>>();\n\n\tconstructor(initial?: Record<string, number>) {\n\t\tif (initial) {\n\t\t\tfor (const [k, v] of Object.entries(initial)) this.next.set(k, v);\n\t\t}\n\t}\n\n\tprivate async withLock<T>(k: string, fn: () => T | Promise<T>): Promise<T> {\n\t\tconst prev = this.locks.get(k) ?? Promise.resolve();\n\t\tlet release!: () => void;\n\t\tconst p = new Promise<void>((resolve) => (release = resolve));\n\t\tconst chain = prev.then(() => p);\n\t\tthis.locks.set(k, chain);\n\t\ttry {\n\t\t\tawait prev;\n\t\t\treturn await fn();\n\t\t} finally {\n\t\t\trelease();\n\t\t\tif (this.locks.get(k) === chain) {\n\t\t\t\tthis.locks.delete(k);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync reserve(keysetId: string, n: number): Promise<CounterRange> {\n\t\tif (n < 0) throw new Error('reserve called with negative count');\n\t\treturn this.withLock(keysetId, () => {\n\t\t\tconst cur = this.next.get(keysetId) ?? 0;\n\t\t\tif (n === 0) return { start: cur, count: 0 }; // report current, do not move\n\t\t\tthis.next.set(keysetId, cur + n);\n\t\t\treturn { start: cur, count: n };\n\t\t});\n\t}\n\n\tasync advanceToAtLeast(keysetId: string, minNext: number): Promise<void> {\n\t\tawait this.withLock(keysetId, () => {\n\t\t\tconst cur = this.next.get(keysetId) ?? 0;\n\t\t\tif (minNext > cur) this.next.set(keysetId, minNext);\n\t\t});\n\t}\n\n\tasync setNext(keysetId: string, next: number): Promise<void> {\n\t\tawait this.withLock(keysetId, () => {\n\t\t\tif (next < 0) throw new Error('setNext: negative next not allowed');\n\t\t\tthis.next.set(keysetId, next);\n\t\t});\n\t}\n\n\tsnapshot(): Promise<Record<string, number>> {\n\t\treturn Promise.resolve(Object.fromEntries(this.next.entries()));\n\t}\n}\n","import {\n\ttype MeltQuoteBolt11Response,\n\ttype MeltQuoteBolt12Response,\n\ttype MeltQuoteBaseResponse,\n\ttype MintQuoteBolt12Response,\n\ttype MintQuoteBolt11Response,\n} from '../model/types';\nimport { type OutputDataLike, type OutputDataFactory } from '../model/OutputData';\nimport type { Proof } from '../model/types/proof';\nimport type { Token } from '../model/types/token';\nimport {\n\ttype OutputType,\n\ttype OutputConfig,\n\ttype SendConfig,\n\ttype ReceiveConfig,\n\ttype MintProofsConfig,\n\ttype P2PKOptions,\n\ttype OnCountersReserved,\n\ttype MeltProofsConfig,\n\ttype MeltProofsResponse,\n\ttype MeltPreview,\n} from './types';\nimport type { Wallet } from './Wallet';\n\nexport type MintMethod = 'bolt11' | 'bolt12';\n\nexport type MintQuoteFor<M extends MintMethod> = M extends 'bolt11'\n\t? string | MintQuoteBolt11Response\n\t: MintQuoteBolt12Response;\n\n/**\n * Fluent operations builder for a Wallet instance.\n *\n * @remarks\n * Provides chainable builders for sending, receiving, and minting. Each builder is single use. If\n * you do not customise an output side, the walletâ€™s policy defaults apply.\n */\nexport class WalletOps {\n\tconstructor(private wallet: Wallet) {}\n\tsend(amount: number, proofs: Proof[]) {\n\t\treturn new SendBuilder(this.wallet, amount, proofs);\n\t}\n\treceive(token: Token | string) {\n\t\treturn new ReceiveBuilder(this.wallet, token);\n\t}\n\tmintBolt11(amount: number, quote: MintQuoteFor<'bolt11'>) {\n\t\treturn new MintBuilder<'bolt11'>(this.wallet, 'bolt11', amount, quote);\n\t}\n\tmintBolt12(amount: number, quote: MintQuoteFor<'bolt12'>) {\n\t\treturn new MintBuilder<'bolt12'>(this.wallet, 'bolt12', amount, quote);\n\t}\n\tmeltBolt11(quote: MeltQuoteBolt11Response, proofs: Proof[]) {\n\t\treturn new MeltBuilder<MeltQuoteBolt11Response>(this.wallet, 'bolt11', quote, proofs);\n\t}\n\tmeltBolt12(quote: MeltQuoteBolt12Response, proofs: Proof[]) {\n\t\treturn new MeltBuilder<MeltQuoteBolt12Response>(this.wallet, 'bolt12', quote, proofs);\n\t}\n}\n\n/**\n * Builder for composing a send or swap.\n *\n * @remarks\n * If you only customise the send side, keep is omitted so the wallet may still attempt an offline\n * exact match selection where possible.\n * @example\n *\n *     const { keep, send } = await wallet.ops\n *     \t.send(5, proofs)\n *     \t.asDeterministic() // counter 0 means auto reserve via CounterSource\n *     \t.keepAsRandom()\n *     \t.includeFees(true) // sender pays receiverâ€™s future spend fee\n *     \t.run();\n */\nexport class SendBuilder {\n\tprivate sendOT?: OutputType;\n\tprivate keepOT?: OutputType;\n\tprivate config: SendConfig = {};\n\tprivate offlineExact?: { requireDleq: boolean };\n\tprivate offlineClose?: { requireDleq: boolean };\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate amount: number,\n\t\tprivate proofs: Proof[],\n\t) {}\n\n\t/**\n\t * Use random blinding for the sent outputs.\n\t *\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.sendOT = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use deterministic outputs for the sent proofs.\n\t *\n\t * @param counter Starting counter. Zero means auto reserve using the walletâ€™s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.sendOT = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use P2PK locked outputs for the sent proofs.\n\t *\n\t * @param options NUT 11 options like pubkey and locktime.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.sendOT = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a factory to generate OutputData for the sent proofs.\n\t *\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.sendOT = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Provide pre created OutputData for the sent proofs.\n\t *\n\t * @param data Fully formed OutputData. Their amounts must sum to the send amount, otherwise the\n\t *   wallet will throw.\n\t */\n\tasCustom(data: OutputDataLike[]) {\n\t\tthis.sendOT = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use random blinding for change outputs.\n\t *\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsRandom(denoms?: number[]) {\n\t\tthis.keepOT = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use deterministic outputs for change.\n\t *\n\t * @param counter Starting counter. Zero means auto reserve using the walletâ€™s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.keepOT = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use P2PK locked change (NUT 11).\n\t *\n\t * @param options Locking options applied to the kept proofs.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.keepOT = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a factory to generate OutputData for change.\n\t *\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.keepOT = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Provide pre created OutputData for change.\n\t *\n\t * @param data Fully formed OutputData for the keep (change) amount.\n\t */\n\tkeepAsCustom(data: OutputDataLike[]) {\n\t\tthis.keepOT = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Make the sender cover the receiverâ€™s future spend fee.\n\t *\n\t * @param on When true, include fees in the sent amount. Default true if called.\n\t */\n\tincludeFees(on = true) {\n\t\tthis.config.includeFees = on;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a specific keyset for the operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Private key(s) used to sign P2PK locked proofs.\n\t *\n\t * @param k Single key or array of multisig keys.\n\t */\n\tprivkey(k: string | string[]) {\n\t\tthis.config.privkey = k;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Provide existing proofs to help optimise denomination selection.\n\t *\n\t * @remarks\n\t * Has no effect if denominations (custom split) was specified.\n\t * @param p Proofs currently held by the wallet, used to hit denomination targets.\n\t */\n\tproofsWeHave(p: Proof[]) {\n\t\tthis.config.proofsWeHave = p;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Force a pure offline, exact match selection. No mint calls are made. If an exact match cannot\n\t * be found, this throws.\n\t *\n\t * @param requireDleq Only consider proofs with a DLEQ when true.\n\t */\n\tofflineExactOnly(requireDleq = false) {\n\t\tthis.offlineExact = { requireDleq };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Force a pure offline selection that allows a close match, overspend permitted per wallet RGLI.\n\t * No mint calls are made. Returns the best offline subset found, or throws if funds are\n\t * insufficient.\n\t *\n\t * @param requireDleq Only consider proofs with a DLEQ when true.\n\t */\n\tofflineCloseMatch(requireDleq = false) {\n\t\tthis.offlineClose = { requireDleq };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Prepare the swap to send.\n\t *\n\t * @remarks\n\t * Call `wallet.completeSwap(SwapPreview)` to complete the send.\n\t * @returns A SwapPreview containing inputs, outputs, amount, fee and unselectedProofs.\n\t */\n\tasync prepare() {\n\t\t// Construct an OutputConfig using default send if no customizations\n\t\tconst outputConfig: OutputConfig = {\n\t\t\tsend: this.sendOT ?? this.wallet.defaultOutputType(),\n\t\t\t...(this.keepOT ? { keep: this.keepOT } : {}),\n\t\t};\n\t\treturn this.wallet.prepareSwapToSend(this.amount, this.proofs, this.config, outputConfig);\n\t}\n\n\t/**\n\t * Execute the send.\n\t *\n\t * @returns The split result with kept and sent proofs.\n\t */\n\tasync run() {\n\t\t// If an offline mode is requested, forbid custom OutputTypes,\n\t\t// because offline uses existing proofs and cannot honour new outputs.\n\t\tif ((this.offlineExact || this.offlineClose) && (this.sendOT || this.keepOT)) {\n\t\t\tthrow new Error(\n\t\t\t\t'Offline selection cannot be combined with custom output types. Remove send/keep output configuration, or use an online swap.',\n\t\t\t);\n\t\t}\n\n\t\t// Strict offline, exact match only\n\t\tif (this.offlineExact) {\n\t\t\t// Sign if needed\n\t\t\tif (this.config.privkey) {\n\t\t\t\tthis.proofs = this.wallet.signP2PKProofs(this.proofs, this.config.privkey);\n\t\t\t}\n\t\t\treturn this.wallet.sendOffline(this.amount, this.proofs, {\n\t\t\t\tincludeFees: this.config.includeFees,\n\t\t\t\texactMatch: true,\n\t\t\t\trequireDleq: this.offlineExact.requireDleq,\n\t\t\t});\n\t\t}\n\n\t\t// Offline close match, may overshoot\n\t\tif (this.offlineClose) {\n\t\t\t// Sign if needed\n\t\t\tif (this.config.privkey) {\n\t\t\t\tthis.proofs = this.wallet.signP2PKProofs(this.proofs, this.config.privkey);\n\t\t\t}\n\t\t\treturn this.wallet.sendOffline(this.amount, this.proofs, {\n\t\t\t\tincludeFees: this.config.includeFees,\n\t\t\t\texactMatch: false,\n\t\t\t\trequireDleq: this.offlineClose.requireDleq,\n\t\t\t});\n\t\t}\n\n\t\t// Construct an OutputConfig using default send if no customizations\n\t\tconst outputConfig: OutputConfig = {\n\t\t\tsend: this.sendOT ?? this.wallet.defaultOutputType(),\n\t\t\t...(this.keepOT ? { keep: this.keepOT } : {}),\n\t\t};\n\t\treturn this.wallet.send(this.amount, this.proofs, this.config, outputConfig);\n\t}\n}\n\n/**\n * Builder for receiving a token.\n *\n * @remarks\n * If you do not call a type method, the walletâ€™s policy default is used.\n * @example\n *\n *     const proofs = await wallet.ops\n *     \t.receive(token)\n *     \t.asDeterministic() // counter 0 auto reserves\n *     \t.requireDleq(true)\n *     \t.run();\n */\nexport class ReceiveBuilder {\n\tprivate outputType?: OutputType;\n\tprivate config: ReceiveConfig = {};\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate token: Token | string,\n\t) {}\n\n\t/**\n\t * Use random blinding for the received outputs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.outputType = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use deterministic outputs for the received proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param counter Starting counter. Zero means auto reserve using the walletâ€™s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.outputType = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use P2PK locked outputs for the received proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param options NUT 11 options like pubkey and locktime.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.outputType = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a factory to generate OutputData for received proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.outputType = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Provide pre created OutputData for received proofs.\n\t *\n\t * @param data Fully formed OutputData for the final amount.\n\t */\n\tasCustom(data: OutputDataLike[]) {\n\t\tthis.outputType = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a specific keyset for the operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Require all incoming proofs to have a valid DLEQ for the selected keyset.\n\t *\n\t * @param on When true, proofs without DLEQ are rejected.\n\t */\n\trequireDleq(on = true) {\n\t\tthis.config.requireDleq = on;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Private key(s) used to sign P2PK locked incoming proofs.\n\t *\n\t * @param k Single key or array of multisig keys.\n\t */\n\tprivkey(k: string | string[]) {\n\t\tthis.config.privkey = k;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Provide existing proofs to help optimise denomination selection.\n\t *\n\t * @remarks\n\t * Has no effect if denominations (custom split) was specified.\n\t * @param p Proofs currently held by the wallet, used to hit denomination targets.\n\t */\n\tproofsWeHave(p: Proof[]) {\n\t\tthis.config.proofsWeHave = p;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Prepare the swap to receive.\n\t *\n\t * @remarks\n\t * Call `wallet.completeSwap(SwapPreview)` to complete the receive.\n\t * @returns A SwapPreview containing inputs, outputs, amount, and fee.\n\t */\n\tasync prepare() {\n\t\treturn this.wallet.prepareSwapToReceive(this.token, this.config, this.outputType);\n\t}\n\n\t/**\n\t * Execute the receive.\n\t *\n\t * @returns The new proofs.\n\t */\n\tasync run() {\n\t\treturn this.wallet.receive(this.token, this.config, this.outputType);\n\t}\n}\n\n/**\n * Builder for minting proofs from a quote.\n *\n * @remarks\n * Bolt12 requires privkey by default, bolt11 only for locked quotes. The compiler will throw an\n * error if bolt12 and privkey() is omitted: MintBuilder<\"bolt12\", false>' is not assignable...\n * @example\n *\n *     const proofs = await wallet.ops\n *     \t.mint(100, quote)\n *     \t.asDeterministic() // counter 0 auto reserves\n *     \t.onCountersReserved((info) => console.log(info))\n *     \t.privkey('sk')\n *     \t.run();\n */\nexport class MintBuilder<\n\tM extends MintMethod,\n\tHasPrivKey extends boolean = M extends 'bolt12' ? false : true,\n> {\n\tprivate outputType?: OutputType;\n\tprivate config: MintProofsConfig = {};\n\n\t// phantom field to satisfy linter (erased at emit)\n\tprivate readonly _hasPrivkey!: HasPrivKey;\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate method: M,\n\t\tprivate amount: number,\n\t\tprivate quote: MintQuoteFor<M>,\n\t) {\n\t\tvoid this._hasPrivkey; // intentionally unused (phantom field)\n\t}\n\n\t/**\n\t * Use random blinding for the minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.outputType = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use deterministic outputs for the minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param counter Starting counter. Zero means auto reserve using the walletâ€™s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.outputType = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use P2PK locked outputs for the minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param options NUT 11 options like pubkey and locktime.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.outputType = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a factory to generate OutputData for minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.outputType = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Provide pre created OutputData for minted proofs.\n\t *\n\t * @param data Fully formed OutputData for the final amount.\n\t */\n\tasCustom(data: OutputDataLike[]) {\n\t\tthis.outputType = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a specific keyset for the operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Private key to sign locked mint quotes.\n\t *\n\t * @param k Private key for locked quotes.\n\t */\n\tprivkey(k: string): MintBuilder<M, true> {\n\t\t// For bolt11 - privkey is sent in the config\n\t\t// For bolt12 - privkey is sent positionally in run()\n\t\tthis.config.privkey = k;\n\t\treturn this as MintBuilder<M, true>;\n\t}\n\n\t/**\n\t * Provide existing proofs to help optimise denomination selection.\n\t *\n\t * @remarks\n\t * Has no effect if denominations (custom split) was specified.\n\t * @param p Proofs currently held by the wallet, used to hit denomination targets.\n\t */\n\tproofsWeHave(p: Proof[]) {\n\t\tthis.config.proofsWeHave = p;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Execute minting against the quote.\n\t *\n\t * @remarks\n\t * This method can only be called for bolt12 quotes when .privkey() is set.\n\t * @returns The newly minted proofs.\n\t */\n\tasync run(this: MintBuilder<M, true>) {\n\t\t// BOLT 11\n\t\tif (this.method === 'bolt11') {\n\t\t\tconst quote = this.quote as string | MintQuoteBolt11Response;\n\t\t\t// For object quotes, enforce privkey when the quote is locked\n\t\t\tif (typeof quote !== 'string' && quote.pubkey && !this.config.privkey) {\n\t\t\t\tthrow new Error('privkey is required for locked BOLT11 mint quotes');\n\t\t\t}\n\t\t\treturn this.wallet.mintProofsBolt11(this.amount, quote, this.config, this.outputType);\n\t\t}\n\n\t\t// BOLT 12\n\t\tconst bolt12 = this.quote as MintQuoteBolt12Response;\n\t\tif (!this.config.privkey) {\n\t\t\tthrow new Error('privkey is required for BOLT12 mint quotes');\n\t\t}\n\t\treturn this.wallet.mintProofsBolt12(\n\t\t\tthis.amount,\n\t\t\tbolt12,\n\t\t\tthis.config.privkey,\n\t\t\tthis.config,\n\t\t\tthis.outputType,\n\t\t);\n\t}\n}\n\n/**\n * Builder for melting proofs to pay a Lightning invoice or BOLT12 offer.\n *\n * @remarks\n * Uses the generic prepareMelt / completeMelt flow under the hood, so it works for any NUT-05 style\n * melt quote, not just BOLT11 / BOLT12.\n * @example\n *\n * ```typescript\n * // Basic BOLT11 melt\n * await wallet.ops.meltBolt11(quote, proofs).run();\n *\n * // BOLT12 melt with deterministic change and NUT-08 blanks callback\n * await wallet.ops\n * \t.meltBolt12(quote12, proofs)\n * \t.asDeterministic() // counter 0 auto reserves\n * \t.onCountersReserved((info) => console.log('Reserved', info))\n * \t.run();\n * ```\n */\nexport class MeltBuilder<TQuote extends MeltQuoteBaseResponse = MeltQuoteBolt11Response> {\n\tprivate outputType?: OutputType;\n\tprivate config: MeltProofsConfig = {};\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate method: string,\n\t\tprivate quote: TQuote,\n\t\tprivate proofs: Proof[],\n\t) {}\n\n\t/**\n\t * Use random blinding for change outputs.\n\t *\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.outputType = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use deterministic outputs for change.\n\t *\n\t * @param counter Starting counter. Zero means auto reserve using the walletâ€™s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.outputType = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use P2PK-locked change (NUT-11).\n\t *\n\t * @param options NUT-11 locking options (e.g., pubkey, locktime).\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.outputType = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a factory to generate OutputData for change.\n\t *\n\t * @param factory Factory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.outputType = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Provide pre-created OutputData for change.\n\t *\n\t * @param data Fully formed OutputData for the change amount.\n\t */\n\tasCustom(data: OutputDataLike[]) {\n\t\tthis.outputType = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a specific keyset for the melt operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Private key(s) used to sign P2PK locked proofs.\n\t *\n\t * @param k Single key or array of multisig keys.\n\t */\n\tprivkey(k: string | string[]) {\n\t\tthis.config.privkey = k;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Receive a callback when NUT-08 blanks (0-sat change outputs) are created for async melts.\n\t *\n\t * @remarks\n\t * You can persist these blanks and later call `wallet.completeMelt(blanks)` to finalize and\n\t * recover change once the invoice/offer is paid.\n\t * @deprecated Use prepare() instead of run() and store the MeltPreview instead.\n\t * @param cb Callback invoked with the created blanks payload.\n\t */\n\tonChangeOutputsCreated(cb: NonNullable<MeltProofsConfig['onChangeOutputsCreated']>) {\n\t\tthis.config.onChangeOutputsCreated = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Prepare the melt.\n\t *\n\t * @remarks\n\t * Call `wallet.completeMelt(MeltPreview)` to complete the melt.\n\t * @returns A MeltPreview containing inputs, outputs, amount, and fee.\n\t */\n\tasync prepare(): Promise<MeltPreview<TQuote>> {\n\t\treturn await this.wallet.prepareMelt<TQuote>(\n\t\t\tthis.method,\n\t\t\tthis.quote,\n\t\t\tthis.proofs,\n\t\t\tthis.config,\n\t\t\tthis.outputType,\n\t\t);\n\t}\n\n\t/**\n\t * Execute the melt against the quote.\n\t *\n\t * @returns The melt result: `{ quote, change }`.\n\t */\n\tasync run(): Promise<MeltProofsResponse<TQuote>> {\n\t\t// Step 1, preview and allocate NUT-08 blanks\n\t\tconst preview = await this.wallet.prepareMelt<TQuote>(\n\t\t\tthis.method,\n\t\t\tthis.quote,\n\t\t\tthis.proofs,\n\t\t\tthis.config,\n\t\t\tthis.outputType,\n\t\t);\n\n\t\t// Step 2, sign if needed and complete the melt\n\t\treturn this.wallet.completeMelt(preview, this.config.privkey);\n\t}\n}\n","import type { Wallet } from './Wallet';\nimport type {\n\tProof,\n\tProofState,\n\tMeltQuoteBaseResponse,\n\tMeltQuoteBolt11Response,\n\tMintQuoteBolt11Response,\n} from '../model/types';\nimport { MintQuoteState, MeltQuoteState } from '../model/types';\nimport type { MeltBlanks } from './types';\nimport { hashToCurve } from '../crypto';\nimport { type OperationCounters } from './CounterSource';\nimport { safeCallback } from '../logger';\n\nexport type SubscriptionCanceller = () => void;\n\nexport type CancellerLike = SubscriptionCanceller | Promise<SubscriptionCanceller>;\n\nexport type SubscribeOpts = { signal?: AbortSignal };\n\ntype ErrorWithCause = Error & { cause?: unknown };\n\nfunction safeStringify(obj: unknown): string {\n\tconst seen = new WeakSet<object>();\n\ttry {\n\t\treturn JSON.stringify(obj, (_k: string, v: unknown) => {\n\t\t\tif (typeof v === 'object' && v !== null) {\n\t\t\t\tif (seen.has(v)) return '[Circular]';\n\t\t\t\tseen.add(v);\n\t\t\t}\n\t\t\treturn v; // returning `unknown` is fine\n\t\t});\n\t} catch {\n\t\treturn Object.prototype.toString.call(obj);\n\t}\n}\n\nfunction normalizeError(err: unknown): Error {\n\tif (err instanceof Error) return err;\n\tconst message = typeof err === 'string' ? err : safeStringify(err);\n\tconst e: ErrorWithCause = new Error(message);\n\te.cause = err;\n\treturn e;\n}\n\nfunction makeAbortError(): Error {\n\tconst e = new Error('Aborted');\n\tObject.defineProperty(e, 'name', { value: 'AbortError' });\n\treturn e;\n}\n\nfunction cancelSafely(c: CancellerLike | null | undefined): void {\n\tif (!c) return;\n\tvoid Promise.resolve(c)\n\t\t.then((fn) => {\n\t\t\ttry {\n\t\t\t\tfn();\n\t\t\t} catch {\n\t\t\t\t/* ignore canceller errors */\n\t\t\t}\n\t\t\treturn;\n\t\t})\n\t\t.catch(() => {\n\t\t\t/* ignore awaiting-canceller errors */\n\t\t});\n}\n\nexport class WalletEvents {\n\tconstructor(private wallet: Wallet) {}\n\n\t// Callbacks registered for Counters Reserved events\n\tprivate countersReservedHandlers = new Set<(payload: OperationCounters) => void>();\n\n\t// Callbacks registered for Melt blanks created events\n\tprivate meltBlanksHandlers = new Set<(payload: MeltBlanks<MeltQuoteBaseResponse>) => void>();\n\n\t// Binds an abort signal to each subscription canceller\n\tprivate withAbort(\n\t\tsignal: AbortSignal | undefined,\n\t\tcancel: SubscriptionCanceller,\n\t): SubscriptionCanceller {\n\t\tif (!signal) return cancel;\n\t\tif (signal.aborted) {\n\t\t\tcancel();\n\t\t\treturn () => {\n\t\t\t\t/* noop */\n\t\t\t};\n\t\t}\n\t\tconst onAbort = () => cancel();\n\t\tsignal.addEventListener('abort', onAbort, { once: true });\n\t\treturn () => {\n\t\t\tsignal.removeEventListener('abort', onAbort);\n\t\t\tcancel();\n\t\t};\n\t}\n\n\t// Subscribe to a quote-paid event and resolve when it fires.\n\t// Supports AbortSignal and timeout, and always cleans up.\n\tprivate waitUntilPaid<T>(\n\t\tsubscribeFn: (\n\t\t\tid: string,\n\t\t\tcb: (p: T) => void, // called when the entity becomes PAID\n\t\t\terr: (e: Error) => void, // called if the subscription itself errors\n\t\t\topts?: { signal?: AbortSignal },\n\t\t) => Promise<SubscriptionCanceller>,\n\t\tid: string, // identifier of the mint/melt/etc. to watch\n\t\topts?: SubscribeOpts & { timeoutMs?: number },\n\t\ttimeoutMsg = 'Timeout waiting for paid',\n\t): Promise<T> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet cancelP: Promise<SubscriptionCanceller> | null = null; // handle to unsub later\n\t\t\tlet to: ReturnType<typeof setTimeout> | null = null; // optional timeout timer\n\t\t\tlet done = false;\n\n\t\t\t// Common cleanup: cancels subscription, clears timer, detaches abort listener.\n\t\t\t// If an error is provided, rejects the promise with it.\n\t\t\tconst cleanup = (err?: unknown) => {\n\t\t\t\tif (done) return;\n\t\t\t\tdone = true;\n\t\t\t\tcancelSafely(cancelP);\n\t\t\t\tif (to) {\n\t\t\t\t\tclearTimeout(to);\n\t\t\t\t\tto = null;\n\t\t\t\t}\n\t\t\t\tif (opts?.signal) opts.signal.removeEventListener('abort', onAbort);\n\t\t\t\tif (err) reject(normalizeError(err));\n\t\t\t};\n\n\t\t\t// Abort handler produces a standardized AbortError and rejects.\n\t\t\tconst onAbort = () => cleanup(makeAbortError());\n\n\t\t\t// Hook up AbortSignal if provided.\n\t\t\tif (opts?.signal) {\n\t\t\t\tif (opts.signal.aborted) return onAbort(); // already aborted\n\t\t\t\topts.signal.addEventListener('abort', onAbort, { once: true });\n\t\t\t}\n\n\t\t\t// Start a timeout if requested.\n\t\t\tif (opts?.timeoutMs && opts.timeoutMs > 0) {\n\t\t\t\tto = setTimeout(() => cleanup(new Error(timeoutMsg)), opts.timeoutMs);\n\t\t\t}\n\n\t\t\t// Subscribe to the actual event. Canceller returned is saved to cancelP.\n\t\t\tcancelP = subscribeFn(\n\t\t\t\tid,\n\t\t\t\t(p) => {\n\t\t\t\t\tcleanup(); // clean up resources\n\t\t\t\t\tresolve(p); // resolve promise with payload\n\t\t\t\t},\n\t\t\t\t(e) => cleanup(e), // reject if subscription itself errors\n\t\t\t\t{ signal: opts?.signal }, // delegate abort to subscription as well\n\t\t\t);\n\n\t\t\t// catch errors starting the subscription\n\t\t\tvoid cancelP.catch((e) => cleanup(e));\n\t\t});\n\t}\n\n\t/**\n\t * Register a callback that fires whenever deterministic counters are reserved.\n\t *\n\t * Timing: the callback is invoked synchronously _after_ a successful reservation and _before_ the\n\t * enclosing wallet method returns. The wallet does **not** await your callback, it is\n\t * fire-and-forget.\n\t *\n\t * Responsibility for async work is on the consumer. If your handler calls an async function (e.g.\n\t * persisting `start + count` to storage), make sure to handle errors inside it to avoid unhandled\n\t * rejections.\n\t *\n\t * Typical use: persist `start + count` for the `keysetId` so counters survive restarts.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * wallet.on.countersReserved(({ keysetId, start, count, next }) => {\n\t * \tsaveNextToDb(keysetId, start + count); // handle async errors inside saveNextToDb\n\t * });\n\t * ```\n\t *\n\t * @param cb Handler called with { keysetId, start, count }.\n\t * @returns A function that unsubscribes the handler.\n\t */\n\tpublic countersReserved(\n\t\tcb: (payload: OperationCounters) => void,\n\t\topts?: SubscribeOpts,\n\t): SubscriptionCanceller {\n\t\tthis.countersReservedHandlers.add(cb);\n\t\tconst cancel = () => this.countersReservedHandlers.delete(cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\t/**\n\t * @internal\n\t */\n\tpublic _emitCountersReserved(payload: OperationCounters) {\n\t\tfor (const h of this.countersReservedHandlers) {\n\t\t\tsafeCallback(h, payload, this.wallet.logger, { event: 'countersReserved' });\n\t\t}\n\t}\n\n\t/**\n\t * Register a callback fired whenever NUT-08 blanks are created during a melt.\n\t *\n\t * Called synchronously right after blanks are prepared (before the melt request), and the wallet\n\t * does not await your handler.\n\t *\n\t * Typical use: persist `payload` so you can later call `wallet.completeMelt(payload)`.\n\t *\n\t * @deprecated Use wallet.prepareMelt() and store the MeltPreview instead.\n\t */\n\tpublic meltBlanksCreated(\n\t\tcb: (payload: MeltBlanks<MeltQuoteBaseResponse>) => void,\n\t\topts?: SubscribeOpts,\n\t): SubscriptionCanceller {\n\t\tthis.meltBlanksHandlers.add(cb);\n\t\tconst cancel = () => this.meltBlanksHandlers.delete(cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic _emitMeltBlanksCreated(payload: MeltBlanks<MeltQuoteBaseResponse>) {\n\t\tfor (const h of this.meltBlanksHandlers) {\n\t\t\tsafeCallback(h, payload, this.wallet.logger, { event: 'meltBlanksCreated' });\n\t\t}\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a mint quote's state changes.\n\t *\n\t * @param quoteIds List of mint quote IDs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a mint quote state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync mintQuoteUpdates(\n\t\tids: string[],\n\t\tcb: (p: MintQuoteBolt11Response) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.wallet.mint.connectWebSocket();\n\t\tconst ws = this.wallet.mint.webSocketConnection;\n\t\tif (!ws) throw new Error('Failed to establish WebSocket connection.');\n\n\t\tconst uniq = Array.from(new Set(ids));\n\t\tconst subId = ws.createSubscription({ kind: 'bolt11_mint_quote', filters: uniq }, cb, err);\n\t\tconst cancel = () => ws.cancelSubscription(subId, cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single mint quote gets paid.\n\t *\n\t * @param quoteId Mint quote id that should be subscribed to.\n\t * @param callback Callback function that will be called when this mint quote gets paid.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync mintQuotePaid(\n\t\tid: string,\n\t\tcb: (p: MintQuoteBolt11Response) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.mintQuoteUpdates(\n\t\t\t[id],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MintQuoteState.PAID) cb(p);\n\t\t\t},\n\t\t\terr,\n\t\t\topts,\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a melt quoteâ€™s state changes.\n\t *\n\t * @param quoteId Melt quote id that should be subscribed to.\n\t * @param callback Callback function that will be called when this melt quote gets paid.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync meltQuoteUpdates(\n\t\tids: string[],\n\t\tcb: (p: MeltQuoteBolt11Response) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.wallet.mint.connectWebSocket();\n\t\tconst ws = this.wallet.mint.webSocketConnection;\n\t\tif (!ws) throw new Error('Failed to establish WebSocket connection.');\n\n\t\tconst uniq = Array.from(new Set(ids));\n\t\tconst subId = ws.createSubscription({ kind: 'bolt11_melt_quote', filters: uniq }, cb, err);\n\t\tconst cancel = () => ws.cancelSubscription(subId, cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single melt quote gets paid.\n\t *\n\t * @param quoteIds List of melt quote IDs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a melt quote state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync meltQuotePaid(\n\t\tid: string,\n\t\tcb: (p: MeltQuoteBolt11Response) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.meltQuoteUpdates(\n\t\t\t[id],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MeltQuoteState.PAID) cb(p);\n\t\t\t},\n\t\t\terr,\n\t\t\topts,\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a subscribed proof state changes.\n\t *\n\t * @param proofs List of proofs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a proof's state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync proofStateUpdates(\n\t\tproofs: Proof[],\n\t\tcb: (payload: ProofState & { proof: Proof }) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.wallet.mint.connectWebSocket();\n\t\tconst ws = this.wallet.mint.webSocketConnection;\n\t\tif (!ws) throw new Error('Failed to establish WebSocket connection.');\n\n\t\tconst enc = new TextEncoder();\n\t\tconst proofMap: Record<string, Proof> = {};\n\t\tfor (const p of proofs) {\n\t\t\tconst y = hashToCurve(enc.encode(p.secret)).toHex(true);\n\t\t\tproofMap[y] = p;\n\t\t}\n\t\tconst ys = Object.keys(proofMap);\n\n\t\tconst handler = (payload: ProofState) => {\n\t\t\tcb({ ...payload, proof: proofMap[payload.Y] });\n\t\t};\n\t\tconst subId = ws.createSubscription({ kind: 'proof_state', filters: ys }, handler, err);\n\t\tconst cancel = () => ws.cancelSubscription(subId, handler);\n\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * Resolve once a mint quote transitions to PAID, with automatic unsubscription, optional abort\n\t * signal, and optional timeout.\n\t *\n\t * The underlying subscription is always cancelled after resolution or rejection, including on\n\t * timeout or abort.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const ac = new AbortController();\n\t * // Cancel if the user navigates away\n\t * window.addEventListener('beforeunload', () => ac.abort(), { once: true });\n\t *\n\t * try {\n\t * \tconst paid = await wallet.on.onceMintPaid(quoteId, {\n\t * \t\tsignal: ac.signal,\n\t * \t\ttimeoutMs: 60_000,\n\t * \t});\n\t * \tconsole.log('Mint paid, amount', paid.amount);\n\t * } catch (e) {\n\t * \tif ((e as Error).name === 'AbortError') {\n\t * \t\tconsole.log('User aborted');\n\t * \t} else {\n\t * \t\tconsole.error('Mint not paid', e);\n\t * \t}\n\t * }\n\t * ```\n\t *\n\t * @param id Mint quote id to watch.\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal to cancel the wait early.\n\t * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.\n\t * @returns A promise that resolves with the latest `MintQuoteBolt11Response` once PAID.\n\t */\n\tonceMintPaid(\n\t\tid: string,\n\t\topts?: { signal?: AbortSignal; timeoutMs?: number },\n\t): Promise<MintQuoteBolt11Response> {\n\t\treturn this.waitUntilPaid<MintQuoteBolt11Response>(\n\t\t\tthis.mintQuotePaid.bind(this),\n\t\t\tid,\n\t\t\topts,\n\t\t\t'Timeout waiting for mint paid',\n\t\t);\n\t}\n\n\t/**\n\t * Resolve when ANY of several mint quotes is PAID, cancelling the rest.\n\t *\n\t * Subscribes to all distinct ids, resolves with `{ id, quote }` for the first PAID, and cancels\n\t * all remaining subscriptions.\n\t *\n\t * Errors from individual subscriptions are ignored by default so a single noisy stream does not\n\t * abort the whole race. Set `failOnError: true` to reject on the first error instead. If all\n\t * subscriptions error and none paid, the promise rejects with the last seen error.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Race multiple quotes obtained from splitting a large top up\n\t * const { id, quote } = await wallet.on.onceAnyMintPaid(batchQuoteIds, {\n\t * \ttimeoutMs: 120_000,\n\t * });\n\t * console.log('First top up paid', id, quote.preimage?.length);\n\t * ```\n\t *\n\t * @param ids Array of mint quote ids (duplicates are ignored).\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal to cancel the wait early.\n\t * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.\n\t * @param opts.failOnError When true, reject on first error. Default false.\n\t * @returns A promise resolving to the id that won and its `MintQuoteBolt11Response`.\n\t */\n\tonceAnyMintPaid(\n\t\tids: string[],\n\t\topts?: { signal?: AbortSignal; timeoutMs?: number; failOnError?: boolean },\n\t): Promise<{ id: string; quote: MintQuoteBolt11Response }> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst unique = Array.from(new Set(ids));\n\t\t\tconst cancels: Map<string, CancellerLike> = new Map();\n\t\t\tlet to: ReturnType<typeof setTimeout> | null = null;\n\t\t\tlet lastError: unknown = null;\n\t\t\tlet fullyRegistered = false;\n\t\t\tlet done = false;\n\n\t\t\tconst cleanup = (err?: unknown) => {\n\t\t\t\tif (done) return;\n\t\t\t\tdone = true;\n\t\t\t\tfor (const c of cancels.values()) {\n\t\t\t\t\tcancelSafely(c);\n\t\t\t\t}\n\t\t\t\tcancels.clear();\n\t\t\t\tif (to) {\n\t\t\t\t\tclearTimeout(to);\n\t\t\t\t\tto = null;\n\t\t\t\t}\n\t\t\t\tif (opts?.signal) opts.signal.removeEventListener('abort', onAbort);\n\t\t\t\tif (err) reject(normalizeError(err));\n\t\t\t};\n\n\t\t\tconst onAbort = () => cleanup(makeAbortError());\n\n\t\t\tif (opts?.signal) {\n\t\t\t\tif (opts.signal.aborted) return onAbort();\n\t\t\t\topts.signal.addEventListener('abort', onAbort, { once: true });\n\t\t\t}\n\n\t\t\tif (opts?.timeoutMs && opts.timeoutMs > 0) {\n\t\t\t\tto = setTimeout(\n\t\t\t\t\t() => cleanup(new Error('Timeout waiting for any mint paid')),\n\t\t\t\t\topts.timeoutMs,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (unique.length === 0) return cleanup(new Error('No quote ids provided'));\n\n\t\t\tfor (const quoteId of unique) {\n\t\t\t\tconst c = this.mintQuotePaid(\n\t\t\t\t\tquoteId,\n\t\t\t\t\t(p) => {\n\t\t\t\t\t\tcleanup();\n\t\t\t\t\t\tresolve({ id: quoteId, quote: p });\n\t\t\t\t\t},\n\t\t\t\t\t(e) => {\n\t\t\t\t\t\t// Catch errors after setup\n\t\t\t\t\t\tif (opts?.failOnError) {\n\t\t\t\t\t\t\tcleanup(e);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastError = e;\n\n\t\t\t\t\t\tconst thisCanceller = cancels.get(quoteId);\n\t\t\t\t\t\tif (thisCanceller) {\n\t\t\t\t\t\t\tcancelSafely(thisCanceller);\n\t\t\t\t\t\t\tcancels.delete(quoteId);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (fullyRegistered && cancels.size === 0) {\n\t\t\t\t\t\t\tcleanup(lastError ?? new Error('No subscriptions remaining'));\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tcancels.set(quoteId, c);\n\n\t\t\t\t// Catch errors setting up\n\t\t\t\tvoid c.catch((e) => {\n\t\t\t\t\tif (opts?.failOnError) {\n\t\t\t\t\t\tcleanup(e);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlastError = e;\n\n\t\t\t\t\tconst thisCanceller = cancels.get(quoteId);\n\t\t\t\t\tif (thisCanceller) {\n\t\t\t\t\t\tcancelSafely(thisCanceller);\n\t\t\t\t\t\tcancels.delete(quoteId);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (fullyRegistered && cancels.size === 0) {\n\t\t\t\t\t\tcleanup(lastError ?? new Error('No subscriptions remaining'));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfullyRegistered = true;\n\t\t});\n\t}\n\n\t/**\n\t * Resolve once a melt quote transitions to PAID, with automatic unsubscription, optional abort\n\t * signal, and optional timeout.\n\t *\n\t * Mirrors onceMintPaid, but for melts.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * try {\n\t * \tconst paid = await wallet.on.onceMeltPaid(meltId, { timeoutMs: 45_000 });\n\t * \tconsole.log('Invoice paid by mint, paid msat', paid.paid ?? 0);\n\t * } catch (e) {\n\t * \tconsole.error('Payment did not complete in time', e);\n\t * }\n\t * ```\n\t *\n\t * @param id Melt quote id to watch.\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal to cancel the wait early.\n\t * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.\n\t * @returns A promise that resolves with the `MeltQuoteBolt11Response` once PAID.\n\t */\n\tonceMeltPaid(\n\t\tid: string,\n\t\topts?: { signal?: AbortSignal; timeoutMs?: number },\n\t): Promise<MeltQuoteBolt11Response> {\n\t\treturn this.waitUntilPaid<MeltQuoteBolt11Response>(\n\t\t\tthis.meltQuotePaid.bind(this),\n\t\t\tid,\n\t\t\topts,\n\t\t\t'Timeout waiting for melt paid',\n\t\t);\n\t}\n\n\t/**\n\t * Async iterable that yields proof state updates for the provided proofs.\n\t *\n\t * Adds a bounded buffer option:\n\t *\n\t * - If `maxBuffer` is set and the queue is full when a new payload arrives, either drop the oldest\n\t *   queued payload (`drop: 'oldest'`, default) or the incoming payload (`drop: 'newest'`). In\n\t *   both cases `onDrop` is invoked with the dropped payload.\n\t *\n\t * The stream ends and cleans up on abort or on the wallet error callback. Errors from the wallet\n\t * are treated as a graceful end for this iterator.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const ac = new AbortController();\n\t * try {\n\t * \tfor await (const update of wallet.on.proofStatesStream(myProofs)) {\n\t * \t\tif (update.state === CheckStateEnum.SPENT) {\n\t * \t\t\tconsole.warn('Spent proof', update.proof.id);\n\t * \t\t}\n\t * \t}\n\t * } catch (e) {\n\t * \tif ((e as Error).name !== 'AbortError') {\n\t * \t\tconsole.error('Stream error', e);\n\t * \t}\n\t * }\n\t * ```\n\t *\n\t * @param proofs The proofs to subscribe to. Only `secret` is required.\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal that stops the stream when aborted.\n\t * @param opts.maxBuffer Maximum number of queued items before applying the drop strategy.\n\t * @param opts.drop Overflow strategy when `maxBuffer` is reached, 'oldest' | 'newest'. Default\n\t *   'oldest'.\n\t * @param opts.onDrop Callback invoked with the payload that was dropped.\n\t * @returns An async iterable of update payloads.\n\t */\n\tproofStatesStream<T = unknown>(\n\t\tproofs: Proof[],\n\t\topts?: {\n\t\t\tsignal?: AbortSignal;\n\t\t\tmaxBuffer?: number;\n\t\t\tdrop?: 'oldest' | 'newest';\n\t\t\tonDrop?: (payload: T) => void;\n\t\t},\n\t): AsyncIterable<T> {\n\t\treturn async function* (this: WalletEvents) {\n\t\t\tconst queue: T[] = [];\n\t\t\tlet done = false;\n\t\t\tlet notify: (() => void) | null = null;\n\n\t\t\tconst max = opts?.maxBuffer && opts.maxBuffer > 0 ? opts.maxBuffer : Infinity;\n\t\t\tconst dropMode: 'oldest' | 'newest' = opts?.drop ?? 'oldest';\n\n\t\t\tconst wake = () => {\n\t\t\t\tconst n = notify;\n\t\t\t\tnotify = null;\n\t\t\t\tif (n) n();\n\t\t\t};\n\n\t\t\tconst push = (payload: T) => {\n\t\t\t\tif (queue.length >= max) {\n\t\t\t\t\tif (dropMode === 'oldest') {\n\t\t\t\t\t\tconst dropped = queue.shift();\n\t\t\t\t\t\tif (dropped !== undefined) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\topts?.onDrop?.(dropped);\n\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\t/* noop */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqueue.push(payload);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\topts?.onDrop?.(payload);\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t/* noop */\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn; // drop newest\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push(payload);\n\t\t\t\t}\n\t\t\t\twake();\n\t\t\t};\n\n\t\t\tconst cancelP: Promise<SubscriptionCanceller> = this.proofStateUpdates(\n\t\t\t\tproofs,\n\t\t\t\t(payload: ProofState & { proof: Proof }) => {\n\t\t\t\t\t// Accept wallet payload type and expose as generic T to consumer\n\t\t\t\t\tpush(payload as unknown as T);\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tdone = true;\n\t\t\t\t\twake();\n\t\t\t\t},\n\t\t\t\t{ signal: opts?.signal },\n\t\t\t);\n\n\t\t\tconst onAbort = () => {\n\t\t\t\tdone = true;\n\t\t\t\twake();\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tif (opts?.signal) {\n\t\t\t\t\tif (opts.signal.aborted) onAbort();\n\t\t\t\t\telse opts.signal.addEventListener('abort', onAbort, { once: true });\n\t\t\t\t}\n\t\t\t\twhile (!done || queue.length) {\n\t\t\t\t\twhile (queue.length) yield queue.shift()!;\n\t\t\t\t\tif (done) break;\n\t\t\t\t\tawait new Promise<void>((resolve) => (notify = resolve));\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tcancelSafely(cancelP);\n\t\t\t\tif (opts?.signal) opts.signal.removeEventListener('abort', onAbort);\n\t\t\t}\n\t\t}.call(this);\n\t}\n\n\t/**\n\t * Create a composite canceller that can collect many subscriptions and dispose them all in one\n\t * call.\n\t *\n\t * Accepts both a `SubscriptionCanceller` and a `Promise<SubscriptionCanceller>`. When the\n\t * composite canceller is called, all collected cancellations are invoked. Errors from individual\n\t * cancellers are caught and ignored.\n\t *\n\t * The returned function also has an `.add()` method to register more cancellers, and a\n\t * `.cancelled` boolean property for debugging.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const cancelAll = wallet.on.group();\n\t * cancelAll.add(wallet.on.mintQuotes(ids, onUpdate, onErr));\n\t * cancelAll.add(asyncSubscribeElsewhere());\n\t *\n\t * // later\n\t * cancelAll(); // disposes everything\n\t * ```\n\t *\n\t * @returns Composite canceller function with `.add()` and `.cancelled` members.\n\t */\n\tgroup(): SubscriptionCanceller & {\n\t\tadd: (c: CancellerLike) => CancellerLike;\n\t\tcancelled: boolean;\n\t} {\n\t\tconst cancels: CancellerLike[] = [];\n\t\tlet cancelled = false;\n\n\t\tconst cancelAll = (() => {\n\t\t\tif (cancelled) return;\n\t\t\tcancelled = true;\n\t\t\twhile (cancels.length) cancelSafely(cancels.pop());\n\t\t}) as SubscriptionCanceller & {\n\t\t\tadd: (c: CancellerLike) => CancellerLike;\n\t\t\tcancelled: boolean;\n\t\t};\n\n\t\tcancelAll.add = (c: CancellerLike) => {\n\t\t\tif (cancelled) {\n\t\t\t\t// already cancelled, immediately dispose newly added subscription\n\t\t\t\tcancelSafely(c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t\tcancels.push(c);\n\t\t\treturn c;\n\t\t};\n\n\t\tObject.defineProperty(cancelAll, 'cancelled', {\n\t\t\tget: () => cancelled,\n\t\t\tenumerable: true,\n\t\t});\n\n\t\treturn cancelAll;\n\t}\n}\n","import type { CounterSource } from './CounterSource';\n\n/**\n * Developer friendly view of the wallet's deterministic output counters.\n */\nexport class WalletCounters {\n\tconstructor(private readonly src: CounterSource) {}\n\t/**\n\t * Returns the \"next\" counter for a specified keyset.\n\t */\n\tasync peekNext(keysetId: string): Promise<number> {\n\t\tconst r = await this.src.reserve(keysetId, 0);\n\t\treturn r.start;\n\t}\n\n\t/**\n\t * Bumps the counter if it is behind `minNext` (no-op if ahead).\n\t */\n\tasync advanceToAtLeast(keysetId: string, minNext: number): Promise<void> {\n\t\t// Mandatory on CounterSource\n\t\tawait this.src.advanceToAtLeast(keysetId, minNext);\n\t}\n\n\t/**\n\t * Hard-sets the cursor (useful for tests or migrations).\n\t *\n\t * @throws If the CounterSource does not support setNext()\n\t */\n\tasync setNext(keysetId: string, next: number): Promise<void> {\n\t\t// Optional capability\n\t\tif (typeof this.src.setNext === 'function') {\n\t\t\tawait this.src.setNext(keysetId, next);\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error('CounterSource does not support setNext()');\n\t}\n\t/**\n\t * Returns the current \"next\" per keyset (what will be reserved next).\n\t *\n\t * @throws If the CounterSource does not support snapshot()\n\t */\n\tasync snapshot(): Promise<Record<string, number>> {\n\t\t// Optional capability\n\t\tif (typeof this.src.snapshot === 'function') {\n\t\t\treturn await this.src.snapshot();\n\t\t}\n\t\tthrow new Error('CounterSource does not support snapshot()');\n\t}\n}\n","/**\n * Cashu Wallet Class.\n *\n * @remarks\n * This is the instantiation point for the Cashu-TS library.\n */\n\nimport {\n\ttype MeltPreview,\n\ttype OutputType,\n\ttype OutputConfig,\n\ttype SendConfig,\n\ttype SendOfflineConfig,\n\ttype ReceiveConfig,\n\ttype MintProofsConfig,\n\ttype MeltProofsConfig,\n\ttype SwapTransaction,\n\ttype MeltProofsResponse,\n\ttype SendResponse,\n\ttype RestoreConfig,\n\ttype SecretsPolicy,\n\ttype SwapPreview,\n\ttype MeltBlanks,\n} from './types';\nimport {\n\ttype CounterSource,\n\tEphemeralCounterSource,\n\ttype OperationCounters,\n\ttype CounterRange,\n} from './CounterSource';\n\nimport {\n\tsignMintQuote,\n\tsignP2PKProofs as cryptoSignP2PKProofs,\n\thashToCurve,\n\tisP2PKSigAll,\n\tbuildP2PKSigAllMessage,\n\tassertSigAllInputs,\n\tbuildLegacyP2PKSigAllMessage,\n\tbuildInterimP2PKSigAllMessage,\n} from '../crypto';\nimport { Mint } from '../mint';\nimport { MintInfo } from '../model/MintInfo';\nimport { KeyChain } from './KeyChain';\nimport { type Keyset } from './Keyset';\nimport { WalletOps } from './WalletOps';\nimport { WalletEvents } from './WalletEvents';\nimport { WalletCounters } from './WalletCounters';\nimport { selectProofsRGLI, type SelectProofs } from './SelectProofs';\nimport { type Logger, NULL_LOGGER, fail, failIf, failIfNullish, safeCallback } from '../logger';\n\n// shared primitives and options\nimport type { Proof } from '../model/types/proof';\nimport type { Token } from '../model/types/token';\nimport type { SerializedBlindedSignature } from '../model/types/blinded';\nimport { CheckStateEnum, type ProofState } from '../model/types/NUT07';\nimport type { KeyChainCache, MintKeys, MintKeyset } from '../model/types/keyset';\nimport type {\n\tGetInfoResponse,\n\tMeltRequest,\n\tMeltQuoteBaseResponse,\n\tMeltQuoteBolt11Request,\n\tMeltQuoteBolt11Response,\n\tMeltQuoteBolt12Response,\n\tMintRequest,\n\tMintQuoteBolt11Response,\n\tMintQuoteBolt12Response,\n\tMintQuoteBolt11Request,\n\tMintQuoteBolt12Request,\n\tSwapRequest,\n} from '../model/types';\n\n// model helpers\nimport { OutputData, type OutputDataLike } from '../model/OutputData';\n\nimport {\n\tvalidateAmount,\n\tgetDecodedToken,\n\tgetKeepAmounts,\n\thasValidDleq,\n\tsplitAmount,\n\tsumProofs,\n\tsanitizeUrl,\n\tinvoiceHasAmountInHRP,\n} from '../utils';\nimport { type AuthProvider } from '../auth/AuthProvider';\n\nconst PENDING_KEYSET_ID = '__PENDING__';\n\n/**\n * Class that represents a Cashu wallet.\n *\n * @remarks\n * This class should act as the entry point for this library. Can be instantiated with a mint\n * instance or mint url.\n * @example\n *\n * ```typescript\n * import { Wallet } from '@cashu/cashu-ts';\n * const wallet = new Wallet('http://localhost:3338', { unit: 'sat' });\n * await wallet.loadMint(); // Initialize mint info, keysets, and keys\n * // Wallet is now ready to use, eg:\n * const proofs = [...]; // your array of unspent proofs\n * const { keep, send } = await wallet.send(32, proofs);\n * ```\n */\nclass Wallet {\n\t/**\n\t * Mint instance - allows direct calls to the mint.\n\t */\n\tpublic readonly mint: Mint;\n\t/**\n\t * Entry point for the builder.\n\t *\n\t * @example\n\t *\n\t *     const { keep, send } = await wallet.ops\n\t *     \t.send(5, proofs)\n\t *     \t.asDeterministic() // counter: 0 = auto\n\t *     \t.keepAsRandom()\n\t *     \t.includeFees(true)\n\t *     \t.run();\n\t *\n\t *     const proofs = await wallet.ops\n\t *     \t.receive(token)\n\t *     \t.asDeterministic()\n\t *     \t.keyset(wallet.keysetId)\n\t *     \t.run();\n\t */\n\tpublic readonly ops: WalletOps;\n\t/**\n\t * Convenience wrapper for events.\n\t */\n\tpublic readonly on: WalletEvents;\n\t/**\n\t * Developer-friendly counters API.\n\t */\n\tpublic readonly counters: WalletCounters;\n\tprivate _keyChain: KeyChain;\n\tprivate _seed: Uint8Array | undefined = undefined;\n\tprivate _unit = 'sat';\n\tprivate _mintInfo: MintInfo | undefined = undefined;\n\tprivate _denominationTarget = 3;\n\tprivate _secretsPolicy: SecretsPolicy = 'auto';\n\tprivate _counterSource: CounterSource;\n\tprivate _boundKeysetId: string = PENDING_KEYSET_ID;\n\tprivate _selectProofs: SelectProofs;\n\tprivate _logger: Logger;\n\n\t/**\n\t * Create a wallet for a given mint and unit. Call `loadMint` before use.\n\t *\n\t * Binding, if `options.keysetId` is omitted, the wallet binds to the cheapest active keyset for\n\t * this unit during `loadMint`. The keychain only loads keysets for this unit.\n\t *\n\t * Caching, to preload, provide both `keysets` and `keys`, otherwise the cache is ignored.\n\t *\n\t * Deterministic secrets, pass `bip39seed` and optionally `secretsPolicy`. Deterministic outputs\n\t * reserve counters from `counterSource`, or an ephemeral in memory source if not supplied.\n\t * `initialCounter` applies only with a supplied `keysetId` and the ephemeral source.\n\t *\n\t * Splitting, `denominationTarget` guides proof splits, default is 3. Override coin selection with\n\t * `selectProofs` if needed. Logging defaults to a null logger.\n\t *\n\t * @remarks\n\t * The options.keys, options.keysets, options.mintInfo options are deprecated. Use\n\t * wallet.loadMintFromCache() after init to load cached mint data.\n\t * @param mint Mint instance or URL.\n\t * @param options Optional settings.\n\t * @param options.unit Wallet unit, default 'sat'.\n\t * @param options.keysetId Bind to this keyset id, else bind on `loadMint`.\n\t * @param options.bip39seed BIP39 seed for deterministic secrets.\n\t * @param options.secretsPolicy Secrets policy, default 'auto'.\n\t * @param options.counterSource Counter source for deterministic outputs. If provided, this takes\n\t *   precedence over counterInit. Use when you need persistence across processes or devices.\n\t * @param options.counterInit Seed values for the built-in EphemeralCounterSource. Ignored if\n\t *   counterSource is also provided.\n\t * @param options.keys DEPRECATED: Use `wallet.loadMintFromCache` after init.\n\t * @param options.keysets DEPRECATED: Use `wallet.loadMintFromCache` after init.\n\t * @param options.mintInfo DEPRECATED: Use `wallet.loadMintFromCache` after init.\n\t * @param options.denominationTarget Target proofs per denomination, default 3.\n\t * @param options.selectProofs Custom proof selection function.\n\t * @param options.logger Logger instance, default null logger.\n\t */\n\tconstructor(\n\t\tmint: Mint | string,\n\t\toptions?: {\n\t\t\tunit?: string;\n\t\t\tauthProvider?: AuthProvider;\n\t\t\tkeysetId?: string; // if omitted, wallet binds to cheapest in loadMint\n\t\t\tbip39seed?: Uint8Array;\n\t\t\tsecretsPolicy?: SecretsPolicy; // optional, auto\n\t\t\tcounterSource?: CounterSource; // optional, otherwise ephemeral\n\t\t\tcounterInit?: Record<string, number>; // optional, starting \"next\" per keyset\n\t\t\t/**\n\t\t\t * @deprecated Use `wallet.loadMintFromCache` after init.\n\t\t\t */\n\t\t\tkeys?: MintKeys[] | MintKeys;\n\t\t\t/**\n\t\t\t * @deprecated Use `wallet.loadMintFromCache` after init.\n\t\t\t */\n\t\t\tkeysets?: MintKeyset[];\n\t\t\t/**\n\t\t\t * @deprecated Use `wallet.loadMintFromCache` after init.\n\t\t\t */\n\t\t\tmintInfo?: GetInfoResponse;\n\t\t\tdenominationTarget?: number;\n\t\t\tselectProofs?: SelectProofs; // optional override\n\t\t\tlogger?: Logger;\n\t\t},\n\t) {\n\t\tthis.ops = new WalletOps(this);\n\t\tthis.on = new WalletEvents(this);\n\t\tthis._logger = options?.logger ?? NULL_LOGGER; // init early (seed can throw)\n\t\tthis._selectProofs = options?.selectProofs ?? selectProofsRGLI; // vital\n\t\tthis.mint =\n\t\t\ttypeof mint === 'string'\n\t\t\t\t? new Mint(mint, { authProvider: options?.authProvider, logger: this._logger })\n\t\t\t\t: mint;\n\t\tthis._unit = options?.unit ?? this._unit;\n\t\tthis._boundKeysetId = options?.keysetId ?? this._boundKeysetId;\n\t\tif (options?.bip39seed) {\n\t\t\tthis.failIf(\n\t\t\t\t!(options.bip39seed instanceof Uint8Array),\n\t\t\t\t'bip39seed must be a valid Uint8Array',\n\t\t\t\t{\n\t\t\t\t\tbip39seed: options.bip39seed,\n\t\t\t\t},\n\t\t\t);\n\t\t\tthis._seed = options.bip39seed;\n\t\t}\n\t\tthis._secretsPolicy = options?.secretsPolicy ?? this._secretsPolicy;\n\t\tif (options?.counterSource) {\n\t\t\tthis._counterSource = options.counterSource;\n\t\t} else {\n\t\t\tthis._counterSource = new EphemeralCounterSource(options?.counterInit);\n\t\t}\n\t\tthis.counters = new WalletCounters(this._counterSource);\n\t\tthis._keyChain = new KeyChain(this.mint, this._unit);\n\t\tthis._denominationTarget = options?.denominationTarget ?? this._denominationTarget;\n\n\t\t// TODO: Deprecated cache init - to be removed with deprecated constructor options\n\t\tif (options?.keysets && options?.keys && options?.mintInfo) {\n\t\t\tconst allKeys = Array.isArray(options.keys) ? options.keys : [options.keys];\n\t\t\t// Convert Mint DTOs to KeyChainCache\n\t\t\tconst cache: KeyChainCache = KeyChain.mintToCacheDTO(\n\t\t\t\tthis._unit,\n\t\t\t\tthis.mint.mintUrl,\n\t\t\t\toptions.keysets,\n\t\t\t\tallKeys,\n\t\t\t);\n\t\t\tthis.loadMintFromCache(options.mintInfo, cache);\n\t\t}\n\t}\n\n\t// Convenience wrappers for \"log and throw\"\n\tprivate fail(message: string, context?: Record<string, unknown>): never {\n\t\treturn fail(message, this._logger, context);\n\t}\n\tprivate failIf(\n\t\tcondition: boolean,\n\t\tmessage: string,\n\t\tcontext?: Record<string, unknown>,\n\t): asserts condition is false {\n\t\treturn failIf(condition, message, this._logger, context);\n\t}\n\tprivate failIfNullish<T>(\n\t\tvalue: T,\n\t\tmessage: string,\n\t\tcontext?: Record<string, unknown>,\n\t): asserts value is Exclude<T, null | undefined> {\n\t\treturn failIfNullish(value, message, this._logger, context);\n\t}\n\tprivate safeCallback<T>(\n\t\tcb: ((p: T) => void) | undefined,\n\t\tpayload: T,\n\t\tcontext?: Record<string, unknown>,\n\t): void {\n\t\tsafeCallback(cb, payload, this._logger, context);\n\t}\n\n\t/**\n\t * Asserts amount is a positive, safe integer.\n\t *\n\t * @param amount To check.\n\t * @param op Caller method name (or other identifier) for debug.\n\t * @throws If not.\n\t */\n\tprivate assertAmount(amount: unknown, op: string): asserts amount is number {\n\t\ttry {\n\t\t\tvalidateAmount(amount, false);\n\t\t} catch (e) {\n\t\t\tthis.fail((e as Error).message, { op, amount });\n\t\t}\n\t}\n\n\t/**\n\t * Load mint information, keysets, and keys.\n\t *\n\t * @remarks\n\t * Must be called before using other methods, unless loading mint from cache. See:\n\t * `loadMintFromCache`.\n\t * @param forceRefresh If true, re-fetches data even if cached.\n\t * @throws If fetching mint info, keysets, or keys fails.\n\t */\n\tasync loadMint(forceRefresh?: boolean): Promise<void> {\n\t\tconst promises = [];\n\n\t\t// Load mint info\n\t\tif (!this._mintInfo || forceRefresh) {\n\t\t\tpromises.push(\n\t\t\t\tthis.mint.getInfo().then((info) => {\n\t\t\t\t\tthis._mintInfo = new MintInfo(info);\n\t\t\t\t\treturn null;\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\t// Load KeyChain\n\t\tpromises.push(this._keyChain.init(forceRefresh).then(() => null));\n\n\t\tawait Promise.all(promises);\n\t\tthis.finishInit();\n\t}\n\n\t/**\n\t * Load mint information, keysets, and keys from cached data.\n\t *\n\t * @remarks\n\t * Use this when you already have cached mint info and keychain cache and want to avoid network\n\t * calls.\n\t *\n\t * The `cache` argument should usually come from `wallet.keyChain.cache`.\n\t */\n\tloadMintFromCache(mintInfo: GetInfoResponse, cache: KeyChainCache): void {\n\t\tthis._mintInfo = new MintInfo(mintInfo);\n\t\tthis._keyChain.loadFromCache(cache);\n\t\tthis.finishInit();\n\t}\n\n\t/**\n\t * Finishes wiring up the wallet instance and checks we are \"Go for launch\".\n\t */\n\tprivate finishInit(): void {\n\t\t// Go Keychain?\n\t\tconst cheapestId = this._keyChain.getCheapestKeyset().id;\n\t\tthis._logger.debug('KeyChain', { keychain: this._keyChain.cache });\n\n\t\t// Bind the cheapest keyset if needed\n\t\tif (this._boundKeysetId === PENDING_KEYSET_ID) {\n\t\t\tthis._boundKeysetId = cheapestId;\n\t\t} else {\n\t\t\tconst k = this._keyChain.getKeyset(this._boundKeysetId);\n\t\t\tthis.failIf(!k.hasKeys, 'Wallet keyset has no keys', { keyset: k.id });\n\t\t}\n\n\t\t// Go Mintinfo?\n\t\tthis.getMintInfo();\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Getters\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Get the wallet's KeyChain.\n\t *\n\t * @returns The Keychain.\n\t */\n\tget keyChain(): KeyChain {\n\t\treturn this._keyChain;\n\t}\n\n\t/**\n\t * Get the wallet's unit.\n\t *\n\t * @returns The unit (e.g., 'sat').\n\t */\n\tget unit(): string {\n\t\treturn this._unit;\n\t}\n\n\t/**\n\t * Get information about the mint.\n\t *\n\t * @remarks\n\t * Returns cached mint info. Call `loadMint` first to initialize the wallet.\n\t * @returns Mint info.\n\t * @throws If mint info is not initialized.\n\t */\n\tgetMintInfo(): MintInfo {\n\t\tthis.failIfNullish(\n\t\t\tthis._mintInfo,\n\t\t\t'Mint info not initialized; call loadMint or loadMintFromCache first',\n\t\t);\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * The keyset ID bound to this wallet instance.\n\t */\n\tget keysetId(): string {\n\t\tthis.failIf(\n\t\t\tthis._boundKeysetId === PENDING_KEYSET_ID,\n\t\t\t'Wallet not initialised, call loadMint or loadMintFromCache first',\n\t\t);\n\t\treturn this._boundKeysetId;\n\t}\n\n\t/**\n\t * Gets the requested keyset or the keyset bound to the wallet.\n\t *\n\t * @remarks\n\t * This method enforces wallet policies. If `id` is omitted, it returns the keyset bound to this\n\t * wallet, including validation that:\n\t *\n\t * - The keyset exists in the keychain,\n\t * - The unit matches the wallet's unit,\n\t * - Keys are loaded for that keyset.\n\t *\n\t * Contrast with `keyChain.getKeyset(id?)`, which, when called without an id, returns the cheapest\n\t * active keyset for the unit, ignoring the wallet binding.\n\t * @param id Optional keyset id to resolve. If omitted, the wallet's bound keyset is used.\n\t * @returns The resolved `Keyset`.\n\t * @throws If the keyset is not found, has no keys, or its unit differs from the wallet.\n\t */\n\tpublic getKeyset(id?: string): Keyset {\n\t\tconst keyset = this._keyChain.getKeyset(id ?? this.keysetId);\n\t\tthis.failIf(keyset.unit !== this._unit, 'Keyset unit does not match wallet unit', {\n\t\t\tkeyset: keyset.id,\n\t\t\tunit: keyset.unit,\n\t\t\twalletUnit: this._unit,\n\t\t});\n\t\tthis.failIf(!keyset.hasKeys, 'Keyset has no keys loaded', { keyset: keyset.id });\n\t\treturn keyset;\n\t}\n\n\tpublic get logger(): Logger {\n\t\treturn this._logger;\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Counters\n\t// -----------------------------------------------------------------\n\n\tprivate async reserveFor(keysetId: string, totalOutputs: number): Promise<CounterRange> {\n\t\tif (totalOutputs <= 0) return { start: 0, count: 0 };\n\t\treturn this._counterSource.reserve(keysetId, totalOutputs);\n\t}\n\n\tprivate countersNeeded(ot: OutputType): number {\n\t\tif (ot.type !== 'deterministic' || ot.counter !== 0) return 0;\n\t\treturn (ot.denominations ?? []).length;\n\t}\n\n\tprivate async addCountersToOutputTypes(\n\t\tkeysetId: string,\n\t\t...outputTypes: OutputType[]\n\t): Promise<{ outputTypes: OutputType[]; used?: OperationCounters }> {\n\t\t// Get all outputTypes with a manual counter and denominations set.\n\t\tconst manual = outputTypes.filter(\n\t\t\t(ot): ot is Extract<OutputType, { type: 'deterministic' }> =>\n\t\t\t\tot.type === 'deterministic' && ot.counter > 0 && (ot.denominations?.length ?? 0) > 0,\n\t\t);\n\n\t\t// Reject if manual ranges overlap\n\t\tif (manual.length > 1) {\n\t\t\tconst ranges = manual\n\t\t\t\t.map((ot) => ({\n\t\t\t\t\tstart: ot.counter,\n\t\t\t\t\tend: ot.counter + ot.denominations!.length, // exclusive\n\t\t\t\t}))\n\t\t\t\t.sort((a, b) => a.start - b.start);\n\t\t\tfor (let i = 1; i < ranges.length; i++) {\n\t\t\t\tthis.failIf(ranges[i].start < ranges[i - 1].end, 'Manual counter ranges overlap', {\n\t\t\t\t\tkeysetId,\n\t\t\t\t\tprev: ranges[i - 1],\n\t\t\t\t\tcur: ranges[i],\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// If any deterministic OutputType has a manual counter (> 0), advance\n\t\t// the counter source so future \"auto\" allocations do not reuse counters.\n\t\tif (manual.length > 0) {\n\t\t\t// Get the max counter manually allocated\n\t\t\tconst maxManualEnd = Math.max(...manual.map((ot) => ot.counter + ot.denominations!.length));\n\n\t\t\t// Bump cursor to at least the end of the manually allocated range\n\t\t\tawait this._counterSource.advanceToAtLeast(keysetId, maxManualEnd);\n\t\t\tthis._logger.debug('Counter source advanced to respect manual deterministic counters', {\n\t\t\t\tkeysetId,\n\t\t\t\tmaxManualEnd,\n\t\t\t});\n\t\t}\n\n\t\t// Reserve counters for deterministic outputTypes with auto counter (counter===0))\n\t\tconst total = outputTypes.reduce((n, ot) => n + this.countersNeeded(ot), 0);\n\t\tif (total === 0) return { outputTypes };\n\n\t\tconst range = await this.reserveFor(keysetId, total);\n\t\tlet cursor = range.start;\n\n\t\tconst patched = outputTypes.map((ot): OutputType => {\n\t\t\tif (ot.type === 'deterministic' && ot.counter === 0) {\n\t\t\t\tconst need = ot.denominations?.length ?? 0;\n\t\t\t\tif (need > 0) {\n\t\t\t\t\tconst patched: typeof ot = { ...ot, counter: cursor };\n\t\t\t\t\tcursor += need;\n\t\t\t\t\treturn patched;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ot;\n\t\t});\n\n\t\t// Fire event after successful reservation (wallet does not await handlers)\n\t\tconst used = {\n\t\t\tkeysetId,\n\t\t\tstart: range.start,\n\t\t\tcount: range.count,\n\t\t\tnext: range.start + range.count,\n\t\t} as OperationCounters;\n\t\tthis.on._emitCountersReserved(used);\n\t\treturn { outputTypes: patched, used };\n\t}\n\n\t/**\n\t * Bind this wallet to a specific keyset id.\n\t *\n\t * @remarks\n\t * This changes the default keyset used by all operations that do not explicitly pass a keysetId.\n\t * The method validates that the keyset exists in the keychain, matches the wallet unit, and has\n\t * keys loaded.\n\t *\n\t * Typical uses:\n\t *\n\t * 1. After loadMint, to pin the wallet to a particular active keyset.\n\t * 2. After a refresh, to rebind deliberately rather than falling back to cheapest.\n\t *\n\t * @param id The keyset identifier to bind to.\n\t * @throws If keyset not found, if it has no keys loaded, or if its unit is not the wallet unit.\n\t */\n\tpublic bindKeyset(id: string): void {\n\t\tconst ks = this._keyChain.getKeyset(id);\n\t\tthis.failIf(ks.unit !== this._unit, 'Keyset unit does not match wallet unit', {\n\t\t\tkeyset: ks.id,\n\t\t\tunit: ks.unit,\n\t\t\twalletUnit: this._unit,\n\t\t});\n\t\tthis.failIf(!ks.hasKeys, 'Keyset has no keys loaded', { keyset: ks.id });\n\t\tthis._boundKeysetId = ks.id;\n\t\tthis._logger.debug('Wallet bound to keyset', {\n\t\t\tkeysetId: ks.id,\n\t\t\tunit: ks.unit,\n\t\t\tfeePPK: ks.fee,\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new Wallet bound to a different keyset, sharing the same CounterSource.\n\t *\n\t * Use this to operate on multiple keysets concurrently without mutating your original wallet.\n\t * Counters remain monotonic across instances because the same CounterSource is reused.\n\t *\n\t * Do NOT pass a fresh CounterSource for the same seed unless you know exactly why. Reusing\n\t * counters can recreate secrets that a mint will reject.\n\t *\n\t * @param id The keyset identifier to bind to.\n\t * @throws If keyset not found, if it has no keys loaded, or if its unit is not the wallet unit.\n\t */\n\tpublic withKeyset(id: string, opts?: { counterSource?: CounterSource }): Wallet {\n\t\tconst newWallet = new Wallet(this.mint, {\n\t\t\tkeysetId: id,\n\t\t\tbip39seed: this._seed,\n\t\t\tsecretsPolicy: this._secretsPolicy,\n\t\t\tlogger: this._logger,\n\t\t\tcounterSource: opts?.counterSource ?? this._counterSource,\n\t\t});\n\t\t// Load mint info from our caches\n\t\tnewWallet.loadMintFromCache(this.getMintInfo().cache, this._keyChain.cache);\n\t\treturn newWallet;\n\t}\n\n\t/**\n\t * Returns the default OutputType for this wallet, based on its configured secrets policy\n\t * (options?.secretsPolicy) and seed state.\n\t *\n\t * - If the secrets policy is 'random', returns { type: 'random' }.\n\t * - If the policy is 'deterministic', requires a seed and returns { type: 'deterministic', counter:\n\t *   0 }. Counter 0 is a flag meaning \"auto-increment from current state\".\n\t * - If no explicit policy is set, falls back to:\n\t *\n\t *   - Deterministic if a seed is present.\n\t *   - Random if no seed is present.\n\t *\n\t * @returns An OutputType object describing the default output strategy.\n\t * @throws Error if the policy is 'deterministic' but no seed has been set.\n\t */\n\tpublic defaultOutputType(): OutputType {\n\t\tif (this._secretsPolicy === 'random') return { type: 'random' };\n\t\tif (this._secretsPolicy === 'deterministic') {\n\t\t\tthis.failIfNullish(this._seed, 'Deterministic policy requires a seed');\n\t\t\treturn { type: 'deterministic', counter: 0 }; // 0 = auto flag\n\t\t}\n\t\treturn this._seed ? { type: 'deterministic', counter: 0 } : { type: 'random' };\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Output Creation\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Configures output denominations with fee adjustments and optimization.\n\t *\n\t * @remarks\n\t * If 'custom' outputType, data outputs MUST sum to the amount. Other outputTypes may supply\n\t * denominations. If no denominations are passed in, they will be calculated based on proofsWeHave\n\t * or the default split. If partial denominations are passed in, the balance will be added using\n\t * default split. Additional denominations to cover fees will then be added if required.\n\t * @param amount The total amount for outputs.\n\t * @param keyset The mint keyset.\n\t * @param outputType The output configuration.\n\t * @param includeFees Whether to include swap fees in the output amount.\n\t * @param proofsWeHave Optional proofs for optimizing denomination splitting.\n\t * @returns OutputType with required denominations.\n\t */\n\tprivate configureOutputs(\n\t\tamount: number,\n\t\tkeyset: Keyset,\n\t\toutputType: OutputType,\n\t\tincludeFees: boolean = false,\n\t\tproofsWeHave: Proof[] = [],\n\t): OutputType {\n\t\tlet newAmount = amount;\n\n\t\t// Custom outputs don't have automatic optimizations or fee inclusion)\n\t\tif (outputType.type === 'custom') {\n\t\t\tthis.failIf(includeFees, 'The custom OutputType does not support automatic fee inclusion');\n\n\t\t\t// Validate sum early, as no denominations to fill\n\t\t\tconst customTotal = OutputData.sumOutputAmounts(outputType.data);\n\t\t\tthis.failIf(\n\t\t\t\tcustomTotal !== amount,\n\t\t\t\t`Custom output data total (${customTotal}) does not match amount (${amount})`,\n\t\t\t);\n\t\t\treturn outputType;\n\t\t}\n\n\t\t// Start with any denominations provided.\n\t\t// Note: These MAY be partial (\"give me a [16,8], anything for the rest\")\n\t\t// We will complete the denomination set before we are done.\n\t\tlet denominations = outputType.denominations ?? [];\n\n\t\t// If no denominations, but proofsWeHave was provided - optimize\n\t\t// to get around _denominationTarget proofs of each denomination.\n\t\tif (denominations.length === 0 && proofsWeHave.length > 0) {\n\t\t\tdenominations = getKeepAmounts(\n\t\t\t\tproofsWeHave,\n\t\t\t\tnewAmount,\n\t\t\t\tkeyset.keys,\n\t\t\t\tthis._denominationTarget,\n\t\t\t);\n\t\t}\n\n\t\t// Fill in any missing denominations with default split.\n\t\t// NOTE: If we have to fill, the result will be in ASC order.\n\t\t// Original order is only maintained for exact denomination sets.\n\t\tdenominations = splitAmount(newAmount, keyset.keys, denominations);\n\n\t\t// If includeFees, we create additional output amounts to cover the\n\t\t// fee the receiver will pay when they spend the proofs (ie sender pays fees)\n\t\tif (includeFees) {\n\t\t\tlet receiveFee = this.getFeesForKeyset(denominations.length, keyset.id);\n\t\t\tlet receiveFeeAmounts = splitAmount(receiveFee, keyset.keys);\n\t\t\twhile (\n\t\t\t\tthis.getFeesForKeyset(denominations.length + receiveFeeAmounts.length, keyset.id) >\n\t\t\t\treceiveFee\n\t\t\t) {\n\t\t\t\treceiveFee++;\n\t\t\t\treceiveFeeAmounts = splitAmount(receiveFee, keyset.keys);\n\t\t\t}\n\t\t\tnewAmount += receiveFee;\n\t\t\tdenominations = [...denominations, ...receiveFeeAmounts];\n\t\t}\n\t\treturn { ...outputType, denominations };\n\t}\n\n\t/**\n\t * Sum total implied by a prepared OutputType. Note: Empty denomination is valid (e.g: zero\n\t * change).\n\t */\n\tprivate preparedTotal(ot: OutputType): number {\n\t\tif (ot.type === 'custom') return OutputData.sumOutputAmounts(ot.data);\n\t\tconst denoms = ot.denominations ?? [];\n\t\treturn denoms.reduce((a, b) => a + b, 0);\n\t}\n\n\t/**\n\t * Generates blinded messages based on the specified output type.\n\t *\n\t * @param amount The total amount for outputs.\n\t * @param keyset The mint keys.\n\t * @param outputType The output configuration.\n\t * @returns Prepared output data.\n\t */\n\tprivate createOutputData(\n\t\tamount: number,\n\t\tkeyset: Keyset,\n\t\toutputType: OutputType,\n\t): OutputDataLike[] {\n\t\t// we can accept zero (for blanks) or positive values\n\t\tthis.failIf(amount < 0, 'Amount was negative', { amount });\n\t\tif (\n\t\t\t// 'custom' OutputType has no denominations. Every other OutputType does.\n\t\t\t// so let's sanity check those were filled properly (eg: configureOutputs)\n\t\t\t'custom' != outputType.type &&\n\t\t\toutputType.denominations &&\n\t\t\toutputType.denominations.length > 0\n\t\t) {\n\t\t\tconst splitSum = outputType.denominations.reduce((sum, a) => sum + a, 0);\n\t\t\tthis.failIf(splitSum !== amount, 'Denominations do not sum to the expected amount', {\n\t\t\t\tsplitSum,\n\t\t\t\texpected: amount,\n\t\t\t});\n\t\t}\n\t\tlet outputData: OutputDataLike[];\n\t\tswitch (outputType.type) {\n\t\t\tcase 'random':\n\t\t\t\toutputData = OutputData.createRandomData(amount, keyset, outputType.denominations);\n\t\t\t\tbreak;\n\t\t\tcase 'deterministic':\n\t\t\t\tthis.failIfNullish(\n\t\t\t\t\tthis._seed,\n\t\t\t\t\t'Deterministic outputs require a seed configured in the wallet',\n\t\t\t\t);\n\t\t\t\toutputData = OutputData.createDeterministicData(\n\t\t\t\t\tamount,\n\t\t\t\t\tthis._seed,\n\t\t\t\t\toutputType.counter,\n\t\t\t\t\tkeyset,\n\t\t\t\t\toutputType.denominations,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'p2pk':\n\t\t\t\toutputData = OutputData.createP2PKData(\n\t\t\t\t\toutputType.options,\n\t\t\t\t\tamount,\n\t\t\t\t\tkeyset,\n\t\t\t\t\toutputType.denominations,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'factory': {\n\t\t\t\tconst factorySplit = splitAmount(amount, keyset.keys, outputType.denominations);\n\t\t\t\toutputData = factorySplit.map((a) => outputType.factory(a, keyset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'custom': {\n\t\t\t\toutputData = outputType.data;\n\t\t\t\tconst customTotal = OutputData.sumOutputAmounts(outputData);\n\t\t\t\tthis.failIf(\n\t\t\t\t\tcustomTotal !== amount,\n\t\t\t\t\t`Custom output data total (${customTotal}) does not match amount (${amount})`,\n\t\t\t\t);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthis.fail('Invalid OutputType');\n\t\t\t}\n\t\t}\n\t\treturn outputData;\n\t}\n\n\t/**\n\t * Creates a swap transaction with sorted outputs for privacy. This prevents a mint working out\n\t * which proofs will be sent or kept.\n\t *\n\t * @param inputs Prepared input proofs.\n\t * @param keepOutputs Outputs to keep (change or receiver's proofs).\n\t * @param sendOutputs Outputs to send (optional, default empty for receive/mint).\n\t * @returns Swap transaction with payload and metadata for processing signatures.\n\t */\n\tprivate createSwapTransaction(\n\t\tinputs: Proof[],\n\t\tkeepOutputs: OutputDataLike[],\n\t\tsendOutputs: OutputDataLike[] = [],\n\t): SwapTransaction {\n\t\t// Prepare inputs for mint\n\t\tinputs = this._prepareInputsForMint(inputs);\n\n\t\t// Sort ASC by amount for privacy, but keep indices to return order afterwards\n\t\t// But ONLY if the transaction is NOT SIG_ALL (as order is fixed for signing)\n\t\tconst mergedBlindingData = [...keepOutputs, ...sendOutputs];\n\t\tconst indices = mergedBlindingData.map((_, i) => i);\n\t\tif (!isP2PKSigAll(inputs)) {\n\t\t\tindices.sort(\n\t\t\t\t(a, b) =>\n\t\t\t\t\tmergedBlindingData[a].blindedMessage.amount - mergedBlindingData[b].blindedMessage.amount,\n\t\t\t);\n\t\t}\n\t\tconst keepVector: boolean[] = [\n\t\t\t...Array.from({ length: keepOutputs.length }, () => true),\n\t\t\t...Array.from({ length: sendOutputs.length }, () => false),\n\t\t];\n\t\tconst sortedOutputData: OutputDataLike[] = indices.map((i) => mergedBlindingData[i]);\n\t\tconst sortedKeepVector: boolean[] = indices.map((i) => keepVector[i]);\n\t\tconst outputs = sortedOutputData.map((d) => d.blindedMessage);\n\t\tthis._logger.debug('createSwapTransaction:', {\n\t\t\tindices,\n\t\t\tsortedKeepVector,\n\t\t\t// outputs, // <-- removed for security\n\t\t});\n\t\tconst payload: SwapRequest = {\n\t\t\tinputs,\n\t\t\toutputs,\n\t\t};\n\t\treturn {\n\t\t\tpayload,\n\t\t\toutputData: sortedOutputData,\n\t\t\tkeepVector: sortedKeepVector,\n\t\t\tsortedIndices: indices,\n\t\t};\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Send and Receive\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Receive a token (swaps with mint for new proofs)\n\t *\n\t * @example\n\t *\n\t * ```typescript\n\t * const result = await wallet.receive(\n\t * \ttoken,\n\t * \t{ includeFees: true },\n\t * \t{ type: 'deterministic', counter: 0 },\n\t * );\n\t * ```\n\t *\n\t * @param token Token string or decoded token.\n\t * @param config Optional receive config.\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Newly minted proofs.\n\t */\n\tasync receive(\n\t\ttoken: Token | string,\n\t\tconfig?: ReceiveConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\t// Prepare and complete the send\n\t\tconst txn = await this.prepareSwapToReceive(token, config, outputType);\n\t\tconst { keep } = await this.completeSwap(txn, config?.privkey);\n\t\treturn keep;\n\t}\n\n\t/**\n\t * Prepare A Receive Transaction.\n\t *\n\t * @remarks\n\t * Allows you to preview fees for a receive, get concrete outputs for P2PK SIG_ALL transactions,\n\t * and do any pre-swap tasks (such as marking proofs in-flight etc)\n\t * @example\n\t *\n\t * ```typescript\n\t * // Prepare transaction\n\t * const txn = await wallet.prepareSwapToReceive(token, { requireDleq: true });\n\t * const fees = txn.fees;\n\t *\n\t * // Complete transaction\n\t * const { keep } = await wallet.completeSwap(txn);\n\t * ```\n\t *\n\t * @param token Token string or decoded token.\n\t * @param config Optional receive config.\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns SwapPreview with metadata for swap transaction.\n\t */\n\tasync prepareSwapToReceive(\n\t\ttoken: Token | string,\n\t\tconfig?: ReceiveConfig,\n\t\toutputType?: OutputType,\n\t): Promise<SwapPreview> {\n\t\tconst { keysetId, requireDleq, proofsWeHave, onCountersReserved } = config || {};\n\t\toutputType = outputType ?? this.defaultOutputType(); // Fallback to policy\n\n\t\t// Decode and validate token\n\t\tconst decodedToken = typeof token === 'string' ? this.decodeToken(token) : token;\n\t\tconst tokenMintUrl = sanitizeUrl(decodedToken.mint);\n\t\tthis.failIf(tokenMintUrl !== this.mint.mintUrl, 'Token belongs to a different mint', {\n\t\t\ttoken: tokenMintUrl,\n\t\t\twallet: this.mint.mintUrl,\n\t\t});\n\t\tthis.failIf(decodedToken.unit !== this._unit, 'Token is not in wallet unit', {\n\t\t\ttoken: decodedToken.unit,\n\t\t\twallet: this._unit,\n\t\t});\n\n\t\t// Extract token proofs\n\t\tlet proofs: Proof[] = [];\n\t\t({ proofs } = decodedToken);\n\t\tconst totalAmount = sumProofs(proofs);\n\t\tthis.failIf(totalAmount === 0, 'Token contains no proofs', { proofs });\n\t\tthis.assertAmount(totalAmount, 'prepareSwapToReceive');\n\n\t\t// Check DLEQs if needed\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tif (requireDleq) {\n\t\t\tfor (const p of proofs) {\n\t\t\t\tconst ks = this._keyChain.getKeyset(p.id);\n\t\t\t\tif (!hasValidDleq(p, ks)) {\n\t\t\t\t\tthis.fail('Token contains proofs with invalid or missing DLEQ');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Shape receive output type and denominations\n\t\tconst swapFee = this.getFeesForProofs(proofs);\n\t\tconst amount = totalAmount - swapFee;\n\t\tlet receiveOT = this.configureOutputs(\n\t\t\tamount,\n\t\t\tkeyset,\n\t\t\toutputType,\n\t\t\tfalse, // includeFees is not applicable for receive\n\t\t\tproofsWeHave,\n\t\t);\n\n\t\t// Assign counter atomically if OutputType is deterministic\n\t\t// and the counter is zero (auto-assign)\n\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, receiveOT);\n\t\t[receiveOT] = autoCounters.outputTypes;\n\t\tif (autoCounters.used) {\n\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'receive' });\n\t\t}\n\t\tthis._logger.debug('receive counter', { counter: autoCounters.used, receiveOT });\n\n\t\t// Create outputs and execute swap\n\t\tconst outputs = this.createOutputData(this.preparedTotal(receiveOT), keyset, receiveOT);\n\n\t\t// Return SwapPreview\n\t\treturn {\n\t\t\tamount,\n\t\t\tfees: swapFee,\n\t\t\tkeysetId: keyset.id,\n\t\t\tinputs: proofs,\n\t\t\tkeepOutputs: outputs,\n\t\t} as SwapPreview;\n\t}\n\n\t/**\n\t * Sends proofs of a given amount from provided proofs.\n\t *\n\t * @remarks\n\t * If proofs are P2PK-locked to your public key, call signP2PKProofs first to sign them. The\n\t * default config uses exact match selection, and does not includeFees or requireDleq. Because the\n\t * send is offline, the user will unlock the signed proofs when they receive them online.\n\t * @param amount Amount to send.\n\t * @param proofs Array of proofs (must sum >= amount; pre-sign if P2PK-locked).\n\t * @param config Optional parameters for the send.\n\t * @returns SendResponse with keep/send proofs.\n\t * @throws Throws if the send cannot be completed offline.\n\t */\n\tsendOffline(amount: number, proofs: Proof[], config?: SendOfflineConfig): SendResponse {\n\t\tthis.assertAmount(amount, 'sendOffline');\n\t\tconst { requireDleq = false, includeFees = false, exactMatch = true } = config || {};\n\t\tif (requireDleq) {\n\t\t\t// Only use proofs that have a DLEQ\n\t\t\tproofs = proofs.filter((p: Proof) => p.dleq != undefined);\n\t\t}\n\t\tthis.failIf(sumProofs(proofs) < amount, 'Not enough funds available to send');\n\n\t\tconst { keep, send } = this.selectProofsToSend(proofs, amount, includeFees, exactMatch);\n\t\t// Ensure witnesses are serialized, strip DLEQ if not required\n\t\tconst sendPrepared = this._prepareInputsForMint(send, requireDleq);\n\t\treturn { keep, send: sendPrepared };\n\t}\n\n\t/**\n\t * Send proofs with online swap if necessary.\n\t *\n\t * @example\n\t *\n\t * ```typescript\n\t * // Simple send\n\t * const result = await wallet.send(5, proofs);\n\t *\n\t * // With a SendConfig\n\t * const result = await wallet.send(5, proofs, { includeFees: true });\n\t *\n\t * // With Custom output configuration\n\t * const customConfig: OutputConfig = {\n\t * \tsend: { type: 'p2pk', options: { pubkey: '...' } },\n\t * \tkeep: { type: 'deterministic', counter: 0 },\n\t * };\n\t * const customResult = await wallet.send(5, proofs, { includeFees: true }, customConfig);\n\t * ```\n\t *\n\t * @param amount Amount to send (receiver gets this net amount).\n\t * @param proofs Array of proofs to split.\n\t * @param config Optional parameters for the swap.\n\t * @returns SendResponse with keep/send proofs.\n\t * @throws Throws if the send cannot be completed offline or if funds are insufficient.\n\t */\n\tasync send(\n\t\tamount: number,\n\t\tproofs: Proof[],\n\t\tconfig?: SendConfig,\n\t\toutputConfig?: OutputConfig,\n\t): Promise<SendResponse> {\n\t\tthis.assertAmount(amount, 'send');\n\t\tconst { keysetId, includeFees = false } = config || {};\n\t\t// Fallback to policy defaults if no outputConfig\n\t\toutputConfig = outputConfig ?? {\n\t\t\tsend: this.defaultOutputType(),\n\t\t\tkeep: this.defaultOutputType(),\n\t\t};\n\n\t\t// First, let's see if we can avoid a swap (and fees)\n\t\t// by trying an exact match offline selection, including fees if\n\t\t// we are giving the receiver the amount + their fee to receive\n\t\t// In Wallet.ts, near send()\n\n\t\ttry {\n\t\t\t// Offline exact-match only allowed for plain-random defaults; deterministic implies swap.\n\t\t\tconst wantsDeterministicByPolicy = this.defaultOutputType().type === 'deterministic';\n\t\t\tconst isPlainRandom = (ot?: OutputType) =>\n\t\t\t\t!ot || (ot.type === 'random' && (!ot.denominations || ot.denominations.length === 0));\n\n\t\t\tif (\n\t\t\t\tkeysetId ||\n\t\t\t\twantsDeterministicByPolicy ||\n\t\t\t\t!isPlainRandom(outputConfig.send) ||\n\t\t\t\t(outputConfig.keep && !isPlainRandom(outputConfig.keep))\n\t\t\t) {\n\t\t\t\t// Explain why we must fall back to swap\n\t\t\t\tconst reasons: string[] = [];\n\t\t\t\tif (keysetId) reasons.push('keysetId override');\n\t\t\t\tif (wantsDeterministicByPolicy) reasons.push('wallet default is deterministic');\n\t\t\t\tif (!isPlainRandom(outputConfig.send)) reasons.push('non-default send output type');\n\t\t\t\tif (outputConfig.keep && !isPlainRandom(outputConfig.keep))\n\t\t\t\t\treasons.push('non-default keep output type');\n\n\t\t\t\tthrow new Error(`Options require a swap: ${reasons.join(', ')}`);\n\t\t\t}\n\n\t\t\t// Proceed with offline exact-match attempt\n\t\t\tconst { keep, send } = this.sendOffline(amount, proofs, {\n\t\t\t\tincludeFees,\n\t\t\t\texactMatch: true,\n\t\t\t\trequireDleq: false, // safety\n\t\t\t});\n\t\t\tconst expectedFee = includeFees ? this.getFeesForProofs(send) : 0;\n\n\t\t\tif (sumProofs(send) === amount + expectedFee) {\n\t\t\t\tthis._logger.info('Successful exactMatch offline selection!');\n\t\t\t\treturn { keep, send };\n\t\t\t}\n\t\t} catch (e: unknown) {\n\t\t\tconst message = e instanceof Error ? e.message : 'Unknown error';\n\t\t\tthis._logger.debug('ExactMatch offline selection failed.', { e: message });\n\t\t}\n\n\t\t// Prepare and complete the send\n\t\tconst txn = await this.prepareSwapToSend(amount, proofs, config, outputConfig);\n\t\treturn await this.completeSwap(txn, config?.privkey);\n\t}\n\n\t/**\n\t * Prepare A Send Transaction.\n\t *\n\t * @remarks\n\t * Allows you to preview fees for a send, get concrete outputs for P2PK SIG_ALL transactions, and\n\t * do any pre-swap tasks (such as marking proofs in-flight etc)\n\t * @example\n\t *\n\t * ```typescript\n\t * // Prepare transaction\n\t * const txn = await wallet.prepareSwapToSend(5, proofs, { includeFees: true });\n\t * const fees = txn.fees;\n\t *\n\t * // Complete transaction\n\t * const { keep, send } = await wallet.completeSwap(txn);\n\t * ```\n\t *\n\t * @param amount Amount to send (receiver gets this net amount).\n\t * @param proofs Array of proofs to split.\n\t * @param config Optional parameters for the swap.\n\t * @returns SwapPreview with metadata for swap transaction.\n\t * @throws Throws if the send cannot be completed offline or if funds are insufficient.\n\t */\n\tasync prepareSwapToSend(\n\t\tamount: number,\n\t\tproofs: Proof[],\n\t\tconfig?: SendConfig,\n\t\toutputConfig?: OutputConfig,\n\t): Promise<SwapPreview> {\n\t\tconst { keysetId, includeFees = false, onCountersReserved } = config || {};\n\n\t\t// Fallback to policy defaults if no outputConfig\n\t\toutputConfig = outputConfig ?? {\n\t\t\tsend: this.defaultOutputType(),\n\t\t\tkeep: this.defaultOutputType(),\n\t\t};\n\n\t\t// Fetch keys\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\n\t\t// Shape SEND output type and denominations\n\t\tlet sendOT = this.configureOutputs(\n\t\t\tamount,\n\t\t\tkeyset,\n\t\t\toutputConfig.send ?? this.defaultOutputType(),\n\t\t\tincludeFees,\n\t\t);\n\t\tconst sendAmount = this.preparedTotal(sendOT);\n\n\t\t// Select the subset of proofs needed to cover the swap (sendTarget + swap fee)\n\t\tconst { keep: unselectedProofs, send: selectedProofs } = this.selectProofsToSend(\n\t\t\tproofs,\n\t\t\tsendAmount,\n\t\t\ttrue, // Include fees to cover swap fee\n\t\t);\n\t\t// this._logger.debug('PROOFS SELECTED', {\n\t\t// \tunselectedProofs: unselectedProofs.map(p=>p.amount),\n\t\t// \tselectedProofs: selectedProofs.map(p=>p.amount),\n\t\t// });\n\t\tif (selectedProofs.length === 0) {\n\t\t\tthrow new Error('Not enough funds available to send');\n\t\t}\n\n\t\t// Calculate our expected change from the swap (and sanity check!)\n\t\tconst selectedSum = sumProofs(selectedProofs);\n\t\tconst swapFee = this.getFeesForProofs(selectedProofs);\n\t\tconst changeAmount = selectedSum - swapFee - sendAmount;\n\t\tthis.failIf(changeAmount < 0, 'Not enough funds available for swap', {\n\t\t\tselectedSum,\n\t\t\tswapFee,\n\t\t\tsendAmount,\n\t\t\tchangeAmount,\n\t\t});\n\n\t\t// Shape KEEP (change) output type and denominations\n\t\t// No includeFees, as we are the receiver of the change\n\t\tlet keepOT = this.configureOutputs(\n\t\t\tchangeAmount,\n\t\t\tkeyset,\n\t\t\toutputConfig.keep ?? this.defaultOutputType(),\n\t\t\tfalse,\n\t\t\tconfig?.proofsWeHave,\n\t\t);\n\t\tconst keepAmount = this.preparedTotal(keepOT);\n\n\t\t// Assign counters atomically if either/both OutputTypes are deterministic\n\t\t// and the counter is zero (auto-assign)\n\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, sendOT, keepOT);\n\t\t[sendOT, keepOT] = autoCounters.outputTypes;\n\t\tif (autoCounters.used) {\n\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'send' });\n\t\t}\n\t\tthis._logger.debug('send counters', { counter: autoCounters.used, sendOT, keepOT });\n\n\t\t// Create the output data\n\t\tconst sendOutputs = this.createOutputData(sendAmount, keyset, sendOT);\n\t\tconst keepOutputs = this.createOutputData(keepAmount, keyset, keepOT);\n\n\t\t// Return SwapPreview\n\t\treturn {\n\t\t\tamount,\n\t\t\tfees: swapFee,\n\t\t\tkeysetId: keyset.id,\n\t\t\tinputs: selectedProofs,\n\t\t\tsendOutputs,\n\t\t\tkeepOutputs,\n\t\t\tunselectedProofs,\n\t\t} as SwapPreview;\n\t}\n\n\t/**\n\t * Complete a prepared swap transaction.\n\t *\n\t * @example\n\t *\n\t * ```typescript\n\t * // Prepare transaction\n\t * const txn = await wallet.prepareSwapToSend(5, proofs, { includeFees: true });\n\t *\n\t * // Complete transaction\n\t * const result = await wallet.completeSwap(txn);\n\t * ```\n\t *\n\t * @param swapPreview With metadata for swap transaction.\n\t * @param privkey The private key(s) for signing.\n\t * @returns SendResponse with keep/send proofs.\n\t */\n\tasync completeSwap(swapPreview: SwapPreview, privkey?: string | string[]): Promise<SendResponse> {\n\t\tconst keepOutputs: OutputDataLike[] = swapPreview?.keepOutputs ? swapPreview.keepOutputs : [];\n\t\tconst sendOutputs: OutputDataLike[] = swapPreview.sendOutputs ? swapPreview.sendOutputs : [];\n\t\tconst unselectedProofs: Proof[] = swapPreview.unselectedProofs\n\t\t\t? swapPreview.unselectedProofs\n\t\t\t: [];\n\n\t\t// Sign proofs if needed\n\t\tif (privkey) {\n\t\t\tswapPreview.inputs = this.signP2PKProofs(swapPreview.inputs, privkey, [\n\t\t\t\t...keepOutputs,\n\t\t\t\t...sendOutputs,\n\t\t\t]);\n\t\t}\n\n\t\t// Create swap transaction\n\t\tconst swapTransaction = this.createSwapTransaction(\n\t\t\tswapPreview.inputs,\n\t\t\tkeepOutputs,\n\t\t\tsendOutputs,\n\t\t);\n\n\t\t// Execute swap\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\t\tthis.failIf(\n\t\t\tsignatures.length < swapTransaction.outputData.length,\n\t\t\t`Mint returned ${signatures.length} signatures, expected ${swapTransaction.outputData.length}`,\n\t\t);\n\n\t\t// Construct proofs\n\t\tconst keyset = this.getKeyset(swapPreview.keysetId);\n\t\tconst swapProofs = swapTransaction.outputData.map((d, i) => d.toProof(signatures[i], keyset));\n\t\tconst reorderedProofs = Array(swapProofs.length);\n\t\tconst reorderedKeepVector = Array(swapTransaction.keepVector.length);\n\t\tswapTransaction.sortedIndices.forEach((s, i) => {\n\t\t\treorderedKeepVector[s] = swapTransaction.keepVector[i];\n\t\t\treorderedProofs[s] = swapProofs[i];\n\t\t});\n\t\tconst keepProofs: Proof[] = [];\n\t\tconst sendProofs: Proof[] = [];\n\t\treorderedProofs.forEach((p: Proof, i) => {\n\t\t\tif (reorderedKeepVector[i]) {\n\t\t\t\tkeepProofs.push(p);\n\t\t\t} else {\n\t\t\t\tsendProofs.push(p);\n\t\t\t}\n\t\t});\n\t\tthis._logger.debug('SEND COMPLETED', {\n\t\t\tunselectedProofs: unselectedProofs.map((p) => p.amount),\n\t\t\tkeepProofs: keepProofs.map((p) => p.amount),\n\t\t\tsendProofs: sendProofs.map((p) => p.amount),\n\t\t});\n\t\treturn {\n\t\t\tkeep: [...keepProofs, ...unselectedProofs],\n\t\t\tsend: sendProofs,\n\t\t};\n\t}\n\n\t/**\n\t * @deprecated - Use send()\n\t */\n\tpublic readonly swap = this.send.bind(this);\n\n\t// -----------------------------------------------------------------\n\t// Section: Transaction Helpers\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Selects proofs to send based on amount and fee inclusion.\n\t *\n\t * @remarks\n\t * Uses an adapted Randomized Greedy with Local Improvement (RGLI) algorithm, which has a time\n\t * complexity O(n log n) and space complexity O(n).\n\t * @param proofs Array of Proof objects available to select from.\n\t * @param amountToSend The target amount to send.\n\t * @param includeFees Optional boolean to include fees; Default: false.\n\t * @param exactMatch Optional boolean to require exact match; Default: false.\n\t * @returns SendResponse containing proofs to keep and proofs to send.\n\t * @throws Throws an error if an exact match cannot be found within MAX_TIMEMS.\n\t * @see https://crypto.ethz.ch/publications/files/Przyda02.pdf\n\t */\n\tselectProofsToSend(\n\t\tproofs: Proof[],\n\t\tamountToSend: number,\n\t\tincludeFees = false,\n\t\texactMatch = false,\n\t): SendResponse {\n\t\tthis.assertAmount(amountToSend, 'selectProofsToSend');\n\t\tconst { keep, send } = this._selectProofs(\n\t\t\tproofs,\n\t\t\tamountToSend,\n\t\t\tthis._keyChain,\n\t\t\tincludeFees,\n\t\t\texactMatch,\n\t\t);\n\t\treturn { keep, send };\n\t}\n\n\t/**\n\t * Prepares proofs for sending by signing P2PK-locked proofs.\n\t *\n\t * @remarks\n\t * Call this method before operations like send if the proofs are P2PK-locked and need unlocking.\n\t * This is a public wrapper for signing.\n\t * @param proofs The proofs to sign.\n\t * @param privkey The private key(s) for signing.\n\t * @param outputData Optional. For signing of SIG_ALL transactions.\n\t * @param quoteId Optional. For signing SIG_ALL melt transactions.\n\t * @returns Signed proofs.\n\t */\n\tsignP2PKProofs(\n\t\tproofs: Proof[],\n\t\tprivkey: string | string[],\n\t\toutputData?: OutputDataLike[],\n\t\tquoteId?: string,\n\t): Proof[] {\n\t\t// Normal case, sign everything as usual\n\t\tif (!isP2PKSigAll(proofs)) {\n\t\t\treturn cryptoSignP2PKProofs(proofs, privkey, this._logger);\n\t\t}\n\n\t\t// Ensure SIG_ALL conditions are met\n\t\tthis.failIfNullish(outputData, 'OutputData is required for SIG_ALL proof signing.');\n\t\tassertSigAllInputs(proofs);\n\n\t\t// SIG_ALL is in flux currently, so let's generate all known message formats\n\t\t// and sign the first proof only against each message...\n\t\tconst [first, ...rest] = proofs;\n\t\tlet signedFirst = first;\n\t\tconst messages = [\n\t\t\tbuildLegacyP2PKSigAllMessage(proofs, outputData, quoteId),\n\t\t\tbuildInterimP2PKSigAllMessage(proofs, outputData, quoteId),\n\t\t\tbuildP2PKSigAllMessage(proofs, outputData, quoteId),\n\t\t];\n\t\tfor (const msg of messages) {\n\t\t\tsignedFirst = cryptoSignP2PKProofs([signedFirst], privkey, this._logger, msg)[0];\n\t\t}\n\n\t\t// Return the proofs in same order as before\n\t\treturn [signedFirst, ...rest];\n\t}\n\n\t/**\n\t * Calculates the fees based on inputs (proofs)\n\t *\n\t * @param proofs Input proofs to calculate fees for.\n\t * @returns Fee amount.\n\t * @throws Throws an error if the proofs keyset is unknown.\n\t */\n\tgetFeesForProofs(proofs: Proof[]): number {\n\t\tconst sumPPK = proofs.reduce((a, c) => a + this.getProofFeePPK(c), 0);\n\t\treturn Math.ceil(sumPPK / 1000);\n\t}\n\n\t/**\n\t * Returns the current fee PPK for a proof according to the cached keyset.\n\t *\n\t * @param proof {Proof} A single proof.\n\t * @returns FeePPK {number} The feePPK for the selected proof.\n\t * @throws Throws an error if the proofs keyset is unknown.\n\t */\n\tprivate getProofFeePPK(proof: Proof): number {\n\t\ttry {\n\t\t\t// We need the proof's keyset so use keyChain here\n\t\t\t// We must NOT fallback to wallet's keyset\n\t\t\treturn this._keyChain.getKeyset(proof.id).fee;\n\t\t} catch (e) {\n\t\t\tthis.fail(`Could not get fee. No keyset found for keyset id: ${proof.id}`, {\n\t\t\t\te,\n\t\t\t\tkeychain: this._keyChain.getKeysets(),\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the fees based on inputs for a given keyset.\n\t *\n\t * @param nInputs Number of inputs.\n\t * @param keysetId KeysetId used to lookup `input_fee_ppk`\n\t * @returns Fee amount.\n\t */\n\tgetFeesForKeyset(nInputs: number, keysetId: string): number {\n\t\ttry {\n\t\t\t// We must NOT fallback to wallet's keyset\n\t\t\tconst feePPK = this._keyChain.getKeyset(keysetId).fee;\n\t\t\treturn Math.floor(Math.max((nInputs * feePPK + 999) / 1000, 0));\n\t\t} catch (e) {\n\t\t\tthis.fail(`No keyset found with ID ${keysetId}`, { e });\n\t\t}\n\t}\n\n\t/**\n\t * Prepares inputs for a mint operation.\n\t *\n\t * @remarks\n\t * Internal method; strips DLEQ (NUT-12) and p2pk_e (NUT-26) for privacy and serializes witnesses.\n\t * Returns an array of new proof objects - does not mutate the originals.\n\t * @param proofs The proofs to prepare.\n\t * @param keepDleq Optional boolean to keep DLEQ (default: false, strips for privacy).\n\t * @returns Prepared proofs for mint payload.\n\t */\n\tprivate _prepareInputsForMint(proofs: Proof[], keepDleq: boolean = false): Proof[] {\n\t\treturn proofs.map((p) => {\n\t\t\tconst witness =\n\t\t\t\tp.witness && typeof p.witness !== 'string' ? JSON.stringify(p.witness) : p.witness;\n\t\t\tconst { dleq, p2pk_e, ...rest } = p; // isolate dleq and p2pk_e\n\t\t\tvoid p2pk_e; // intentionally unused (linter)\n\t\t\t// New proof object\n\t\t\treturn keepDleq && dleq ? { ...rest, dleq, witness } : { ...rest, witness };\n\t\t});\n\t}\n\n\t/**\n\t * Decodes a string token.\n\t *\n\t * @remarks\n\t * Rehydrates a token from the space-saving CBOR format, including mapping short keyset ids to\n\t * their full representation.\n\t * @param token The token in string format (cashuB...)\n\t * @returns Token object.\n\t */\n\tpublic decodeToken(token: string): Token {\n\t\tconst keysetIds = this._keyChain.getAllKeysetIds();\n\t\treturn getDecodedToken(token, keysetIds);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Restore\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Restores batches of deterministic proofs until no more signatures are returned from the mint.\n\t *\n\t * @param [gapLimit=300] The amount of empty counters that should be returned before restoring\n\t *   ends (defaults to 300). Default is `300`\n\t * @param [batchSize=100] The amount of proofs that should be restored at a time (defaults to\n\t *   100). Default is `100`\n\t * @param [counter=0] The counter that should be used as a starting point (defaults to 0). Default\n\t *   is `0`\n\t * @param [keysetId] Which keysetId to use for the restoration. If none is passed the instance's\n\t *   default one will be used.\n\t */\n\tasync batchRestore(\n\t\tgapLimit = 300,\n\t\tbatchSize = 100,\n\t\tcounter = 0,\n\t\tkeysetId?: string,\n\t): Promise<{ proofs: Proof[]; lastCounterWithSignature?: number }> {\n\t\tconst requiredEmptyBatches = Math.ceil(gapLimit / batchSize);\n\t\tconst restoredProofs: Proof[] = [];\n\n\t\tlet lastCounterWithSignature: undefined | number;\n\t\tlet emptyBatchesFound = 0;\n\n\t\twhile (emptyBatchesFound < requiredEmptyBatches) {\n\t\t\tconst restoreRes = await this.restore(counter, batchSize, { keysetId });\n\t\t\tif (restoreRes.proofs.length > 0) {\n\t\t\t\temptyBatchesFound = 0;\n\t\t\t\trestoredProofs.push(...restoreRes.proofs);\n\t\t\t\tlastCounterWithSignature = restoreRes.lastCounterWithSignature;\n\t\t\t} else {\n\t\t\t\temptyBatchesFound++;\n\t\t\t}\n\t\t\tcounter += batchSize;\n\t\t}\n\t\treturn { proofs: restoredProofs, lastCounterWithSignature };\n\t}\n\n\t/**\n\t * Regenerates.\n\t *\n\t * @param start Set starting point for count (first cycle for each keyset should usually be 0)\n\t * @param count Set number of blinded messages that should be generated.\n\t * @param options.keysetId Set a custom keysetId to restore from. @see `keyChain)`\n\t */\n\tasync restore(\n\t\tstart: number,\n\t\tcount: number,\n\t\tconfig?: RestoreConfig,\n\t): Promise<{ proofs: Proof[]; lastCounterWithSignature?: number }> {\n\t\tconst { keysetId } = config || {};\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tthis.failIfNullish(this._seed, 'Cashu Wallet must be initialized with a seed to use restore');\n\n\t\t// create deterministic blank outputs for unknown restore amounts\n\t\t// Note: zero amount + zero denomination passes splitAmount validation\n\t\tconst zeros = Array(count).fill(0);\n\t\tconst outputData = OutputData.createDeterministicData(0, this._seed, start, keyset, zeros);\n\n\t\tconst { outputs, signatures } = await this.mint.restore({\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t});\n\n\t\tconst signatureMap: { [sig: string]: SerializedBlindedSignature } = {};\n\t\toutputs.forEach((o, i) => (signatureMap[o.B_] = signatures[i]));\n\n\t\tconst restoredProofs: Proof[] = [];\n\t\tlet lastCounterWithSignature: number | undefined;\n\n\t\tfor (let i = 0; i < outputData.length; i++) {\n\t\t\tconst matchingSig = signatureMap[outputData[i].blindedMessage.B_];\n\t\t\tif (matchingSig) {\n\t\t\t\tlastCounterWithSignature = start + i;\n\t\t\t\toutputData[i].blindedMessage.amount = matchingSig.amount;\n\t\t\t\trestoredProofs.push(outputData[i].toProof(matchingSig, keyset));\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tproofs: restoredProofs,\n\t\t\tlastCounterWithSignature,\n\t\t};\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Create Mint Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use createMintQuoteBolt11()\n\t */\n\tasync createMintQuote(amount: number, description?: string): Promise<MintQuoteBolt11Response> {\n\t\treturn this.createMintQuoteBolt11(amount, description);\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint. Response returns a Lightning payment request for the\n\t * requested given amount and unit.\n\t *\n\t * @param amount Amount requesting for mint.\n\t * @param description Optional description for the mint quote.\n\t * @param pubkey Optional public key to lock the quote to.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuoteBolt11(\n\t\tamount: number,\n\t\tdescription?: string,\n\t): Promise<MintQuoteBolt11Response> {\n\t\tthis.assertAmount(amount, 'createMintQuoteBolt11');\n\t\t// Check if mint supports description for bolt11\n\t\tif (description) {\n\t\t\tconst mintInfo = this.getMintInfo();\n\t\t\tif (!mintInfo.supportsNut04Description('bolt11', this._unit)) {\n\t\t\t\tthis.fail('Mint does not support description for bolt11');\n\t\t\t}\n\t\t}\n\n\t\tconst mintQuotePayload: MintQuoteBolt11Request = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t};\n\t\tconst res = await this.mint.createMintQuoteBolt11(mintQuotePayload);\n\t\treturn { ...res, amount: res.amount || amount, unit: res.unit || this._unit };\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint that is locked to a public key.\n\t *\n\t * @param amount Amount requesting for mint.\n\t * @param pubkey Public key to lock the quote to.\n\t * @param description Optional description for the mint quote.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit. The quote will be locked to the specified `pubkey`.\n\t */\n\tasync createLockedMintQuote(\n\t\tamount: number,\n\t\tpubkey: string,\n\t\tdescription?: string,\n\t): Promise<MintQuoteBolt11Response> {\n\t\tthis.assertAmount(amount, 'createLockedMintQuote');\n\t\tconst { supported } = this.getMintInfo().isSupported(20);\n\t\tthis.failIf(!supported, 'Mint does not support NUT-20');\n\t\tconst mintQuotePayload: MintQuoteBolt11Request = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t\tpubkey: pubkey,\n\t\t};\n\t\tconst res = await this.mint.createMintQuoteBolt11(mintQuotePayload);\n\t\tthis.failIf(typeof res.pubkey !== 'string', 'Mint returned unlocked mint quote');\n\t\tconst resPubkey = res.pubkey!;\n\t\treturn {\n\t\t\t...res,\n\t\t\tpubkey: resPubkey,\n\t\t\tamount: res.amount || amount,\n\t\t\tunit: res.unit || this._unit,\n\t\t};\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint. Response returns a Lightning BOLT12 offer for the\n\t * requested given amount and unit.\n\t *\n\t * @param pubkey Public key to lock the quote to.\n\t * @param options.amount BOLT12 offer amount requesting for mint. If not specified, the offer will\n\t *   be amountless.\n\t * @param options.description Description for the mint quote.\n\t * @returns The mint will return a mint quote with a BOLT12 offer for minting tokens of the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuoteBolt12(\n\t\tpubkey: string,\n\t\toptions?: {\n\t\t\tamount?: number;\n\t\t\tdescription?: string;\n\t\t},\n\t): Promise<MintQuoteBolt12Response> {\n\t\t// Check if mint supports description for bolt12\n\t\tconst mintInfo = this.getMintInfo();\n\t\tif (options?.description && !mintInfo.supportsNut04Description('bolt12', this._unit)) {\n\t\t\tthis.fail('Mint does not support description for bolt12');\n\t\t}\n\n\t\tconst mintQuotePayload: MintQuoteBolt12Request = {\n\t\t\tpubkey: pubkey,\n\t\t\tunit: this._unit,\n\t\t\tamount: options?.amount,\n\t\t\tdescription: options?.description,\n\t\t};\n\n\t\treturn this.mint.createMintQuoteBolt12(mintQuotePayload);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Check Mint Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use checkMintQuoteBolt11()\n\t */\n\tasync checkMintQuote(quote: string | MintQuoteBolt11Response): Promise<MintQuoteBolt11Response> {\n\t\treturn this.checkMintQuoteBolt11(quote);\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The mint will create and return a Lightning invoice for the specified amount.\n\t */\n\tasync checkMintQuoteBolt11(\n\t\tquote: string | MintQuoteBolt11Response,\n\t): Promise<MintQuoteBolt11Response> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst baseRes = await this.mint.checkMintQuoteBolt11(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn baseRes;\n\t\t}\n\t\treturn { ...baseRes, amount: baseRes.amount || quote.amount, unit: baseRes.unit || quote.unit };\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The latest mint quote for the given quote ID.\n\t */\n\tasync checkMintQuoteBolt12(quote: string): Promise<MintQuoteBolt12Response> {\n\t\treturn this.mint.checkMintQuoteBolt12(quote);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Mint Proofs\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use mintProofsBolt11()\n\t */\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: string | MintQuoteBolt11Response,\n\t\tconfig?: MintProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt11', amount, quote, config, outputType);\n\t}\n\n\t/**\n\t * Mint proofs for a bolt11 quote.\n\t *\n\t * @param amount Amount to mint.\n\t * @param quote Mint quote ID or object (bolt11).\n\t * @param config Optional parameters (e.g. privkey for locked quotes).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Minted proofs.\n\t */\n\tasync mintProofsBolt11(\n\t\tamount: number,\n\t\tquote: string | MintQuoteBolt11Response,\n\t\tconfig?: MintProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt11', amount, quote, config, outputType);\n\t}\n\n\t/**\n\t * Mints proofs for a bolt12 quote.\n\t *\n\t * @param amount Amount to mint.\n\t * @param quote Bolt12 mint quote.\n\t * @param privkey Private key to unlock the quote.\n\t * @param config Optional parameters (e.g. keysetId).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Minted proofs.\n\t */\n\tasync mintProofsBolt12(\n\t\tamount: number,\n\t\tquote: MintQuoteBolt12Response,\n\t\tprivkey: string,\n\t\tconfig?: { keysetId?: string },\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt12', amount, quote, { ...config, privkey }, outputType);\n\t}\n\n\t/**\n\t * Internal helper for minting proofs with bolt11 or bolt12.\n\t *\n\t * @remarks\n\t * Handles blinded messages, signatures, and proof construction. Use public methods like\n\t * mintProofs or helpers for API access.\n\t * @param method 'bolt11' or 'bolt12'.\n\t * @param amount Amount to mint (must be positive).\n\t * @param quote Quote ID or object.\n\t * @param config Optional (privkey, keysetId).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Minted proofs.\n\t * @throws If params are invalid or mint returns errors.\n\t */\n\tprivate async _mintProofs<T extends 'bolt11' | 'bolt12'>(\n\t\tmethod: T,\n\t\tamount: number,\n\t\tquote: string | (T extends 'bolt11' ? MintQuoteBolt11Response : MintQuoteBolt12Response),\n\t\tconfig?: MintProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\tthis.assertAmount(amount, `_mintProofs: ${method}`);\n\t\toutputType = outputType ?? this.defaultOutputType(); // Fallback to policy\n\t\tconst { privkey, keysetId, proofsWeHave, onCountersReserved } = config ?? {};\n\n\t\t// Shape output type and denominations for our proofs\n\t\t// we are receiving, so no includeFees.\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tlet mintOT = this.configureOutputs(\n\t\t\tamount,\n\t\t\tkeyset,\n\t\t\toutputType,\n\t\t\tfalse, // no fees\n\t\t\tproofsWeHave,\n\t\t);\n\t\tconst mintAmount = this.preparedTotal(mintOT);\n\n\t\t// Assign counters atomically if OutputType is deterministic\n\t\t// and the counter is zero (auto-assign)\n\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, mintOT);\n\t\t[mintOT] = autoCounters.outputTypes;\n\t\tif (autoCounters.used) {\n\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'mintProofs' });\n\t\t}\n\t\tthis._logger.debug('mint counter', { counter: autoCounters.used, mintOT });\n\n\t\t// Create outputs and mint payload\n\t\tconst outputs = this.createOutputData(mintAmount, keyset, mintOT);\n\t\tconst blindedMessages = outputs.map((d) => d.blindedMessage);\n\t\tconst mintPayload: MintRequest = {\n\t\t\toutputs: blindedMessages,\n\t\t\tquote: typeof quote === 'string' ? quote : quote.quote,\n\t\t};\n\n\t\t// Sign payload if the quote carries a public key\n\t\tif (typeof quote !== 'string' && quote.pubkey) {\n\t\t\tthis.failIf(!privkey, 'Can not sign locked quote without private key');\n\t\t\tconst mintQuoteSignature = signMintQuote(privkey!, quote.quote, blindedMessages);\n\t\t\tmintPayload.signature = mintQuoteSignature;\n\t\t}\n\t\t// Mint proofs\n\t\tlet signatures;\n\t\tif (method === 'bolt12') {\n\t\t\t({ signatures } = await this.mint.mintBolt12(mintPayload));\n\t\t} else {\n\t\t\t({ signatures } = await this.mint.mintBolt11(mintPayload));\n\t\t}\n\t\tthis.failIf(\n\t\t\tsignatures.length !== outputs.length,\n\t\t\t`Mint returned ${signatures.length} signatures, expected ${outputs.length}`,\n\t\t);\n\n\t\tthis._logger.debug('MINT COMPLETED', { amounts: outputs.map((o) => o.blindedMessage.amount) });\n\t\treturn outputs.map((d, i) => d.toProof(signatures[i], keyset));\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Create Melt Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use createMeltQuoteBolt11.\n\t */\n\tasync createMeltQuote(invoice: string, amountMsat?: number): Promise<MeltQuoteBolt11Response> {\n\t\treturn this.createMeltQuoteBolt11(invoice, amountMsat);\n\t}\n\n\t/**\n\t * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order\n\t * to pay a Lightning invoice.\n\t *\n\t * @param invoice LN invoice that needs to get a fee estimate.\n\t * @param amountMsat Optional amount in millisatoshis to attach for amountless invoices, must not\n\t *   be provided for invoices that already encode an amount.\n\t * @returns The mint will create and return a melt quote for the invoice with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMeltQuoteBolt11(\n\t\tinvoice: string,\n\t\tamountMsat?: number,\n\t): Promise<MeltQuoteBolt11Response> {\n\t\tif (amountMsat !== undefined) {\n\t\t\tthis.failIf(\n\t\t\t\tinvoiceHasAmountInHRP(invoice),\n\t\t\t\t'amountMsat supplied but invoice already contains an amount. Leave amountMsat undefined for non-zero invoices.',\n\t\t\t);\n\n\t\t\tthis.assertAmount(amountMsat, 'createMeltQuoteBolt11');\n\t\t}\n\n\t\tconst supportsAmountless = this._mintInfo?.supportsAmountless?.('bolt11', this._unit) ?? false;\n\n\t\tconst meltQuotePayload: MeltQuoteBolt11Request = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\n\t\t\t...(supportsAmountless && amountMsat !== undefined\n\t\t\t\t? {\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tamountless: {\n\t\t\t\t\t\t\t\tamount_msat: amountMsat,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: {}),\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuoteBolt11(meltQuotePayload);\n\t\treturn {\n\t\t\t...meltQuote,\n\t\t\tunit: meltQuote.unit || this._unit,\n\t\t\trequest: meltQuote.request || invoice,\n\t\t};\n\t}\n\n\t/**\n\t * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order\n\t * to pay a BOLT12 offer.\n\t *\n\t * @param offer BOLT12 offer that needs to get a fee estimate.\n\t * @param amountMsat Amount in millisatoshis for amount-less offers. If this is defined and the\n\t *   offer has an amount, they **MUST** be equal.\n\t * @returns The mint will create and return a melt quote for the offer with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMeltQuoteBolt12(\n\t\toffer: string,\n\t\tamountMsat?: number,\n\t): Promise<MeltQuoteBolt12Response> {\n\t\treturn this.mint.createMeltQuoteBolt12({\n\t\t\tunit: this._unit,\n\t\t\trequest: offer,\n\t\t\toptions: amountMsat\n\t\t\t\t? {\n\t\t\t\t\t\tamountless: {\n\t\t\t\t\t\t\tamount_msat: amountMsat,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: undefined,\n\t\t});\n\t}\n\n\t/**\n\t * Requests a multi path melt quote from the mint.\n\t *\n\t * @remarks\n\t * Uses NUT-15 Partial multi-path payments for BOLT11.\n\t * @param invoice LN invoice that needs to get a fee estimate.\n\t * @param partialAmount The partial amount of the invoice's total to be paid by this instance.\n\t * @returns The mint will create and return a melt quote for the invoice with an amount and fee\n\t *   reserve.\n\t * @see https://github.com/cashubtc/nuts/blob/main/15.md\n\t */\n\tasync createMultiPathMeltQuote(\n\t\tinvoice: string,\n\t\tmillisatPartialAmount: number,\n\t): Promise<MeltQuoteBolt11Response> {\n\t\tthis.assertAmount(millisatPartialAmount, 'createMultiPathMeltQuote');\n\t\tconst { supported, params } = this.getMintInfo().isSupported(15);\n\t\tthis.failIf(!supported, 'Mint does not support NUT-15');\n\t\tthis.failIf(\n\t\t\t!params?.some((p) => p.method === 'bolt11' && p.unit === this._unit),\n\t\t\t`Mint does not support MPP for bolt11 and ${this._unit}`,\n\t\t);\n\t\tconst meltQuotePayload: MeltQuoteBolt11Request = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\t\t\toptions: { mpp: { amount: millisatPartialAmount } },\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuoteBolt11(meltQuotePayload);\n\t\treturn { ...meltQuote, request: invoice, unit: this._unit };\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Check Melt Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use checkMeltQuoteBolt11()\n\t */\n\tasync checkMeltQuote(quote: string | MeltQuoteBolt11Response): Promise<MeltQuoteBolt11Response> {\n\t\treturn this.checkMeltQuoteBolt11(quote);\n\t}\n\n\t/**\n\t * Returns an existing bolt11 melt quote from the mint.\n\t *\n\t * @param quote ID of the melt quote.\n\t * @returns The mint will return an existing melt quote.\n\t */\n\tasync checkMeltQuoteBolt11(\n\t\tquote: string | MeltQuoteBolt11Response,\n\t): Promise<MeltQuoteBolt11Response> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst meltQuote = await this.mint.checkMeltQuoteBolt11(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn meltQuote;\n\t\t}\n\t\treturn { ...meltQuote, request: quote.request, unit: quote.unit };\n\t}\n\n\t/**\n\t * Returns an existing bolt12 melt quote from the mint.\n\t *\n\t * @param quote ID of the melt quote.\n\t * @returns The mint will return an existing melt quote.\n\t */\n\tasync checkMeltQuoteBolt12(quote: string): Promise<MeltQuoteBolt12Response> {\n\t\treturn this.mint.checkMeltQuoteBolt12(quote);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Melt Proofs\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use meltProofsBolt11()\n\t */\n\tasync meltProofs(\n\t\tmeltQuote: MeltQuoteBolt11Response,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltProofsResponse<MeltQuoteBolt11Response>> {\n\t\treturn this.meltProofsBolt11(meltQuote, proofsToSend, config, outputType);\n\t}\n\n\t/**\n\t * Melt proofs for a bolt11 melt quote.\n\t *\n\t * @remarks\n\t * ProofsToSend must be at least amount+fee_reserve from the melt quote. This function does not\n\t * perform coin selection!.\n\t * @param meltQuote ID of the melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param config Optional parameters.\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns MeltProofsResponse with quote and change proofs.\n\t */\n\tasync meltProofsBolt11(\n\t\tmeltQuote: MeltQuoteBolt11Response,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltProofsResponse<MeltQuoteBolt11Response>> {\n\t\tconst meltTxn = await this.prepareMelt('bolt11', meltQuote, proofsToSend, config, outputType);\n\t\tconst preferAsync: boolean = typeof config?.onChangeOutputsCreated === 'function';\n\t\treturn this.completeMelt<MeltQuoteBolt11Response>(meltTxn, config?.privkey, preferAsync);\n\t}\n\n\t/**\n\t * Melt proofs for a bolt12 melt quote, returns change proofs using specified outputType.\n\t *\n\t * @remarks\n\t * ProofsToSend must be at least amount+fee_reserve from the melt quote. This function does not\n\t * perform coin selection!.\n\t * @param meltQuote ID of the melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param config Optional parameters.\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns MeltProofsResponse with quote and change proofs.\n\t */\n\tasync meltProofsBolt12(\n\t\tmeltQuote: MeltQuoteBolt12Response,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltProofsResponse<MeltQuoteBolt12Response>> {\n\t\tconst meltTxn = await this.prepareMelt('bolt12', meltQuote, proofsToSend, config, outputType);\n\t\tconst preferAsync: boolean = typeof config?.onChangeOutputsCreated === 'function';\n\t\treturn this.completeMelt<MeltQuoteBolt12Response>(meltTxn, config?.privkey, preferAsync);\n\t}\n\n\t/**\n\t * Prepare A Melt Transaction.\n\t *\n\t * @remarks\n\t * Allows you to preview fees for a melt, get concrete outputs for P2PK SIG_ALL melts, and do any\n\t * pre-melt tasks (such as marking proofs in-flight etc). Creates NUT-08 blanks (1-sat) for\n\t * Lightning fee return and returns a MeltPreview, which you can melt using completeMelt.\n\t * @param method Payment method of the quote.\n\t * @param meltQuote The melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param config Optional (keysetId, onChangeOutputsCreated).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns MeltPreview.\n\t * @throws If params are invalid.\n\t * @see https://github.com/cashubtc/nuts/blob/main/08.md.\n\t */\n\tasync prepareMelt<TQuote extends MeltQuoteBaseResponse>(\n\t\tmethod: string,\n\t\tmeltQuote: TQuote,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltPreview<TQuote>> {\n\t\toutputType = outputType ?? this.defaultOutputType(); // Fallback to policy\n\t\tconst { keysetId, onChangeOutputsCreated, onCountersReserved } = config || {};\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tconst sendAmount = sumProofs(proofsToSend);\n\n\t\t// feeReserve is the overage above the invoice/offer amount.\n\t\t// In the common case where selected proofs = amount + fee_reserve,\n\t\t// this equals the quoteâ€™s fee_reserve. If you overshoot more,\n\t\t// the extra also becomes NUT-08 lightning fee change.\n\t\tconst feeReserve = sendAmount - meltQuote.amount;\n\t\tlet outputData: OutputDataLike[] = [];\n\n\t\t// bolt11 does not allow partial payment, and although bolt12 could, mints\n\t\t// like CDK forbid it. So let's fail loudly up front...\n\t\tthis.failIf(feeReserve < 0, 'Not enough proofs to cover amount + fee reserve', {\n\t\t\tsendAmount,\n\t\t\tquoteAmount: meltQuote.amount,\n\t\t});\n\n\t\tif (outputType.type === 'custom') {\n\t\t\toutputData = outputType.data;\n\t\t}\n\t\t// Create NUT-08 blanks for return of Lightning fee change\n\t\t// Note: zero amount + zero denomination passes splitAmount validation\n\t\telse if (feeReserve > 0) {\n\t\t\tlet count = Math.ceil(Math.log2(feeReserve)) || 1;\n\t\t\tif (count < 0) count = 0; // Prevents: -Infinity\n\t\t\tconst denominations: number[] = count ? new Array<number>(count).fill(0) : [];\n\t\t\tthis._logger.debug('Creating NUT-08 blanks for fee reserve', {\n\t\t\t\tfeeReserve,\n\t\t\t\tdenominations,\n\t\t\t});\n\n\t\t\tlet meltOT: OutputType = { ...outputType, denominations };\n\t\t\t// Assign counter atomically if OutputType is deterministic\n\t\t\t// and the counter is zero (auto-assign)\n\t\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, meltOT);\n\t\t\t[meltOT] = autoCounters.outputTypes;\n\t\t\tif (autoCounters.used) {\n\t\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'meltProofs' });\n\t\t\t}\n\t\t\tthis._logger.debug('melt counter', { counter: autoCounters.used, meltOT });\n\t\t\t// Generate the blank outputs (no fees as we are receiving change)\n\t\t\t// Remember, zero amount + zero denomination passes splitAmount validation\n\t\t\toutputData = this.createOutputData(0, keyset, meltOT);\n\t\t}\n\n\t\t// Create melt preview\n\t\tconst meltPreview: MeltPreview<TQuote> = {\n\t\t\tmethod,\n\t\t\tinputs: proofsToSend,\n\t\t\toutputData,\n\t\t\tkeysetId: keyset.id,\n\t\t\tquote: meltQuote,\n\t\t};\n\n\t\t// Fire legacy event(s) after preview creation\n\t\t// Note: These events are deprecated and should be removed in a future version\n\t\tif (outputData.length > 0) {\n\t\t\tconst blanks: MeltBlanks<TQuote> = {\n\t\t\t\tmethod: method as 'bolt11' | 'bolt12',\n\t\t\t\tpayload: {\n\t\t\t\t\tquote: meltQuote.quote,\n\t\t\t\t\tinputs: proofsToSend,\n\t\t\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t\t\t},\n\t\t\t\toutputData,\n\t\t\t\tkeyset,\n\t\t\t\tquote: meltQuote,\n\t\t\t};\n\t\t\tthis.safeCallback(onChangeOutputsCreated, blanks, { op: 'meltProofs' });\n\t\t\tthis.on._emitMeltBlanksCreated(blanks); // global callback\n\t\t}\n\n\t\treturn meltPreview;\n\t}\n\n\t/**\n\t * Completes a pending melt by calling the melt endpoint and constructing change proofs.\n\t *\n\t * @remarks\n\t * Use with a MeltPreview returned from prepareMelt or the legacy MeltBlanks object returned by\n\t * the meltBlanksCreated or onChangeOutputsCreated callback. This method lets you sign P2PK locked\n\t * proofs before melting. If the payment is pending or unpaid, the change array will be empty.\n\t * @param meltPreview The preview from prepareMelt().\n\t * @param privkey The private key(s) for signing.\n\t * @param preferAsync Optional override to set 'respond-async' header.\n\t * @returns Updated MeltProofsResponse.\n\t * @throws If melt fails or signatures don't match output count.\n\t */\n\tasync completeMelt<TQuote extends MeltQuoteBaseResponse>(\n\t\tmeltPreview: MeltPreview<TQuote> | MeltBlanks<TQuote>,\n\t\tprivkey?: string | string[],\n\t\tpreferAsync?: boolean,\n\t): Promise<MeltProofsResponse<TQuote>> {\n\t\t// Convert from legacy MeltBlanks if needed\n\t\tmeltPreview = this.maybeConvertMeltBlanks(meltPreview);\n\n\t\t// Extract vars from MeltPreview\n\t\tlet inputs = meltPreview.inputs;\n\t\tconst outputs = meltPreview.outputData.map((d) => d.blindedMessage);\n\t\tconst quote = meltPreview.quote.quote;\n\t\tconst keyset = this.getKeyset(meltPreview.keysetId);\n\n\t\t// Sign proofs if needed\n\t\tif (privkey) {\n\t\t\tinputs = this.signP2PKProofs(inputs, privkey, meltPreview.outputData, quote);\n\t\t}\n\n\t\t// Prepare proofs for mint\n\t\tinputs = this._prepareInputsForMint(inputs);\n\n\t\t// Construct melt payload\n\t\tconst meltPayload: MeltRequest = { quote, inputs, outputs };\n\n\t\t// Make melt call (note: bolt11 has legacy data handling)\n\t\tconst meltResponse: MeltQuoteBaseResponse =\n\t\t\tmeltPreview.method === 'bolt11'\n\t\t\t\t? await this.mint.meltBolt11(meltPayload, { preferAsync })\n\t\t\t\t: await this.mint.melt<TQuote>(meltPreview.method, meltPayload, {\n\t\t\t\t\t\tpreferAsync,\n\t\t\t\t\t});\n\n\t\t// Check for too many blind signatures before mapping\n\t\tthis.failIf(\n\t\t\t(meltResponse.change?.length ?? 0) > meltPreview.outputData.length,\n\t\t\t`Mint returned ${meltResponse.change?.length ?? 0} signatures, but only ${meltPreview.outputData.length} blanks were provided`,\n\t\t);\n\n\t\t// Construct change (shorter ok)\n\t\tconst change =\n\t\t\tmeltResponse.change?.map((s, i) => meltPreview.outputData[i].toProof(s, keyset)) ?? [];\n\n\t\tif (preferAsync) {\n\t\t\tthis._logger.debug('ASYNC MELT REQUESTED', meltResponse);\n\t\t} else {\n\t\t\tthis._logger.debug('MELT COMPLETED', { changeAmounts: change.map((p) => p.amount) });\n\t\t}\n\n\t\tconst mergedQuote = {\n\t\t\t...meltPreview.quote,\n\t\t\t...meltResponse,\n\t\t} as TQuote;\n\n\t\treturn { quote: mergedQuote, change } as MeltProofsResponse<TQuote>;\n\t}\n\n\t/**\n\t * Helper to ease transition from MeltBlanks to MeltPreview.\n\t */\n\tprivate maybeConvertMeltBlanks<TQuote extends MeltQuoteBaseResponse>(\n\t\tmelt: MeltPreview<TQuote> | MeltBlanks<TQuote>,\n\t): MeltPreview<TQuote> {\n\t\t// New shape already, just return as is\n\t\tif (!('payload' in melt)) {\n\t\t\treturn melt;\n\t\t}\n\t\t// Legacy MeltBlanks, adapt it to MeltPreview\n\t\tthis._logger.warn(\n\t\t\t'MeltBlanks objects and the meltBlanksCreated / onChangeOutputsCreated events are deprecated. Please use wallet.prepareMelt() to create a MeltPreview instead.',\n\t\t);\n\t\tconst { method, payload, outputData, keyset, quote } = melt;\n\t\treturn {\n\t\t\tmethod,\n\t\t\tinputs: payload.inputs,\n\t\t\toutputData,\n\t\t\tkeysetId: keyset.id,\n\t\t\tquote,\n\t\t};\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Proof States\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)\n\t *\n\t * @param proofs (only the `secret` field is required)\n\t * @returns NUT-07 state for each proof, in same order.\n\t */\n\tasync checkProofsStates(proofs: Array<Pick<Proof, 'secret'>>): Promise<ProofState[]> {\n\t\tconst enc = new TextEncoder();\n\t\tconst Ys = proofs.map((p: Pick<Proof, 'secret'>) =>\n\t\t\thashToCurve(enc.encode(p.secret)).toHex(true),\n\t\t);\n\t\t// TODO: Replace this with a value from the info endpoint of the mint eventually\n\t\tconst BATCH_SIZE = 100;\n\t\tconst states: ProofState[] = [];\n\t\tfor (let i = 0; i < Ys.length; i += BATCH_SIZE) {\n\t\t\tconst YsSlice = Ys.slice(i, i + BATCH_SIZE);\n\t\t\tconst { states: batchStates } = await this.mint.check({\n\t\t\t\tYs: YsSlice,\n\t\t\t});\n\t\t\tconst stateMap: { [y: string]: ProofState } = {};\n\t\t\tbatchStates.forEach((s) => {\n\t\t\t\tstateMap[s.Y] = s;\n\t\t\t});\n\t\t\tfor (let j = 0; j < YsSlice.length; j++) {\n\t\t\t\tconst state = stateMap[YsSlice[j]];\n\t\t\t\tthis.failIfNullish(state, 'Could not find state for proof with Y: ' + YsSlice[j]);\n\t\t\t\tstates.push(state);\n\t\t\t}\n\t\t}\n\t\treturn states;\n\t}\n\n\t/**\n\t * Groups proofs by their corresponding state, preserving order within each group.\n\t *\n\t * @param proofs (only the `secret` field is required)\n\t * @returns An object with arrays of proofs grouped by CheckStateEnum state.\n\t */\n\tasync groupProofsByState(\n\t\tproofs: Proof[],\n\t): Promise<{ unspent: Proof[]; pending: Proof[]; spent: Proof[] }> {\n\t\tconst states: ProofState[] = await this.checkProofsStates(proofs);\n\t\tconst result = {\n\t\t\tunspent: [] as Proof[],\n\t\t\tpending: [] as Proof[],\n\t\t\tspent: [] as Proof[],\n\t\t};\n\t\tfor (let i = 0; i < states.length; i++) {\n\t\t\tconst proof = proofs[i];\n\t\t\tswitch (states[i].state) {\n\t\t\t\tcase CheckStateEnum.UNSPENT:\n\t\t\t\t\tresult.unspent.push(proof);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CheckStateEnum.PENDING:\n\t\t\t\t\tresult.pending.push(proof);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CheckStateEnum.SPENT:\n\t\t\t\t\tresult.spent.push(proof);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport { Wallet };\n","import type { AuthProvider } from './AuthProvider';\nimport request, { type RequestFn } from '../transport';\nimport { joinUrls, hasValidDleq, encodeJsonToBase64, Bytes } from '../utils';\nimport { MintInfo } from '../model/MintInfo';\nimport { OutputData } from '../model/OutputData';\nimport type {\n\tGetInfoResponse,\n\tGetKeysResponse,\n\tGetKeysetsResponse,\n\tProof,\n\tSerializedBlindedSignature,\n} from '../model/types';\nimport { type Logger, NULL_LOGGER } from '../logger';\nimport { type OIDCAuth, type TokenResponse } from './OIDCAuth';\nimport { KeyChain, type Keyset } from '../wallet';\n\nexport type AuthManagerOptions = {\n\t/**\n\t * Hard limit to target when minting BATs in one request. If omitted, we'll read\n\t * `nuts['22'].bat_max_mint` from the mint \"/v1/info\" endpoint.\n\t */\n\tmaxPerMint?: number;\n\t/**\n\t * Desired BAT pool size. Weâ€™ll top-up to min(desiredPoolSize, bat_max_mint) on demand.\n\t */\n\tdesiredPoolSize?: number;\n\t/**\n\t * Custom request fn (e.g. for tests or host env).\n\t */\n\trequest?: RequestFn;\n\t/**\n\t * Logger.\n\t */\n\tlogger?: Logger;\n};\n\ntype StoredTokens = {\n\taccessToken?: string;\n\trefreshToken?: string;\n\t/**\n\t * Epoch timestamp (ms).\n\t */\n\texpiresAt?: number;\n};\n\n/**\n * Response from the mint after blind auth minting.\n */\ntype BlindAuthMintResponse = {\n\tsignatures: SerializedBlindedSignature[];\n};\n\n/**\n * AuthManager.\n *\n * - Owns CAT lifecycle (stores, optional refresh via attached OIDCAuth)\n * - Mints and serves BATs (NUT-22)\n * - Validates DLEQs for BATs per NUT-12.\n * - Supplies serialized BATs for 'Blind-auth' and CAT for 'Clear-auth'\n */\nexport class AuthManager implements AuthProvider {\n\tprivate readonly mintUrl: string;\n\tprivate readonly req: RequestFn;\n\tprivate readonly logger: Logger;\n\tprivate info?: MintInfo;\n\tprivate lockChain?: Promise<void>;\n\tprivate inflightRefresh?: Promise<void>;\n\tprivate static readonly MIN_VALID_SECS = 30;\n\n\t// Open ID Connect (OIDC)\n\tprivate oidc?: OIDCAuth;\n\tprivate tokens: StoredTokens = {};\n\n\t// Blind Auth Token (BAT) pool\n\tprivate pool: Proof[] = [];\n\tprivate desiredPoolSize = 10;\n\tprivate maxPerMint = 10;\n\n\t// Keychain for 'auth' unit\n\tprivate keychain?: KeyChain;\n\n\tconstructor(mintUrl: string, opts?: AuthManagerOptions) {\n\t\tthis.mintUrl = mintUrl;\n\t\tthis.req = opts?.request ?? request;\n\t\tthis.logger = opts?.logger ?? NULL_LOGGER;\n\t\tthis.desiredPoolSize = Math.max(1, opts?.desiredPoolSize ?? this.desiredPoolSize);\n\t\tthis.maxPerMint = Math.max(1, opts?.maxPerMint ?? this.maxPerMint);\n\t}\n\n\t// ------------------------------\n\t// Public API\n\t// ------------------------------\n\n\t/**\n\t * Attach an OIDCAuth instance so this manager can refresh CATs. Registers a listener to update\n\t * internal CAT/refresh state on new tokens.\n\t */\n\tattachOIDC(oidc: OIDCAuth): this {\n\t\tthis.oidc = oidc;\n\t\tthis.oidc.addTokenListener((t) => this.updateFromOIDC(t));\n\t\treturn this;\n\t}\n\n\tget poolSize(): number {\n\t\treturn this.pool.length;\n\t}\n\tget poolTarget(): number {\n\t\treturn this.desiredPoolSize;\n\t}\n\tget activeAuthKeysetId(): string | undefined {\n\t\ttry {\n\t\t\treturn this.keychain?.getCheapestKeyset().id;\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\tget hasCAT(): boolean {\n\t\treturn !!this.tokens.accessToken;\n\t}\n\n\t// ------------------------------\n\t// AuthProvider (NUT-21, Clear-auth)\n\t// ------------------------------\n\n\tgetCAT(): string | undefined {\n\t\treturn this.tokens.accessToken;\n\t}\n\n\tsetCAT(cat: string | undefined): void {\n\t\tthis.tokens.accessToken = cat;\n\t\tif (!cat) {\n\t\t\tthis.tokens.refreshToken = undefined;\n\t\t\tthis.tokens.expiresAt = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Ensure a valid CAT is available (refresh if expiring soon). Returns a token safe to send right\n\t * now, or undefined if unobtainable.\n\t */\n\tasync ensureCAT(minValidSecs?: number): Promise<string | undefined> {\n\t\tif (this.validForAtLeast(minValidSecs)) {\n\t\t\treturn this.tokens.accessToken;\n\t\t}\n\n\t\tif (!this.oidc || !this.tokens.refreshToken) {\n\t\t\treturn this.tokens.accessToken; // nothing we can do\n\t\t}\n\n\t\t// One refresh at a time\n\t\tif (!this.inflightRefresh) {\n\t\t\tthis.inflightRefresh = (async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst tok = await this.oidc!.refresh(this.tokens.refreshToken!);\n\t\t\t\t\tthis.updateFromOIDC(tok);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tthis.logger.warn('AuthManager: CAT refresh failed', { err });\n\t\t\t\t} finally {\n\t\t\t\t\tthis.inflightRefresh = undefined;\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\t\tawait this.inflightRefresh;\n\t\treturn this.validForAtLeast(0) ? this.tokens.accessToken : undefined;\n\t}\n\n\t// Returns true if expiry date is >minValidSecs away\n\tprivate validForAtLeast(minValidSecs: number = AuthManager.MIN_VALID_SECS): boolean {\n\t\tconst { accessToken, expiresAt } = this.tokens;\n\t\tif (!accessToken) return false;\n\t\tif (!expiresAt) return true; // Unknown expiry, allow and rely on server to reject if invalid\n\t\treturn Date.now() + minValidSecs * 1000 < expiresAt;\n\t}\n\n\t// Updates access and refresh tokens in our store, using either the explicit expires_in key or falling back to the JWT expiry.\n\tprivate updateFromOIDC(t: TokenResponse): void {\n\t\tif (!t.access_token) return;\n\t\tconst nowMs = Date.now();\n\t\tthis.tokens.accessToken = t.access_token;\n\t\tif (t.refresh_token) this.tokens.refreshToken = t.refresh_token;\n\t\tif (typeof t.expires_in === 'number' && t.expires_in > 0) {\n\t\t\tthis.tokens.expiresAt = nowMs + t.expires_in * 1000; // Prefer expires_in\n\t\t} else {\n\t\t\t// Fall back to JWT exp, else undefined\n\t\t\tconst expSec = this.parseJwtExpSec(t.access_token);\n\t\t\tthis.tokens.expiresAt = expSec ? expSec * 1000 : undefined;\n\t\t}\n\t\tthis.logger.debug('AuthManager: OIDC tokens updated', { expiresAt: this.tokens.expiresAt });\n\t}\n\n\t// ------------------------------\n\t// AuthProvider (NUT-22, Blind-auth)\n\t// ------------------------------\n\n\t/**\n\t * Ensure there are enough BAT tokens (topping up if needed)\n\t *\n\t * @param minTokens Minimum tokens needed.\n\t */\n\tasync ensure(minTokens: number): Promise<void> {\n\t\tawait this.init();\n\t\tif (this.pool.length >= minTokens) return;\n\t\tconst toTarget = Math.max(this.desiredPoolSize, minTokens);\n\t\tconst batMax = this.getBatMaxMint();\n\t\tconst batch = Math.min(toTarget - this.pool.length, batMax);\n\t\tif (batch <= 0) return;\n\t\tawait this.topUp(batch);\n\t}\n\n\t/**\n\t * Gets a Blind Authentication Token (BAT)\n\t *\n\t * @param {method, path} to Call (not used in our implementation)\n\t * @returns The serialized BAT ready to insert into request header.\n\t */\n\tasync getBlindAuthToken({\n\t\tmethod,\n\t\tpath,\n\t}: {\n\t\tmethod: 'GET' | 'POST';\n\t\tpath: string;\n\t}): Promise<string> {\n\t\tif (this.info && !this.info.requiresBlindAuthToken(method, path)) {\n\t\t\tthis.logger.warn('Endpoint is not marked as protected by NUT-22; still issuing BAT', {\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t});\n\t\t}\n\n\t\treturn this.withLock(async () => {\n\t\t\tawait this.ensure(1);\n\t\t\tif (this.pool.length === 0) {\n\t\t\t\tthrow new Error('AuthManager: no BATs available and minting failed');\n\t\t\t}\n\t\t\t// Pop one BAT and serialize without DLEQ for the header. Per NUT-22, wallets\n\t\t\t// SHOULD delete BAT even on error, so no need to track it in-flight.\n\t\t\tconst proof = this.pool.pop()!;\n\t\t\tthis.logger.debug('AuthManager: BAT requested', {\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\tremaining: this.pool.length,\n\t\t\t});\n\t\t\treturn serializeBAT(proof);\n\t\t});\n\t}\n\n\t/**\n\t * Replace or merge the current BAT pool with previously persisted BATs.\n\t */\n\timportPool(proofs: Proof[], mode: 'replace' | 'merge' = 'replace'): void {\n\t\tif (mode === 'replace') {\n\t\t\tthis.pool = [];\n\t\t}\n\t\tconst seen = new Map(this.pool.map((p) => [p.secret, p]));\n\t\tfor (const p of proofs) {\n\t\t\tif (!p || !p.secret || !p.C || !p.id) continue; // shape check\n\t\t\tif (!seen.has(p.secret)) {\n\t\t\t\tthis.pool.push(p);\n\t\t\t\tseen.set(p.secret, p);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return a deep-copied snapshot of the current BAT pool (full Proofs, including dleq).\n\t */\n\texportPool(): Proof[] {\n\t\treturn this.pool.map((p) => ({ ...p, dleq: p.dleq ? { ...p.dleq } : undefined }));\n\t}\n\n\t// ------------------------------\n\t// Internals\n\t// ------------------------------\n\n\t/**\n\t * Extract exp, seconds since epoch, from a JWT access token.\n\t */\n\tprivate parseJwtExpSec(token?: string): number | undefined {\n\t\tif (!token) return;\n\t\tconst parts = token.split('.');\n\t\tif (parts.length !== 3) return;\n\t\ttry {\n\t\t\tconst jsonStr = Bytes.toString(Bytes.fromBase64(parts[1]));\n\t\t\tconst obj = JSON.parse(jsonStr) as { exp?: unknown };\n\t\t\tconst exp = typeof obj.exp === 'number' ? obj.exp : Number(obj.exp);\n\t\t\tif (Number.isFinite(exp) && exp > 0) return exp;\n\t\t} catch {\n\t\t\tthis.logger.warn('JWT access token was malformed.', {\n\t\t\t\ttoken,\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n\n\t/**\n\t * Simple mutex lock - chains promises in order.\n\t */\n\tprivate async withLock<T>(fn: () => T | Promise<T>): Promise<T> {\n\t\tconst prev = this.lockChain ?? Promise.resolve();\n\t\tlet release!: () => void;\n\t\tconst lock = new Promise<void>((resolve) => {\n\t\t\trelease = resolve;\n\t\t});\n\t\tconst chain = prev.then(() => lock); // capture the exact Promise we assign\n\t\tthis.lockChain = chain;\n\t\ttry {\n\t\t\tawait prev;\n\t\t\treturn await fn();\n\t\t} finally {\n\t\t\trelease();\n\t\t\t// Only clear if no newer chain has been installed\n\t\t\tif (this.lockChain === chain) this.lockChain = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Initialise mint info and auth keysets/keys as needed.\n\t */\n\tprivate async init(): Promise<void> {\n\t\tif (!this.info) {\n\t\t\tconst info = await this.req<GetInfoResponse>({\n\t\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/info'),\n\t\t\t\tmethod: 'GET',\n\t\t\t});\n\t\t\tthis.info = new MintInfo(info);\n\t\t}\n\t\tif (!this.keychain) {\n\t\t\t// fetch blind keysets and keys for unit 'auth'\n\t\t\tconst [allKeysets, allKeys] = await Promise.all([\n\t\t\t\tthis.req<GetKeysetsResponse>({\n\t\t\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/auth/blind/keysets'),\n\t\t\t\t\tmethod: 'GET',\n\t\t\t\t}),\n\t\t\t\tthis.req<GetKeysResponse>({\n\t\t\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/auth/blind/keys'),\n\t\t\t\t\tmethod: 'GET',\n\t\t\t\t}),\n\t\t\t]);\n\t\t\t// build a KeyChain preloaded with caches, unit 'auth'\n\t\t\t// Then smoke test to surface errors early - no need to init() with cached keys\n\t\t\tthis.keychain = new KeyChain(this.mintUrl, 'auth', allKeysets.keysets, allKeys.keysets);\n\t\t\tthis.keychain.getCheapestKeyset();\n\t\t}\n\t}\n\n\t/**\n\t * Gets the BAT minting limit: lower of manager limit and Mintâ€™s NUT-22 limit.\n\t */\n\tprivate getBatMaxMint(): number {\n\t\tif (!this.info) throw new Error('AuthManager: mint info not loaded');\n\t\tconst n22 = this.info.nuts['22'];\n\t\tconst mintMax = n22?.bat_max_mint ?? this.maxPerMint;\n\t\treturn Math.max(1, Math.min(this.maxPerMint, mintMax));\n\t}\n\n\tprivate getActiveKeys(): Keyset {\n\t\tif (!this.keychain) throw new Error('AuthManager: keyset not loaded for active keyset');\n\t\treturn this.keychain.getCheapestKeyset();\n\t}\n\n\t/**\n\t * Mint a batch of BATs using the current CAT if the endpoint is protected by NUT-21.\n\t */\n\tprivate async topUp(n: number): Promise<void> {\n\t\tif (!this.info) throw new Error('AuthManager: mint info not loaded');\n\n\t\t// Check NUT-21 protection of the BAT mint endpoint\n\t\tconst needsCAT = this.info.requiresClearAuthToken('POST', '/v1/auth/blind/mint');\n\t\tlet cat: string | undefined;\n\t\tif (needsCAT) {\n\t\t\tcat = await this.ensureCAT();\n\t\t\tif (!cat) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'AuthManager: Clear-auth token required for /v1/auth/blind/mint but not available. Authenticate with the mint to obtain a CAT first.',\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t// Create blinded messages for amount n in unit 'auth' (supports only 1s)\n\t\tconst keys = this.getActiveKeys();\n\t\tconst outputs = OutputData.createRandomData(n, keys);\n\t\tconst payload = { outputs: outputs.map((d) => d.blindedMessage) };\n\t\t// Set CAT header if needed\n\t\tconst headers: Record<string, string> = {};\n\t\tif (cat) headers['Clear-auth'] = cat;\n\t\t// Do the topup\n\t\tconst res = await this.req<BlindAuthMintResponse>({\n\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/auth/blind/mint'),\n\t\t\tmethod: 'POST',\n\t\t\theaders,\n\t\t\trequestBody: payload as unknown as Record<string, unknown>,\n\t\t});\n\t\tif (!Array.isArray(res?.signatures) || res.signatures.length !== outputs.length) {\n\t\t\tthrow new Error('AuthManager: bad BAT mint response');\n\t\t}\n\t\t// Create BAT proofs and check DLEQ\n\t\tconst proofs = outputs.map((d, i) => d.toProof(res.signatures[i], keys));\n\t\tfor (const p of proofs) {\n\t\t\tif (!hasValidDleq(p, keys)) {\n\t\t\t\tthrow new Error('AuthManager: mint returned BAT with invalid DLEQ');\n\t\t\t}\n\t\t}\n\t\t// Add BAT proofs to pool\n\t\tthis.pool.push(...proofs);\n\t\tthis.logger.debug('AuthManager: performed topUp', {\n\t\t\tminted: proofs.length,\n\t\t\tpool: this.pool.length,\n\t\t});\n\t}\n}\n\n// ------------------------------\n// Helpers\n// ------------------------------\n\n/**\n * Serialize an Auth Proof as a BAT header value: \"authA\" + base64(JSON_without_dleq)\n */\nfunction serializeBAT(proof: Proof): string {\n\t// strip dleq per NUT-22\n\tconst token = { id: proof.id, secret: proof.secret, C: proof.C };\n\tconst base64Data = encodeJsonToBase64(token);\n\treturn `authA${base64Data}`;\n}\n","import { type Logger } from '../logger';\nimport { Mint } from '../mint/Mint';\nimport { Wallet } from '../wallet/Wallet';\nimport { AuthManager } from './AuthManager';\nimport type { OIDCAuth, OIDCAuthOptions } from './OIDCAuth';\n\n/**\n * High-level helper to create a fully authenticated wallet session.\n *\n * @remarks\n * Like a dependency injector, it wires AuthManager->Mint->OIDCAuth->Wallet in the correct order.\n * Wallet is returned ready to use.\n * @param mintUrl URL of the mint to connect to.\n * @param options.authPool Optional. Desired BAT pool size (default 10)\n * @param options.oidc Optional. Options for OIDCAuth (scope, clientId, logger, etc.)\n * @returns {mint, auth, oidc, wallet} â€” hydrated, ready to use.\n * @throws If mint does not require authentication.\n */\nexport async function createAuthWallet(\n\tmintUrl: string,\n\toptions?: {\n\t\tauthPool?: number;\n\t\toidc?: OIDCAuthOptions;\n\t\tlogger?: Logger;\n\t},\n): Promise<{ mint: Mint; auth: AuthManager; oidc: OIDCAuth; wallet: Wallet }> {\n\t// 1. Create an AuthManager for both BAT and CAT handling\n\tconst auth = new AuthManager(mintUrl, {\n\t\tdesiredPoolSize: options?.authPool ?? 10,\n\t\tlogger: options?.logger,\n\t});\n\n\t// 2. Create a Mint instance using the AuthManager\n\tconst mint = new Mint(mintUrl, { authProvider: auth, logger: options?.logger });\n\n\t// 3. Discover and configure OIDCAuth from the mint\n\tconst oidc = await mint.oidcAuth({\n\t\t...options?.oidc,\n\t\tlogger: options?.logger,\n\t\tonTokens: (t) => auth.setCAT(t.access_token), // set CAT automatically\n\t});\n\n\t// 4. Attach OIDCAuth back into AuthManager for refresh, etc.\n\tauth.attachOIDC(oidc);\n\n\t// 5. Hydrate wallet using the same mint and auth provider\n\tconst wallet = new Wallet(mint, { authProvider: auth, logger: options?.logger });\n\tawait wallet.loadMint();\n\n\treturn { mint, auth, oidc, wallet };\n}\n"],"names":["HttpResponseError","message","status","NetworkError","MintOperationError","code","detail","NULL_LOGGER","fail","logger","context","failIf","condition","failIfNullish","value","safeCallback","cb","payload","maybePromise","error","LEVEL_ORDER","ConsoleLogger","minLevel","level","ctx","out","k","v","line","fn","msg","measureTime","start","globalRequestOptions","requestLogger","setGlobalRequestOptions","options","setRequestLogger","_request","endpoint","requestBody","requestHeaders","body","headers","response","err","errorData","errorMessage","request","_WS","injectWebSocketImpl","ws","getWebSocketImpl","Bytes","hex","matches","byte","bytes","str","arrays","totalLength","sum","arr","result","offset","size","buffer","i","chunk","base64","normalizedBase64","c","a","b","minLength","temp","length","encodeUint8toBase64Url","encodeBase64toUint8","base64String","encodeJsonToBase64","jsonObj","jsonString","base64urlFromBase64","encodeBase64ToJson","base64urlToBase64","isBase64String","base64url","normalized","padLength","padded","decoded","reStandard","reUrl","originalNoPad","LIMIT_LENGTH","assertBech32mFormat","separatorIndex","encodeBech32m","hrp","data","limitLength","words","bech32m","decodeBech32m","encoded","prefix","decodeBech32mToBytes","isResultKeyType","encodeCBOR","encodeItem","encodeNumber","encodeString","encodeArray","encodeByteString","encodeObject","encodeUnsigned","encodeSigned","unsigned","encodeFloat64","ab","dv","utf8","item","keys","key","decodeCBOR","view","decodeItem","initialByte","majorType","additionalInfo","decodeUnsigned","decodeSigned","decodeByteString","decodeString","decodeArray","decodeMap","decodeSimpleAndFloat","ensureAvailable","needed","decodeLength","hi","lo","newOffset","array","currentOffset","map","keyResult","valueResult","decodeFloat16","uint16","exponent","fraction","sign","DOMAIN_SEPARATOR","utf8ToBytes","hashToCurve","secret","msgToHash","sha256","counter","maxIterations","counterBytes","hash","pointFromHex","bytesToHex","hash_e","pubkeys","e_","p","pointFromBytes","secp256k1","getKeysetIdInt","keysetId","keysetIdInt","hexToNumber","createRandomSecretKey","createBlindSignature","B_","privateKey","amount","id","createRandomBlindedMessage","_deprecated","createRandomRawBlindedMessage","secretStr","randomBytes","secretBytes","blindMessage","r","Y","rG","unblindSignature","C_","A","constructProofFromPromise","promise","C","serializeProof","proof","deserializeProof","schnorrSignMessage","msghash","privKeyBytes","hexToBytes","sig","schnorr","schnorrVerifyMessage","signature","pubkey","throws","pubkeyX","e","getValidSigners","signatures","meetsSignerThreshold","threshold","DERIVATION_PATH","serializeMintKeys","mintKeys","serializedMintKeys","deserializeMintKeys","getPubKeyFromPrivKey","privKey","createNewMintKeys","pow2height","seed","expiry","input_fee_ppk","unit","versionByte","pubKeys","privKeys","masterKey","HDKey","index","deriveKeysetId","verifyProof","createSecret","kind","tags","newSecret","parseSecret","parsed","t","tt","assertSecretKind","allowed","kinds","actual","getSecretKind","getSecretData","getDataField","getTags","hasTag","getTag","tag","getTagScalar","vals","getTagInt","P2BK_DST","deriveP2BKBlindedPubkeys","eBytes","E","kid","P","deriveP2BKBlindingTweakFromECDH","P_","deriveP2BKSecretKeys","Ehex","blindPubKey","keysetIdHex","privs","pubs","privHex","hexP_","kHex","deriveP2BKSecretKey","privkey","rBlind","blindPubkey","naturalPub","n","skStd","skNeg","numberToHexPadded64","R","xP","xNaturalPub","yP","yNaturalPub","point","scalar","slotIndex","Zx","iByte","createP2PKsecret","parseP2PKSecret","getP2PKExpectedWitnessPubkeys","lockState","getP2PKLockState","locktimeKeys","getP2PKWitnessPubkeys","refundKeys","getP2PKWitnessRefundkeys","allKeys","getP2PKLocktime","ts","nowSeconds","locktime","getP2PKNSigs","getP2PKNSigsRefund","getP2PKSigFlag","getP2PKWitnessSignatures","witness","parseWitnessData","signP2PKProofs","proofs","toHex","privateKeyHex","privateKeys","maybeDeriveP2BKPrivateKeys","signedProof","priv","signP2PKProof","witnesses","w","newWitness","hasP2PKSignedProof","isP2PKSigAll","verifyP2PKSpendingConditions","mainKeys","nsigs","mainSigners","resultBase","nSigsRefund","refundSigners","refundBase","isP2PKSpendAuthorised","assertSigAllInputs","inputs","first","data0","tags0","si","buildP2PKSigAllMessage","outputs","quoteId","parts","o","buildInterimP2PKSigAllMessage","buildLegacyP2PKSigAllMessage","signP2PKSecret","verifyP2PKSecretSignature","getP2PKExpectedKWitnessPubkeys","verifyP2PKSig","arraysEqual","arr1","arr2","verifyDLEQProof","dleq","s","sG","eA","sB_","eC_","R_1","R_2","verifyDLEQProof_reblind","bG","createDLEQProof","scalar_a","scalar_e","s_scalar","numberToBytesBE","STANDARD_DERIVATION_PATH","SECP256K1_N","deriveSecret","isValidHex","derive_deprecated","derive","deriveBlindingFactor","secretOrBlinding","hmacDigest","hmac","x","hdkey","derivationPath","derived","createHTLCsecret","parseHTLCSecret","createHTLCHash","preimage","hasPreimage","piBytes","verifyHTLCHash","valid","verifyHTLCSpendingConditions","p2pkResult","getHTLCWitnessPreimage","isHTLCSpendAuthorised","constructMessage","quote","blindedMessages","blindedMessage","msgbytes","signMintQuote","privkeyBytes","verifyMintQuoteSignature","sigbytes","pubkeyBytes","PaymentRequestTransportType","TAG_ID","TAG_AMOUNT","TAG_UNIT","TAG_SINGLE_USE","TAG_MINT","TAG_DESCRIPTION","TAG_TRANSPORT","TAG_NUT10","TRANSPORT_TAG_KIND","TRANSPORT_TAG_TARGET","TRANSPORT_TAG_TAG_TUPLE","TRANSPORT_KIND_NOSTR","TRANSPORT_KIND_HTTP_POST","NUT10_TAG_KIND","NUT10_TAG_DATA","NUT10_TAG_TAG_TUPLE","NUT10_KIND_P2PK","NUT10_KIND_HTLC","decodeTLV","decodeAllParts","part","parseString","parseU64","parseU8","parseTransport","parseNut10","decodeNextPart","dataView","transportKindToType","nut10KindToType","targetBytes","parseTagTuple","target","relayUrls","tuple","encodeNprofile","finalTags","kindNum","encodeTLV","encodeTLVPart","encodeU64","encodeU8","mint","transport","encodeTransport","nut10","encodeNut10","transportTypeToKind","type","nut10TypeToKind","relayTags","relays","decodeNprofile","relay","allTags","encodeTagTuple","encoder","nprofile","bech32","tlvData","tlv","encodePubkeyRelaysTLV","encodedRelays","totalSize","PaymentRequest","mints","description","singleUse","nut26","rawRequest","tlvRequest","tlvBytes","rawPaymentRequest","transports","encodedRequest","lowerRequest","encodedData","splitAmount","keyset","split","order","totalSplitAmount","sumArray","positive","amt","totalPositive","hasCorrespondingKey","sortedKeyAmounts","getKeysetAmounts","requireCount","getKeepAmounts","proofsWeHave","amountToKeep","targetCount","amountsWeWant","amountsWeHave","countWeHave","countWeWant","amountDiff","bytesToNumber","number","hasNonHexId","bigIntStringify","_key","getEncodedTokenV3","token","removeDleq","convertToShortKeysetId","stripDleq","v3TokenObj","newP","getEncodedToken","opts","getEncodedTokenV4","tokenTemplate","templateFromToken","version","base64Data","idMap","validateAmount","allowZero","tokenFromTemplate","template","decodedToken","getDecodedToken","tokenString","keysetOrIds","keysetIds","ks","tokenStr","removePrefix","handleTokens","mapShortKeysetIds","getTokenMetadata","tokenObj","sumProofs","encodedToken","parsedV3Token","entry","uInt8Token","tokenData","arg2","isDeprecatedBase64","pubkeysConcat","amountA","amountB","pubKey","prev","curr","mergeUInt8Arrays","a1","a2","mergedArray","sortProofsById","isObj","checkResponse","joinUrls","sanitizeUrl","url","acc","decodePaymentRequest","paymentRequest","MessageNode","node","MessageQueue","messageNode","newNode","verifyKeysetId","isBase64","newProofs","idBytes","hasValidDleq","concatByteArrays","byteArray","pointer","getEncodedTokenBinary","utf8Encoder","binaryTemplate","getDecodedTokenBinary","utfDecoder","binaryToken","deepEqual","keysA","keysB","invoiceHasAmountInHRP","invoice","ConnectionManager","existing","newConn","WSConnection","timeoutMs","resolve","reject","opened","settled","timer","settle","cleanupSocket","ev","reason","method","params","subId","callback","listeners","errorCallback","notification","rpcId","MintQuoteState","MeltQuoteState","CheckStateEnum","handleMeltQuoteResponseDeprecated","handleMintQuoteResponseDeprecated","handleMintInfoContactFieldDeprecated","contact","MintInfo","info","pe22","pe21","num","path","idx","cacheKey","cached","exactHit","prefixHit","res","mintMeltInfo","maybe","rec","mm","pp","endpoints","exact","met","meltMethods","OIDCAuth","discoveryUrl","n21","clientId","scope","text","json","cfg","rnd","verifier","vBytes","chBytes","challenge","input","form","tok","ep","device_code","intervalSec","delay","interval","aborted","refresh_token","username","password","listener","enc","formBody","ms","Mint","mintUrl","customRequest","swapPayload","mintQuotePayload","mintPayload","meltQuotePayload","meltPayload","checkPayload","targetUrl","restorePayload","wsSegment","wsUrl","bat","init","requestInstance","cat","Keyset","active","final_expiry","meta","KeyChain","cachedKeysets","cachedKeys","arrayOfKeys","cache","chain","allKeysets","keysById","maybeKeys","kc","keysets","forceRefresh","allKeysetsResponse","allKeysResponse","unitKeysets","keysMap","mk","activeKeysets","metaList","keysList","BlindedMessage","RESERVED_P2PK_TAGS","assertValidTagKey","MAX_SECRET_LENGTH","EPHEMERAL_E","setEphemeralE","takeEphemeralE","OutputData","blindingFactor","blindSignature","serializedProof","p2pk","customSplit","lockKeys","reqLock","reqRefund","isHTLC","refund","ordered","blinded","_E","charCount","od","randomHex","secretBytesAsHex","utf8SecretBytes","deterministicR","output","normalisePubkey","pk","toUnixSeconds","P2PKBuilder","when","values","hashlock","locks","refunds","total","selectProofsRGLI","amountToSend","keyChain","includeFees","exactMatch","_logger","bestSubset","bestDelta","bestAmount","bestFeePPK","feeForProof","sumExFees","feePPK","shuffleArray","shuffled","j","binarySearchIndex","lessOrEqual","left","right","mid","midValue","insertSorted","obj","calculateDelta","totalAmount","totalFeePPK","proofWithFees","ppkfee","exFee","spendableProofs","endIndex","rightIndex","biggerIndex","nextBiggerExFee","totalNetSum","maxOverAmount","trial","S","newAmount","newFeePPK","netSum","SSet","others","indices","_","objP","tempAmount","tempFeePPK","tempNetSum","qIndex","objQ","delta","tempS","tempDelta","bestSum","bestProofs","bestSubsetSet","keep","EphemeralCounterSource","initial","release","cur","minNext","next","WalletOps","wallet","SendBuilder","ReceiveBuilder","MintBuilder","MeltBuilder","denoms","factory","on","requireDleq","outputConfig","bolt12","preview","safeStringify","seen","_k","normalizeError","makeAbortError","cancelSafely","WalletEvents","signal","cancel","onAbort","subscribeFn","timeoutMsg","cancelP","to","done","cleanup","h","ids","uniq","proofMap","y","ys","handler","unique","cancels","lastError","fullyRegistered","thisCanceller","queue","notify","max","dropMode","wake","push","dropped","cancelled","cancelAll","WalletCounters","src","PENDING_KEYSET_ID","Wallet","op","promises","mintInfo","cheapestId","totalOutputs","ot","outputTypes","manual","ranges","maxManualEnd","range","cursor","patched","need","used","newWallet","outputType","customTotal","denominations","receiveFee","receiveFeeAmounts","splitSum","outputData","keepOutputs","sendOutputs","mergedBlindingData","keepVector","sortedOutputData","sortedKeepVector","d","config","txn","onCountersReserved","tokenMintUrl","swapFee","receiveOT","autoCounters","send","sendPrepared","wantsDeterministicByPolicy","isPlainRandom","reasons","expectedFee","sendOT","sendAmount","unselectedProofs","selectedProofs","selectedSum","changeAmount","keepOT","keepAmount","swapPreview","swapTransaction","swapProofs","reorderedProofs","reorderedKeepVector","keepProofs","sendProofs","cryptoSignP2PKProofs","rest","signedFirst","messages","sumPPK","nInputs","keepDleq","p2pk_e","gapLimit","batchSize","requiredEmptyBatches","restoredProofs","lastCounterWithSignature","emptyBatchesFound","restoreRes","count","zeros","signatureMap","matchingSig","supported","resPubkey","baseRes","mintOT","mintAmount","mintQuoteSignature","amountMsat","supportsAmountless","meltQuote","offer","millisatPartialAmount","proofsToSend","meltTxn","preferAsync","onChangeOutputsCreated","feeReserve","meltOT","meltPreview","blanks","meltResponse","change","melt","Ys","BATCH_SIZE","states","YsSlice","batchStates","stateMap","state","_AuthManager","oidc","minValidSecs","accessToken","expiresAt","nowMs","expSec","minTokens","toTarget","batMax","batch","serializeBAT","mode","jsonStr","exp","lock","mintMax","needsCAT","AuthManager","createAuthWallet","auth"],"mappings":"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"}