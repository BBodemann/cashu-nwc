"use strict";var Di=Object.defineProperty;var Ui=(s,t,e)=>t in s?Di(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var k=(s,t,e)=>Ui(s,typeof t!="symbol"?t+"":t,e);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const Et=require("@scure/base");class Wt extends Error{constructor(t,e){super(t),this.status=e,this.name="HttpResponseError",Object.setPrototypeOf(this,Wt.prototype)}}class Re extends Error{constructor(t){super(t),this.name="NetworkError",Object.setPrototypeOf(this,Re.prototype)}}class De extends Wt{constructor(t,e){super(e||"Unknown mint operation error",400),this.code=t,this.name="MintOperationError",Object.setPrototypeOf(this,De.prototype)}}const X={error(){},warn(){},info(){},debug(){},trace(){},log(){}};function Ue(s,t=X,e){throw t.error(s,e),new Error(s)}function xn(s,t,e=X,n){s&&Ue(t,e,n)}function Os(s,t,e=X,n){s==null&&Ue(t,e,n)}function ee(s,t,e=X,n){if(s)try{const r=s(t);r&&typeof r.then=="function"&&r.catch(i=>{try{e.warn("callback failed",{...n??{},error:i,cb:s.name??""})}catch{}})}catch(r){try{e.warn("callback failed",{...n??{},error:r,cb:s.name??""})}catch{}}}const us={error:0,warn:1,info:2,debug:3,trace:4};class qi{constructor(t="info"){this.minLevel=t}should(t){return us[t]<=us[this.minLevel]}method(t){switch(t){case"error":return console.error;case"warn":return console.warn;case"info":return console.info;case"debug":return console.debug;case"trace":return console.trace;default:return console.log}}header(t,e){return`[${t.toUpperCase()}] ${e}`}flattenContext(t){if(!t)return;const e={};for(const[n,r]of Object.entries(t))e[n]=r instanceof Error?{message:r.message,stack:r.stack}:r;return e}emit(t,e,n){if(!this.should(t))return;const r=this.header(t,e),i=this.flattenContext(n),o=this.method(t);i&&Object.keys(i).length?o(r,i):o(r)}error(t,e){this.emit("error",t,e)}warn(t,e){this.emit("warn",t,e)}info(t,e){this.emit("info",t,e)}debug(t,e){this.emit("debug",t,e)}trace(t,e){this.emit("trace",t,e)}log(t,e,n){this.emit(t,e,n)}}function Fi(){const s=Date.now();return{elapsed:()=>Date.now()-s}}let Ls={},Ns=X;function Hi(s){Ls=s}function $i(s){Ns=s}async function Wi({endpoint:s,requestBody:t,headers:e,...n}){const r=t?JSON.stringify(t):void 0,i={Accept:"application/json, text/plain, */*",...r?{"Content-Type":"application/json"}:void 0,...e};let o;try{o=await fetch(s,{body:r,headers:i,...n})}catch(c){throw new Re(c instanceof Error?c.message:"Network request failed")}if(!o.ok){let c;try{c=await o.json()}catch{c={error:"bad response"}}if(o.status===400&&"code"in c&&typeof c.code=="number"&&"detail"in c&&typeof c.detail=="string")throw new De(c.code,c.detail);let a="HTTP request failed";throw"error"in c&&typeof c.error=="string"?a=c.error:"detail"in c&&typeof c.detail=="string"&&(a=c.detail),new Wt(a,o.status)}try{return await o.json()}catch(c){throw Ns.error("Failed to parse HTTP response",{err:c}),new Wt("bad response",o.status)}}async function Rs(s){return await Wi({...s,...Ls})}let _e;typeof WebSocket<"u"&&(_e=WebSocket);function ji(s){_e=s}function Vi(){if(_e===void 0)throw new Error("WebSocket implementation not initialized");return _e}class N{static fromHex(t){if(t=t.trim(),t.length===0)return new Uint8Array(0);if(t.length<2||t.length&1)throw new Error("Invalid hex string: odd length.");if((t.startsWith("0x")||t.startsWith("0X"))&&(t=t.slice(2)),!t.match(/^[0-9a-fA-F]*$/))throw new Error("Invalid hex string: contains non-hex characters");const n=t.match(/.{1,2}/g);if(!n)throw new Error("Invalid hex string");return new Uint8Array(n.map(r=>parseInt(r,16)))}static toHex(t){return Array.from(t,e=>e.toString(16).padStart(2,"0")).join("")}static fromString(t){return t=t.trim(),new TextEncoder().encode(t)}static toString(t){return new TextDecoder("utf-8").decode(t)}static concat(...t){const e=t.reduce((i,o)=>i+o.length,0),n=new Uint8Array(e);let r=0;for(const i of t)n.set(i,r),r+=i.length;return n}static alloc(t){return new Uint8Array(t)}static writeBigUint64BE(t){const e=new ArrayBuffer(8);return new DataView(e).setBigUint64(0,t,!1),new Uint8Array(e)}static toBase64(t){if(typeof Buffer<"u")return Buffer.from(t).toString("base64");if(t.length>32768){let e="";for(let n=0;n<t.length;n+=32768){const r=t.slice(n,n+32768);e+=btoa(String.fromCharCode(...r))}return e}return btoa(String.fromCharCode(...t))}static fromBase64(t){t=t.trim();let e=t.replace(/-/g,"+").replace(/_/g,"/");for(;e.length%4;)e+="=";return typeof Buffer<"u"?new Uint8Array(Buffer.from(e,"base64")):new Uint8Array([...atob(e)].map(n=>n.charCodeAt(0)))}static equals(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return n===0}static compare(t,e){const n=Math.min(t.length,e.length);for(let r=0;r<n;r++){if(t[r]<e[r])return-1;if(t[r]>e[r])return 1}return t.length-e.length}static toBigInt(t){let e=0n;for(const n of t)e=e<<8n|BigInt(n);return e}static fromBigInt(t){if(t<0n)throw new RangeError("value must be non-negative");if(t===0n)return new Uint8Array([0]);let e=t,n=0;for(;e>0n;)n++,e>>=8n;const r=new Uint8Array(n);e=t;for(let i=n-1;i>=0;i--)r[i]=Number(e&0xffn),e>>=8n;return r}}function fn(s){return N.toBase64(s).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function Sn(s){return N.fromBase64(s)}function Ds(s){const t=JSON.stringify(s);return Qi(N.toBase64(N.fromString(t)))}function Gi(s){const t=N.toString(N.fromBase64(zi(s)));return JSON.parse(t)}function zi(s){return s.replace(/-/g,"+").replace(/_/g,"/").split("=")[0]}function Qi(s){return s.replace(/\+/g,"-").replace(/\//g,"_").split("=")[0]}function qe(s){if(typeof s!="string"||s.length===0)return!1;const t=/^[A-Za-z0-9\-_]+={0,2}$/,e=/^[A-Za-z0-9+/]+={0,2}$/;if(!t.test(s)&&!e.test(s))return!1;const n=s.replace(/-/g,"+").replace(/_/g,"/"),r=(4-n.length%4)%4;if(r>2)return!1;const i=n+"=".repeat(r);try{const o=N.fromBase64(i),c=N.toBase64(o),a=c.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,""),u=n.replace(/=+$/,"");return c.replace(/=+$/,"")===u||a===u}catch{return!1}}const An=1023;function Zi(s){const t=s.lastIndexOf("1");if(t<1||t===s.length-1)throw new Error("Invalid bech32m string: missing or misplaced separator")}function Yi(s,t,e=An){const n=Et.bech32m.toWords(t);return Et.bech32m.encode(s,n,e)}function Xi(s,t=An){Zi(s);const{prefix:e,words:n}=Et.bech32m.decode(s,t),r=Et.bech32m.fromWords(n);return{hrp:e,data:r}}function Ji(s,t=An){return Xi(s,t).data}function to(s){return typeof s=="number"||typeof s=="string"}function Pn(s){const t=[];return Tn(s,t),new Uint8Array(t)}function Tn(s,t){if(s===null)t.push(246);else if(s===void 0)t.push(247);else if(typeof s=="boolean")t.push(s?245:244);else if(typeof s=="number")ro(s,t);else if(typeof s=="string")Us(s,t);else if(Array.isArray(s))oo(s,t);else if(s instanceof Uint8Array)io(s,t);else if(typeof s=="object"&&s!==null&&!Array.isArray(s))co(s,t);else throw new Error("Unsupported type")}function eo(s,t){if(s<24)t.push(s);else if(s<256)t.push(24,s);else if(s<65536)t.push(25,s>>>8&255,s&255);else if(s<4294967296)t.push(26,s>>>24&255,s>>>16&255,s>>>8&255,s&255);else throw new Error("Unsupported integer size")}function no(s,t){const e=-1-s;if(e<24)t.push(32|e);else if(e<256)t.push(56,e&255);else if(e<65536)t.push(57,e>>>8&255,e&255);else if(e<4294967296)t.push(58,e>>>24&255,e>>>16&255,e>>>8&255,e&255);else throw new Error("Unsupported integer size")}function so(s,t){const e=new ArrayBuffer(8),n=new DataView(e);n.setFloat64(0,s,!1),t.push(251);for(let r=0;r<8;r++)t.push(n.getUint8(r))}function ro(s,t){Number.isInteger(s)?s>=0?eo(s,t):no(s,t):so(s,t)}function io(s,t){const e=s.length;if(e<24)t.push(64+e);else if(e<256)t.push(88,e);else if(e<65536)t.push(89,e>>8&255,e&255);else if(e<4294967296)t.push(90,e>>>24&255,e>>>16&255,e>>>8&255,e&255);else throw new Error("Byte string too long to encode");for(let n=0;n<s.length;n++)t.push(s[n])}function Us(s,t){const e=new TextEncoder().encode(s),n=e.length;if(n<24)t.push(96+n);else if(n<256)t.push(120,n);else if(n<65536)t.push(121,n>>>8&255,n&255);else if(n<4294967296)t.push(122,n>>>24&255,n>>>16&255,n>>>8&255,n&255);else throw new Error("String too long to encode");for(let r=0;r<e.length;r++)t.push(e[r])}function oo(s,t){const e=s.length;if(e<24)t.push(128|e);else if(e<256)t.push(152,e);else if(e<65536)t.push(153,e>>>8&255,e&255);else throw new Error("Unsupported array length");for(const n of s)Tn(n,t)}function co(s,t){const e=Object.keys(s),n=e.length;if(n>=4294967296)throw new Error("Object has too many keys to encode");n<24?t.push(160|n):n<256?t.push(184,n):n<65536?t.push(185,n>>8&255,n&255):t.push(186,n>>24&255,n>>16&255,n>>8&255,n&255);for(const r of e)Us(r,t),Tn(s[r],t)}function In(s){const t=new DataView(s.buffer,s.byteOffset,s.byteLength);return xe(t,0).value}function xe(s,t){if(t>=s.byteLength)throw new Error("Unexpected end of data");const e=s.getUint8(t++),n=e>>5,r=e&31;switch(n){case 0:return ao(s,t,r);case 1:return uo(s,t,r);case 2:return lo(s,t,r);case 3:return ho(s,t,r);case 4:return fo(s,t,r);case 5:return go(s,t,r);case 7:return yo(s,t,r);default:throw new Error(`Unsupported major type: ${n}`)}}function Pt(s,t,e){if(t+e>s.byteLength)throw new Error("Unexpected end of data")}function zt(s,t,e){if(e<24)return{value:e,offset:t};if(e===24)return Pt(s,t,1),{value:s.getUint8(t++),offset:t};if(e===25){Pt(s,t,2);const n=s.getUint16(t,!1);return t+=2,{value:n,offset:t}}if(e===26){Pt(s,t,4);const n=s.getUint32(t,!1);return t+=4,{value:n,offset:t}}if(e===27){Pt(s,t,8);const n=s.getUint32(t,!1),r=s.getUint32(t+4,!1);return t+=8,{value:n*2**32+r,offset:t}}throw new Error(`Unsupported length: ${e}`)}function ao(s,t,e){const{value:n,offset:r}=zt(s,t,e);return{value:n,offset:r}}function uo(s,t,e){const{value:n,offset:r}=zt(s,t,e);return{value:-1-n,offset:r}}function lo(s,t,e){const{value:n,offset:r}=zt(s,t,e);if(r+n>s.byteLength)throw new Error("Byte string length exceeds data length");return{value:new Uint8Array(s.buffer,s.byteOffset+r,n),offset:r+n}}function ho(s,t,e){const{value:n,offset:r}=zt(s,t,e);if(r+n>s.byteLength)throw new Error("String length exceeds data length");const i=new Uint8Array(s.buffer,s.byteOffset+r,n);return{value:new TextDecoder().decode(i),offset:r+n}}function fo(s,t,e){const{value:n,offset:r}=zt(s,t,e),i=[];let o=r;for(let c=0;c<n;c++){const a=xe(s,o);i.push(a.value),o=a.offset}return{value:i,offset:o}}function go(s,t,e){const{value:n,offset:r}=zt(s,t,e),i={};let o=r;for(let c=0;c<n;c++){const a=xe(s,o);if(!to(a.value))throw new Error("Invalid key type");const u=xe(s,a.offset);i[a.value]=u.value,o=u.offset}return{value:i,offset:o}}function po(s){const t=(s&31744)>>10,e=s&1023,n=s&32768?-1:1;return t===0?n*2**-14*(e/1024):t===31?e?NaN:n*(1/0):n*2**(t-15)*(1+e/1024)}function yo(s,t,e){if(e<24)switch(e){case 20:return{value:!1,offset:t};case 21:return{value:!0,offset:t};case 22:return{value:null,offset:t};case 23:return{value:void 0,offset:t};default:throw new Error(`Unknown simple value: ${e}`)}if(e===24)return Pt(s,t,1),{value:s.getUint8(t++),offset:t};if(e===25){Pt(s,t,2);const n=po(s.getUint16(t,!1));return t+=2,{value:n,offset:t}}if(e===26){Pt(s,t,4);const n=s.getFloat32(t,!1);return t+=4,{value:n,offset:t}}if(e===27){Pt(s,t,8);const n=s.getFloat64(t,!1);return t+=8,{value:n,offset:t}}throw new Error(`Unknown simple or float value: ${e}`)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Bn(s){return s instanceof Uint8Array||ArrayBuffer.isView(s)&&s.constructor.name==="Uint8Array"}function Nt(s,t=""){if(!Number.isSafeInteger(s)||s<0){const e=t&&`"${t}" `;throw new Error(`${e}expected integer >= 0, got ${s}`)}}function U(s,t,e=""){const n=Bn(s),r=s?.length,i=t!==void 0;if(!n||i&&r!==t){const o=e&&`"${e}" `,c=i?` of length ${t}`:"",a=n?`length=${r}`:`type=${typeof s}`;throw new Error(o+"expected Uint8Array"+c+", got "+a)}return s}function qs(s){if(typeof s!="function"||typeof s.create!="function")throw new Error("Hash must wrapped by utils.createHasher");Nt(s.outputLen),Nt(s.blockLen)}function Se(s,t=!0){if(s.destroyed)throw new Error("Hash instance has been destroyed");if(t&&s.finished)throw new Error("Hash#digest() has already been called")}function mo(s,t){U(s,void 0,"digestInto() output");const e=t.outputLen;if(s.length<e)throw new Error('"digestInto() output" expected to be of length >='+e)}function Tt(...s){for(let t=0;t<s.length;t++)s[t].fill(0)}function Ht(s){return new DataView(s.buffer,s.byteOffset,s.byteLength)}function dt(s,t){return s<<32-t|s>>>t}function de(s,t){return s<<t|s>>>32-t>>>0}const Fs=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",wo=Array.from({length:256},(s,t)=>t.toString(16).padStart(2,"0"));function F(s){if(U(s),Fs)return s.toHex();let t="";for(let e=0;e<s.length;e++)t+=wo[s[e]];return t}const pt={_0:48,_9:57,A:65,F:70,a:97,f:102};function ls(s){if(s>=pt._0&&s<=pt._9)return s-pt._0;if(s>=pt.A&&s<=pt.F)return s-(pt.A-10);if(s>=pt.a&&s<=pt.f)return s-(pt.a-10)}function R(s){if(typeof s!="string")throw new Error("hex string expected, got "+typeof s);if(Fs)return Uint8Array.fromHex(s);const t=s.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(e);for(let r=0,i=0;r<e;r++,i+=2){const o=ls(s.charCodeAt(i)),c=ls(s.charCodeAt(i+1));if(o===void 0||c===void 0){const a=s[i]+s[i+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+i)}n[r]=o*16+c}return n}function Hs(s){if(typeof s!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(s))}function rt(...s){let t=0;for(let n=0;n<s.length;n++){const r=s[n];U(r),t+=r.length}const e=new Uint8Array(t);for(let n=0,r=0;n<s.length;n++){const i=s[n];e.set(i,r),r+=i.length}return e}function Mn(s,t={}){const e=(r,i)=>s(i).update(r).digest(),n=s(void 0);return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=r=>s(r),Object.assign(e,t),Object.freeze(e)}function gt(s=32){const t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof t?.getRandomValues!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(s))}const $s=s=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,s])});function bo(s,t,e){return s&t^~s&e}function Eo(s,t,e){return s&t^s&e^t&e}class Cn{constructor(t,e,n,r){k(this,"blockLen");k(this,"outputLen");k(this,"padOffset");k(this,"isLE");k(this,"buffer");k(this,"view");k(this,"finished",!1);k(this,"length",0);k(this,"pos",0);k(this,"destroyed",!1);this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=r,this.buffer=new Uint8Array(t),this.view=Ht(this.buffer)}update(t){Se(this),U(t);const{view:e,buffer:n,blockLen:r}=this,i=t.length;for(let o=0;o<i;){const c=Math.min(r-this.pos,i-o);if(c===r){const a=Ht(t);for(;r<=i-o;o+=r)this.process(a,o);continue}n.set(t.subarray(o,o+c),this.pos),this.pos+=c,o+=c,this.pos===r&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Se(this),mo(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:r,isLE:i}=this;let{pos:o}=this;e[o++]=128,Tt(this.buffer.subarray(o)),this.padOffset>r-o&&(this.process(n,0),o=0);for(let h=o;h<r;h++)e[h]=0;n.setBigUint64(r-8,BigInt(this.length*8),i),this.process(n,0);const c=Ht(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const u=a/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<u;h++)c.setUint32(4*h,l[h],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:r,finished:i,destroyed:o,pos:c}=this;return t.destroyed=o,t.finished=i,t.length=r,t.pos=c,r%e&&t.buffer.set(n),t}clone(){return this._cloneInto()}}const kt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Y=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),ge=BigInt(2**32-1),hs=BigInt(32);function ko(s,t=!1){return t?{h:Number(s&ge),l:Number(s>>hs&ge)}:{h:Number(s>>hs&ge)|0,l:Number(s&ge)|0}}function vo(s,t=!1){const e=s.length;let n=new Uint32Array(e),r=new Uint32Array(e);for(let i=0;i<e;i++){const{h:o,l:c}=ko(s[i],t);[n[i],r[i]]=[o,c]}return[n,r]}const fs=(s,t,e)=>s>>>e,ds=(s,t,e)=>s<<32-e|t>>>e,Dt=(s,t,e)=>s>>>e|t<<32-e,Ut=(s,t,e)=>s<<32-e|t>>>e,pe=(s,t,e)=>s<<64-e|t>>>e-32,ye=(s,t,e)=>s>>>e-32|t<<64-e;function yt(s,t,e,n){const r=(t>>>0)+(n>>>0);return{h:s+e+(r/2**32|0)|0,l:r|0}}const _o=(s,t,e)=>(s>>>0)+(t>>>0)+(e>>>0),xo=(s,t,e,n)=>t+e+n+(s/2**32|0)|0,So=(s,t,e,n)=>(s>>>0)+(t>>>0)+(e>>>0)+(n>>>0),Ao=(s,t,e,n,r)=>t+e+n+r+(s/2**32|0)|0,Po=(s,t,e,n,r)=>(s>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0),To=(s,t,e,n,r,i)=>t+e+n+r+i+(s/2**32|0)|0,Io=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),vt=new Uint32Array(64);class Bo extends Cn{constructor(t){super(64,t,8,!1)}get(){const{A:t,B:e,C:n,D:r,E:i,F:o,G:c,H:a}=this;return[t,e,n,r,i,o,c,a]}set(t,e,n,r,i,o,c,a){this.A=t|0,this.B=e|0,this.C=n|0,this.D=r|0,this.E=i|0,this.F=o|0,this.G=c|0,this.H=a|0}process(t,e){for(let h=0;h<16;h++,e+=4)vt[h]=t.getUint32(e,!1);for(let h=16;h<64;h++){const f=vt[h-15],d=vt[h-2],y=dt(f,7)^dt(f,18)^f>>>3,m=dt(d,17)^dt(d,19)^d>>>10;vt[h]=m+vt[h-7]+y+vt[h-16]|0}let{A:n,B:r,C:i,D:o,E:c,F:a,G:u,H:l}=this;for(let h=0;h<64;h++){const f=dt(c,6)^dt(c,11)^dt(c,25),d=l+f+bo(c,a,u)+Io[h]+vt[h]|0,m=(dt(n,2)^dt(n,13)^dt(n,22))+Eo(n,r,i)|0;l=u,u=a,a=c,c=o+d|0,o=i,i=r,r=n,n=d+m|0}n=n+this.A|0,r=r+this.B|0,i=i+this.C|0,o=o+this.D|0,c=c+this.E|0,a=a+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(n,r,i,o,c,a,u,l)}roundClean(){Tt(vt)}destroy(){this.set(0,0,0,0,0,0,0,0),Tt(this.buffer)}}class Mo extends Bo{constructor(){super(32);k(this,"A",kt[0]|0);k(this,"B",kt[1]|0);k(this,"C",kt[2]|0);k(this,"D",kt[3]|0);k(this,"E",kt[4]|0);k(this,"F",kt[5]|0);k(this,"G",kt[6]|0);k(this,"H",kt[7]|0)}}const Ws=vo(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(s=>BigInt(s))),Co=Ws[0],Ko=Ws[1],_t=new Uint32Array(80),xt=new Uint32Array(80);class Oo extends Cn{constructor(t){super(128,t,16,!1)}get(){const{Ah:t,Al:e,Bh:n,Bl:r,Ch:i,Cl:o,Dh:c,Dl:a,Eh:u,El:l,Fh:h,Fl:f,Gh:d,Gl:y,Hh:m,Hl:w}=this;return[t,e,n,r,i,o,c,a,u,l,h,f,d,y,m,w]}set(t,e,n,r,i,o,c,a,u,l,h,f,d,y,m,w){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=r|0,this.Ch=i|0,this.Cl=o|0,this.Dh=c|0,this.Dl=a|0,this.Eh=u|0,this.El=l|0,this.Fh=h|0,this.Fl=f|0,this.Gh=d|0,this.Gl=y|0,this.Hh=m|0,this.Hl=w|0}process(t,e){for(let B=0;B<16;B++,e+=4)_t[B]=t.getUint32(e),xt[B]=t.getUint32(e+=4);for(let B=16;B<80;B++){const D=_t[B-15]|0,j=xt[B-15]|0,q=Dt(D,j,1)^Dt(D,j,8)^fs(D,j,7),Q=Ut(D,j,1)^Ut(D,j,8)^ds(D,j,7),H=_t[B-2]|0,K=xt[B-2]|0,at=Dt(H,K,19)^pe(H,K,61)^fs(H,K,6),nt=Ut(H,K,19)^ye(H,K,61)^ds(H,K,6),v=So(Q,nt,xt[B-7],xt[B-16]),b=Ao(v,q,at,_t[B-7],_t[B-16]);_t[B]=b|0,xt[B]=v|0}let{Ah:n,Al:r,Bh:i,Bl:o,Ch:c,Cl:a,Dh:u,Dl:l,Eh:h,El:f,Fh:d,Fl:y,Gh:m,Gl:w,Hh:P,Hl:C}=this;for(let B=0;B<80;B++){const D=Dt(h,f,14)^Dt(h,f,18)^pe(h,f,41),j=Ut(h,f,14)^Ut(h,f,18)^ye(h,f,41),q=h&d^~h&m,Q=f&y^~f&w,H=Po(C,j,Q,Ko[B],xt[B]),K=To(H,P,D,q,Co[B],_t[B]),at=H|0,nt=Dt(n,r,28)^pe(n,r,34)^pe(n,r,39),v=Ut(n,r,28)^ye(n,r,34)^ye(n,r,39),b=n&i^n&c^i&c,p=r&o^r&a^o&a;P=m|0,C=w|0,m=d|0,w=y|0,d=h|0,y=f|0,{h,l:f}=yt(u|0,l|0,K|0,at|0),u=c|0,l=a|0,c=i|0,a=o|0,i=n|0,o=r|0;const g=_o(at,v,p);n=xo(g,K,nt,b),r=g|0}({h:n,l:r}=yt(this.Ah|0,this.Al|0,n|0,r|0)),{h:i,l:o}=yt(this.Bh|0,this.Bl|0,i|0,o|0),{h:c,l:a}=yt(this.Ch|0,this.Cl|0,c|0,a|0),{h:u,l}=yt(this.Dh|0,this.Dl|0,u|0,l|0),{h,l:f}=yt(this.Eh|0,this.El|0,h|0,f|0),{h:d,l:y}=yt(this.Fh|0,this.Fl|0,d|0,y|0),{h:m,l:w}=yt(this.Gh|0,this.Gl|0,m|0,w|0),{h:P,l:C}=yt(this.Hh|0,this.Hl|0,P|0,C|0),this.set(n,r,i,o,c,a,u,l,h,f,d,y,m,w,P,C)}roundClean(){Tt(_t,xt)}destroy(){Tt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Lo extends Oo{constructor(){super(64);k(this,"Ah",Y[0]|0);k(this,"Al",Y[1]|0);k(this,"Bh",Y[2]|0);k(this,"Bl",Y[3]|0);k(this,"Ch",Y[4]|0);k(this,"Cl",Y[5]|0);k(this,"Dh",Y[6]|0);k(this,"Dl",Y[7]|0);k(this,"Eh",Y[8]|0);k(this,"El",Y[9]|0);k(this,"Fh",Y[10]|0);k(this,"Fl",Y[11]|0);k(this,"Gh",Y[12]|0);k(this,"Gl",Y[13]|0);k(this,"Hh",Y[14]|0);k(this,"Hl",Y[15]|0)}}const Z=Mn(()=>new Mo,$s(1)),gs=Mn(()=>new Lo,$s(3));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Kn=BigInt(0),dn=BigInt(1);function Ae(s,t=""){if(typeof s!="boolean"){const e=t&&`"${t}" `;throw new Error(e+"expected boolean, got type="+typeof s)}return s}function js(s){if(typeof s=="bigint"){if(!ke(s))throw new Error("positive bigint expected, got "+s)}else Nt(s);return s}function me(s){const t=js(s).toString(16);return t.length&1?"0"+t:t}function Vs(s){if(typeof s!="string")throw new Error("hex string expected, got "+typeof s);return s===""?Kn:BigInt("0x"+s)}function ae(s){return Vs(F(s))}function Gs(s){return Vs(F(No(U(s)).reverse()))}function Fe(s,t){Nt(t),s=js(s);const e=R(s.toString(16).padStart(t*2,"0"));if(e.length!==t)throw new Error("number too large");return e}function zs(s,t){return Fe(s,t).reverse()}function No(s){return Uint8Array.from(s)}function Ro(s){return Uint8Array.from(s,(t,e)=>{const n=t.charCodeAt(0);if(t.length!==1||n>127)throw new Error(`string contains non-ASCII character "${s[e]}" with code ${n} at position ${e}`);return n})}const ke=s=>typeof s=="bigint"&&Kn<=s;function Do(s,t,e){return ke(s)&&ke(t)&&ke(e)&&t<=s&&s<e}function Uo(s,t,e,n){if(!Do(t,e,n))throw new Error("expected valid "+s+": "+e+" <= n < "+n+", got "+t)}function qo(s){let t;for(t=0;s>Kn;s>>=dn,t+=1);return t}const On=s=>(dn<<BigInt(s))-dn;function Fo(s,t,e){if(Nt(s,"hashLen"),Nt(t,"qByteLen"),typeof e!="function")throw new Error("hmacFn must be a function");const n=w=>new Uint8Array(w),r=Uint8Array.of(),i=Uint8Array.of(0),o=Uint8Array.of(1),c=1e3;let a=n(s),u=n(s),l=0;const h=()=>{a.fill(1),u.fill(0),l=0},f=(...w)=>e(u,rt(a,...w)),d=(w=r)=>{u=f(i,w),a=f(),w.length!==0&&(u=f(o,w),a=f())},y=()=>{if(l++>=c)throw new Error("drbg: tried max amount of iterations");let w=0;const P=[];for(;w<t;){a=f();const C=a.slice();P.push(C),w+=a.length}return rt(...P)};return(w,P)=>{h(),d(w);let C;for(;!(C=P(y()));)d();return h(),C}}function Ln(s,t={},e={}){if(!s||typeof s!="object")throw new Error("expected valid options object");function n(i,o,c){const a=s[i];if(c&&a===void 0)return;const u=typeof a;if(u!==o||a===null)throw new Error(`param "${i}" is invalid: expected ${o}, got ${u}`)}const r=(i,o)=>Object.entries(i).forEach(([c,a])=>n(c,a,o));r(t,!1),r(e,!0)}function ps(s){const t=new WeakMap;return(e,...n)=>{const r=t.get(e);if(r!==void 0)return r;const i=s(e,...n);return t.set(e,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const it=BigInt(0),et=BigInt(1),Ct=BigInt(2),Qs=BigInt(3),Zs=BigInt(4),Ys=BigInt(5),Ho=BigInt(7),Xs=BigInt(8),$o=BigInt(9),Js=BigInt(16);function ht(s,t){const e=s%t;return e>=it?e:t+e}function ut(s,t,e){let n=s;for(;t-- >it;)n*=n,n%=e;return n}function ys(s,t){if(s===it)throw new Error("invert: expected non-zero number");if(t<=it)throw new Error("invert: expected positive modulus, got "+t);let e=ht(s,t),n=t,r=it,i=et;for(;e!==it;){const c=n/e,a=n%e,u=r-i*c;n=e,e=a,r=i,i=u}if(n!==et)throw new Error("invert: does not exist");return ht(r,t)}function Nn(s,t,e){if(!s.eql(s.sqr(t),e))throw new Error("Cannot find square root")}function tr(s,t){const e=(s.ORDER+et)/Zs,n=s.pow(t,e);return Nn(s,n,t),n}function Wo(s,t){const e=(s.ORDER-Ys)/Xs,n=s.mul(t,Ct),r=s.pow(n,e),i=s.mul(t,r),o=s.mul(s.mul(i,Ct),r),c=s.mul(i,s.sub(o,s.ONE));return Nn(s,c,t),c}function jo(s){const t=He(s),e=er(s),n=e(t,t.neg(t.ONE)),r=e(t,n),i=e(t,t.neg(n)),o=(s+Ho)/Js;return(c,a)=>{let u=c.pow(a,o),l=c.mul(u,n);const h=c.mul(u,r),f=c.mul(u,i),d=c.eql(c.sqr(l),a),y=c.eql(c.sqr(h),a);u=c.cmov(u,l,d),l=c.cmov(f,h,y);const m=c.eql(c.sqr(l),a),w=c.cmov(u,l,m);return Nn(c,w,a),w}}function er(s){if(s<Qs)throw new Error("sqrt is not defined for small field");let t=s-et,e=0;for(;t%Ct===it;)t/=Ct,e++;let n=Ct;const r=He(s);for(;ms(r,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return tr;let i=r.pow(n,t);const o=(t+et)/Ct;return function(a,u){if(a.is0(u))return u;if(ms(a,u)!==1)throw new Error("Cannot find square root");let l=e,h=a.mul(a.ONE,i),f=a.pow(u,t),d=a.pow(u,o);for(;!a.eql(f,a.ONE);){if(a.is0(f))return a.ZERO;let y=1,m=a.sqr(f);for(;!a.eql(m,a.ONE);)if(y++,m=a.sqr(m),y===l)throw new Error("Cannot find square root");const w=et<<BigInt(l-y-1),P=a.pow(h,w);l=y,h=a.sqr(P),f=a.mul(f,h),d=a.mul(d,P)}return d}}function Vo(s){return s%Zs===Qs?tr:s%Xs===Ys?Wo:s%Js===$o?jo(s):er(s)}const Go=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function zo(s){const t={ORDER:"bigint",BYTES:"number",BITS:"number"},e=Go.reduce((n,r)=>(n[r]="function",n),t);return Ln(s,e),s}function Qo(s,t,e){if(e<it)throw new Error("invalid exponent, negatives unsupported");if(e===it)return s.ONE;if(e===et)return t;let n=s.ONE,r=t;for(;e>it;)e&et&&(n=s.mul(n,r)),r=s.sqr(r),e>>=et;return n}function nr(s,t,e=!1){const n=new Array(t.length).fill(e?s.ZERO:void 0),r=t.reduce((o,c,a)=>s.is0(c)?o:(n[a]=o,s.mul(o,c)),s.ONE),i=s.inv(r);return t.reduceRight((o,c,a)=>s.is0(c)?o:(n[a]=s.mul(o,n[a]),s.mul(o,c)),i),n}function ms(s,t){const e=(s.ORDER-et)/Ct,n=s.pow(t,e),r=s.eql(n,s.ONE),i=s.eql(n,s.ZERO),o=s.eql(n,s.neg(s.ONE));if(!r&&!i&&!o)throw new Error("invalid Legendre symbol result");return r?1:i?0:-1}function Zo(s,t){t!==void 0&&Nt(t);const e=t!==void 0?t:s.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}class Yo{constructor(t,e={}){k(this,"ORDER");k(this,"BITS");k(this,"BYTES");k(this,"isLE");k(this,"ZERO",it);k(this,"ONE",et);k(this,"_lengths");k(this,"_sqrt");k(this,"_mod");if(t<=it)throw new Error("invalid field: expected ORDER > 0, got "+t);let n;this.isLE=!1,e!=null&&typeof e=="object"&&(typeof e.BITS=="number"&&(n=e.BITS),typeof e.sqrt=="function"&&(this.sqrt=e.sqrt),typeof e.isLE=="boolean"&&(this.isLE=e.isLE),e.allowedLengths&&(this._lengths=e.allowedLengths?.slice()),typeof e.modFromBytes=="boolean"&&(this._mod=e.modFromBytes));const{nBitLength:r,nByteLength:i}=Zo(t,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=t,this.BITS=r,this.BYTES=i,this._sqrt=void 0,Object.preventExtensions(this)}create(t){return ht(t,this.ORDER)}isValid(t){if(typeof t!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof t);return it<=t&&t<this.ORDER}is0(t){return t===it}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}isOdd(t){return(t&et)===et}neg(t){return ht(-t,this.ORDER)}eql(t,e){return t===e}sqr(t){return ht(t*t,this.ORDER)}add(t,e){return ht(t+e,this.ORDER)}sub(t,e){return ht(t-e,this.ORDER)}mul(t,e){return ht(t*e,this.ORDER)}pow(t,e){return Qo(this,t,e)}div(t,e){return ht(t*ys(e,this.ORDER),this.ORDER)}sqrN(t){return t*t}addN(t,e){return t+e}subN(t,e){return t-e}mulN(t,e){return t*e}inv(t){return ys(t,this.ORDER)}sqrt(t){return this._sqrt||(this._sqrt=Vo(this.ORDER)),this._sqrt(this,t)}toBytes(t){return this.isLE?zs(t,this.BYTES):Fe(t,this.BYTES)}fromBytes(t,e=!1){U(t);const{_lengths:n,BYTES:r,isLE:i,ORDER:o,_mod:c}=this;if(n){if(!n.includes(t.length)||t.length>r)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+t.length);const u=new Uint8Array(r);u.set(t,i?0:u.length-t.length),t=u}if(t.length!==r)throw new Error("Field.fromBytes: expected "+r+" bytes, got "+t.length);let a=i?Gs(t):ae(t);if(c&&(a=ht(a,o)),!e&&!this.isValid(a))throw new Error("invalid field element: outside of range 0..ORDER");return a}invertBatch(t){return nr(this,t)}cmov(t,e,n){return n?e:t}}function He(s,t={}){return new Yo(s,t)}function sr(s){if(typeof s!="bigint")throw new Error("field order must be bigint");const t=s.toString(2).length;return Math.ceil(t/8)}function rr(s){const t=sr(s);return t+Math.ceil(t/2)}function ir(s,t,e=!1){U(s);const n=s.length,r=sr(t),i=rr(t);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);const o=e?Gs(s):ae(s),c=ht(o,t-et)+et;return e?zs(c,r):Fe(c,r)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const jt=BigInt(0),Kt=BigInt(1);function Pe(s,t){const e=t.negate();return s?e:t}function ws(s,t){const e=nr(s.Fp,t.map(n=>n.Z));return t.map((n,r)=>s.fromAffine(n.toAffine(e[r])))}function or(s,t){if(!Number.isSafeInteger(s)||s<=0||s>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+s)}function en(s,t){or(s,t);const e=Math.ceil(t/s)+1,n=2**(s-1),r=2**s,i=On(s),o=BigInt(s);return{windows:e,windowSize:n,mask:i,maxNumber:r,shiftBy:o}}function bs(s,t,e){const{windowSize:n,mask:r,maxNumber:i,shiftBy:o}=e;let c=Number(s&r),a=s>>o;c>n&&(c-=i,a+=Kt);const u=t*n,l=u+Math.abs(c)-1,h=c===0,f=c<0,d=t%2!==0;return{nextN:a,offset:l,isZero:h,isNeg:f,isNegF:d,offsetF:u}}const nn=new WeakMap,cr=new WeakMap;function sn(s){return cr.get(s)||1}function Es(s){if(s!==jt)throw new Error("invalid wNAF")}class Xo{constructor(t,e){k(this,"BASE");k(this,"ZERO");k(this,"Fn");k(this,"bits");this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,n=this.ZERO){let r=t;for(;e>jt;)e&Kt&&(n=n.add(r)),r=r.double(),e>>=Kt;return n}precomputeWindow(t,e){const{windows:n,windowSize:r}=en(e,this.bits),i=[];let o=t,c=o;for(let a=0;a<n;a++){c=o,i.push(c);for(let u=1;u<r;u++)c=c.add(o),i.push(c);o=c.double()}return i}wNAF(t,e,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let r=this.ZERO,i=this.BASE;const o=en(t,this.bits);for(let c=0;c<o.windows;c++){const{nextN:a,offset:u,isZero:l,isNeg:h,isNegF:f,offsetF:d}=bs(n,c,o);n=a,l?i=i.add(Pe(f,e[d])):r=r.add(Pe(h,e[u]))}return Es(n),{p:r,f:i}}wNAFUnsafe(t,e,n,r=this.ZERO){const i=en(t,this.bits);for(let o=0;o<i.windows&&n!==jt;o++){const{nextN:c,offset:a,isZero:u,isNeg:l}=bs(n,o,i);if(n=c,!u){const h=e[a];r=r.add(l?h.negate():h)}}return Es(n),r}getPrecomputes(t,e,n){let r=nn.get(e);return r||(r=this.precomputeWindow(e,t),t!==1&&(typeof n=="function"&&(r=n(r)),nn.set(e,r))),r}cached(t,e,n){const r=sn(t);return this.wNAF(r,this.getPrecomputes(r,t,n),e)}unsafe(t,e,n,r){const i=sn(t);return i===1?this._unsafeLadder(t,e,r):this.wNAFUnsafe(i,this.getPrecomputes(i,t,n),e,r)}createCache(t,e){or(e,this.bits),cr.set(t,e),nn.delete(t)}hasCache(t){return sn(t)!==1}}function Jo(s,t,e,n){let r=t,i=s.ZERO,o=s.ZERO;for(;e>jt||n>jt;)e&Kt&&(i=i.add(r)),n&Kt&&(o=o.add(r)),r=r.double(),e>>=Kt,n>>=Kt;return{p1:i,p2:o}}function ks(s,t,e){if(t){if(t.ORDER!==s)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return zo(t),t}else return He(s,{isLE:e})}function tc(s,t,e={},n){if(n===void 0&&(n=s==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${s} CURVE object`);for(const a of["p","n","h"]){const u=t[a];if(!(typeof u=="bigint"&&u>jt))throw new Error(`CURVE.${a} must be positive bigint`)}const r=ks(t.p,e.Fp,n),i=ks(t.n,e.Fn,n),c=["Gx","Gy","a","b"];for(const a of c)if(!r.isValid(t[a]))throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:r,Fn:i}}function ar(s,t){return function(n){const r=s(n);return{secretKey:r,publicKey:t(r)}}}class ur{constructor(t,e){k(this,"oHash");k(this,"iHash");k(this,"blockLen");k(this,"outputLen");k(this,"finished",!1);k(this,"destroyed",!1);if(qs(t),U(e,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,r=new Uint8Array(n);r.set(e.length>n?t.create().update(e).digest():e);for(let i=0;i<r.length;i++)r[i]^=54;this.iHash.update(r),this.oHash=t.create();for(let i=0;i<r.length;i++)r[i]^=106;this.oHash.update(r),Tt(r)}update(t){return Se(this),this.iHash.update(t),this}digestInto(t){Se(this),U(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:i,blockLen:o,outputLen:c}=this;return t=t,t.finished=r,t.destroyed=i,t.blockLen=o,t.outputLen=c,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ne=(s,t,e)=>new ur(s,t).update(e).digest();ne.create=(s,t)=>new ur(s,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const vs=(s,t)=>(s+(s>=0?t:-t)/lr)/t;function ec(s,t,e){const[[n,r],[i,o]]=t,c=vs(o*s,e),a=vs(-r*s,e);let u=s-c*n-a*i,l=-c*r-a*o;const h=u<mt,f=l<mt;h&&(u=-u),f&&(l=-l);const d=On(Math.ceil(qo(e)/2))+$t;if(u<mt||u>=d||l<mt||l>=d)throw new Error("splitScalar (endomorphism): failed, k="+s);return{k1neg:h,k1:u,k2neg:f,k2:l}}function gn(s){if(!["compact","recovered","der"].includes(s))throw new Error('Signature format must be "compact", "recovered", or "der"');return s}function rn(s,t){const e={};for(let n of Object.keys(t))e[n]=s[n]===void 0?t[n]:s[n];return Ae(e.lowS,"lowS"),Ae(e.prehash,"prehash"),e.format!==void 0&&gn(e.format),e}class nc extends Error{constructor(t=""){super(t)}}const St={Err:nc,_tlv:{encode:(s,t)=>{const{Err:e}=St;if(s<0||s>256)throw new e("tlv.encode: wrong tag");if(t.length&1)throw new e("tlv.encode: unpadded data");const n=t.length/2,r=me(n);if(r.length/2&128)throw new e("tlv.encode: long form length too big");const i=n>127?me(r.length/2|128):"";return me(s)+i+r+t},decode(s,t){const{Err:e}=St;let n=0;if(s<0||s>256)throw new e("tlv.encode: wrong tag");if(t.length<2||t[n++]!==s)throw new e("tlv.decode: wrong tlv");const r=t[n++],i=!!(r&128);let o=0;if(!i)o=r;else{const a=r&127;if(!a)throw new e("tlv.decode(long): indefinite length not supported");if(a>4)throw new e("tlv.decode(long): byte length is too big");const u=t.subarray(n,n+a);if(u.length!==a)throw new e("tlv.decode: length bytes not complete");if(u[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const l of u)o=o<<8|l;if(n+=a,o<128)throw new e("tlv.decode(long): not minimal encoding")}const c=t.subarray(n,n+o);if(c.length!==o)throw new e("tlv.decode: wrong value length");return{v:c,l:t.subarray(n+o)}}},_int:{encode(s){const{Err:t}=St;if(s<mt)throw new t("integer: negative integers are not allowed");let e=me(s);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return e},decode(s){const{Err:t}=St;if(s[0]&128)throw new t("invalid signature integer: negative");if(s[0]===0&&!(s[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return ae(s)}},toSig(s){const{Err:t,_int:e,_tlv:n}=St,r=U(s,void 0,"signature"),{v:i,l:o}=n.decode(48,r);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:c,l:a}=n.decode(2,i),{v:u,l}=n.decode(2,a);if(l.length)throw new t("invalid signature: left bytes after parsing");return{r:e.decode(c),s:e.decode(u)}},hexFromSig(s){const{_tlv:t,_int:e}=St,n=t.encode(2,e.encode(s.r)),r=t.encode(2,e.encode(s.s)),i=n+r;return t.encode(48,i)}},mt=BigInt(0),$t=BigInt(1),lr=BigInt(2),we=BigInt(3),sc=BigInt(4);function rc(s,t={}){const e=tc("weierstrass",s,t),{Fp:n,Fn:r}=e;let i=e.CURVE;const{h:o,n:c}=i;Ln(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:a}=t;if(a&&(!n.is0(i.a)||typeof a.beta!="bigint"||!Array.isArray(a.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const u=fr(n,r);function l(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function h(b,p,g){const{x:E,y:x}=p.toAffine(),I=n.toBytes(E);if(Ae(g,"isCompressed"),g){l();const T=!n.isOdd(x);return rt(hr(T),I)}else return rt(Uint8Array.of(4),I,n.toBytes(x))}function f(b){U(b,void 0,"Point");const{publicKey:p,publicKeyUncompressed:g}=u,E=b.length,x=b[0],I=b.subarray(1);if(E===p&&(x===2||x===3)){const T=n.fromBytes(I);if(!n.isValid(T))throw new Error("bad point: is not on curve, wrong x");const S=m(T);let _;try{_=n.sqrt(S)}catch(W){const $=W instanceof Error?": "+W.message:"";throw new Error("bad point: is not on curve, sqrt error"+$)}l();const A=n.isOdd(_);return(x&1)===1!==A&&(_=n.neg(_)),{x:T,y:_}}else if(E===g&&x===4){const T=n.BYTES,S=n.fromBytes(I.subarray(0,T)),_=n.fromBytes(I.subarray(T,T*2));if(!w(S,_))throw new Error("bad point: is not on curve");return{x:S,y:_}}else throw new Error(`bad point: got length ${E}, expected compressed=${p} or uncompressed=${g}`)}const d=t.toBytes||h,y=t.fromBytes||f;function m(b){const p=n.sqr(b),g=n.mul(p,b);return n.add(n.add(g,n.mul(b,i.a)),i.b)}function w(b,p){const g=n.sqr(p),E=m(b);return n.eql(g,E)}if(!w(i.Gx,i.Gy))throw new Error("bad curve params: generator point");const P=n.mul(n.pow(i.a,we),sc),C=n.mul(n.sqr(i.b),BigInt(27));if(n.is0(n.add(P,C)))throw new Error("bad curve params: a or b");function B(b,p,g=!1){if(!n.isValid(p)||g&&n.is0(p))throw new Error(`bad point coordinate ${b}`);return p}function D(b){if(!(b instanceof K))throw new Error("Weierstrass Point expected")}function j(b){if(!a||!a.basises)throw new Error("no endo");return ec(b,a.basises,r.ORDER)}const q=ps((b,p)=>{const{X:g,Y:E,Z:x}=b;if(n.eql(x,n.ONE))return{x:g,y:E};const I=b.is0();p==null&&(p=I?n.ONE:n.inv(x));const T=n.mul(g,p),S=n.mul(E,p),_=n.mul(x,p);if(I)return{x:n.ZERO,y:n.ZERO};if(!n.eql(_,n.ONE))throw new Error("invZ was invalid");return{x:T,y:S}}),Q=ps(b=>{if(b.is0()){if(t.allowInfinityPoint&&!n.is0(b.Y))return;throw new Error("bad point: ZERO")}const{x:p,y:g}=b.toAffine();if(!n.isValid(p)||!n.isValid(g))throw new Error("bad point: x or y not field elements");if(!w(p,g))throw new Error("bad point: equation left != right");if(!b.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function H(b,p,g,E,x){return g=new K(n.mul(g.X,b),g.Y,g.Z),p=Pe(E,p),g=Pe(x,g),p.add(g)}const v=class v{constructor(p,g,E){k(this,"X");k(this,"Y");k(this,"Z");this.X=B("x",p),this.Y=B("y",g,!0),this.Z=B("z",E),Object.freeze(this)}static CURVE(){return i}static fromAffine(p){const{x:g,y:E}=p||{};if(!p||!n.isValid(g)||!n.isValid(E))throw new Error("invalid affine point");if(p instanceof v)throw new Error("projective point not allowed");return n.is0(g)&&n.is0(E)?v.ZERO:new v(g,E,n.ONE)}static fromBytes(p){const g=v.fromAffine(y(U(p,void 0,"point")));return g.assertValidity(),g}static fromHex(p){return v.fromBytes(R(p))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(p=8,g=!0){return nt.createCache(this,p),g||this.multiply(we),this}assertValidity(){Q(this)}hasEvenY(){const{y:p}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(p)}equals(p){D(p);const{X:g,Y:E,Z:x}=this,{X:I,Y:T,Z:S}=p,_=n.eql(n.mul(g,S),n.mul(I,x)),A=n.eql(n.mul(E,S),n.mul(T,x));return _&&A}negate(){return new v(this.X,n.neg(this.Y),this.Z)}double(){const{a:p,b:g}=i,E=n.mul(g,we),{X:x,Y:I,Z:T}=this;let S=n.ZERO,_=n.ZERO,A=n.ZERO,M=n.mul(x,x),W=n.mul(I,I),$=n.mul(T,T),O=n.mul(x,I);return O=n.add(O,O),A=n.mul(x,T),A=n.add(A,A),S=n.mul(p,A),_=n.mul(E,$),_=n.add(S,_),S=n.sub(W,_),_=n.add(W,_),_=n.mul(S,_),S=n.mul(O,S),A=n.mul(E,A),$=n.mul(p,$),O=n.sub(M,$),O=n.mul(p,O),O=n.add(O,A),A=n.add(M,M),M=n.add(A,M),M=n.add(M,$),M=n.mul(M,O),_=n.add(_,M),$=n.mul(I,T),$=n.add($,$),M=n.mul($,O),S=n.sub(S,M),A=n.mul($,W),A=n.add(A,A),A=n.add(A,A),new v(S,_,A)}add(p){D(p);const{X:g,Y:E,Z:x}=this,{X:I,Y:T,Z:S}=p;let _=n.ZERO,A=n.ZERO,M=n.ZERO;const W=i.a,$=n.mul(i.b,we);let O=n.mul(g,I),V=n.mul(E,T),G=n.mul(x,S),ct=n.add(g,E),z=n.add(I,T);ct=n.mul(ct,z),z=n.add(O,V),ct=n.sub(ct,z),z=n.add(g,x);let J=n.add(I,S);return z=n.mul(z,J),J=n.add(O,G),z=n.sub(z,J),J=n.add(E,x),_=n.add(T,S),J=n.mul(J,_),_=n.add(V,G),J=n.sub(J,_),M=n.mul(W,z),_=n.mul($,G),M=n.add(_,M),_=n.sub(V,M),M=n.add(V,M),A=n.mul(_,M),V=n.add(O,O),V=n.add(V,O),G=n.mul(W,G),z=n.mul($,z),V=n.add(V,G),G=n.sub(O,G),G=n.mul(W,G),z=n.add(z,G),O=n.mul(V,z),A=n.add(A,O),O=n.mul(J,z),_=n.mul(ct,_),_=n.sub(_,O),O=n.mul(ct,V),M=n.mul(J,M),M=n.add(M,O),new v(_,A,M)}subtract(p){return this.add(p.negate())}is0(){return this.equals(v.ZERO)}multiply(p){const{endo:g}=t;if(!r.isValidNot0(p))throw new Error("invalid scalar: out of range");let E,x;const I=T=>nt.cached(this,T,S=>ws(v,S));if(g){const{k1neg:T,k1:S,k2neg:_,k2:A}=j(p),{p:M,f:W}=I(S),{p:$,f:O}=I(A);x=W.add(O),E=H(g.beta,M,$,T,_)}else{const{p:T,f:S}=I(p);E=T,x=S}return ws(v,[E,x])[0]}multiplyUnsafe(p){const{endo:g}=t,E=this;if(!r.isValid(p))throw new Error("invalid scalar: out of range");if(p===mt||E.is0())return v.ZERO;if(p===$t)return E;if(nt.hasCache(this))return this.multiply(p);if(g){const{k1neg:x,k1:I,k2neg:T,k2:S}=j(p),{p1:_,p2:A}=Jo(v,E,I,S);return H(g.beta,_,A,x,T)}else return nt.unsafe(E,p)}toAffine(p){return q(this,p)}isTorsionFree(){const{isTorsionFree:p}=t;return o===$t?!0:p?p(v,this):nt.unsafe(this,c).is0()}clearCofactor(){const{clearCofactor:p}=t;return o===$t?this:p?p(v,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(p=!0){return Ae(p,"isCompressed"),this.assertValidity(),d(v,this,p)}toHex(p=!0){return F(this.toBytes(p))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};k(v,"BASE",new v(i.Gx,i.Gy,n.ONE)),k(v,"ZERO",new v(n.ZERO,n.ONE,n.ZERO)),k(v,"Fp",n),k(v,"Fn",r);let K=v;const at=r.BITS,nt=new Xo(K,t.endo?Math.ceil(at/2):at);return K.BASE.precompute(8),K}function hr(s){return Uint8Array.of(s?2:3)}function fr(s,t){return{secretKey:t.BYTES,publicKey:1+s.BYTES,publicKeyUncompressed:1+2*s.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function ic(s,t={}){const{Fn:e}=s,n=t.randomBytes||gt,r=Object.assign(fr(s.Fp,e),{seed:rr(e.ORDER)});function i(d){try{const y=e.fromBytes(d);return e.isValidNot0(y)}catch{return!1}}function o(d,y){const{publicKey:m,publicKeyUncompressed:w}=r;try{const P=d.length;return y===!0&&P!==m||y===!1&&P!==w?!1:!!s.fromBytes(d)}catch{return!1}}function c(d=n(r.seed)){return ir(U(d,r.seed,"seed"),e.ORDER)}function a(d,y=!0){return s.BASE.multiply(e.fromBytes(d)).toBytes(y)}function u(d){const{secretKey:y,publicKey:m,publicKeyUncompressed:w}=r;if(!Bn(d)||"_lengths"in e&&e._lengths||y===m)return;const P=U(d,void 0,"key").length;return P===m||P===w}function l(d,y,m=!0){if(u(d)===!0)throw new Error("first arg must be private key");if(u(y)===!1)throw new Error("second arg must be public key");const w=e.fromBytes(d);return s.fromBytes(y).multiply(w).toBytes(m)}const h={isValidSecretKey:i,isValidPublicKey:o,randomSecretKey:c},f=ar(c,a);return Object.freeze({getPublicKey:a,getSharedSecret:l,keygen:f,Point:s,utils:h,lengths:r})}function oc(s,t,e={}){qs(t),Ln(e,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),e=Object.assign({},e);const n=e.randomBytes||gt,r=e.hmac||((p,g)=>ne(t,p,g)),{Fp:i,Fn:o}=s,{ORDER:c,BITS:a}=o,{keygen:u,getPublicKey:l,getSharedSecret:h,utils:f,lengths:d}=ic(s,e),y={prehash:!0,lowS:typeof e.lowS=="boolean"?e.lowS:!0,format:"compact",extraEntropy:!1},m=c*lr<i.ORDER;function w(p){const g=c>>$t;return p>g}function P(p,g){if(!o.isValidNot0(g))throw new Error(`invalid signature ${p}: out of range 1..Point.Fn.ORDER`);return g}function C(){if(m)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function B(p,g){gn(g);const E=d.signature,x=g==="compact"?E:g==="recovered"?E+1:void 0;return U(p,x)}class D{constructor(g,E,x){k(this,"r");k(this,"s");k(this,"recovery");if(this.r=P("r",g),this.s=P("s",E),x!=null){if(C(),![0,1,2,3].includes(x))throw new Error("invalid recovery id");this.recovery=x}Object.freeze(this)}static fromBytes(g,E=y.format){B(g,E);let x;if(E==="der"){const{r:_,s:A}=St.toSig(U(g));return new D(_,A)}E==="recovered"&&(x=g[0],E="compact",g=g.subarray(1));const I=d.signature/2,T=g.subarray(0,I),S=g.subarray(I,I*2);return new D(o.fromBytes(T),o.fromBytes(S),x)}static fromHex(g,E){return this.fromBytes(R(g),E)}assertRecovery(){const{recovery:g}=this;if(g==null)throw new Error("invalid recovery id: must be present");return g}addRecoveryBit(g){return new D(this.r,this.s,g)}recoverPublicKey(g){const{r:E,s:x}=this,I=this.assertRecovery(),T=I===2||I===3?E+c:E;if(!i.isValid(T))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const S=i.toBytes(T),_=s.fromBytes(rt(hr((I&1)===0),S)),A=o.inv(T),M=q(U(g,void 0,"msgHash")),W=o.create(-M*A),$=o.create(x*A),O=s.BASE.multiplyUnsafe(W).add(_.multiplyUnsafe($));if(O.is0())throw new Error("invalid recovery: point at infinify");return O.assertValidity(),O}hasHighS(){return w(this.s)}toBytes(g=y.format){if(gn(g),g==="der")return R(St.hexFromSig(this));const{r:E,s:x}=this,I=o.toBytes(E),T=o.toBytes(x);return g==="recovered"?(C(),rt(Uint8Array.of(this.assertRecovery()),I,T)):rt(I,T)}toHex(g){return F(this.toBytes(g))}}const j=e.bits2int||function(g){if(g.length>8192)throw new Error("input is too large");const E=ae(g),x=g.length*8-a;return x>0?E>>BigInt(x):E},q=e.bits2int_modN||function(g){return o.create(j(g))},Q=On(a);function H(p){return Uo("num < 2^"+a,p,mt,Q),o.toBytes(p)}function K(p,g){return U(p,void 0,"message"),g?U(t(p),void 0,"prehashed message"):p}function at(p,g,E){const{lowS:x,prehash:I,extraEntropy:T}=rn(E,y);p=K(p,I);const S=q(p),_=o.fromBytes(g);if(!o.isValidNot0(_))throw new Error("invalid private key");const A=[H(_),H(S)];if(T!=null&&T!==!1){const O=T===!0?n(d.secretKey):T;A.push(U(O,void 0,"extraEntropy"))}const M=rt(...A),W=S;function $(O){const V=j(O);if(!o.isValidNot0(V))return;const G=o.inv(V),ct=s.BASE.multiply(V).toAffine(),z=o.create(ct.x);if(z===mt)return;const J=o.create(G*o.create(W+z*_));if(J===mt)return;let cs=(ct.x===z?0:2)|Number(ct.y&$t),as=J;return x&&w(J)&&(as=o.neg(J),cs^=1),new D(z,as,m?void 0:cs)}return{seed:M,k2sig:$}}function nt(p,g,E={}){const{seed:x,k2sig:I}=at(p,g,E);return Fo(t.outputLen,o.BYTES,r)(x,I).toBytes(E.format)}function v(p,g,E,x={}){const{lowS:I,prehash:T,format:S}=rn(x,y);if(E=U(E,void 0,"publicKey"),g=K(g,T),!Bn(p)){const _=p instanceof D?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+_)}B(p,S);try{const _=D.fromBytes(p,S),A=s.fromBytes(E);if(I&&_.hasHighS())return!1;const{r:M,s:W}=_,$=q(g),O=o.inv(W),V=o.create($*O),G=o.create(M*O),ct=s.BASE.multiplyUnsafe(V).add(A.multiplyUnsafe(G));return ct.is0()?!1:o.create(ct.x)===M}catch{return!1}}function b(p,g,E={}){const{prehash:x}=rn(E,y);return g=K(g,x),D.fromBytes(p,"recovered").recoverPublicKey(g).toBytes()}return Object.freeze({keygen:u,getPublicKey:l,getSharedSecret:h,utils:f,lengths:d,Point:s,sign:nt,verify:v,recoverPublicKey:b,Signature:D,hash:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const $e={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},cc={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},ac=BigInt(0),pn=BigInt(2);function uc(s){const t=$e.p,e=BigInt(3),n=BigInt(6),r=BigInt(11),i=BigInt(22),o=BigInt(23),c=BigInt(44),a=BigInt(88),u=s*s*s%t,l=u*u*s%t,h=ut(l,e,t)*l%t,f=ut(h,e,t)*l%t,d=ut(f,pn,t)*u%t,y=ut(d,r,t)*d%t,m=ut(y,i,t)*y%t,w=ut(m,c,t)*m%t,P=ut(w,a,t)*w%t,C=ut(P,c,t)*m%t,B=ut(C,e,t)*l%t,D=ut(B,o,t)*y%t,j=ut(D,n,t)*u%t,q=ut(j,pn,t);if(!Te.eql(Te.sqr(q),s))throw new Error("Cannot find square root");return q}const Te=He($e.p,{sqrt:uc}),Rt=rc($e,{Fp:Te,endo:cc}),L=oc(Rt,Z),_s={};function Ie(s,...t){let e=_s[s];if(e===void 0){const n=Z(Ro(s));e=rt(n,n),_s[s]=e}return Z(rt(e,...t))}const Rn=s=>s.toBytes(!0).slice(1),Dn=s=>s%pn===ac;function yn(s){const{Fn:t,BASE:e}=Rt,n=t.fromBytes(s),r=e.multiply(n);return{scalar:Dn(r.y)?n:t.neg(n),bytes:Rn(r)}}function dr(s){const t=Te;if(!t.isValidNot0(s))throw new Error("invalid x: Fail if x  p");const e=t.create(s*s),n=t.create(e*s+BigInt(7));let r=t.sqrt(n);Dn(r)||(r=t.neg(r));const i=Rt.fromAffine({x:s,y:r});return i.assertValidity(),i}const Jt=ae;function gr(...s){return Rt.Fn.create(Jt(Ie("BIP0340/challenge",...s)))}function xs(s){return yn(s).bytes}function lc(s,t,e=gt(32)){const{Fn:n}=Rt,r=U(s,void 0,"message"),{bytes:i,scalar:o}=yn(t),c=U(e,32,"auxRand"),a=n.toBytes(o^Jt(Ie("BIP0340/aux",c))),u=Ie("BIP0340/nonce",a,i,r),{bytes:l,scalar:h}=yn(u),f=gr(l,i,r),d=new Uint8Array(64);if(d.set(l,0),d.set(n.toBytes(n.create(h+f*o)),32),!pr(d,r,i))throw new Error("sign: Invalid signature produced");return d}function pr(s,t,e){const{Fp:n,Fn:r,BASE:i}=Rt,o=U(s,64,"signature"),c=U(t,void 0,"message"),a=U(e,32,"publicKey");try{const u=dr(Jt(a)),l=Jt(o.subarray(0,32));if(!n.isValidNot0(l))return!1;const h=Jt(o.subarray(32,64));if(!r.isValidNot0(h))return!1;const f=gr(r.toBytes(l),Rn(u),c),d=i.multiplyUnsafe(h).add(u.multiplyUnsafe(r.neg(f))),{x:y,y:m}=d.toAffine();return!(d.is0()||!Dn(m)||y!==l)}catch{return!1}}const ue=(()=>{const e=(n=gt(48))=>ir(n,$e.n);return{keygen:ar(e,xs),getPublicKey:xs,sign:lc,verify:pr,Point:Rt,utils:{randomSecretKey:e,taggedHash:Ie,lift_x:dr,pointToBytes:Rn},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})(),hc=Hs("Secp256k1_HashToCurve_Cashu_");function Qt(s){const t=Z(N.concat(hc,s)),e=new Uint32Array(1),n=2**16;for(let r=0;r<n;r++){const i=new Uint8Array(e.buffer),o=Z(N.concat(t,i));try{return It(F(N.concat(new Uint8Array([2]),o)))}catch{e[0]++}}throw new Error("No valid point found")}function Un(s){const e=s.map(n=>n.toHex(!1)).join("");return Z(new TextEncoder().encode(e))}function fc(s){return L.Point.fromHex(F(s))}function It(s){return L.Point.fromHex(s)}const yr=s=>{let t;return/^[a-fA-F0-9]+$/.test(s)?t=oe(s)%BigInt(2**31-1):t=N.toBigInt(Sn(s))%BigInt(2**31-1),t};function We(){return L.utils.randomSecretKey()}function dc(s,t,e,n){const r=L.Point.Fn.fromBytes(t);return{C_:s.multiply(r),amount:e,id:n}}function gc(s){return mr()}function mr(){const s=F(gt(32)),t=new TextEncoder().encode(s);return te(t)}function te(s,t){const e=Qt(s);t||(t=L.Point.Fn.fromBytes(We()));const n=L.Point.BASE.multiply(t);return{B_:e.add(n),r:t,secret:s}}function wr(s,t,e){return s.subtract(e.multiply(t))}function br(s,t,e,n){const r=n,i=wr(s.C_,t,r);return{id:s.id,amount:s.amount,secret:e,C:i}}const Er=s=>({amount:s.amount,C:s.C.toHex(!0),id:s.id,secret:new TextDecoder().decode(s.secret),witness:JSON.stringify(s.witness)}),pc=s=>({amount:s.amount,C:It(s.C),id:s.id,secret:new TextEncoder().encode(s.secret),witness:s.witness?JSON.parse(s.witness):void 0}),qn=(s,t)=>{const e=Z(new TextEncoder().encode(s)),n=typeof t=="string"?R(t):t,r=ue.sign(e,n);return F(r)},le=(s,t,e,n=!1)=>{try{const r=Z(new TextEncoder().encode(t)),i=e.length===66?e.slice(2):e;return ue.verify(R(s),r,R(i))}catch(r){if(n)throw r}return!1};function Be(s,t,e){return Array.from(new Set(e)).filter(r=>s.some(i=>le(i,t,r)))}const yc=(s,t,e,n=1)=>Be(s,t,e).length>=n,mc=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),kr=Uint8Array.from(new Array(16).fill(0).map((s,t)=>t)),wc=kr.map(s=>(9*s+5)%16),vr=(()=>{const e=[[kr],[wc]];for(let n=0;n<4;n++)for(let r of e)r.push(r[n].map(i=>mc[i]));return e})(),_r=vr[0],xr=vr[1],Sr=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(s=>Uint8Array.from(s)),bc=_r.map((s,t)=>s.map(e=>Sr[t][e])),Ec=xr.map((s,t)=>s.map(e=>Sr[t][e])),kc=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),vc=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function Ss(s,t,e,n){return s===0?t^e^n:s===1?t&e|~t&n:s===2?(t|~e)^n:s===3?t&n|e&~n:t^(e|~n)}const be=new Uint32Array(16);class _c extends Cn{constructor(){super(64,20,8,!0);k(this,"h0",1732584193);k(this,"h1",-271733879);k(this,"h2",-1732584194);k(this,"h3",271733878);k(this,"h4",-1009589776)}get(){const{h0:e,h1:n,h2:r,h3:i,h4:o}=this;return[e,n,r,i,o]}set(e,n,r,i,o){this.h0=e|0,this.h1=n|0,this.h2=r|0,this.h3=i|0,this.h4=o|0}process(e,n){for(let y=0;y<16;y++,n+=4)be[y]=e.getUint32(n,!0);let r=this.h0|0,i=r,o=this.h1|0,c=o,a=this.h2|0,u=a,l=this.h3|0,h=l,f=this.h4|0,d=f;for(let y=0;y<5;y++){const m=4-y,w=kc[y],P=vc[y],C=_r[y],B=xr[y],D=bc[y],j=Ec[y];for(let q=0;q<16;q++){const Q=de(r+Ss(y,o,a,l)+be[C[q]]+w,D[q])+f|0;r=f,f=l,l=de(a,10)|0,a=o,o=Q}for(let q=0;q<16;q++){const Q=de(i+Ss(m,c,u,h)+be[B[q]]+P,j[q])+d|0;i=d,d=h,h=de(u,10)|0,u=c,c=Q}}this.set(this.h1+a+h|0,this.h2+l+d|0,this.h3+f+i|0,this.h4+r+c|0,this.h0+o+u|0)}roundClean(){Tt(be)}destroy(){this.destroyed=!0,Tt(this.buffer),this.set(0,0,0,0,0)}}const xc=Mn(()=>new _c);/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */const Xt=L.Point,{Fn:Yt}=Xt,on=Et.createBase58check(Z),Sc=Uint8Array.from("Bitcoin seed".split(""),s=>s.charCodeAt(0)),cn={private:76066276,public:76067358},an=2147483648,Ac=s=>xc(Z(s)),Pc=s=>Ht(s).getUint32(0,!1),Ee=s=>{if(!Number.isSafeInteger(s)||s<0||s>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+s);const t=new Uint8Array(4);return Ht(t).setUint32(0,s,!1),t};class At{constructor(t){k(this,"versions");k(this,"depth",0);k(this,"index",0);k(this,"chainCode",null);k(this,"parentFingerprint",0);k(this,"_privateKey");k(this,"_publicKey");k(this,"pubHash");if(!t||typeof t!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=t.versions||cn,this.depth=t.depth||0,this.chainCode=t.chainCode||null,this.index=t.index||0,this.parentFingerprint=t.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(this.depth>255)throw new Error("HDKey: depth exceeds the serializable value 255");if(t.publicKey&&t.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(t.privateKey){if(!L.utils.isValidSecretKey(t.privateKey))throw new Error("Invalid private key");this._privateKey=t.privateKey,this._publicKey=L.getPublicKey(t.privateKey,!0)}else if(t.publicKey)this._publicKey=Xt.fromBytes(t.publicKey).toBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=Ac(this._publicKey)}get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return Pc(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this._privateKey||null}get publicKey(){return this._publicKey||null}get privateExtendedKey(){const t=this._privateKey;if(!t)throw new Error("No private key");return on.encode(this.serialize(this.versions.private,rt(Uint8Array.of(0),t)))}get publicExtendedKey(){if(!this._publicKey)throw new Error("No public key");return on.encode(this.serialize(this.versions.public,this._publicKey))}static fromMasterSeed(t,e=cn){if(U(t),8*t.length<128||8*t.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+t.length);const n=ne(gs,Sc,t),r=n.slice(0,32),i=n.slice(32);return new At({versions:e,chainCode:i,privateKey:r})}static fromExtendedKey(t,e=cn){const n=on.decode(t),r=Ht(n),i=r.getUint32(0,!1),o={versions:e,depth:n[4],parentFingerprint:r.getUint32(5,!1),index:r.getUint32(9,!1),chainCode:n.slice(13,45)},c=n.slice(45),a=c[0]===0;if(i!==e[a?"private":"public"])throw new Error("Version mismatch");return a?new At({...o,privateKey:c.slice(1)}):new At({...o,publicKey:c})}static fromJSON(t){return At.fromExtendedKey(t.xpriv)}derive(t){if(!/^[mM]'?/.test(t))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(t))return this;const e=t.replace(/^[mM]'?\//,"").split("/");let n=this;for(const r of e){const i=/^(\d+)('?)$/.exec(r),o=i&&i[1];if(!i||i.length!==3||typeof o!="string")throw new Error("invalid child index: "+r);let c=+o;if(!Number.isSafeInteger(c)||c>=an)throw new Error("Invalid index");i[2]==="'"&&(c+=an),n=n.deriveChild(c)}return n}deriveChild(t){if(!this._publicKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let e=Ee(t);if(t>=an){const a=this._privateKey;if(!a)throw new Error("Could not derive hardened child key");e=rt(Uint8Array.of(0),a,e)}else e=rt(this._publicKey,e);const n=ne(gs,this.chainCode,e),r=n.slice(0,32),i=n.slice(32);if(!L.utils.isValidSecretKey(r))throw new Error("Tweak bigger than curve order");const o={versions:this.versions,chainCode:i,depth:this.depth+1,parentFingerprint:this.fingerprint,index:t},c=Yt.fromBytes(r);try{if(this._privateKey){const a=Yt.create(Yt.fromBytes(this._privateKey)+c);if(!Yt.isValidNot0(a))throw new Error("The tweak was out of range or the resulted private key is invalid");o.privateKey=Yt.toBytes(a)}else{const a=Xt.fromBytes(this._publicKey).add(Xt.BASE.multiply(c));if(a.equals(Xt.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");o.publicKey=a.toBytes(!0)}return new At(o)}catch{return this.deriveChild(t+1)}}sign(t){if(!this._privateKey)throw new Error("No privateKey set!");return U(t,32),L.sign(t,this._privateKey,{prehash:!1})}verify(t,e){if(U(t,32),U(e,64),!this._publicKey)throw new Error("No publicKey set!");return L.verify(e,t,this._publicKey,{prehash:!1})}wipePrivateData(){return this._privateKey&&(this._privateKey.fill(0),this._privateKey=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(t,e){if(!this.chainCode)throw new Error("No chainCode set");return U(e,33),rt(Ee(t),new Uint8Array([this.depth]),Ee(this.parentFingerprint),Ee(this.index),this.chainCode,e)}}const As="m/0'/0'/0'";function Ar(s){const t={};return Object.keys(s).forEach(e=>{t[e]=F(s[e])}),t}function Tc(s){const t={};return Object.keys(s).forEach(e=>{t[e]=R(s[e])}),t}function Pr(s){return L.getPublicKey(s,!0)}function Ic(s,t,e){const{expiry:n,input_fee_ppk:r,unit:i="sat",versionByte:o=1}=e||{};let c=0n;const a={},u={};let l;for(t&&(l=At.fromMasterSeed(t));c<s;){const f=(2n**c).toString();if(l){const d=l.derive(`${As}/${c}`).privateKey;if(d)u[f]=d;else throw new Error(`Could not derive Private key from: ${As}/${c}`)}else u[f]=We();a[f]=Pr(u[f]),c++}const h=Ye(Ar(a),{expiry:n,input_fee_ppk:r,unit:i,versionByte:o});return{pubKeys:a,privKeys:u,keysetId:h}}function Bc(s,t){const e=Qt(s.secret),n=L.Point.Fn.fromBytes(t);return e.multiply(n).equals(s.C)}function Fn(s,t,e){const n=[s,{nonce:F(gt(32)),data:t,tags:e}];return JSON.stringify(n)}function he(s){let t;try{typeof s=="string"?t=JSON.parse(s):t=s}catch{throw new Error("Can't parse secret")}if(!Array.isArray(t)||t.length!==2||typeof t[0]!="string"||typeof t[1]!="object"||t[0].trim().length===0||t[1]===null)throw new Error("Invalid NUT-10 secret");const[e,n]=t;if(typeof n.nonce!="string"||typeof n.data!="string")throw new Error("Invalid NUT-10 secret nonce / data");if(n.tags){if(!Array.isArray(n.tags))throw new Error("Invalid NUT-10 secret tags");if(n.tags.some(i=>!Array.isArray(i)||i.length===0||i.some(o=>typeof o!="string"||!o.length)))throw new Error("Invalid NUT-10 tag(s)")}return[e,{nonce:n.nonce,data:n.data,tags:n.tags}]}function Hn(s,t){const e=Array.isArray(s)?s:[s],n=he(t),r=n[0];if(!e.includes(r))throw new Error(`Invalid secret kind: ${r} Allowed: ${e.join(", ")}`);return n}function $n(s){return he(s)[0]}function Wn(s){return he(s)[1]}function jn(s){const{data:t}=Wn(s);return t}function Vn(s){const{tags:t}=Wn(s);return t??[]}function Mc(s,t){return Vn(s).some(e=>e[0]===t)}function je(s,t){const e=Vn(s).find(n=>n[0]===t);if(!(!e||e.length<=1))return e.slice(1)}function Gn(s,t){const e=je(s,t);return e&&e.length>0?e[0]:void 0}function Ve(s,t){const e=Gn(s,t);if(e===void 0)return;const n=Number.parseInt(e,10);return Number.isFinite(n)?n:void 0}const mn=Hs("Cashu_P2BK_v1");function Tr(s,t,e){if(!s.length)return{blinded:[],Ehex:""};e=e??L.utils.randomSecretKey();const n=L.Point.Fn.fromBytes(e),r=L.getPublicKey(e,!0),i=R(t);return{blinded:s.map((c,a)=>{const u=It(c),l=Mr(u,n,i,a),h=u.add(L.Point.BASE.multiply(l));if(h.equals(L.Point.ZERO))throw new Error("Blinded key at infinity");return h.toHex(!0)}),Ehex:F(r)}}function Ir(s,t,e,n){const r=Array.isArray(t)?t:[t],i=Array.isArray(e)?e:[e],o=new Set,c=L.Point.fromHex(s),a=R(n);for(const u of r){const l=L.Point.Fn.fromBytes(R(u)),h=L.getPublicKey(R(u),!0);i.forEach((f,d)=>{const y=Mr(c,l,a,d),m=R(f),w=Br(u,y,m,h);w&&o.add(w)})}return Array.from(o)}function Br(s,t,e,n){const r=L.Point.CURVE().n,i=typeof s=="string"?oe(s):s,o=typeof t=="string"?oe(t):t;if(i<=0n||i>=r)throw new Error("Invalid private key");if(o<=0n||o>=r)throw new Error("Invalid scalar r");if(n=n??L.Point.BASE.multiply(i).toBytes(!0),n.length!==33)throw new Error("naturalPub must be 33 bytes");const c=(i+o)%r,a=(r-i+o)%r;if(!e){if(c===0n)throw new Error("Derived secret key is zero");return Ke(c)}if(e.length!==33)throw new Error("blindPubkey must be 33 bytes");const u=L.Point.fromHex(F(e)),l=L.Point.BASE.multiply(o),h=u.subtract(l);if(h.equals(L.Point.ZERO))return null;const f=h.toBytes(!0).slice(1),d=n.slice(1);if(!N.equals(f,d))return null;const y=h.toBytes(!0)[0]&1,m=n[0]&1,w=y===m?c:a;if(w===0n)throw new Error("Derived secret key is zero");return Ke(w)}function Mr(s,t,e,n){const r=s.multiply(t).toBytes(!0).slice(1),i=new Uint8Array([n&255]);let o=N.toBigInt(Z(N.concat(mn,r,e,i)));if((o===0n||o>=L.Point.CURVE().n)&&(o=N.toBigInt(Z(N.concat(mn,r,e,i,new Uint8Array([255])))),o===0n||o>=L.Point.CURVE().n))throw new Error("P2BK: tweak derivation failed");return o}function Cc(s,t){return Fn("P2PK",s,t)}function ot(s){return s instanceof Uint8Array&&(s=new TextDecoder().decode(s)),Hn(["P2PK","HTLC"],s)}function zn(s){try{const t=ot(s),e=fe(t),n=Ge(t),r=Zt(t);if(e==="ACTIVE"||e==="PERMANENT")return n;if(e==="EXPIRED"&&r.length){const i=[...n,...r];return Array.from(new Set(i))}}catch{}return[]}function Ge(s){const t=ot(s);let e="";$n(t)==="P2PK"&&(e=jn(t));const n=je(t,"pubkeys")??[],r=[e,...n].filter(Boolean);return Array.from(new Set(r))}function Zt(s){const t=ot(s);return je(t,"refund")??[]}function Cr(s){const t=ot(s),e=Ve(t,"locktime");return e===void 0||!Number.isFinite(e)||e<=0?1/0:e}function fe(s,t=Math.floor(Date.now()/1e3)){const e=ot(s),n=Cr(e);return Number.isFinite(n)?t<n?"ACTIVE":"EXPIRED":"PERMANENT"}function Kr(s){const t=ot(s),e=fe(t);return!Zt(t).length&&e==="EXPIRED"?0:Ve(t,"n_sigs")??1}function Or(s){const t=ot(s),e=fe(t);return Zt(t).length&&e==="EXPIRED"?Ve(t,"n_sigs_refund")??1:0}function Me(s){const t=ot(s);return Gn(t,"sigflag")==="SIG_ALL"?"SIG_ALL":"SIG_INPUTS"}function ze(s){return Lr(s)?.signatures??[]}function Lr(s){if(!s)return;let t;try{t=typeof s=="string"?JSON.parse(s):s}catch(n){console.error("Failed to parse witness string:",n);return}const e={signatures:t.signatures??[]};return typeof t.preimage=="string"&&t.preimage.length>0&&(e.preimage=t.preimage),e}function wn(s,t,e=X,n){const r=o=>typeof o=="string"?o:F(o),i=Array.isArray(t)?t.map(r):r(t);return s.map((o,c)=>{const a=Dr(i,o);let u=o;for(const l of a)try{u=Nr(u,l,n)}catch(h){const f=h instanceof Error?h.message:"Unknown error";e.warn(`Proof #${c+1}: ${f}`)}return u})}function Nr(s,t,e){const n=ot(s.secret);e=e??s.secret;const r=typeof t=="string"?R(t):t,i=F(ue.getPublicKey(r)),o=zn(n);if(!o.length||!o.some(f=>f.includes(i)))throw new Error(`Signature not required from [02|03]${i}`);if(ze(s.witness).some(f=>le(f,e,i)))throw new Error(`Proof already signed by [02|03]${i}`);const u=qn(e,t),l=Lr(s.witness),h={...l&&l.preimage!==void 0?{preimage:l.preimage}:{},signatures:[...l?.signatures??[],u]};return{...s,witness:h}}function Kc(s,t,e){if(!t.witness)return!1;if(se([t])&&!e)throw new Error("Cannot verify a SIG_ALL proof without the message to sign");return e=e??t.secret,ze(t.witness).some(r=>le(r,e,s))}function Qn(s,t=X,e){if(se([s])&&!e)throw t.error("Cannot verify a SIG_ALL proof without the message to sign"),new Error("Cannot verify a SIG_ALL proof without the message to sign");e=e??s.secret;const n=ot(s.secret),r=ze(s.witness),i=fe(n),o=Ge(n),c=Kr(n),a=Be(r,e,o),u={success:!0,path:"MAIN",lockState:i,requiredSigners:c,eligibleSigners:o.length,receivedSigners:a};let l=u;if(o.length&&c>0&&a.length>=c)return t.debug("Spending condition satisfied via main pubkeys",{result:l}),l;if(i!=="EXPIRED")return l={...u,success:!1,path:"FAILED"},t.debug("P2PK lock enabled, but threshold not met by main pubkeys",{result:l}),l;t.debug("P2PK lock expired. Checking refund path.",{lockState:i});const h=Zt(n);if(h.length){const f=Or(n),d=Be(r,e,h),y={...u,path:"REFUND",requiredSigners:f,eligibleSigners:h.length,receivedSigners:d};return f>0&&d.length>=f?(l=y,t.debug("Spending condition satisfied via refund pubkeys",{result:l}),l):(l={...y,success:!1,path:"FAILED"},t.debug("Spending threshold not met by refund pubkeys",{result:l}),l)}return l={...u,path:"UNLOCKED"},t.debug("No refund pubkeys, anyone can spend.",{result:l}),l}function Rr(s,t=X,e){return Qn(s,t,e).success}function Dr(s,t){const e=Array.isArray(s)?s:[s],n=t?.p2pk_e;if(!n)return Array.from(new Set(e));const r=ot(t.secret),i=[...Ge(r),...Zt(r)],o=t.id;return Ir(n,e,i,o)}function Ur(s){if(s.length===0)throw new Error("No proofs");const t=ot(s[0].secret);if(Me(t)!=="SIG_ALL")throw new Error("First proof is not SIG_ALL");const e=t[1].data,n=JSON.stringify(t[1].tags??[]);for(let r=1;r<s.length;r++){const i=ot(s[r].secret);if(i[0]!==t[0])throw new Error(`Proof #${r+1} is not ${t[0]}`);if(Me(i)!=="SIG_ALL")throw new Error(`Proof #${r+1} is not SIG_ALL`);if(i[1].data!==e)throw new Error("SIG_ALL inputs must share identical Secret.data");if(JSON.stringify(i[1].tags??[])!==n)throw new Error("SIG_ALL inputs must share identical Secret.tags")}}function qr(s,t,e){const n=[];for(const r of s)n.push(r.secret,r.C);for(const r of t)n.push(String(r.blindedMessage.amount),r.blindedMessage.B_);return e&&n.push(e),n.join("")}function se(s){return s.some(t=>{try{return Me(t.secret)==="SIG_ALL"}catch{return!1}})}function Fr(s,t,e){const n=[];for(const r of s)n.push(r.secret,r.C);for(const r of t)n.push(String(r.blindedMessage.amount),r.blindedMessage.id,r.blindedMessage.B_);return e&&n.push(e),n.join("")}function Hr(s,t,e){const n=[];for(const r of s)n.push(r.secret);for(const r of t)n.push(r.blindedMessage.B_);return e&&n.push(e),n.join("")}const Oc=(s,t)=>qn(s,t),Lc=(s,t,e)=>le(s,t,e);function Nc(s){return zn(s)}function Rc(s){return Rr(s)}function Dc(s,t){if(s.length!==t.length)return!1;for(let e=0;e<s.length;e++)if(s[e]!==t[e])return!1;return!0}const $r=(s,t,e,n)=>{const r=L.Point.Fn.fromBytes(s.s),i=L.Point.Fn.fromBytes(s.e),o=L.Point.BASE.multiply(r),c=n.multiply(i),a=t.multiply(r),u=e.multiply(i),l=o.subtract(c),h=a.subtract(u),f=Un([l,h,n,e]);return Dc(f,s.e)},Wr=(s,t,e,n)=>{if(t.r===void 0)throw new Error("verifyDLEQProof_reblind: Undefined blinding factor");const r=Qt(s),i=e.add(n.multiply(t.r)),o=L.Point.BASE.multiply(t.r),c=r.add(o);return $r(t,c,i,n)},Uc=(s,t)=>{const e=L.Point.Fn.fromBytes(We()),n=L.Point.BASE.multiply(e),r=s.multiply(e),i=L.Point.Fn.fromBytes(t),o=s.multiply(i),c=L.Point.BASE.multiply(i),a=Un([n,r,c,o]),u=L.Point.Fn.fromBytes(a),l=L.Point.Fn.add(e,L.Point.Fn.mul(u,i));return{s:Fe(l,32),e:a}},qc="m/129372'/0'",Ps=BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141"),jr=(s,t,e)=>{const n=/^[a-fA-F0-9]+$/.test(t);if(!n&&qe(t)||n&&t.startsWith("00"))return Ce(s,t,e,0);if(n&&t.startsWith("01"))return Gr(s,t,e,0);throw new Error(`Unrecognized keyset ID version ${t.slice(0,2)}`)},Vr=(s,t,e)=>{const n=/^[a-fA-F0-9]+$/.test(t);if(!n&&qe(t)||n&&t.startsWith("00"))return Ce(s,t,e,1);if(n&&t.startsWith("01"))return Gr(s,t,e,1);throw new Error(`Unrecognized keyset ID version ${t.slice(0,2)}`)},Gr=(s,t,e,n)=>{let r=N.concat(N.fromString("Cashu_KDF_HMAC_SHA256"),N.fromHex(t),N.writeBigUint64BE(BigInt(e)));switch(n){case 0:r=N.concat(r,N.fromHex("00"));break;case 1:r=N.concat(r,N.fromHex("01"))}const i=ne(Z,s,r);if(n===1){const o=N.toBigInt(i);if(o>=Ps)return N.fromBigInt(o-Ps);if(o===0n)throw new Error("Derived invalid blinding scalar r == 0");return i}return i},Ce=(s,t,e,n)=>{const r=At.fromMasterSeed(s),i=yr(t),o=`${qc}/${i}'/${e}'/${n}`,c=r.derive(o);if(c.privateKey===null)throw new Error("Could not derive private key");return c.privateKey};function Fc(s,t){return Fn("HTLC",s,t)}function Hc(s){return Hn("HTLC",s)}function zr(s){const t=s!==void 0;if(t&&!/^[0-9a-f]{64}$/i.test(s))throw new Error("Preimage must be a 64 character hexadecimal string (32 bytes).");const e=t?R(s):gt(32);return{hash:F(Z(e)),preimage:F(e)}}function Qr(s,t){const{hash:e}=zr(s);return t===e}function Zr(s,t=X,e){let n;e=e??s.secret;const r=he(s.secret),i=Qn(s,t,e);if(i.path!="MAIN"||$n(r)!=="HTLC")return i;const o=Yr(s.witness);if(!o)return n={...i,success:!1,path:"FAILED"},t.debug("Hashlock spend failed, no preimage found",{result:n}),n;const c=jn(r);return Qr(o,c)?(n=i,t.debug("Spending condition satisfied via hashlock (receiver) pathway",{result:n}),n):(n={...i,success:!1,path:"FAILED"},t.debug("Hashlock spend failed, wrong preimage for hash",{result:n}),n)}function $c(s,t=X,e){return Zr(s,t,e).success}function Yr(s){if(!s)return;let t;try{t=typeof s=="string"?JSON.parse(s):s}catch(n){console.error("Failed to parse HTLC witness string:",n);return}const e=t.preimage;return typeof e=="string"&&e.length>0?e:void 0}function Xr(s,t){let e=s;for(const r of t)e+=r.B_;const n=new TextEncoder().encode(e);return Z(n)}function Jr(s,t,e){const n=Xr(t,e),r=R(s),i=ue.sign(n,r);return F(i)}function Wc(s,t,e,n){const r=R(n);let i=R(s);if(i.length!==33)return!1;i=i.slice(1);const o=Xr(t,e);return ue.verify(r,o,i)}var re=(s=>(s.POST="post",s.NOSTR="nostr",s))(re||{});const ti=1,ei=2,bn=3,ni=4,si=5,ri=6,ii=7,oi=8,ci=1,ai=2,ui=3,Zn=0,li=1,hi=1,fi=2,di=3,gi=0,pi=1;function jc(s){const t=Yn(s),e={};for(const n of t)switch(n.tag){case ti:e.id=Ot(n.value);break;case ei:e.amount=Gc(n.value);break;case bn:n.value.length===1&&n.value[0]===0?e.unit="sat":e.unit=Ot(n.value);break;case ni:e.singleUse=Xn(n.value)===1;break;case si:e.mints||(e.mints=[]),e.mints.push(Ot(n.value));break;case ri:e.description=Ot(n.value);break;case ii:e.transports||(e.transports=[]),e.transports.push(Zc(n.value));break;case oi:e.nut10||(e.nut10=[]),e.nut10.push(Yc(n.value));break}return e}function Yn(s){const t=[];let e=0;for(;e<s.length;){const n=Vc(s.subarray(e));t.push(n),e+=3+n.length}return t}function Vc(s){if(s.length<3)throw new Error("TLV data too short: need at least 3 bytes for tag and length");const t=new DataView(s.buffer,s.byteOffset,s.byteLength),e=t.getUint8(0),n=t.getUint16(1,!1);if(s.length<3+n)throw new Error(`TLV data too short: expected ${3+n} bytes, got ${s.length}`);const r=s.subarray(3,3+n);return{tag:e,length:n,value:r}}function Ot(s){return new TextDecoder().decode(s)}function Gc(s){if(s.length!==8)throw new Error(`Invalid u64: expected 8 bytes, got ${s.length}`);return new DataView(s.buffer,s.byteOffset,s.byteLength).getBigUint64(0,!1)}function Xn(s){if(s.length!==1)throw new Error(`Invalid u8: expected 1 byte, got ${s.length}`);return s[0]}function zc(s){switch(s){case Zn:return"nostr";case li:return"post";default:throw new Error(`Unsupported transport kind: ${s}`)}}function Qc(s){switch(s){case gi:return"P2PK";case pi:return"HTLC";default:throw new Error(`Unsupported NUT-10 kind: ${s}`)}}function Zc(s){const t=Yn(s);let e,n,r;for(const c of t)switch(c.tag){case ci:e=Xn(c.value);break;case ai:n=c.value;break;case ui:r||(r=[]),r.push(yi(c.value));break}if(e===void 0)throw new Error("Transport missing required kind field");if(n===void 0)throw new Error("Transport missing required target field");let i;if(e===Zn){const c=r?.filter(a=>a[0]==="r").flatMap(a=>a.slice(1))??[];i=ia(n,c),r=r?.filter(a=>a[0]!=="r")}else i=Ot(n);const o=r&&r.length>0?r:void 0;return{type:zc(e),target:i,tags:o}}function Yc(s){const t=Yn(s);let e,n,r;for(const o of t)switch(o.tag){case hi:e=Xn(o.value);break;case fi:n=Ot(o.value);break;case di:r||(r=[]),r.push(yi(o.value));break}if(e===void 0)throw new Error("NUT-10 spending condition missing required kind field");if(n===void 0)throw new Error("NUT-10 spending condition missing required data field");const i=r&&r.length>0?r:void 0;return{kind:Qc(e),data:n,tags:i}}function yi(s){const t=[];let e=0;for(;e<s.length;){const n=s[e];if(e+=1,s.length-e<n)throw new Error(`Tag tuple data too short: expected ${n} bytes, got ${s.length-e}`);const r=Ot(s.subarray(e,e+n));t.push(r),e+=n}return t}function Xc(s){const t=[];if(s.id&&t.push(tt(ti,qt(s.id))),s.amount!==void 0&&t.push(tt(ei,Jc(s.amount))),s.unit&&(s.unit==="sat"?t.push(tt(bn,new Uint8Array([0]))):t.push(tt(bn,qt(s.unit)))),s.singleUse!==void 0&&t.push(tt(ni,Jn(s.singleUse?1:0))),s.mints&&s.mints.length>0)for(const i of s.mints)t.push(tt(si,qt(i)));if(s.description&&t.push(tt(ri,qt(s.description))),s.transports&&s.transports.length>0)for(const i of s.transports)t.push(tt(ii,na(i)));if(s.nut10&&s.nut10.length>0)for(const i of s.nut10)t.push(tt(oi,sa(i)));const e=t.reduce((i,o)=>i+o.length,0),n=new Uint8Array(e);let r=0;for(const i of t)n.set(i,r),r+=i.length;return n}function tt(s,t){const e=t.length;if(e>65535)throw new Error(`TLV value too long: ${e} bytes (max 65535)`);const n=new Uint8Array(3+e);return n[0]=s,n[1]=e>>8&255,n[2]=e&255,n.set(t,3),n}function qt(s){return new TextEncoder().encode(s)}function Jc(s){const t=new ArrayBuffer(8);return new DataView(t).setBigUint64(0,s,!1),new Uint8Array(t)}function Jn(s){return new Uint8Array([s])}function ta(s){switch(s){case re.NOSTR:return Zn;case re.POST:return li;default:throw new Error(`Unsupported transport type: ${s}`)}}function ea(s){switch(s){case"P2PK":return gi;case"HTLC":return pi;default:throw new Error(`Unsupported NUT-10 type: ${s}`)}}function na(s){const t=[],e=ta(s.type);t.push(tt(ci,Jn(e)));let n,r=[];if(s.type===re.NOSTR){const{pubkey:u,relays:l}=ra(s.target);n=u,r=l.map(h=>["r",h])}else n=qt(s.target);t.push(tt(ai,n));const i=[...r,...s.tags||[]];if(i.length>0)for(const u of i)t.push(tt(ui,mi(u)));const o=t.reduce((u,l)=>u+l.length,0),c=new Uint8Array(o);let a=0;for(const u of t)c.set(u,a),a+=u.length;return c}function sa(s){const t=[],e=ea(s.kind);if(t.push(tt(hi,Jn(e))),t.push(tt(fi,qt(s.data))),s.tags&&s.tags.length>0)for(const o of s.tags)t.push(tt(di,mi(o)));const n=t.reduce((o,c)=>o+c.length,0),r=new Uint8Array(n);let i=0;for(const o of t)r.set(o,i),i+=o.length;return r}function mi(s){const t=new TextEncoder,e=[];for(const o of s){const c=t.encode(o);if(c.length>255)throw new Error(`Tag tuple string too long: ${o} (max 255 bytes)`);const a=new Uint8Array(1+c.length);a[0]=c.length,a.set(c,1),e.push(a)}const n=e.reduce((o,c)=>o+c.length,0),r=new Uint8Array(n);let i=0;for(const o of e)r.set(o,i),i+=o.length;return r}function ra(s){const t=Et.bech32.decode(s,1024);if(t.prefix!=="nprofile")throw new Error(`Invalid nprofile: expected prefix 'nprofile', got '${t.prefix}'`);const e=Et.bech32.fromWords(t.words),n=new Uint8Array(e);let r;const i=[];let o=0;for(;o<n.length;){if(o+2>n.length)throw new Error("Nprofile TLV data too short");const c=n[o],a=n[o+1];if(o+=2,o+a>n.length)throw new Error(`Nprofile TLV value too short: expected ${a} bytes`);const u=n.subarray(o,o+a);if(o+=a,c===0){if(u.length!==32)throw new Error(`Invalid pubkey length: expected 32 bytes, got ${u.length}`);r=u}else c===1&&i.push(new TextDecoder().decode(u))}if(!r)throw new Error("Nprofile missing required pubkey");return{pubkey:r,relays:i}}function ia(s,t){const e=oa(s,t),n=Et.bech32.toWords(e);return Et.bech32.encode("nprofile",n,1024)}function oa(s,t){if(s.length!==32)throw new Error(`Invalid pubkey: expected 32 bytes, got ${s.length}`);const e=new TextEncoder,n=t.map(c=>e.encode(c));for(let c=0;c<n.length;c++)if(n[c].length>255)throw new Error(`Relay URL too long: ${t[c]} (max 255 bytes)`);const r=34+n.reduce((c,a)=>c+2+a.length,0),i=new Uint8Array(r);let o=0;i[o++]=0,i[o++]=32,i.set(s,o),o+=32;for(const c of n)i[o++]=1,i[o++]=c.length,i.set(c,o),o+=c.length;return i}class ie{constructor(t,e,n,r,i,o,c=!1,a,u=!1){this.transport=t,this.id=e,this.amount=n,this.unit=r,this.mints=i,this.description=o,this.singleUse=c,this.nut10=a,this.nut26=u}toRawRequest(){const t={};return this.transport&&(t.t=this.transport.map(e=>({t:e.type,a:e.target,g:e.tags}))),this.id&&(t.i=this.id),this.amount&&(t.a=this.amount),this.unit&&(t.u=this.unit),this.mints&&(t.m=this.mints),this.description&&(t.d=this.description),this.singleUse&&(t.s=this.singleUse),this.nut10&&(t.nut10={k:this.nut10.kind,d:this.nut10.data,t:this.nut10.tags}),this.nut26&&(t.nut26=this.nut26),t}toEncodedRequest(){const t=this.toRawRequest(),e=Pn(t);return"creqA"+N.toBase64(e)}toEncodedCreqA(){return this.toEncodedRequest()}toEncodedCreqB(){const t={id:this.id,amount:this.amount!==void 0?BigInt(this.amount):void 0,unit:this.unit,singleUse:this.singleUse,mints:this.mints,description:this.description,transports:this.transport,nut10:this.nut10?[{kind:this.nut10.kind,data:this.nut10.data,tags:this.nut10.tags}]:void 0},e=Xc(t);return Yi("creqb",e).toUpperCase()}getTransport(t){return this.transport?.find(e=>e.type===t)}static fromRawRequest(t){const e=t.t?t.t.map(r=>({type:r.t,target:r.a,tags:r.g})):void 0,n=t.nut10?{kind:t.nut10.k,data:t.nut10.d,tags:t.nut10.t}:void 0;return new ie(e,t.i,t.a,t.u,t.m,t.d,t.s,n,t.nut26)}static fromEncodedRequest(t){const e=t.toLowerCase();if(e.startsWith("creqb")){const c=Ji(e),a=jc(c);return new ie(a.transports,a.id,a.amount!==void 0?Number(a.amount):void 0,a.unit,a.mints,a.description,a.singleUse??!1,void 0,!1)}if(!t.startsWith("creq"))throw new Error("unsupported pr: invalid prefix");if(t[4]!=="A")throw new Error("unsupported pr version");const r=t.slice(5),i=Sn(r),o=In(i);return this.fromRawRequest(o)}}function wt(s,t,e,n){if(e){const i=Ts(e);if(s===0&&i===0)return e;const o=e.filter(a=>a>0),c=Ts(o);if(c>s)throw new Error(`Split is greater than total amount: ${c} > ${s}`);if(o.some(a=>!es(a,t)))throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");if(c===s)return o;e=o,s-=c}else e=[];const r=ts(t,"desc");if(!r||r.length===0)throw new Error("Cannot split amount, keyset is inactive or contains no keys");for(const i of r){if(i<=0)continue;const o=Math.floor(s/i);if(e.push(...Array(o).fill(i)),s-=i*o,s===0)break}if(s!==0)throw new Error(`Unable to split remaining amount: ${s}`);return n?e.sort((i,o)=>n==="desc"?o-i:i-o):e}function wi(s,t,e,n){const r=[],i=s.map(a=>a.amount);ts(e,"asc").forEach(a=>{const u=i.filter(h=>h===a).length,l=Math.max(n-u,0);for(let h=0;h<l&&!(r.reduce((f,d)=>f+d,0)+a>t);++h)r.push(a)});const c=t-r.reduce((a,u)=>a+u,0);return c&&wt(c,e).forEach(u=>{r.push(u)}),r.sort((a,u)=>a-u)}function ts(s,t="desc"){return t=="desc"?Object.keys(s).map(e=>parseInt(e)).sort((e,n)=>n-e):Object.keys(s).map(e=>parseInt(e)).sort((e,n)=>e-n)}function es(s,t){return s in t}function ca(s){return N.toBigInt(s)}function oe(s){return BigInt(`0x${s}`)}function Ke(s){return s.toString(16).padStart(64,"0")}function Lt(s){return/^[a-f0-9]*$/i.test(s)}function Qe(s){return Array.isArray(s)?s.some(t=>!Lt(t.id)):!Lt(s.id)}function aa(s,t){return typeof t=="bigint"?t.toString():t}function bi(s,t){Qe(s.proofs)||(s.proofs=Ei(s.proofs)),t&&(s.proofs=rs(s.proofs));const e={token:[{mint:s.mint,proofs:s.proofs}]};return s.unit&&(e.unit=s.unit),s.memo&&(e.memo=s.memo),"cashu"+"A"+Ds(e)}function Ei(s){return s.map(t=>{const e={...t};return e.id=e.id.slice(0,16),e})}function ua(s,t){if(Qe(s.proofs)||t?.version===3){if(t?.version===4)throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");return bi(s,t?.removeDleq)}return ki(s,t?.removeDleq)}function ki(s,t){if(t&&(s.proofs=rs(s.proofs)),s.proofs.forEach(a=>{if(a.dleq&&a.dleq.r==null)throw new Error("Missing blinding factor in included DLEQ proof")}),Qe(s.proofs))throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");s.proofs=Ei(s.proofs);const n=vi(s),r=Pn(n),i="cashu",o="B",c=fn(r);return i+o+c}function vi(s){const t={},e=s.mint;for(let r=0;r<s.proofs.length;r++){const i=s.proofs[r];t[i.id]?t[i.id].push(i):t[i.id]=[i]}const n={m:e,u:s.unit||"sat",t:Object.keys(t).map(r=>({i:R(r),p:t[r].map(i=>({a:i.amount,s:i.secret,c:R(i.C),...i.dleq&&{d:{e:R(i.dleq.e),s:R(i.dleq.s),r:R(i.dleq.r??"00")}},...i.p2pk_e&&{pe:R(i.p2pk_e)},...i.witness&&{w:JSON.stringify(i.witness)}}))}))};return s.memo&&(n.d=s.memo),n}function Ze(s,t=!1){if(typeof s!="number"||!Number.isFinite(s)||!Number.isInteger(s))throw new Error(`Invalid amount: ${String(s)}`);if(!Number.isSafeInteger(s))throw new Error(`Amount must be a safe integer: ${s}`);if(t?s<0:s<=0)throw new Error(`Amount must be ${t?"non-negative":"positive"}: ${s}`)}function _i(s){const t=[];s.t.forEach(n=>n.p.forEach(r=>{Ze(r.a,!0),t.push({secret:r.s,C:F(r.c),amount:r.a,id:F(n.i),...r.d&&{dleq:{r:F(r.d.r),s:F(r.d.s),e:F(r.d.e)}},...r.pe&&{p2pk_e:F(r.pe)},...r.w&&{witness:r.w}})}));const e={mint:s.m,proofs:t,unit:s.u||"sat"};return s.d&&(e.memo=s.d),e}function xi(s,t){const e=(t??[]).map(i=>typeof i=="string"?i:i.id),n=Ti(s),r=ns(n);return r.proofs=pa(r.proofs,e),r}function la(s){s=Ti(s);const t=ns(s);return{unit:t.unit||"sat",mint:t.mint,amount:Mt(t.proofs),...t.memo&&{memo:t.memo},incompleteProofs:t.proofs.map(e=>({secret:e.secret,C:e.C,amount:e.amount,...e.dleq&&{dleq:e.dleq},...e.witness&&{witness:e.witness}}))}}function ns(s){const t=s.slice(0,1),e=s.slice(1);if(t==="A"){const n=Gi(e);if(n.token.length>1)throw new Error("Multi entry token are not supported");const r=n.token[0];for(const o of r.proofs)Ze(o.amount,!0);const i={mint:r.mint,proofs:r.proofs,unit:n.unit||"sat"};return n.memo&&(i.memo=n.memo),i}else if(t==="B"){const n=Sn(e),r=In(n);return _i(r)}throw new Error("Token version is not supported")}function Ye(s,t,e,n,r,i){let o="sat";if(t&&typeof t=="object"?(o=t.unit??"sat",e=t.expiry,n=t.versionByte??1,i=t.input_fee_ppk,r=t.isDeprecatedBase64??!1):(o=t??"sat",n=n??0,r=r??!1),r){const c=Object.entries(s).sort(([l],[h])=>Number(l)-Number(h)).map(([,l])=>l).reduce((l,h)=>l+h,""),a=Z(N.fromString(c));return N.toBase64(a).slice(0,12)}switch(n){case 0:{const c=Object.entries(s).sort(([l],[h])=>Number(l)-Number(h)).map(([,l])=>R(l)).reduce((l,h)=>Si(l,h),new Uint8Array),a=Z(c);return"00"+N.toHex(a).slice(0,14)}case 1:{if(!o)throw new Error("Cannot compute keyset ID version 01: unit is required.");let a=Object.entries(s).sort(([h],[f])=>Number(h)-Number(f)).map(([h,f])=>`${h}:${f}`).join(",");a+=`|unit:${o}`,i&&(a+=`|input_fee_ppk:${i}`),e&&(a+=`|final_expiry:${e}`);const u=Z(N.fromString(a));return"01"+N.toHex(u)}default:throw new Error(`Unrecognized keyset ID version: ${n}`)}}function Si(s,t){const e=new Uint8Array(s.length+t.length);return e.set(s),e.set(t,s.length),e}function ha(s){return s.sort((t,e)=>t.id.localeCompare(e.id))}function lt(s){return typeof s=="object"}function fa(s){if(lt(s)){if("error"in s&&s.error)throw new Error(s.error);if("detail"in s&&s.detail)throw new Error(s.detail)}}function ft(...s){return s.map(t=>t.replace(/(^\/+|\/+$)/g,"")).join("/")}function ss(s){return s.replace(/\/$/,"")}function Mt(s){return s.reduce((t,e)=>t+e.amount,0)}function da(s){return ie.fromEncodedRequest(s)}class Ai{get value(){return this._value}set value(t){this._value=t}get next(){return this._next}set next(t){this._next=t}constructor(t){this._value=t,this._next=null}}class Pi{get first(){return this._first}set first(t){this._first=t}get last(){return this._last}set last(t){this._last=t}get size(){return this._size}set size(t){this._size=t}constructor(){this._first=null,this._last=null,this._size=0}enqueue(t){const e=new Ai(t);return this._size===0||!this._last?(this._first=e,this._last=e):(this._last.next=e,this._last=e),this._size++,!0}dequeue(){if(this._size===0||!this._first)return null;const t=this._first;return this._first=t.next,t.next=null,this._size--,t.value}}function rs(s){return s.map(t=>{const e={...t};return delete e.dleq,e})}function ga(s){const t=qe(s.id),e=/^[a-fA-F0-9]+$/.test(s.id),n=e?R(s.id)[0]:0;return Ye(s.keys,{expiry:s.final_expiry,input_fee_ppk:s.input_fee_ppk,unit:s.unit,versionByte:n,isDeprecatedBase64:t&&!e})===s.id}function pa(s,t){const e=(t??[]).map(r=>typeof r=="string"?r:r.id),n=[];for(const r of s){let i;try{i=R(r.id)}catch{n.push(r);continue}if(i[0]===0)n.push(r);else if(i[0]===1){if(!e)throw new Error("A short keyset ID v2 was encountered, but got no keysets to map it to.");const o=e.filter(c=>r.id===c.slice(0,r.id.length));if(o.length>1)throw new Error(`Short keyset ID ${r.id} is ambiguous.`);if(o.length===0)throw new Error(`Couldn't map short keyset ID ${r.id} to any known keysets of the current Mint`);r.id=o[0],n.push(r)}else throw new Error(`Unknown keyset ID version: ${i[0]}`)}return n}function is(s,t){if(s.dleq==null)return!1;const e={e:R(s.dleq.e),s:R(s.dleq.s),r:oe(s.dleq.r??"00")};if(!es(s.amount,t.keys))throw new Error(`Undefined key for amount ${s.amount} in keyset ${t.id}`);const n=t.keys[s.amount];return Wr(new TextEncoder().encode(s.secret),e,It(s.C),It(n))}function ya(...s){const t=s.reduce((r,i)=>r+i.length,0),e=new Uint8Array(t);let n=0;for(let r=0;r<s.length;r++)e.set(s[r],n),n=n+s[r].length;return e}function ma(s){const t=new TextEncoder,e=vi(s),n=Pn(e),r=t.encode("craw"),i=t.encode("B");return ya(r,i,n)}function wa(s){const t=new TextDecoder,e=t.decode(s.slice(0,4)),n=t.decode(new Uint8Array([s[4]]));if(e!=="craw"||n!=="B")throw new Error("not a valid binary token");const r=s.slice(5),i=In(r);return _i(i)}function Ts(s){return s.reduce((t,e)=>t+e,0)}function En(s,t){if(s===t)return!0;if(s==null||t==null||typeof s!="object"||typeof t!="object")return!1;if(Array.isArray(s)&&Array.isArray(t))return s.length!==t.length?!1:s.every((r,i)=>En(r,t[i]));if(Array.isArray(s)||Array.isArray(t))return!1;const e=Object.keys(s),n=Object.keys(t);return e.length!==n.length?!1:e.every(r=>n.includes(r)&&En(s[r],t[r]))}function Ti(s){return["web+cashu://","cashu://","cashu:","cashu"].forEach(e=>{s.startsWith(e)&&(s=s.slice(e.length))}),s}function Ii(s){return/^ln[a-z]{2,}[1-9][0-9]*(?:[mun]|0p)?1/i.test(s)}class Ft{constructor(){this.connectionMap=new Map}static getInstance(){return Ft.instance||(Ft.instance=new Ft),Ft.instance}getConnection(t,e){const n=this.connectionMap.get(t);if(n)return e&&n.setLogger(e),n;const r=new Bi(t,e);return this.connectionMap.set(t,r),r}}class Bi{constructor(t,e){this.subListeners={},this.rpcListeners={},this.rpcId=0,this.onCloseCallbacks=[],this._WS=Vi(),this.url=new URL(t),this.messageQueue=new Pi,this._logger=e??X}setLogger(t){this._logger=t}connect(t=1e4){return this.connectionPromise?this.connectionPromise:(this.connectionPromise=new Promise((e,n)=>{let r=!1,i=!1,o=null;const c=l=>{i||(i=!0,o&&clearTimeout(o),l())},a=()=>{if(this.ws){try{this.ws.onopen=null,this.ws.onerror=null,this.ws.onmessage=null,this.ws.onclose=null}catch{}try{this.ws.close()}catch{}this.ws=void 0,this.stopMessageHandling()}},u=l=>{this.connectionPromise=void 0,a();const h=l instanceof Error?l:new Error(String(l));this.failPendingRpc(h),c(()=>n(h))};try{this.ws=new this._WS(this.url.toString())}catch(l){u(l);return}o=setTimeout(()=>{u(new Error(`WebSocket connect timeout after ${t}ms`))},t),this.ws.onopen=()=>{r=!0,c(e)},this.ws.onerror=l=>{if(!r){u(new Error("Failed to open WebSocket"));return}this._logger.error("WebSocket error after open",{ev:l})},this.ws.onmessage=l=>{this.messageQueue.enqueue(l.data),this.handlingInterval||(this.handlingInterval=setInterval(this.handleNextMessage.bind(this),0))},this.ws.onclose=l=>{if(this.connectionPromise=void 0,!r){const m=l?.reason?`, ${l.reason}`:"";u(new Error(`WebSocket closed before open (code ${l?.code??0}${m})`));return}this.stopMessageHandling();const h=l?.reason?`, ${l.reason}`:"",f=l?.code??0;!(typeof l.wasClean=="boolean"?l.wasClean:!0)||f!==1e3&&f!==1001?this.failPendingRpc(new Error(`WebSocket closed (code ${f}${h})`)):this.rpcListeners={},this.onCloseCallbacks.forEach(m=>m(l))}}),this.connectionPromise)}sendRequest(t,e){if(this.ws?.readyState!==this._WS.OPEN){if(t==="unsubscribe")return;throw this._logger.error("Attempted sendRequest, but socket was not open"),new Error("Socket not open")}const n=this.rpcId;this.rpcId++,this.sendRpcMessage(t,e,n)}closeSubscription(t){this.ws?.send(JSON.stringify(["CLOSE",t]))}addSubListener(t,e){(this.subListeners[t]=this.subListeners[t]||[]).push(e)}stopMessageHandling(){for(this.handlingInterval&&(clearInterval(this.handlingInterval),this.handlingInterval=void 0);this.messageQueue.size>0;)this.messageQueue.dequeue()}failPendingRpc(t){const e=this.rpcListeners;this.rpcListeners={};for(const n of Object.keys(e))try{e[n].errorCallback(t)}catch{}}sendRpcMessage(t,e,n){if(this.ws?.readyState!==this._WS.OPEN)throw new Error("Socket not open");const r=JSON.stringify({jsonrpc:"2.0",method:t,params:e,id:n});try{this.ws.send(r)}catch(i){this._logger.error("WebSocket send failed",{e:i}),this.connectionPromise=void 0;try{this.ws.close()}catch{}this.ws=void 0,this.stopMessageHandling();const o=i instanceof Error?i:new Error(String(i));throw this.failPendingRpc(o),o}}addRpcListener(t,e,n){this.rpcListeners[n]={callback:t,errorCallback:e}}removeRpcListener(t){delete this.rpcListeners[t]}removeListener(t,e){if(this.subListeners[t]){if(this.subListeners[t].length===1){delete this.subListeners[t];return}this.subListeners[t]=this.subListeners[t].filter(n=>n!==e)}}async ensureConnection(t){this.ws?.readyState!==this._WS.OPEN&&await this.connect(t)}handleNextMessage(){if(this.messageQueue.size===0){this.handlingInterval&&(clearInterval(this.handlingInterval),this.handlingInterval=void 0);return}const t=this.messageQueue.dequeue();try{const e=JSON.parse(t);if("result"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].callback(),this.removeRpcListener(e.id));else if("error"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].errorCallback(new Error(e.error.message)),this.removeRpcListener(e.id));else if("method"in e&&!("id"in e)){const n=e.params?.subId;if(!n)return;if(this.subListeners[n]?.length>0){const r=e;this.subListeners[n].forEach(i=>{try{i(r.params?.payload)}catch(o){this._logger.error("Subscription handler threw",{e:o})}})}}}catch(e){this._logger.error("Error doing handleNextMessage",{e})}}createSubscription(t,e,n){if(this.ws?.readyState!==this._WS.OPEN)throw this._logger.error("Attempted createSubscription, but socket was not open"),new Error("Socket is not open");const r=(Math.random()+1).toString(36).substring(7),i=this.rpcId;this.addRpcListener(()=>{this.addSubListener(r,e)},n,i);try{this.sendRequest("subscribe",{...t,subId:r})}catch(o){throw this.removeRpcListener(i),o}return r}cancelSubscription(t,e,n){if(this.removeListener(t,e),this.ws?.readyState!==this._WS.OPEN){this._logger.info("Socket not open, removed listener locally {subId}",{subId:t});return}const r=this.rpcId;this.rpcId++,this.addRpcListener(()=>{this._logger.info("Unsubscribed {subId}",{subId:t})},n||(i=>this._logger.error("Unsubscribe failed",{e:i})),r);try{this.sendRpcMessage("unsubscribe",{subId:t},r)}catch(i){throw this.removeRpcListener(r),i}}get activeSubscriptions(){return Object.keys(this.subListeners)}close(){if(this.ws){try{this.ws.close()}catch{}this.ws=void 0}this.connectionPromise=void 0,this.stopMessageHandling()}onClose(t){this.onCloseCallbacks.push(t)}}const Oe={UNPAID:"UNPAID",PAID:"PAID",ISSUED:"ISSUED"},Vt={UNPAID:"UNPAID",PENDING:"PENDING",PAID:"PAID"},ve={UNSPENT:"UNSPENT",PENDING:"PENDING",SPENT:"SPENT"};function un(s,t){return s.state||(t.warn("Field 'state' not found in Melt quote response. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"),typeof s.paid=="boolean"&&(s.state=s.paid?Vt.PAID:Vt.UNPAID)),s}function Is(s,t){return s.state||(t.warn("Field 'state' not found in Mint quote response. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"),typeof s.paid=="boolean"&&(s.state=s.paid?Oe.PAID:Oe.UNPAID)),s}function ba(s,t){return Array.isArray(s?.contact)&&s?.contact.length>0&&(s.contact=s.contact.map(e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="string"&&typeof e[1]=="string"?(t.warn("Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"),{method:e[0],info:e[1]}):e)),s}class ce{constructor(t){this._mintInfo=t;const e=this.toEndpoints(t?.nuts?.[22]?.protected_endpoints);this._protected22=this.buildIndex(e);const n=this.toEndpoints(t?.nuts?.[21]?.protected_endpoints);this._protected21=this.buildIndex(n)}isSupported(t){switch(t){case 4:case 5:return this.checkMintMelt(t);case 7:case 8:case 9:case 10:case 11:case 12:case 14:case 20:return this.checkGenericNut(t);case 17:return this.checkNut17();case 15:return this.checkNut15();default:throw new Error("nut is not supported by cashu-ts")}}requiresBlindAuthToken(t,e){return this.matchesProtected(this._protected22,t,e)}requiresClearAuthToken(t,e){return this.matchesProtected(this._protected21,t,e)}matchesProtected(t,e,n){if(!t)return!1;const r=`${e} ${n}`,i=t.cache[r];if(typeof i=="boolean")return i;const o=t.exact.some(u=>u.method===e&&u.path===n),c=o?!1:t.prefix.some(u=>u.method===e&&n.startsWith(u.path)),a=o||c;return t.cache[r]=a,a}checkGenericNut(t){return this._mintInfo.nuts[t]?.supported?{supported:!0}:{supported:!1}}checkMintMelt(t){const e=this._mintInfo.nuts[t];return e&&e.methods.length>0&&!e.disabled?{disabled:!1,params:e.methods}:{disabled:!0,params:e?.methods??[]}}checkNut17(){return this._mintInfo.nuts[17]&&this._mintInfo.nuts[17].supported.length>0?{supported:!0,params:this._mintInfo.nuts[17].supported}:{supported:!1}}checkNut15(){return this._mintInfo.nuts[15]&&this._mintInfo.nuts[15].methods.length>0?{supported:!0,params:this._mintInfo.nuts[15].methods}:{supported:!1}}toEndpoints(t){if(!Array.isArray(t))return[];const e=[];for(const n of t)if(n&&typeof n=="object"){const r=n,i=r.method,o=r.path;if(typeof i=="string"&&typeof o=="string"){const c=i.toUpperCase();(c==="GET"||c==="POST")&&e.push({method:c,path:o})}}return e}buildIndex(t){if(!t||t.length===0)return;const e=[],n=[];for(const i of t){let o=i.path;o.startsWith("^")&&(o=o.slice(1)),o.endsWith("$")&&(o=o.slice(0,-1)),o.endsWith(".*")?n.push({method:i.method,path:o.slice(0,-2)}):e.push({method:i.method,path:o})}return{cache:{},exact:e,prefix:n}}get cache(){return this._mintInfo}get contact(){return this._mintInfo.contact}get description(){return this._mintInfo.description}get description_long(){return this._mintInfo.description_long}get name(){return this._mintInfo.name}get pubkey(){return this._mintInfo.pubkey}get nuts(){return this._mintInfo.nuts}get version(){return this._mintInfo.version}get motd(){return this._mintInfo.motd}get supportsBolt12Description(){return this.supportsNut04Description("bolt12")}supportsNut04Description(t,e){return this._mintInfo.nuts[4]?.methods.some(n=>n.method===t&&(e?n.unit===e:!0)&&(n.options?.description===!0||n.description===!0))}supportsAmountless(t="bolt11",e="sat"){const n=this._mintInfo?.nuts?.[5]?.methods??[];return Array.isArray(n)?n.some(r=>r.method===t&&r.unit===e&&r.options?.amountless===!0):!1}}class Xe{constructor(t,e){this.tokenListeners=[],this.discoveryUrl=t,this.logger=e?.logger??X,this.clientId=e?.clientId??"cashu-client",this.scope=e?.scope??"openid",this.onTokens=e?.onTokens}static fromMintInfo(t,e){const n=t?.nuts?.["21"];if(!n?.openid_discovery)throw new Error("OIDCAuth: mint does not advertise NUT-21 openid_discovery");const r=e?.clientId??n.client_id??"cashu-client";return new Xe(n.openid_discovery,{...e,clientId:r})}setClient(t){this.clientId=t}setScope(t){this.scope=t??"openid"}addTokenListener(t){this.tokenListeners.push(t)}async loadConfig(){if(this.config)return this.config;const t=await fetch(this.discoveryUrl,{method:"GET",headers:{Accept:"application/json"}}),e=await t.text();let n;try{n=e?JSON.parse(e):void 0}catch(i){this.logger.warn("OIDCAuth: bad discovery JSON",{err:i})}if(!t.ok||!n)throw new Error("OIDCAuth: invalid discovery document");const r=n;if(typeof r.token_endpoint!="string"||r.token_endpoint.length===0)throw new Error("OIDCAuth: invalid discovery document, missing token_endpoint");return this.config=r,r}generatePKCE(){const t=gt(48),e=fn(t),n=N.fromString(e),r=Z(n),i=fn(r);return{verifier:e,challenge:i}}async buildAuthCodeUrl(t){const e=await this.loadConfig(),n=t.scope??this.scope,r=new URLSearchParams({response_type:"code",client_id:this.clientId,redirect_uri:t.redirectUri,scope:n,code_challenge_method:t.codeChallengeMethod??"S256",code_challenge:t.codeChallenge});if(t.state&&r.set("state",t.state),!e.authorization_endpoint)throw new Error("OIDCAuth: discovery lacks authorization_endpoint");return`${e.authorization_endpoint}?${r.toString()}`}async exchangeAuthCode(t){const e=await this.loadConfig(),n=this.toForm({grant_type:"authorization_code",code:t.code,redirect_uri:t.redirectUri,client_id:this.clientId,code_verifier:t.codeVerifier}),r=await this.postFormStrict(e.token_endpoint,n);return this.handleTokens(r),r}async deviceStart(){const e=(await this.loadConfig()).device_authorization_endpoint;if(!e)throw new Error("OIDCAuth: provider lacks device_authorization_endpoint");const n=this.toForm({client_id:this.clientId,scope:this.scope});return this.postFormStrict(e,n)}async devicePoll(t,e=5){const n=await this.loadConfig();let r=Math.max(1,e);for(;;){await this.sleep(r*1e3);const i=this.toForm({grant_type:"urn:ietf:params:oauth:grant-type:device_code",device_code:t,client_id:this.clientId}),o=await this.postFormLoose(n.token_endpoint,i);if(o.access_token)return this.handleTokens(o),o;const c=(o.error??"").toString();if(c==="authorization_pending")continue;if(c==="slow_down"){r=Math.max(r+5,r*2);continue}const a=o.error_description||c||"device authorization failed";throw new Error(`OIDCAuth: ${a}`)}}async startDeviceAuth(t=5){const e=await this.deviceStart(),n=Math.max(e.interval??1,t);let r=!1;return{...e,poll:async()=>{const c=await this.loadConfig();let a=Math.max(1,n);for(;;){if(r)throw new Error("OIDCAuth: device polling cancelled");await this.sleep(a*1e3);const u=this.toForm({grant_type:"urn:ietf:params:oauth:grant-type:device_code",device_code:e.device_code,client_id:this.clientId}),l=await this.postFormLoose(c.token_endpoint,u);if(l.access_token)return this.handleTokens(l),l;const h=(l.error??"").toString();if(h==="authorization_pending")continue;if(h==="slow_down"){a=Math.max(a+5,a*2);continue}const f=l.error_description||h||"device authorization failed";throw new Error(`OIDCAuth: ${f}`)}},cancel:()=>{r=!0}}}async refresh(t){const e=await this.loadConfig(),n=this.toForm({grant_type:"refresh_token",refresh_token:t,client_id:this.clientId}),r=await this.postFormStrict(e.token_endpoint,n);return this.handleTokens(r),r}async passwordGrant(t,e){const n=await this.loadConfig(),r=this.toForm({grant_type:"password",client_id:this.clientId,username:t,password:e,scope:this.scope}),i=await this.postFormStrict(n.token_endpoint,r);return this.handleTokens(i),i}handleTokens(t){if(!t.access_token){const e=t.error_description||t.error||"token response missing access_token";throw new Error(`OIDCAuth: ${e}`)}queueMicrotask(()=>ee(this.onTokens,t,this.logger,{where:"OIDCAuth.handleTokens"}));for(const e of this.tokenListeners)queueMicrotask(()=>ee(e,t,this.logger,{where:"OIDCAuth.handleTokens.listener"}))}toForm(t){const e=n=>encodeURIComponent(n).replace(/%20/g,"+");return Object.entries(t).map(([n,r])=>`${e(n)}=${e(r)}`).join("&")}async postFormStrict(t,e){try{this.logger.debug("OIDCAuth Request",{formBody:e});const n=await fetch(t,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:e}),r=await n.text();let i;try{i=r?JSON.parse(r):void 0}catch(o){this.logger.warn("OIDCAuth: bad JSON (strict)",{err:o})}if(!n.ok){const o=i??{},c=o.error_description||o.error||`HTTP ${n.status}`;throw new Error(`OIDCAuth: ${c}`)}return this.logger.debug("OIDCAuth Response",{json:i}),i??{}}catch(n){throw this.logger.error("OIDCAuth: postFormStrict failed",{err:n}),n}}async postFormLoose(t,e){try{this.logger.debug("OIDCAuth Request",{formBody:e});const r=await(await fetch(t,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:e})).text();let i;try{i=r?JSON.parse(r):void 0}catch(o){this.logger.warn("OIDCAuth: bad JSON (loose)",{err:o})}return this.logger.debug("OIDCAuth Response",{json:i}),i??{}}catch(n){return this.logger.error("OIDCAuth: postFormLoose network error",{err:n}),{error:"network_error",error_description:String(n)}}}sleep(t){return new Promise(e=>setTimeout(e,t))}}class Je{constructor(t,e){this._mintUrl=ss(t),this._request=e?.customRequest??Rs,this._authProvider=e?.authProvider,this._logger=e?.logger??X,$i(this._logger)}get mintUrl(){return this._mintUrl}async oidcAuth(t){const e=(await this.getLazyMintInfo()).nuts[21];if(!e?.openid_discovery)throw new Error("Mint: no NUT-21 openid_discovery");return new Xe(e.openid_discovery,{...t,clientId:t?.clientId??e.client_id??"cashu-client"})}async getInfo(t){const n=await(t??this._request)({endpoint:ft(this._mintUrl,"/v1/info")});return ba(n,this._logger)}async getLazyMintInfo(){if(this._mintInfo)return this._mintInfo;const t=await this.getInfo();return this._mintInfo=new ce(t),this._mintInfo}async swap(t,e){const n=await this.requestWithAuth("POST","/v1/swap",{requestBody:t},e);if(!lt(n)||!Array.isArray(n?.signatures))throw this._logger.error("Invalid response from mint...",{data:n,op:"swap"}),new Error("Invalid response from mint");return n}async createMintQuoteBolt11(t,e){const n=await this.requestWithAuth("POST","/v1/mint/quote/bolt11",{requestBody:t},e);return Is(n,this._logger)}async createMintQuoteBolt12(t,e){return await this.requestWithAuth("POST","/v1/mint/quote/bolt12",{requestBody:t},e)}async checkMintQuoteBolt11(t,e){const n=await this.requestWithAuth("GET",`/v1/mint/quote/bolt11/${t}`,{},e);return Is(n,this._logger)}async checkMintQuoteBolt12(t,e){return await this.requestWithAuth("GET",`/v1/mint/quote/bolt12/${t}`,{},e)}async mintBolt11(t,e){const n=await this.requestWithAuth("POST","/v1/mint/bolt11",{requestBody:t},e);if(!lt(n)||!Array.isArray(n?.signatures))throw this._logger.error("Invalid response from mint...",{data:n,op:"mintBolt11"}),new Error("Invalid response from mint");return n}async mintBolt12(t,e){const n=await this.requestWithAuth("POST","/v1/mint/bolt12",{requestBody:t},e);if(!lt(n)||!Array.isArray(n?.signatures))throw this._logger.error("Invalid response from mint...",{data:n,op:"mintBolt12"}),new Error("Invalid response from mint");return n}async createMeltQuoteBolt11(t,e){const n=await this.requestWithAuth("POST","/v1/melt/quote/bolt11",{requestBody:t},e),r=un(n,this._logger);if(!lt(r)||typeof r?.amount!="number"||typeof r?.fee_reserve!="number"||typeof r?.quote!="string")throw this._logger.error("Invalid response from mint...",{data:r,op:"createMeltQuoteBolt11"}),new Error("Invalid response from mint");return r}async createMeltQuoteBolt12(t,e){return await this.requestWithAuth("POST","/v1/melt/quote/bolt12",{requestBody:t},e)}async checkMeltQuoteBolt11(t,e){const n=await this.requestWithAuth("GET",`/v1/melt/quote/bolt11/${t}`,{},e),r=un(n,this._logger);if(!lt(r)||typeof r?.amount!="number"||typeof r?.fee_reserve!="number"||typeof r?.quote!="string"||typeof r?.state!="string"||!Object.values(Vt).includes(r.state))throw this._logger.error("Invalid response from mint...",{data:r,op:"checkMeltQuoteBolt11"}),new Error("Invalid response from mint");return r}async checkMeltQuoteBolt12(t,e){return await this.requestWithAuth("GET",`/v1/melt/quote/bolt12/${t}`,{},e)}async melt(t,e,n){const r={...n?.preferAsync?{Prefer:"respond-async"}:{}};xn(!this.isValidMethodString(t),`Invalid melt method: ${t}`,this._logger);const i=await this.requestWithAuth("POST",`/v1/melt/${t}`,{requestBody:e,headers:r},n?.customRequest);if(!lt(i))throw this._logger.error("Invalid response from mint...",{data:i,op:"melt"}),new Error("Invalid response from mint");return i}async meltBolt11(t,e){const n=await this.melt("bolt11",t,e),r=un(n,this._logger);if(!lt(r)||typeof r?.state!="string"||!Object.values(Vt).includes(r.state))throw this._logger.error("Invalid response from mint...",{data:r,op:"meltBolt11"}),new Error("Invalid response from mint");return r}async meltBolt12(t,e){return this.melt("bolt12",t,e)}async check(t,e){const n=await this.requestWithAuth("POST","/v1/checkstate",{requestBody:t},e);if(!lt(n)||!Array.isArray(n?.states))throw this._logger.error("Invalid response from mint...",{data:n,op:"check"}),new Error("Invalid response from mint");return n}async getKeys(t,e,n){const r=e||this._mintUrl;t&&(t=t.replace(/\//g,"_").replace(/\+/g,"-"));const o=await(n??this._request)({endpoint:t?ft(r,"/v1/keys",t):ft(r,"/v1/keys")});if(!lt(o)||!Array.isArray(o.keysets))throw this._logger.error("Invalid response from mint...",{data:o,op:"getKeys"}),new Error("Invalid response from mint");return o}async getKeySets(t){return(t??this._request)({endpoint:ft(this._mintUrl,"/v1/keysets")})}async restore(t,e){const r=await(e??this._request)({endpoint:ft(this._mintUrl,"/v1/restore"),method:"POST",requestBody:t});if(!lt(r)||!Array.isArray(r?.outputs)||!Array.isArray(r?.signatures))throw this._logger.error("Invalid response from mint...",{data:r,op:"restore"}),new Error("Invalid response from mint");return r}async connectWebSocket(){try{const t=new URL(this._mintUrl),e="v1/ws";t.pathname.endsWith("/")?t.pathname+=e:t.pathname+="/"+e,t.protocol=t.protocol==="https:"?"wss:":"ws:";const n=t.toString();this.ws||(this.ws=Ft.getInstance().getConnection(n,this._logger)),await this.ws.ensureConnection()}catch(t){this._logger.error("Failed to connect to WebSocket...",{e:t});try{this.ws?.close()}catch{}throw this.ws=void 0,new Error("Failed to connect to WebSocket...")}}disconnectWebSocket(){this.ws&&this.ws.close()}get webSocketConnection(){return this.ws}async handleClearAuth(t,e){if(!(!this._authProvider||!(await this.getLazyMintInfo()).requiresClearAuthToken(t,e)))return this._logger.error("Clear Authentication Token...",{cat:this._authProvider.getCAT()}),this._authProvider.getCAT()}async handleBlindAuth(t,e){if(!this._authProvider||!(await this.getLazyMintInfo()).requiresBlindAuthToken(t,e))return;const r=await this._authProvider.getBlindAuthToken({method:t,path:e});return this._logger.error("Blind Authentication Token...",{bat:r}),r}async requestWithAuth(t,e,n={},r){const i=r??this._request,o=await this.handleBlindAuth(t,e),c=await this.handleClearAuth(t,e),a={...n.headers??{},...o?{"Blind-auth":o}:{},...c?{"Clear-auth":c}:{}};return i({...n,endpoint:ft(this._mintUrl,e),method:t,headers:a})}isValidMethodString(t){return!!(typeof t=="string"&&/^[a-z0-9_-]+$/.test(t))}}class Gt{constructor(t,e,n,r,i){this._keys={},this._id=t,this._unit=e,this._active=n,this._input_fee_ppk=r,this._final_expiry=i}get id(){return this._id}get unit(){return this._unit}get isActive(){return this._active}get fee(){return this._input_fee_ppk??0}get expiry(){return this._final_expiry}get hasKeys(){return Object.keys(this._keys).length>0}get hasHexId(){return Lt(this._id)}get keys(){return this._keys}set keys(t){this._keys=t}get active(){return this.isActive}get input_fee_ppk(){return this.fee}get final_expiry(){return this.expiry}toMintKeyset(){return{id:this._id,unit:this._unit,active:this._active,input_fee_ppk:this._input_fee_ppk,final_expiry:this._final_expiry}}toMintKeys(){return this.hasKeys?{id:this._id,unit:this._unit,active:this._active,input_fee_ppk:this._input_fee_ppk,final_expiry:this._final_expiry,keys:this._keys}:null}verify(){return this.hasKeys?Gt.verifyKeysetId(this.toMintKeys()):!1}static verifyKeysetId(t){if(!t.keys||Object.keys(t.keys).length===0)return!1;const e=qe(t.id)&&!Lt(t.id),n=Lt(t.id)?R(t.id)[0]:0;return Ye(t.keys,{input_fee_ppk:t.input_fee_ppk,expiry:t.final_expiry,unit:t.unit,versionByte:n,isDeprecatedBase64:e})===t.id}static fromMintApi(t,e){const n=new Gt(t.id,t.unit,t.active,t.input_fee_ppk,t.final_expiry);if(e){if(e.id!==t.id)throw new Error(`Mismatched keyset ids: meta=${t.id}, keys=${e.id}`);if(e.unit!==t.unit)throw new Error(`Mismatched keyset units: meta=${t.unit}, keys=${e.unit}`);if(e.final_expiry!==void 0&&t.final_expiry!==void 0&&e.final_expiry!==t.final_expiry)throw new Error(`Mismatched keyset expiry for id=${t.id}`);n.keys=e.keys}return n}}class bt{constructor(t,e,n,r){if(this.keysets={},this.mint=typeof t=="string"?new Je(t):t,this.unit=e,n&&r){const i=Array.isArray(r)?r:[r];this.buildKeychain(n,i),this.getCheapestKeyset()}}static fromCache(t,e){const n=new bt(t,e.unit);return n.loadFromCache(e),n}static mintToCacheDTO(t,e,n,r){const i=new Map(r.map(c=>[c.id,c]));return{keysets:n.map(c=>{const a=i.get(c.id),u={...c};return a&&(u.keys=a.keys),u}),unit:t,mintUrl:e}}static cacheToMintDTO(t){const e=t.keysets.map(r=>({id:r.id,unit:r.unit,active:r.active,input_fee_ppk:r.input_fee_ppk,final_expiry:r.final_expiry})),n=t.keysets.filter(r=>!!r.keys).map(r=>({id:r.id,unit:r.unit,active:r.active,input_fee_ppk:r.input_fee_ppk,final_expiry:r.final_expiry,keys:r.keys}));return{keysets:e,keys:n}}async init(t){if(Object.keys(this.keysets).length>0&&!t)return;const[e,n]=await Promise.all([this.mint.getKeySets(),this.mint.getKeys()]);this.buildKeychain(e.keysets,n.keysets),this.getCheapestKeyset()}loadFromCache(t){if(t.unit!==this.unit)throw new Error(`KeyChain unit mismatch in cache, expected '${this.unit}', got '${t.unit}' from ${t.mintUrl}`);const{keysets:e,keys:n}=bt.cacheToMintDTO(t);this.buildKeychain(e,n),this.getCheapestKeyset()}buildKeychain(t,e){this.keysets={};const n=t.filter(i=>i.unit===this.unit);if(!n.length)throw new Error(`No Keysets found for unit: ${this.unit}`);const r=new Map(e.filter(i=>i.unit===this.unit).map(i=>[i.id,i]));for(const i of n){let o;if(i.active&&Lt(i.id)){const c=r.get(i.id);o=Gt.fromMintApi(i,c)}else o=Gt.fromMintApi(i);if(o.hasKeys&&!o.verify())throw new Error(`Keyset verification failed for ID ${o.id}`);this.keysets[o.id]=o}}getKeyset(t){const e=t?this.keysets[t]:this.getCheapestKeyset();if(!e)throw new Error(`Keyset '${t}' not found`);return e}getCheapestKeyset(){if(Object.keys(this.keysets).length===0)throw new Error("KeyChain not initialized");const t=Object.values(this.keysets).filter(e=>e.isActive&&e.hasHexId&&e.hasKeys);if(t.length===0)throw new Error("No active keyset found");return t.sort((e,n)=>e.fee-n.fee)[0]}getKeysets(){if(Object.keys(this.keysets).length===0)throw new Error("KeyChain not initialized");return Object.values(this.keysets)}getAllKeys(){return this.getKeysets().map(t=>t.toMintKeys()).filter(t=>t!==null)}getAllKeysetIds(){return this.getKeysets().map(t=>t.id)}get cache(){const t=this.getKeysets(),e=t.map(r=>r.toMintKeyset()),n=t.map(r=>r.toMintKeys()).filter(r=>r!==null);return bt.mintToCacheDTO(this.unit,this.mint.mintUrl,e,n)}getCache(){const t=this.cache,{keysets:e,keys:n}=bt.cacheToMintDTO(t);return{keysets:e,keys:n,unit:t.unit,mintUrl:t.mintUrl}}}class ln{constructor(t,e,n){this.amount=t,this.B_=e,this.id=n}getSerializedBlindedMessage(){return{amount:this.amount,B_:this.B_.toHex(!0),id:this.id}}}const Ea=new Set(["locktime","pubkeys","n_sigs","refund","n_sigs_refund"]);function Mi(s){if(!s||typeof s!="string")throw new Error("tag key must be a non empty string");if(Ea.has(s))throw new Error(`additionalTags must not use reserved key "${s}"`)}const Bs=1024,kn=new WeakMap;function ka(s,t){t&&kn.set(s,t)}function va(s){const t=kn.get(s);if(t)return kn.delete(s),t}class st{constructor(t,e,n){this.secret=n,this.blindingFactor=e,this.blindedMessage=t}toProof(t,e){let n;t.dleq&&(n={s:R(t.dleq.s),e:R(t.dleq.e),r:this.blindingFactor});const r={id:t.id,amount:t.amount,C_:It(t.C_)},i=It(e.keys[t.amount]),o=br(r,this.blindingFactor,this.secret,i),c={...Er(o),...n&&{dleq:{s:F(n.s),e:F(n.e),r:Ke(n.r??BigInt(0))}}},a=va(this);return a&&(c.p2pk_e=a),c}static createP2PKData(t,e,n,r){return wt(e,n.keys,r).map(o=>this.createSingleP2PKData(t,o,n.id))}static createSingleP2PKData(t,e,n){const r=Array.isArray(t.pubkey)?t.pubkey:[t.pubkey],i=t.refundKeys??[],o=Math.max(1,Math.min(t.requiredSignatures??1,r.length)),c=Math.max(1,Math.min(t.requiredRefundSignatures??1,i.length||1));if(r.length===0)throw new Error("P2PK requires at least one pubkey");const a=typeof t.hashlock=="string"&&t.hashlock.length>0;let u=a?t.hashlock:r[0],l=a?r:r.slice(1),h=i,f;if(t.blindKeys){const Q=[...r,...i],{blinded:H,Ehex:K}=Tr(Q,n);a?l=H.slice(0,r.length):(u=H[0],l=H.slice(1,r.length)),h=H.slice(r.length),f=K}const d=[],y=t.locktime??NaN;if(Number.isSafeInteger(y)&&y>=0&&d.push(["locktime",String(y)]),l.length>0&&(d.push(["pubkeys",...l]),o>1&&d.push(["n_sigs",String(o)])),h.length>0&&(d.push(["refund",...h]),c>1&&d.push(["n_sigs_refund",String(c)])),t.sigFlag=="SIG_ALL"&&d.push(["sigflag","SIG_ALL"]),t.additionalTags?.length){const Q=t.additionalTags.map(([H,...K])=>(Mi(H),[H,...K.map(String)]));d.push(...Q)}const w=[a?"HTLC":"P2PK",{nonce:F(gt(32)),data:u,tags:d}],P=JSON.stringify(w),C=[...P].length;if(C>Bs)throw new Error(`Secret too long (${C} characters), maximum is ${Bs}`);const B=new TextEncoder().encode(P),{r:D,B_:j}=te(B),q=new st(new ln(e,j,n).getSerializedBlindedMessage(),D,B);return t.blindKeys&&f&&ka(q,f),q}static createRandomData(t,e,n){return wt(t,e.keys,n).map(i=>this.createSingleRandomData(i,e.id))}static createSingleRandomData(t,e){const n=F(gt(32)),r=new TextEncoder().encode(n),{r:i,B_:o}=te(r);return new st(new ln(t,o,e).getSerializedBlindedMessage(),i,r)}static createDeterministicData(t,e,n,r,i){return wt(t,r.keys,i).map((c,a)=>this.createSingleDeterministicData(c,e,n+a,r.id))}static createSingleDeterministicData(t,e,n,r){const i=jr(e,r,n),o=F(i),c=new TextEncoder().encode(o),a=N.toBigInt(Vr(e,r,n)),{r:u,B_:l}=te(c,a);return new st(new ln(t,l,r).getSerializedBlindedMessage(),u,c)}static sumOutputAmounts(t){return t.reduce((e,n)=>e+n.blindedMessage.amount,0)}}function Ms(s){const t=s.toLowerCase();if(t.length===66&&(t.startsWith("02")||t.startsWith("03")))return t;if(t.length===64)return`02${t}`;throw new Error(`Invalid pubkey, expected 33 byte compressed or 32 byte x only, got length ${t.length}`)}function _a(s){return s instanceof Date?Math.floor(s.getTime()/1e3):s<1e12?Math.floor(s):Math.floor(s/1e3)}class os{constructor(){this.lockSet=new Set,this.refundSet=new Set,this.extraTags=[]}addLockPubkey(t){const e=Array.isArray(t)?t:[t];for(const n of e)this.lockSet.add(Ms(n));return this}addRefundPubkey(t){const e=Array.isArray(t)?t:[t];for(const n of e)this.refundSet.add(Ms(n));return this}lockUntil(t){return this.locktime=_a(t),this}requireLockSignatures(t){return this.nSigs=Math.max(1,Math.trunc(t)),this}requireRefundSignatures(t){return this.nSigsRefund=Math.max(1,Math.trunc(t)),this}addTag(t,e){Mi(t);const n=e===void 0?[]:Array.isArray(e)?e:[e];return this.extraTags.push([t,...n.map(String)]),this}addTags(t){for(const[e,...n]of t)this.addTag(e,n);return this}blindKeys(){return this._blindKeys=!0,this}sigAll(){return this.sigFlag="SIG_ALL",this}addHashlock(t){return this.hashlock=t,this}toOptions(){const t=Array.from(this.lockSet),e=Array.from(this.refundSet);if(t.length===0)throw new Error("At least one lock pubkey is required");if(e.length>0&&this.locktime===void 0)throw new Error("Refund pubkeys require a locktime, add lockUntil(...) or remove refund keys");const n=t.length+e.length;if(n>10)throw new Error(`Too many pubkeys, ${n} provided, maximum allowed is 10 in total`);const r=this.nSigs?Math.min(Math.max(1,this.nSigs),t.length):void 0,i=this.nSigsRefund?Math.min(Math.max(1,this.nSigsRefund),Math.max(1,e.length)):void 0,c={pubkey:t.length===1?t[0]:t,...this.locktime!==void 0?{locktime:this.locktime}:{},...e.length?{refundKeys:e}:{},...r&&r>1?{requiredSignatures:r}:{},...i&&i>1?{requiredRefundSignatures:i}:{},...this.extraTags.length?{additionalTags:this.extraTags.slice()}:{},...this._blindKeys?{blindKeys:!0}:{},...this.sigFlag=="SIG_ALL"?{sigFlag:"SIG_ALL"}:{},...this.hashlock?{hashlock:this.hashlock}:{}};return st.createSingleP2PKData(c,1,"deedbeef"),c}static fromOptions(t){const e=new os,n=Array.isArray(t.pubkey)?t.pubkey:[t.pubkey];return e.addLockPubkey(n),t.locktime!==void 0&&e.lockUntil(t.locktime),t.refundKeys?.length&&e.addRefundPubkey(t.refundKeys),t.requiredSignatures!==void 0&&e.requireLockSignatures(t.requiredSignatures),t.requiredRefundSignatures!==void 0&&e.requireRefundSignatures(t.requiredRefundSignatures),t.additionalTags?.length&&e.addTags(t.additionalTags),t.blindKeys&&e.blindKeys(),t.sigFlag=="SIG_ALL"&&e.sigAll(),t.hashlock&&e.addHashlock(t.hashlock),e}}const Ci=(s,t,e,n=!1,r=!1,i=X)=>{const h=Fi();let f=null,d=1/0,y=0,m=0;const w=v=>{try{return e.getKeyset(v.id).fee}catch(b){Ue(`Could not get fee. No keyset found for keyset id: ${v.id}`,i,{error:b,keychain:e.getKeysets()})}},P=(v,b)=>v-(n?Math.ceil(b/1e3):0),C=v=>{const b=[...v];for(let p=b.length-1;p>0;p--){const g=Math.floor(Math.random()*(p+1));[b[p],b[g]]=[b[g],b[p]]}return b},B=(v,b,p)=>{let g=0,E=v.length-1,x=null;for(;g<=E;){const I=Math.floor((g+E)/2),T=v[I].exFee;(p?T<=b:T>=b)?(x=I,p?g=I+1:E=I-1):p?E=I-1:g=I+1}return p?x:g<v.length?g:null},D=(v,b)=>{const p=b.exFee;let g=0,E=v.length;for(;g<E;){const x=Math.floor((g+E)/2);v[x].exFee<p?g=x+1:E=x}v.splice(g,0,b)},j=(v,b)=>P(v,b)<t?1/0:v+b/1e3-t;let q=0,Q=0;const H=s.map(v=>{const b=w(v),p=n?v.amount-b/1e3:v.amount,g={proof:v,exFee:p,ppkfee:b};return(!n||p>0)&&(q+=v.amount,Q+=b),g});let K=n?H.filter(v=>v.exFee>0):H;if(K.sort((v,b)=>v.exFee-b.exFee),K.length>0){let v;if(r){const b=B(K,t,!0);v=b!==null?b+1:0}else{const b=B(K,t,!1);if(b!==null){const p=K[b].exFee,g=B(K,p,!0);Os(g,"Unexpected null rightIndex in binary search",i),v=g+1}else v=K.length}for(let b=v;b<K.length;b++)q-=K[b].proof.amount,Q-=K[b].ppkfee;K=K.slice(0,v)}const at=P(q,Q);if(t<=0||t>at)return{keep:s,send:[]};const nt=Math.min(Math.ceil(t*(1+0/100)),t+0,at);for(let v=0;v<60;v++){const b=[];let p=0,g=0;for(const S of C(K)){const _=p+S.proof.amount,A=g+S.ppkfee,M=P(_,A);if(r&&M>t||(b.push(S),p=_,g=A,M>=t))break}const E=new Set(b),x=K.filter(S=>!E.has(S)),I=C(Array.from({length:b.length},(S,_)=>_)).slice(0,5e3);for(const S of I){const _=P(p,g);if(_===t||!r&&_>=t&&_<=nt)break;const A=b[S],M=p-A.proof.amount,W=g-A.ppkfee,$=P(M,W),O=t-$,V=B(x,O,r);if(V!==null){const G=x[V];(!r||G.exFee>A.exFee)&&(O>=0||G.exFee<=A.exFee)&&(b[S]=G,p=M+G.proof.amount,g=W+G.ppkfee,x.splice(V,1),D(x,A))}}const T=j(p,g);if(T<d){i.debug(`selectProofsToSend: best solution found in trial #${v} - amount: ${p}, delta: ${T}`),f=[...b].sort((_,A)=>A.exFee-_.exFee),d=T,y=p,m=g;const S=[...f];for(;S.length>1&&d>0;){const _=S.pop(),A=p-_.proof.amount,M=g-_.ppkfee,W=j(A,M);if(W==1/0)break;W<d&&(f=[...S],d=W,y=A,m=M,p=A,g=M)}}if(f&&d<1/0){const S=P(y,m);if(S===t||!r&&S>=t&&S<=nt)break}if(h.elapsed()>1e3){xn(r,"Proof selection took too long. Try again with a smaller proof set.",i),i.warn("Proof selection took too long. Returning best selection so far.");break}}if(f&&d<1/0){const v=f.map(g=>g.proof),b=new Set(v),p=s.filter(g=>!b.has(g));return i.info(`Proof selection took ${h.elapsed()}ms`),{keep:p,send:v}}return{keep:s,send:[]}};class xa{constructor(t){if(this.next=new Map,this.locks=new Map,t)for(const[e,n]of Object.entries(t))this.next.set(e,n)}async withLock(t,e){const n=this.locks.get(t)??Promise.resolve();let r;const i=new Promise(c=>r=c),o=n.then(()=>i);this.locks.set(t,o);try{return await n,await e()}finally{r(),this.locks.get(t)===o&&this.locks.delete(t)}}async reserve(t,e){if(e<0)throw new Error("reserve called with negative count");return this.withLock(t,()=>{const n=this.next.get(t)??0;return e===0?{start:n,count:0}:(this.next.set(t,n+e),{start:n,count:e})})}async advanceToAtLeast(t,e){await this.withLock(t,()=>{const n=this.next.get(t)??0;e>n&&this.next.set(t,e)})}async setNext(t,e){await this.withLock(t,()=>{if(e<0)throw new Error("setNext: negative next not allowed");this.next.set(t,e)})}snapshot(){return Promise.resolve(Object.fromEntries(this.next.entries()))}}class Ki{constructor(t){this.wallet=t}send(t,e){return new Oi(this.wallet,t,e)}receive(t){return new Li(this.wallet,t)}mintBolt11(t,e){return new vn(this.wallet,"bolt11",t,e)}mintBolt12(t,e){return new vn(this.wallet,"bolt12",t,e)}meltBolt11(t,e){return new _n(this.wallet,"bolt11",t,e)}meltBolt12(t,e){return new _n(this.wallet,"bolt12",t,e)}}class Oi{constructor(t,e,n){this.wallet=t,this.amount=e,this.proofs=n,this.config={}}asRandom(t){return this.sendOT={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.sendOT={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.sendOT={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.sendOT={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.sendOT={type:"custom",data:t},this}keepAsRandom(t){return this.keepOT={type:"random",denominations:t},this}keepAsDeterministic(t=0,e){return this.keepOT={type:"deterministic",counter:t,denominations:e},this}keepAsP2PK(t,e){return this.keepOT={type:"p2pk",options:t,denominations:e},this}keepAsFactory(t,e){return this.keepOT={type:"factory",factory:t,denominations:e},this}keepAsCustom(t){return this.keepOT={type:"custom",data:t},this}includeFees(t=!0){return this.config.includeFees=t,this}keyset(t){return this.config.keysetId=t,this}privkey(t){return this.config.privkey=t,this}proofsWeHave(t){return this.config.proofsWeHave=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}offlineExactOnly(t=!1){return this.offlineExact={requireDleq:t},this}offlineCloseMatch(t=!1){return this.offlineClose={requireDleq:t},this}async prepare(){const t={send:this.sendOT??this.wallet.defaultOutputType(),...this.keepOT?{keep:this.keepOT}:{}};return this.wallet.prepareSwapToSend(this.amount,this.proofs,this.config,t)}async run(){if((this.offlineExact||this.offlineClose)&&(this.sendOT||this.keepOT))throw new Error("Offline selection cannot be combined with custom output types. Remove send/keep output configuration, or use an online swap.");if(this.offlineExact)return this.config.privkey&&(this.proofs=this.wallet.signP2PKProofs(this.proofs,this.config.privkey)),this.wallet.sendOffline(this.amount,this.proofs,{includeFees:this.config.includeFees,exactMatch:!0,requireDleq:this.offlineExact.requireDleq});if(this.offlineClose)return this.config.privkey&&(this.proofs=this.wallet.signP2PKProofs(this.proofs,this.config.privkey)),this.wallet.sendOffline(this.amount,this.proofs,{includeFees:this.config.includeFees,exactMatch:!1,requireDleq:this.offlineClose.requireDleq});const t={send:this.sendOT??this.wallet.defaultOutputType(),...this.keepOT?{keep:this.keepOT}:{}};return this.wallet.send(this.amount,this.proofs,this.config,t)}}class Li{constructor(t,e){this.wallet=t,this.token=e,this.config={}}asRandom(t){return this.outputType={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.outputType={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.outputType={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.outputType={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.outputType={type:"custom",data:t},this}keyset(t){return this.config.keysetId=t,this}requireDleq(t=!0){return this.config.requireDleq=t,this}privkey(t){return this.config.privkey=t,this}proofsWeHave(t){return this.config.proofsWeHave=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}async prepare(){return this.wallet.prepareSwapToReceive(this.token,this.config,this.outputType)}async run(){return this.wallet.receive(this.token,this.config,this.outputType)}}class vn{constructor(t,e,n,r){this.wallet=t,this.method=e,this.amount=n,this.quote=r,this.config={},this._hasPrivkey}asRandom(t){return this.outputType={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.outputType={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.outputType={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.outputType={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.outputType={type:"custom",data:t},this}keyset(t){return this.config.keysetId=t,this}privkey(t){return this.config.privkey=t,this}proofsWeHave(t){return this.config.proofsWeHave=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}async run(){if(this.method==="bolt11"){const e=this.quote;if(typeof e!="string"&&e.pubkey&&!this.config.privkey)throw new Error("privkey is required for locked BOLT11 mint quotes");return this.wallet.mintProofsBolt11(this.amount,e,this.config,this.outputType)}const t=this.quote;if(!this.config.privkey)throw new Error("privkey is required for BOLT12 mint quotes");return this.wallet.mintProofsBolt12(this.amount,t,this.config.privkey,this.config,this.outputType)}}class _n{constructor(t,e,n,r){this.wallet=t,this.method=e,this.quote=n,this.proofs=r,this.config={}}asRandom(t){return this.outputType={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.outputType={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.outputType={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.outputType={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.outputType={type:"custom",data:t},this}keyset(t){return this.config.keysetId=t,this}privkey(t){return this.config.privkey=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}onChangeOutputsCreated(t){return this.config.onChangeOutputsCreated=t,this}async prepare(){return await this.wallet.prepareMelt(this.method,this.quote,this.proofs,this.config,this.outputType)}async run(){const t=await this.wallet.prepareMelt(this.method,this.quote,this.proofs,this.config,this.outputType);return this.wallet.completeMelt(t,this.config.privkey)}}function Sa(s){const t=new WeakSet;try{return JSON.stringify(s,(e,n)=>{if(typeof n=="object"&&n!==null){if(t.has(n))return"[Circular]";t.add(n)}return n})}catch{return Object.prototype.toString.call(s)}}function Cs(s){if(s instanceof Error)return s;const t=typeof s=="string"?s:Sa(s),e=new Error(t);return e.cause=s,e}function Ks(){const s=new Error("Aborted");return Object.defineProperty(s,"name",{value:"AbortError"}),s}function Bt(s){s&&Promise.resolve(s).then(t=>{try{t()}catch{}}).catch(()=>{})}class Ni{constructor(t){this.wallet=t,this.countersReservedHandlers=new Set,this.meltBlanksHandlers=new Set}withAbort(t,e){if(!t)return e;if(t.aborted)return e(),()=>{};const n=()=>e();return t.addEventListener("abort",n,{once:!0}),()=>{t.removeEventListener("abort",n),e()}}waitUntilPaid(t,e,n,r="Timeout waiting for paid"){return new Promise((i,o)=>{let c=null,a=null,u=!1;const l=f=>{u||(u=!0,Bt(c),a&&(clearTimeout(a),a=null),n?.signal&&n.signal.removeEventListener("abort",h),f&&o(Cs(f)))},h=()=>l(Ks());if(n?.signal){if(n.signal.aborted)return h();n.signal.addEventListener("abort",h,{once:!0})}n?.timeoutMs&&n.timeoutMs>0&&(a=setTimeout(()=>l(new Error(r)),n.timeoutMs)),c=t(e,f=>{l(),i(f)},f=>l(f),{signal:n?.signal}),c.catch(f=>l(f))})}countersReserved(t,e){this.countersReservedHandlers.add(t);const n=()=>this.countersReservedHandlers.delete(t);return this.withAbort(e?.signal,n)}_emitCountersReserved(t){for(const e of this.countersReservedHandlers)ee(e,t,this.wallet.logger,{event:"countersReserved"})}meltBlanksCreated(t,e){this.meltBlanksHandlers.add(t);const n=()=>this.meltBlanksHandlers.delete(t);return this.withAbort(e?.signal,n)}_emitMeltBlanksCreated(t){for(const e of this.meltBlanksHandlers)ee(e,t,this.wallet.logger,{event:"meltBlanksCreated"})}async mintQuoteUpdates(t,e,n,r){await this.wallet.mint.connectWebSocket();const i=this.wallet.mint.webSocketConnection;if(!i)throw new Error("Failed to establish WebSocket connection.");const o=Array.from(new Set(t)),c=i.createSubscription({kind:"bolt11_mint_quote",filters:o},e,n),a=()=>i.cancelSubscription(c,e);return this.withAbort(r?.signal,a)}async mintQuotePaid(t,e,n,r){return this.mintQuoteUpdates([t],i=>{i.state===Oe.PAID&&e(i)},n,r)}async meltQuoteUpdates(t,e,n,r){await this.wallet.mint.connectWebSocket();const i=this.wallet.mint.webSocketConnection;if(!i)throw new Error("Failed to establish WebSocket connection.");const o=Array.from(new Set(t)),c=i.createSubscription({kind:"bolt11_melt_quote",filters:o},e,n),a=()=>i.cancelSubscription(c,e);return this.withAbort(r?.signal,a)}async meltQuotePaid(t,e,n,r){return this.meltQuoteUpdates([t],i=>{i.state===Vt.PAID&&e(i)},n,r)}async proofStateUpdates(t,e,n,r){await this.wallet.mint.connectWebSocket();const i=this.wallet.mint.webSocketConnection;if(!i)throw new Error("Failed to establish WebSocket connection.");const o=new TextEncoder,c={};for(const f of t){const d=Qt(o.encode(f.secret)).toHex(!0);c[d]=f}const a=Object.keys(c),u=f=>{e({...f,proof:c[f.Y]})},l=i.createSubscription({kind:"proof_state",filters:a},u,n),h=()=>i.cancelSubscription(l,u);return this.withAbort(r?.signal,h)}onceMintPaid(t,e){return this.waitUntilPaid(this.mintQuotePaid.bind(this),t,e,"Timeout waiting for mint paid")}onceAnyMintPaid(t,e){return new Promise((n,r)=>{const i=Array.from(new Set(t)),o=new Map;let c=null,a=null,u=!1,l=!1;const h=d=>{if(!l){l=!0;for(const y of o.values())Bt(y);o.clear(),c&&(clearTimeout(c),c=null),e?.signal&&e.signal.removeEventListener("abort",f),d&&r(Cs(d))}},f=()=>h(Ks());if(e?.signal){if(e.signal.aborted)return f();e.signal.addEventListener("abort",f,{once:!0})}if(e?.timeoutMs&&e.timeoutMs>0&&(c=setTimeout(()=>h(new Error("Timeout waiting for any mint paid")),e.timeoutMs)),i.length===0)return h(new Error("No quote ids provided"));for(const d of i){const y=this.mintQuotePaid(d,m=>{h(),n({id:d,quote:m})},m=>{if(e?.failOnError){h(m);return}a=m;const w=o.get(d);w&&(Bt(w),o.delete(d)),u&&o.size===0&&h(a??new Error("No subscriptions remaining"))});o.set(d,y),y.catch(m=>{if(e?.failOnError){h(m);return}a=m;const w=o.get(d);w&&(Bt(w),o.delete(d)),u&&o.size===0&&h(a??new Error("No subscriptions remaining"))})}u=!0})}onceMeltPaid(t,e){return this.waitUntilPaid(this.meltQuotePaid.bind(this),t,e,"Timeout waiting for melt paid")}proofStatesStream(t,e){return async function*(){const n=[];let r=!1,i=null;const o=e?.maxBuffer&&e.maxBuffer>0?e.maxBuffer:1/0,c=e?.drop??"oldest",a=()=>{const f=i;i=null,f&&f()},u=f=>{if(n.length>=o)if(c==="oldest"){const d=n.shift();if(d!==void 0)try{e?.onDrop?.(d)}catch{}n.push(f)}else{try{e?.onDrop?.(f)}catch{}return}else n.push(f);a()},l=this.proofStateUpdates(t,f=>{u(f)},()=>{r=!0,a()},{signal:e?.signal}),h=()=>{r=!0,a()};try{for(e?.signal&&(e.signal.aborted?h():e.signal.addEventListener("abort",h,{once:!0}));!r||n.length;){for(;n.length;)yield n.shift();if(r)break;await new Promise(f=>i=f)}}finally{Bt(l),e?.signal&&e.signal.removeEventListener("abort",h)}}.call(this)}group(){const t=[];let e=!1;const n=(()=>{if(!e)for(e=!0;t.length;)Bt(t.pop())});return n.add=r=>e?(Bt(r),r):(t.push(r),r),Object.defineProperty(n,"cancelled",{get:()=>e,enumerable:!0}),n}}class Ri{constructor(t){this.src=t}async peekNext(t){return(await this.src.reserve(t,0)).start}async advanceToAtLeast(t,e){await this.src.advanceToAtLeast(t,e)}async setNext(t,e){if(typeof this.src.setNext=="function"){await this.src.setNext(t,e);return}throw new Error("CounterSource does not support setNext()")}async snapshot(){if(typeof this.src.snapshot=="function")return await this.src.snapshot();throw new Error("CounterSource does not support snapshot()")}}const hn="__PENDING__";class tn{constructor(t,e){if(this._seed=void 0,this._unit="sat",this._mintInfo=void 0,this._denominationTarget=3,this._secretsPolicy="auto",this._boundKeysetId=hn,this.swap=this.send.bind(this),this.ops=new Ki(this),this.on=new Ni(this),this._logger=e?.logger??X,this._selectProofs=e?.selectProofs??Ci,this.mint=typeof t=="string"?new Je(t,{authProvider:e?.authProvider,logger:this._logger}):t,this._unit=e?.unit??this._unit,this._boundKeysetId=e?.keysetId??this._boundKeysetId,e?.bip39seed&&(this.failIf(!(e.bip39seed instanceof Uint8Array),"bip39seed must be a valid Uint8Array",{bip39seed:e.bip39seed}),this._seed=e.bip39seed),this._secretsPolicy=e?.secretsPolicy??this._secretsPolicy,e?.counterSource?this._counterSource=e.counterSource:this._counterSource=new xa(e?.counterInit),this.counters=new Ri(this._counterSource),this._keyChain=new bt(this.mint,this._unit),this._denominationTarget=e?.denominationTarget??this._denominationTarget,e?.keysets&&e?.keys&&e?.mintInfo){const n=Array.isArray(e.keys)?e.keys:[e.keys],r=bt.mintToCacheDTO(this._unit,this.mint.mintUrl,e.keysets,n);this.loadMintFromCache(e.mintInfo,r)}}fail(t,e){return Ue(t,this._logger,e)}failIf(t,e,n){return xn(t,e,this._logger,n)}failIfNullish(t,e,n){return Os(t,e,this._logger,n)}safeCallback(t,e,n){ee(t,e,this._logger,n)}assertAmount(t,e){try{Ze(t,!1)}catch(n){this.fail(n.message,{op:e,amount:t})}}async loadMint(t){const e=[];(!this._mintInfo||t)&&e.push(this.mint.getInfo().then(n=>(this._mintInfo=new ce(n),null))),e.push(this._keyChain.init(t).then(()=>null)),await Promise.all(e),this.finishInit()}loadMintFromCache(t,e){this._mintInfo=new ce(t),this._keyChain.loadFromCache(e),this.finishInit()}finishInit(){const t=this._keyChain.getCheapestKeyset().id;if(this._logger.debug("KeyChain",{keychain:this._keyChain.cache}),this._boundKeysetId===hn)this._boundKeysetId=t;else{const e=this._keyChain.getKeyset(this._boundKeysetId);this.failIf(!e.hasKeys,"Wallet keyset has no keys",{keyset:e.id})}this.getMintInfo()}get keyChain(){return this._keyChain}get unit(){return this._unit}getMintInfo(){return this.failIfNullish(this._mintInfo,"Mint info not initialized; call loadMint or loadMintFromCache first"),this._mintInfo}get keysetId(){return this.failIf(this._boundKeysetId===hn,"Wallet not initialised, call loadMint or loadMintFromCache first"),this._boundKeysetId}getKeyset(t){const e=this._keyChain.getKeyset(t??this.keysetId);return this.failIf(e.unit!==this._unit,"Keyset unit does not match wallet unit",{keyset:e.id,unit:e.unit,walletUnit:this._unit}),this.failIf(!e.hasKeys,"Keyset has no keys loaded",{keyset:e.id}),e}get logger(){return this._logger}async reserveFor(t,e){return e<=0?{start:0,count:0}:this._counterSource.reserve(t,e)}countersNeeded(t){return t.type!=="deterministic"||t.counter!==0?0:(t.denominations??[]).length}async addCountersToOutputTypes(t,...e){const n=e.filter(u=>u.type==="deterministic"&&u.counter>0&&(u.denominations?.length??0)>0);if(n.length>1){const u=n.map(l=>({start:l.counter,end:l.counter+l.denominations.length})).sort((l,h)=>l.start-h.start);for(let l=1;l<u.length;l++)this.failIf(u[l].start<u[l-1].end,"Manual counter ranges overlap",{keysetId:t,prev:u[l-1],cur:u[l]})}if(n.length>0){const u=Math.max(...n.map(l=>l.counter+l.denominations.length));await this._counterSource.advanceToAtLeast(t,u),this._logger.debug("Counter source advanced to respect manual deterministic counters",{keysetId:t,maxManualEnd:u})}const r=e.reduce((u,l)=>u+this.countersNeeded(l),0);if(r===0)return{outputTypes:e};const i=await this.reserveFor(t,r);let o=i.start;const c=e.map(u=>{if(u.type==="deterministic"&&u.counter===0){const l=u.denominations?.length??0;if(l>0){const h={...u,counter:o};return o+=l,h}}return u}),a={keysetId:t,start:i.start,count:i.count,next:i.start+i.count};return this.on._emitCountersReserved(a),{outputTypes:c,used:a}}bindKeyset(t){const e=this._keyChain.getKeyset(t);this.failIf(e.unit!==this._unit,"Keyset unit does not match wallet unit",{keyset:e.id,unit:e.unit,walletUnit:this._unit}),this.failIf(!e.hasKeys,"Keyset has no keys loaded",{keyset:e.id}),this._boundKeysetId=e.id,this._logger.debug("Wallet bound to keyset",{keysetId:e.id,unit:e.unit,feePPK:e.fee})}withKeyset(t,e){const n=new tn(this.mint,{keysetId:t,bip39seed:this._seed,secretsPolicy:this._secretsPolicy,logger:this._logger,counterSource:e?.counterSource??this._counterSource});return n.loadMintFromCache(this.getMintInfo().cache,this._keyChain.cache),n}defaultOutputType(){return this._secretsPolicy==="random"?{type:"random"}:this._secretsPolicy==="deterministic"?(this.failIfNullish(this._seed,"Deterministic policy requires a seed"),{type:"deterministic",counter:0}):this._seed?{type:"deterministic",counter:0}:{type:"random"}}configureOutputs(t,e,n,r=!1,i=[]){let o=t;if(n.type==="custom"){this.failIf(r,"The custom OutputType does not support automatic fee inclusion");const a=st.sumOutputAmounts(n.data);return this.failIf(a!==t,`Custom output data total (${a}) does not match amount (${t})`),n}let c=n.denominations??[];if(c.length===0&&i.length>0&&(c=wi(i,o,e.keys,this._denominationTarget)),c=wt(o,e.keys,c),r){let a=this.getFeesForKeyset(c.length,e.id),u=wt(a,e.keys);for(;this.getFeesForKeyset(c.length+u.length,e.id)>a;)a++,u=wt(a,e.keys);o+=a,c=[...c,...u]}return{...n,denominations:c}}preparedTotal(t){return t.type==="custom"?st.sumOutputAmounts(t.data):(t.denominations??[]).reduce((n,r)=>n+r,0)}createOutputData(t,e,n){if(this.failIf(t<0,"Amount was negative",{amount:t}),n.type!="custom"&&n.denominations&&n.denominations.length>0){const i=n.denominations.reduce((o,c)=>o+c,0);this.failIf(i!==t,"Denominations do not sum to the expected amount",{splitSum:i,expected:t})}let r;switch(n.type){case"random":r=st.createRandomData(t,e,n.denominations);break;case"deterministic":this.failIfNullish(this._seed,"Deterministic outputs require a seed configured in the wallet"),r=st.createDeterministicData(t,this._seed,n.counter,e,n.denominations);break;case"p2pk":r=st.createP2PKData(n.options,t,e,n.denominations);break;case"factory":{r=wt(t,e.keys,n.denominations).map(o=>n.factory(o,e));break}case"custom":{r=n.data;const i=st.sumOutputAmounts(r);this.failIf(i!==t,`Custom output data total (${i}) does not match amount (${t})`);break}default:this.fail("Invalid OutputType")}return r}createSwapTransaction(t,e,n=[]){t=this._prepareInputsForMint(t);const r=[...e,...n],i=r.map((h,f)=>f);se(t)||i.sort((h,f)=>r[h].blindedMessage.amount-r[f].blindedMessage.amount);const o=[...Array.from({length:e.length},()=>!0),...Array.from({length:n.length},()=>!1)],c=i.map(h=>r[h]),a=i.map(h=>o[h]),u=c.map(h=>h.blindedMessage);return this._logger.debug("createSwapTransaction:",{indices:i,sortedKeepVector:a}),{payload:{inputs:t,outputs:u},outputData:c,keepVector:a,sortedIndices:i}}async receive(t,e,n){const r=await this.prepareSwapToReceive(t,e,n),{keep:i}=await this.completeSwap(r,e?.privkey);return i}async prepareSwapToReceive(t,e,n){const{keysetId:r,requireDleq:i,proofsWeHave:o,onCountersReserved:c}=e||{};n=n??this.defaultOutputType();const a=typeof t=="string"?this.decodeToken(t):t,u=ss(a.mint);this.failIf(u!==this.mint.mintUrl,"Token belongs to a different mint",{token:u,wallet:this.mint.mintUrl}),this.failIf(a.unit!==this._unit,"Token is not in wallet unit",{token:a.unit,wallet:this._unit});let l=[];({proofs:l}=a);const h=Mt(l);this.failIf(h===0,"Token contains no proofs",{proofs:l}),this.assertAmount(h,"prepareSwapToReceive");const f=this.getKeyset(r);if(i)for(const C of l){const B=this._keyChain.getKeyset(C.id);is(C,B)||this.fail("Token contains proofs with invalid or missing DLEQ")}const d=this.getFeesForProofs(l),y=h-d;let m=this.configureOutputs(y,f,n,!1,o);const w=await this.addCountersToOutputTypes(f.id,m);[m]=w.outputTypes,w.used&&this.safeCallback(c,w.used,{op:"receive"}),this._logger.debug("receive counter",{counter:w.used,receiveOT:m});const P=this.createOutputData(this.preparedTotal(m),f,m);return{amount:y,fees:d,keysetId:f.id,inputs:l,keepOutputs:P}}sendOffline(t,e,n){this.assertAmount(t,"sendOffline");const{requireDleq:r=!1,includeFees:i=!1,exactMatch:o=!0}=n||{};r&&(e=e.filter(l=>l.dleq!=null)),this.failIf(Mt(e)<t,"Not enough funds available to send");const{keep:c,send:a}=this.selectProofsToSend(e,t,i,o),u=this._prepareInputsForMint(a,r);return{keep:c,send:u}}async send(t,e,n,r){this.assertAmount(t,"send");const{keysetId:i,includeFees:o=!1}=n||{};r=r??{send:this.defaultOutputType(),keep:this.defaultOutputType()};try{const a=this.defaultOutputType().type==="deterministic",u=d=>!d||d.type==="random"&&(!d.denominations||d.denominations.length===0);if(i||a||!u(r.send)||r.keep&&!u(r.keep)){const d=[];throw i&&d.push("keysetId override"),a&&d.push("wallet default is deterministic"),u(r.send)||d.push("non-default send output type"),r.keep&&!u(r.keep)&&d.push("non-default keep output type"),new Error(`Options require a swap: ${d.join(", ")}`)}const{keep:l,send:h}=this.sendOffline(t,e,{includeFees:o,exactMatch:!0,requireDleq:!1}),f=o?this.getFeesForProofs(h):0;if(Mt(h)===t+f)return this._logger.info("Successful exactMatch offline selection!"),{keep:l,send:h}}catch(a){const u=a instanceof Error?a.message:"Unknown error";this._logger.debug("ExactMatch offline selection failed.",{e:u})}const c=await this.prepareSwapToSend(t,e,n,r);return await this.completeSwap(c,n?.privkey)}async prepareSwapToSend(t,e,n,r){const{keysetId:i,includeFees:o=!1,onCountersReserved:c}=n||{};r=r??{send:this.defaultOutputType(),keep:this.defaultOutputType()};const a=this.getKeyset(i);let u=this.configureOutputs(t,a,r.send??this.defaultOutputType(),o);const l=this.preparedTotal(u),{keep:h,send:f}=this.selectProofsToSend(e,l,!0);if(f.length===0)throw new Error("Not enough funds available to send");const d=Mt(f),y=this.getFeesForProofs(f),m=d-y-l;this.failIf(m<0,"Not enough funds available for swap",{selectedSum:d,swapFee:y,sendAmount:l,changeAmount:m});let w=this.configureOutputs(m,a,r.keep??this.defaultOutputType(),!1,n?.proofsWeHave);const P=this.preparedTotal(w),C=await this.addCountersToOutputTypes(a.id,u,w);[u,w]=C.outputTypes,C.used&&this.safeCallback(c,C.used,{op:"send"}),this._logger.debug("send counters",{counter:C.used,sendOT:u,keepOT:w});const B=this.createOutputData(l,a,u),D=this.createOutputData(P,a,w);return{amount:t,fees:y,keysetId:a.id,inputs:f,sendOutputs:B,keepOutputs:D,unselectedProofs:h}}async completeSwap(t,e){const n=t?.keepOutputs?t.keepOutputs:[],r=t.sendOutputs?t.sendOutputs:[],i=t.unselectedProofs?t.unselectedProofs:[];e&&(t.inputs=this.signP2PKProofs(t.inputs,e,[...n,...r]));const o=this.createSwapTransaction(t.inputs,n,r),{signatures:c}=await this.mint.swap(o.payload);this.failIf(c.length<o.outputData.length,`Mint returned ${c.length} signatures, expected ${o.outputData.length}`);const a=this.getKeyset(t.keysetId),u=o.outputData.map((y,m)=>y.toProof(c[m],a)),l=Array(u.length),h=Array(o.keepVector.length);o.sortedIndices.forEach((y,m)=>{h[y]=o.keepVector[m],l[y]=u[m]});const f=[],d=[];return l.forEach((y,m)=>{h[m]?f.push(y):d.push(y)}),this._logger.debug("SEND COMPLETED",{unselectedProofs:i.map(y=>y.amount),keepProofs:f.map(y=>y.amount),sendProofs:d.map(y=>y.amount)}),{keep:[...f,...i],send:d}}selectProofsToSend(t,e,n=!1,r=!1){this.assertAmount(e,"selectProofsToSend");const{keep:i,send:o}=this._selectProofs(t,e,this._keyChain,n,r);return{keep:i,send:o}}signP2PKProofs(t,e,n,r){if(!se(t))return wn(t,e,this._logger);this.failIfNullish(n,"OutputData is required for SIG_ALL proof signing."),Ur(t);const[i,...o]=t;let c=i;const a=[Hr(t,n,r),Fr(t,n,r),qr(t,n,r)];for(const u of a)c=wn([c],e,this._logger,u)[0];return[c,...o]}getFeesForProofs(t){const e=t.reduce((n,r)=>n+this.getProofFeePPK(r),0);return Math.ceil(e/1e3)}getProofFeePPK(t){try{return this._keyChain.getKeyset(t.id).fee}catch(e){this.fail(`Could not get fee. No keyset found for keyset id: ${t.id}`,{e,keychain:this._keyChain.getKeysets()})}}getFeesForKeyset(t,e){try{const n=this._keyChain.getKeyset(e).fee;return Math.floor(Math.max((t*n+999)/1e3,0))}catch(n){this.fail(`No keyset found with ID ${e}`,{e:n})}}_prepareInputsForMint(t,e=!1){return t.map(n=>{const r=n.witness&&typeof n.witness!="string"?JSON.stringify(n.witness):n.witness,{dleq:i,p2pk_e:o,...c}=n;return e&&i?{...c,dleq:i,witness:r}:{...c,witness:r}})}decodeToken(t){const e=this._keyChain.getAllKeysetIds();return xi(t,e)}async batchRestore(t=300,e=100,n=0,r){const i=Math.ceil(t/e),o=[];let c,a=0;for(;a<i;){const u=await this.restore(n,e,{keysetId:r});u.proofs.length>0?(a=0,o.push(...u.proofs),c=u.lastCounterWithSignature):a++,n+=e}return{proofs:o,lastCounterWithSignature:c}}async restore(t,e,n){const{keysetId:r}=n||{},i=this.getKeyset(r);this.failIfNullish(this._seed,"Cashu Wallet must be initialized with a seed to use restore");const o=Array(e).fill(0),c=st.createDeterministicData(0,this._seed,t,i,o),{outputs:a,signatures:u}=await this.mint.restore({outputs:c.map(d=>d.blindedMessage)}),l={};a.forEach((d,y)=>l[d.B_]=u[y]);const h=[];let f;for(let d=0;d<c.length;d++){const y=l[c[d].blindedMessage.B_];y&&(f=t+d,c[d].blindedMessage.amount=y.amount,h.push(c[d].toProof(y,i)))}return{proofs:h,lastCounterWithSignature:f}}async createMintQuote(t,e){return this.createMintQuoteBolt11(t,e)}async createMintQuoteBolt11(t,e){this.assertAmount(t,"createMintQuoteBolt11"),e&&(this.getMintInfo().supportsNut04Description("bolt11",this._unit)||this.fail("Mint does not support description for bolt11"));const n={unit:this._unit,amount:t,description:e},r=await this.mint.createMintQuoteBolt11(n);return{...r,amount:r.amount||t,unit:r.unit||this._unit}}async createLockedMintQuote(t,e,n){this.assertAmount(t,"createLockedMintQuote");const{supported:r}=this.getMintInfo().isSupported(20);this.failIf(!r,"Mint does not support NUT-20");const i={unit:this._unit,amount:t,description:n,pubkey:e},o=await this.mint.createMintQuoteBolt11(i);this.failIf(typeof o.pubkey!="string","Mint returned unlocked mint quote");const c=o.pubkey;return{...o,pubkey:c,amount:o.amount||t,unit:o.unit||this._unit}}async createMintQuoteBolt12(t,e){const n=this.getMintInfo();e?.description&&!n.supportsNut04Description("bolt12",this._unit)&&this.fail("Mint does not support description for bolt12");const r={pubkey:t,unit:this._unit,amount:e?.amount,description:e?.description};return this.mint.createMintQuoteBolt12(r)}async checkMintQuote(t){return this.checkMintQuoteBolt11(t)}async checkMintQuoteBolt11(t){const e=typeof t=="string"?t:t.quote,n=await this.mint.checkMintQuoteBolt11(e);return typeof t=="string"?n:{...n,amount:n.amount||t.amount,unit:n.unit||t.unit}}async checkMintQuoteBolt12(t){return this.mint.checkMintQuoteBolt12(t)}async mintProofs(t,e,n,r){return this._mintProofs("bolt11",t,e,n,r)}async mintProofsBolt11(t,e,n,r){return this._mintProofs("bolt11",t,e,n,r)}async mintProofsBolt12(t,e,n,r,i){return this._mintProofs("bolt12",t,e,{...r,privkey:n},i)}async _mintProofs(t,e,n,r,i){this.assertAmount(e,`_mintProofs: ${t}`),i=i??this.defaultOutputType();const{privkey:o,keysetId:c,proofsWeHave:a,onCountersReserved:u}=r??{},l=this.getKeyset(c);let h=this.configureOutputs(e,l,i,!1,a);const f=this.preparedTotal(h),d=await this.addCountersToOutputTypes(l.id,h);[h]=d.outputTypes,d.used&&this.safeCallback(u,d.used,{op:"mintProofs"}),this._logger.debug("mint counter",{counter:d.used,mintOT:h});const y=this.createOutputData(f,l,h),m=y.map(C=>C.blindedMessage),w={outputs:m,quote:typeof n=="string"?n:n.quote};if(typeof n!="string"&&n.pubkey){this.failIf(!o,"Can not sign locked quote without private key");const C=Jr(o,n.quote,m);w.signature=C}let P;return t==="bolt12"?{signatures:P}=await this.mint.mintBolt12(w):{signatures:P}=await this.mint.mintBolt11(w),this.failIf(P.length!==y.length,`Mint returned ${P.length} signatures, expected ${y.length}`),this._logger.debug("MINT COMPLETED",{amounts:y.map(C=>C.blindedMessage.amount)}),y.map((C,B)=>C.toProof(P[B],l))}async createMeltQuote(t,e){return this.createMeltQuoteBolt11(t,e)}async createMeltQuoteBolt11(t,e){e!==void 0&&(this.failIf(Ii(t),"amountMsat supplied but invoice already contains an amount. Leave amountMsat undefined for non-zero invoices."),this.assertAmount(e,"createMeltQuoteBolt11"));const n=this._mintInfo?.supportsAmountless?.("bolt11",this._unit)??!1,r={unit:this._unit,request:t,...n&&e!==void 0?{options:{amountless:{amount_msat:e}}}:{}},i=await this.mint.createMeltQuoteBolt11(r);return{...i,unit:i.unit||this._unit,request:i.request||t}}async createMeltQuoteBolt12(t,e){return this.mint.createMeltQuoteBolt12({unit:this._unit,request:t,options:e?{amountless:{amount_msat:e}}:void 0})}async createMultiPathMeltQuote(t,e){this.assertAmount(e,"createMultiPathMeltQuote");const{supported:n,params:r}=this.getMintInfo().isSupported(15);this.failIf(!n,"Mint does not support NUT-15"),this.failIf(!r?.some(c=>c.method==="bolt11"&&c.unit===this._unit),`Mint does not support MPP for bolt11 and ${this._unit}`);const i={unit:this._unit,request:t,options:{mpp:{amount:e}}};return{...await this.mint.createMeltQuoteBolt11(i),request:t,unit:this._unit}}async checkMeltQuote(t){return this.checkMeltQuoteBolt11(t)}async checkMeltQuoteBolt11(t){const e=typeof t=="string"?t:t.quote,n=await this.mint.checkMeltQuoteBolt11(e);return typeof t=="string"?n:{...n,request:t.request,unit:t.unit}}async checkMeltQuoteBolt12(t){return this.mint.checkMeltQuoteBolt12(t)}async meltProofs(t,e,n,r){return this.meltProofsBolt11(t,e,n,r)}async meltProofsBolt11(t,e,n,r){const i=await this.prepareMelt("bolt11",t,e,n,r),o=typeof n?.onChangeOutputsCreated=="function";return this.completeMelt(i,n?.privkey,o)}async meltProofsBolt12(t,e,n,r){const i=await this.prepareMelt("bolt12",t,e,n,r),o=typeof n?.onChangeOutputsCreated=="function";return this.completeMelt(i,n?.privkey,o)}async prepareMelt(t,e,n,r,i){i=i??this.defaultOutputType();const{keysetId:o,onChangeOutputsCreated:c,onCountersReserved:a}=r||{},u=this.getKeyset(o),l=Mt(n),h=l-e.amount;let f=[];if(this.failIf(h<0,"Not enough proofs to cover amount + fee reserve",{sendAmount:l,quoteAmount:e.amount}),i.type==="custom")f=i.data;else if(h>0){let y=Math.ceil(Math.log2(h))||1;y<0&&(y=0);const m=y?new Array(y).fill(0):[];this._logger.debug("Creating NUT-08 blanks for fee reserve",{feeReserve:h,denominations:m});let w={...i,denominations:m};const P=await this.addCountersToOutputTypes(u.id,w);[w]=P.outputTypes,P.used&&this.safeCallback(a,P.used,{op:"meltProofs"}),this._logger.debug("melt counter",{counter:P.used,meltOT:w}),f=this.createOutputData(0,u,w)}const d={method:t,inputs:n,outputData:f,keysetId:u.id,quote:e};if(f.length>0){const y={method:t,payload:{quote:e.quote,inputs:n,outputs:f.map(m=>m.blindedMessage)},outputData:f,keyset:u,quote:e};this.safeCallback(c,y,{op:"meltProofs"}),this.on._emitMeltBlanksCreated(y)}return d}async completeMelt(t,e,n){t=this.maybeConvertMeltBlanks(t);let r=t.inputs;const i=t.outputData.map(f=>f.blindedMessage),o=t.quote.quote,c=this.getKeyset(t.keysetId);e&&(r=this.signP2PKProofs(r,e,t.outputData,o)),r=this._prepareInputsForMint(r);const a={quote:o,inputs:r,outputs:i},u=t.method==="bolt11"?await this.mint.meltBolt11(a,{preferAsync:n}):await this.mint.melt(t.method,a,{preferAsync:n});this.failIf((u.change?.length??0)>t.outputData.length,`Mint returned ${u.change?.length??0} signatures, but only ${t.outputData.length} blanks were provided`);const l=u.change?.map((f,d)=>t.outputData[d].toProof(f,c))??[];return n?this._logger.debug("ASYNC MELT REQUESTED",u):this._logger.debug("MELT COMPLETED",{changeAmounts:l.map(f=>f.amount)}),{quote:{...t.quote,...u},change:l}}maybeConvertMeltBlanks(t){if(!("payload"in t))return t;this._logger.warn("MeltBlanks objects and the meltBlanksCreated / onChangeOutputsCreated events are deprecated. Please use wallet.prepareMelt() to create a MeltPreview instead.");const{method:e,payload:n,outputData:r,keyset:i,quote:o}=t;return{method:e,inputs:n.inputs,outputData:r,keysetId:i.id,quote:o}}async checkProofsStates(t){const e=new TextEncoder,n=t.map(o=>Qt(e.encode(o.secret)).toHex(!0)),r=100,i=[];for(let o=0;o<n.length;o+=r){const c=n.slice(o,o+r),{states:a}=await this.mint.check({Ys:c}),u={};a.forEach(l=>{u[l.Y]=l});for(let l=0;l<c.length;l++){const h=u[c[l]];this.failIfNullish(h,"Could not find state for proof with Y: "+c[l]),i.push(h)}}return i}async groupProofsByState(t){const e=await this.checkProofsStates(t),n={unspent:[],pending:[],spent:[]};for(let r=0;r<e.length;r++){const i=t[r];switch(e[r].state){case ve.UNSPENT:n.unspent.push(i);break;case ve.PENDING:n.pending.push(i);break;case ve.SPENT:n.spent.push(i);break}}return n}}const Ne=class Ne{constructor(t,e){this.tokens={},this.pool=[],this.desiredPoolSize=10,this.maxPerMint=10,this.mintUrl=t,this.req=e?.request??Rs,this.logger=e?.logger??X,this.desiredPoolSize=Math.max(1,e?.desiredPoolSize??this.desiredPoolSize),this.maxPerMint=Math.max(1,e?.maxPerMint??this.maxPerMint)}attachOIDC(t){return this.oidc=t,this.oidc.addTokenListener(e=>this.updateFromOIDC(e)),this}get poolSize(){return this.pool.length}get poolTarget(){return this.desiredPoolSize}get activeAuthKeysetId(){try{return this.keychain?.getCheapestKeyset().id}catch{return}}get hasCAT(){return!!this.tokens.accessToken}getCAT(){return this.tokens.accessToken}setCAT(t){this.tokens.accessToken=t,t||(this.tokens.refreshToken=void 0,this.tokens.expiresAt=void 0)}async ensureCAT(t){return this.validForAtLeast(t)?this.tokens.accessToken:!this.oidc||!this.tokens.refreshToken?this.tokens.accessToken:(this.inflightRefresh||(this.inflightRefresh=(async()=>{try{const e=await this.oidc.refresh(this.tokens.refreshToken);this.updateFromOIDC(e)}catch(e){this.logger.warn("AuthManager: CAT refresh failed",{err:e})}finally{this.inflightRefresh=void 0}})()),await this.inflightRefresh,this.validForAtLeast(0)?this.tokens.accessToken:void 0)}validForAtLeast(t=Ne.MIN_VALID_SECS){const{accessToken:e,expiresAt:n}=this.tokens;return e?n?Date.now()+t*1e3<n:!0:!1}updateFromOIDC(t){if(!t.access_token)return;const e=Date.now();if(this.tokens.accessToken=t.access_token,t.refresh_token&&(this.tokens.refreshToken=t.refresh_token),typeof t.expires_in=="number"&&t.expires_in>0)this.tokens.expiresAt=e+t.expires_in*1e3;else{const n=this.parseJwtExpSec(t.access_token);this.tokens.expiresAt=n?n*1e3:void 0}this.logger.debug("AuthManager: OIDC tokens updated",{expiresAt:this.tokens.expiresAt})}async ensure(t){if(await this.init(),this.pool.length>=t)return;const e=Math.max(this.desiredPoolSize,t),n=this.getBatMaxMint(),r=Math.min(e-this.pool.length,n);r<=0||await this.topUp(r)}async getBlindAuthToken({method:t,path:e}){return this.info&&!this.info.requiresBlindAuthToken(t,e)&&this.logger.warn("Endpoint is not marked as protected by NUT-22; still issuing BAT",{method:t,path:e}),this.withLock(async()=>{if(await this.ensure(1),this.pool.length===0)throw new Error("AuthManager: no BATs available and minting failed");const n=this.pool.pop();return this.logger.debug("AuthManager: BAT requested",{method:t,path:e,remaining:this.pool.length}),Aa(n)})}importPool(t,e="replace"){e==="replace"&&(this.pool=[]);const n=new Map(this.pool.map(r=>[r.secret,r]));for(const r of t)!r||!r.secret||!r.C||!r.id||n.has(r.secret)||(this.pool.push(r),n.set(r.secret,r))}exportPool(){return this.pool.map(t=>({...t,dleq:t.dleq?{...t.dleq}:void 0}))}parseJwtExpSec(t){if(!t)return;const e=t.split(".");if(e.length===3)try{const n=N.toString(N.fromBase64(e[1])),r=JSON.parse(n),i=typeof r.exp=="number"?r.exp:Number(r.exp);if(Number.isFinite(i)&&i>0)return i}catch{this.logger.warn("JWT access token was malformed.",{token:t})}}async withLock(t){const e=this.lockChain??Promise.resolve();let n;const r=new Promise(o=>{n=o}),i=e.then(()=>r);this.lockChain=i;try{return await e,await t()}finally{n(),this.lockChain===i&&(this.lockChain=void 0)}}async init(){if(!this.info){const t=await this.req({endpoint:ft(this.mintUrl,"/v1/info"),method:"GET"});this.info=new ce(t)}if(!this.keychain){const[t,e]=await Promise.all([this.req({endpoint:ft(this.mintUrl,"/v1/auth/blind/keysets"),method:"GET"}),this.req({endpoint:ft(this.mintUrl,"/v1/auth/blind/keys"),method:"GET"})]);this.keychain=new bt(this.mintUrl,"auth",t.keysets,e.keysets),this.keychain.getCheapestKeyset()}}getBatMaxMint(){if(!this.info)throw new Error("AuthManager: mint info not loaded");const e=this.info.nuts[22]?.bat_max_mint??this.maxPerMint;return Math.max(1,Math.min(this.maxPerMint,e))}getActiveKeys(){if(!this.keychain)throw new Error("AuthManager: keyset not loaded for active keyset");return this.keychain.getCheapestKeyset()}async topUp(t){if(!this.info)throw new Error("AuthManager: mint info not loaded");const e=this.info.requiresClearAuthToken("POST","/v1/auth/blind/mint");let n;if(e&&(n=await this.ensureCAT(),!n))throw new Error("AuthManager: Clear-auth token required for /v1/auth/blind/mint but not available. Authenticate with the mint to obtain a CAT first.");const r=this.getActiveKeys(),i=st.createRandomData(t,r),o={outputs:i.map(l=>l.blindedMessage)},c={};n&&(c["Clear-auth"]=n);const a=await this.req({endpoint:ft(this.mintUrl,"/v1/auth/blind/mint"),method:"POST",headers:c,requestBody:o});if(!Array.isArray(a?.signatures)||a.signatures.length!==i.length)throw new Error("AuthManager: bad BAT mint response");const u=i.map((l,h)=>l.toProof(a.signatures[h],r));for(const l of u)if(!is(l,r))throw new Error("AuthManager: mint returned BAT with invalid DLEQ");this.pool.push(...u),this.logger.debug("AuthManager: performed topUp",{minted:u.length,pool:this.pool.length})}};Ne.MIN_VALID_SECS=30;let Le=Ne;function Aa(s){const t={id:s.id,secret:s.secret,C:s.C};return`authA${Ds(t)}`}async function Pa(s,t){const e=new Le(s,{desiredPoolSize:t?.authPool??10,logger:t?.logger}),n=new Je(s,{authProvider:e,logger:t?.logger}),r=await n.oidcAuth({...t?.oidc,logger:t?.logger,onTokens:o=>e.setCAT(o.access_token)});e.attachOIDC(r);const i=new tn(n,{authProvider:e,logger:t?.logger});return await i.loadMint(),{mint:n,auth:e,oidc:r,wallet:i}}exports.AuthManager=Le;exports.CheckStateEnum=ve;exports.ConsoleLogger=qi;exports.HttpResponseError=Wt;exports.KeyChain=bt;exports.Keyset=Gt;exports.MeltBuilder=_n;exports.MeltQuoteState=Vt;exports.MessageNode=Ai;exports.MessageQueue=Pi;exports.Mint=Je;exports.MintBuilder=vn;exports.MintInfo=ce;exports.MintOperationError=De;exports.MintQuoteState=Oe;exports.NetworkError=Re;exports.OIDCAuth=Xe;exports.OutputData=st;exports.P2BK_DST=mn;exports.P2PKBuilder=os;exports.PaymentRequest=ie;exports.PaymentRequestTransportType=re;exports.ReceiveBuilder=Li;exports.SendBuilder=Oi;exports.WSConnection=Bi;exports.Wallet=tn;exports.WalletCounters=Ri;exports.WalletEvents=Ni;exports.WalletOps=Ki;exports.assertSecretKind=Hn;exports.assertSigAllInputs=Ur;exports.bigIntStringify=aa;exports.blindMessage=te;exports.buildInterimP2PKSigAllMessage=Fr;exports.buildLegacyP2PKSigAllMessage=Hr;exports.buildP2PKSigAllMessage=qr;exports.bytesToNumber=ca;exports.checkResponse=fa;exports.constructProofFromPromise=br;exports.createAuthWallet=Pa;exports.createBlindSignature=dc;exports.createDLEQProof=Uc;exports.createHTLCHash=zr;exports.createHTLCsecret=Fc;exports.createNewMintKeys=Ic;exports.createP2PKsecret=Cc;exports.createRandomBlindedMessage=gc;exports.createRandomRawBlindedMessage=mr;exports.createRandomSecretKey=We;exports.createSecret=Fn;exports.decodePaymentRequest=da;exports.deepEqual=En;exports.deriveBlindingFactor=Vr;exports.deriveKeysetId=Ye;exports.deriveP2BKBlindedPubkeys=Tr;exports.deriveP2BKSecretKey=Br;exports.deriveP2BKSecretKeys=Ir;exports.deriveSecret=jr;exports.deserializeMintKeys=Tc;exports.deserializeProof=pc;exports.getDataField=jn;exports.getDecodedToken=xi;exports.getDecodedTokenBinary=wa;exports.getEncodedToken=ua;exports.getEncodedTokenBinary=ma;exports.getEncodedTokenV3=bi;exports.getEncodedTokenV4=ki;exports.getHTLCWitnessPreimage=Yr;exports.getKeepAmounts=wi;exports.getKeysetAmounts=ts;exports.getKeysetIdInt=yr;exports.getP2PKExpectedKWitnessPubkeys=Nc;exports.getP2PKExpectedWitnessPubkeys=zn;exports.getP2PKLockState=fe;exports.getP2PKLocktime=Cr;exports.getP2PKNSigs=Kr;exports.getP2PKNSigsRefund=Or;exports.getP2PKSigFlag=Me;exports.getP2PKWitnessPubkeys=Ge;exports.getP2PKWitnessRefundkeys=Zt;exports.getP2PKWitnessSignatures=ze;exports.getPubKeyFromPrivKey=Pr;exports.getSecretData=Wn;exports.getSecretKind=$n;exports.getTag=je;exports.getTagInt=Ve;exports.getTagScalar=Gn;exports.getTags=Vn;exports.getTokenMetadata=la;exports.getValidSigners=Be;exports.handleTokens=ns;exports.hasCorrespondingKey=es;exports.hasNonHexId=Qe;exports.hasP2PKSignedProof=Kc;exports.hasTag=Mc;exports.hasValidDleq=is;exports.hashToCurve=Qt;exports.hash_e=Un;exports.hexToNumber=oe;exports.injectWebSocketImpl=ji;exports.invoiceHasAmountInHRP=Ii;exports.isHTLCSpendAuthorised=$c;exports.isObj=lt;exports.isP2PKSigAll=se;exports.isP2PKSpendAuthorised=Rr;exports.isValidHex=Lt;exports.joinUrls=ft;exports.maybeDeriveP2BKPrivateKeys=Dr;exports.meetsSignerThreshold=yc;exports.mergeUInt8Arrays=Si;exports.numberToHexPadded64=Ke;exports.parseHTLCSecret=Hc;exports.parseP2PKSecret=ot;exports.parseSecret=he;exports.pointFromBytes=fc;exports.pointFromHex=It;exports.sanitizeUrl=ss;exports.schnorrSignMessage=qn;exports.schnorrVerifyMessage=le;exports.selectProofsRGLI=Ci;exports.serializeMintKeys=Ar;exports.serializeProof=Er;exports.setGlobalRequestOptions=Hi;exports.signMintQuote=Jr;exports.signP2PKProof=Nr;exports.signP2PKProofs=wn;exports.signP2PKSecret=Oc;exports.sortProofsById=ha;exports.splitAmount=wt;exports.stripDleq=rs;exports.sumProofs=Mt;exports.unblindSignature=wr;exports.validateAmount=Ze;exports.verifyDLEQProof=$r;exports.verifyDLEQProof_reblind=Wr;exports.verifyHTLCHash=Qr;exports.verifyHTLCSpendingConditions=Zr;exports.verifyKeysetId=ga;exports.verifyMintQuoteSignature=Wc;exports.verifyP2PKSecretSignature=Lc;exports.verifyP2PKSig=Rc;exports.verifyP2PKSpendingConditions=Qn;exports.verifyProof=Bc;
//# sourceMappingURL=cashu-ts.cjs.map
