import { WeierstrassPoint } from '@noble/curves/abstract/weierstrass.js';

/**
 * Assert that a Secret is of the expected kind.
 *
 * @param allowed - NUT-10 Kind(s) allowed.
 * @param secret - The Proof secret.
 * @returns Parsed Secret if the kind matches.
 * @throws If secret kind is not as expected.
 */
export declare function assertSecretKind(allowed: SecretKind | SecretKind[], secret: Secret | string): Secret;

/* Excluded from this release type: assertSigAllInputs */

/**
 * AuthManager.
 *
 * - Owns CAT lifecycle (stores, optional refresh via attached OIDCAuth)
 * - Mints and serves BATs (NUT-22)
 * - Validates DLEQs for BATs per NUT-12.
 * - Supplies serialized BATs for 'Blind-auth' and CAT for 'Clear-auth'
 */
export declare class AuthManager implements AuthProvider {
    private readonly mintUrl;
    private readonly req;
    private readonly logger;
    private info?;
    private lockChain?;
    private inflightRefresh?;
    private static readonly MIN_VALID_SECS;
    private oidc?;
    private tokens;
    private pool;
    private desiredPoolSize;
    private maxPerMint;
    private keychain?;
    constructor(mintUrl: string, opts?: AuthManagerOptions);
    /**
     * Attach an OIDCAuth instance so this manager can refresh CATs. Registers a listener to update
     * internal CAT/refresh state on new tokens.
     */
    attachOIDC(oidc: OIDCAuth): this;
    get poolSize(): number;
    get poolTarget(): number;
    get activeAuthKeysetId(): string | undefined;
    get hasCAT(): boolean;
    getCAT(): string | undefined;
    setCAT(cat: string | undefined): void;
    /**
     * Ensure a valid CAT is available (refresh if expiring soon). Returns a token safe to send right
     * now, or undefined if unobtainable.
     */
    ensureCAT(minValidSecs?: number): Promise<string | undefined>;
    private validForAtLeast;
    private updateFromOIDC;
    /**
     * Ensure there are enough BAT tokens (topping up if needed)
     *
     * @param minTokens Minimum tokens needed.
     */
    ensure(minTokens: number): Promise<void>;
    /**
     * Gets a Blind Authentication Token (BAT)
     *
     * @param {method, path} to Call (not used in our implementation)
         * @returns The serialized BAT ready to insert into request header.
         */
     getBlindAuthToken({ method, path, }: {
         method: 'GET' | 'POST';
         path: string;
     }): Promise<string>;
     /**
      * Replace or merge the current BAT pool with previously persisted BATs.
      */
     importPool(proofs: Proof[], mode?: 'replace' | 'merge'): void;
     /**
      * Return a deep-copied snapshot of the current BAT pool (full Proofs, including dleq).
      */
     exportPool(): Proof[];
     /**
      * Extract exp, seconds since epoch, from a JWT access token.
      */
     private parseJwtExpSec;
     /**
      * Simple mutex lock - chains promises in order.
      */
     private withLock;
     /**
      * Initialise mint info and auth keysets/keys as needed.
      */
     private init;
     /**
      * Gets the BAT minting limit: lower of manager limit and Mint’s NUT-22 limit.
      */
     private getBatMaxMint;
     private getActiveKeys;
     /**
      * Mint a batch of BATs using the current CAT if the endpoint is protected by NUT-21.
      */
     private topUp;
    }

    export declare type AuthManagerOptions = {
        /**
         * Hard limit to target when minting BATs in one request. If omitted, we'll read
         * `nuts['22'].bat_max_mint` from the mint "/v1/info" endpoint.
         */
        maxPerMint?: number;
        /**
         * Desired BAT pool size. We’ll top-up to min(desiredPoolSize, bat_max_mint) on demand.
         */
        desiredPoolSize?: number;
        /**
         * Custom request fn (e.g. for tests or host env).
         */
        request?: RequestFn;
        /**
         * Logger.
         */
        logger?: Logger;
    };

    export declare interface AuthProvider {
        getBlindAuthToken(input: {
            method: 'GET' | 'POST';
            path: string;
        }): Promise<string>;
        ensure?(minTokens: number): Promise<void>;
        getCAT(): string | undefined;
        setCAT(cat: string | undefined): void;
        /**
         * Ensure a valid CAT is available, refreshing if expiring soon. Return a token that is safe to
         * send right now, or undefined if not obtainable.
         */
        ensureCAT?(minValiditySec?: number): Promise<string | undefined>;
    }

    export declare function bigIntStringify<T>(_key: unknown, value: T): string | T;

    /**
     * @deprecated - Use {@link RawBlindedMessage}.
     */
    export declare type BlindedMessage = RawBlindedMessage;

    /**
     * Blind a secret message.
     *
     * @param secret A UTF-8 byte encoded string.
     * @param r Optional. Deterministic blinding scalar to use (eg: for testing / seeded)
     * @returns A RawBlindedMessage: {B_, r, secret}
     */
    export declare function blindMessage(secret: Uint8Array, r?: bigint): RawBlindedMessage;

    export declare type BlindSignature = {
        C_: WeierstrassPoint<bigint>;
        amount: number;
        id: string;
    };

    /**
     * Payload for requesting a BOLT12 melt quote. Used to pay Lightning Network offers.
     *
     * @deprecated - Use MeltQuoteBolt12Request.
     */
    export declare type Bolt12MeltQuotePayload = MeltQuoteBolt12Request;

    /**
     * @deprecated - Use MeltQuoteBolt12Response.
     */
    export declare type Bolt12MeltQuoteResponse = MeltQuoteBolt12Response;

    /**
     * Payload for requesting a BOLT12 mint quote.
     *
     * @deprecated - Use MintQuoteBolt12Request.
     */
    export declare type Bolt12MintQuotePayload = MintQuoteBolt12Request;

    /**
     * Response from the mint after requesting a BOLT12 mint quote. Contains a Lightning Network offer
     * and tracks payment/issuance amounts.
     *
     * @deprecated - Use MintQuoteBolt12Response.
     */
    export declare type Bolt12MintQuoteResponse = MintQuoteBolt12Response;

    /* Excluded from this release type: buildInterimP2PKSigAllMessage */

    /* Excluded from this release type: buildLegacyP2PKSigAllMessage */

    /* Excluded from this release type: buildP2PKSigAllMessage */

    /**
     * Converts a bytes array to a number.
     *
     * @deprecated We now use Bytes.toBigInt internally for better performance. This function is kept
     *   public for backward compatibility.
     * @param bytes To convert to number.
     * @returns Number as bigint.
     */
    export declare function bytesToNumber(bytes: Uint8Array): bigint;

    export declare type CancellerLike = SubscriptionCanceller | Promise<SubscriptionCanceller>;

    export declare function checkResponse(data: {
        error?: string;
        detail?: string;
    }): void;

    /**
     * Enum for the state of a proof.
     */
    export declare const CheckStateEnum: {
        readonly UNSPENT: "UNSPENT";
        readonly PENDING: "PENDING";
        readonly SPENT: "SPENT";
    };

    export declare type CheckStateEnum = (typeof CheckStateEnum)[keyof typeof CheckStateEnum];

    /**
     * Payload that needs to be sent to the mint when checking for spendable proofs.
     */
    export declare type CheckStatePayload = {
        /**
         * The Y = hash_to_curve(secret) of the proofs to be checked.
         */
        Ys: string[];
    };

    /**
     * Response when checking proofs if they are spendable. Should not rely on this for receiving, since
     * it can be easily cheated.
     */
    export declare type CheckStateResponse = {
        states: ProofState[];
    };

    /**
     * Outputs messages to the console based on the specified log level.
     *
     * Supports placeholder substitution in messages (e.g., `{key}`) using values from the optional
     * `context` object. Context keys not used in substitution are appended to the output as additional
     * data. Each log message is prefixed with the log level in square brackets (e.g., `[INFO]`).
     *
     * @example Const logger = new ConsoleLogger(LogLevel.DEBUG); logger.info('User {username} logged
     * in', { username: 'alice', ip: '127.0.0.1' }); // Output: [INFO] User alice logged in { ip:
     * "127.0.0.1" }
     */
    export declare class ConsoleLogger implements Logger {
        private minLevel;
        constructor(minLevel?: LogLevel);
        private should;
        private method;
        private header;
        private flattenContext;
        private emit;
        error(msg: string, ctx?: Record<string, unknown>): void;
        warn(msg: string, ctx?: Record<string, unknown>): void;
        info(msg: string, ctx?: Record<string, unknown>): void;
        debug(msg: string, ctx?: Record<string, unknown>): void;
        trace(msg: string, ctx?: Record<string, unknown>): void;
        log(level: LogLevel, message: string, context?: Record<string, unknown>): void;
    }

    export declare function constructProofFromPromise(promise: BlindSignature, r: bigint, secret: Uint8Array, key: WeierstrassPoint<bigint>): RawProof;

    /**
     * Usable counters in range is [start, start+count-1]
     *
     * @example // Start: 5, count: 3 => 5,6,7.
     */
    export declare interface CounterRange {
        start: number;
        count: number;
    }

    export declare interface CounterSource {
        /**
         * Reserve n counters for a keyset.
         *
         * N may be 0. In that case the call MUST NOT mutate state and MUST return { start: currentNext,
         * count: 0 }, effectively a read only peek of the cursor.
         */
        reserve(keysetId: string, n: number): Promise<CounterRange>;
        /**
         * Monotonic bump, ensure the next counter is at least minNext.
         */
        advanceToAtLeast(keysetId: string, minNext: number): Promise<void>;
        /**
         * Optional introspection.
         */
        snapshot?(): Promise<Record<string, number>>;
        /**
         * Optional hard set, useful for tests or migrations.
         */
        setNext?(keysetId: string, next: number): Promise<void>;
    }

    /**
     * High-level helper to create a fully authenticated wallet session.
     *
     * @remarks
     * Like a dependency injector, it wires AuthManager->Mint->OIDCAuth->Wallet in the correct order.
     * Wallet is returned ready to use.
     * @param mintUrl URL of the mint to connect to.
     * @param options.authPool Optional. Desired BAT pool size (default 10)
     * @param options.oidc Optional. Options for OIDCAuth (scope, clientId, logger, etc.)
     * @returns {mint, auth, oidc, wallet} — hydrated, ready to use.
         * @throws If mint does not require authentication.
         */
     export declare function createAuthWallet(mintUrl: string, options?: {
         authPool?: number;
         oidc?: OIDCAuthOptions;
         logger?: Logger;
     }): Promise<{
         mint: Mint;
         auth: AuthManager;
         oidc: OIDCAuth;
         wallet: Wallet;
     }>;

     export declare function createBlindSignature(B_: WeierstrassPoint<bigint>, privateKey: Uint8Array, amount: number, id: string): BlindSignature;

     /**
      * !!! WARNING !!! Not recommended for production use, due to non-constant time operations See:
      * https://github.com/cashubtc/cashu-crypto-ts/pull/2 for more details See:
      * https://en.wikipedia.org/wiki/Timing_attack for information about timing attacks.
      */
     export declare const createDLEQProof: (B_: WeierstrassPoint<bigint>, a: Uint8Array) => DLEQ;

     /**
      * Create an HTLC hash/preimage pair.
      *
      * @param preimage - Optional. Preimage to use (Default: random preimage)
      * @returns Hash and preimage pair.
      * @throws If the preimage supplied is not a 64-char hex string.
      */
     export declare function createHTLCHash(preimage?: string): {
         hash: string;
         preimage: string;
     };

     /**
      * Create an HTLC secret.
      *
      * @remarks
      * Use `createHTLCHash()` for hash creation.
      * @param hash - The HTLC hash to add to Secret.data.
      * @param tags - Optional. Additional P2PK tags.
      */
     export declare function createHTLCsecret(hash: string, tags?: string[][]): string;

     /**
      * Creates new mint keys.
      *
      * @param pow2height Number of powers of 2 to create (Max 65).
      * @param seed (Optional). Seed for key derivation.
      * @param options.expiry (optional) expiry of the keyset.
      * @param options.input_fee_ppk (optional) Input fee for keyset (in ppk)
      * @param options.unit (optional) the unit of the keyset. Default: sat.
      * @param options.versionByte (optional) version of the keyset ID. Default: 1.
      * @returns KeysetPair object.
      * @throws If keyset versionByte is not valid.
      */
     export declare function createNewMintKeys(pow2height: IntRange<0, 65>, seed?: Uint8Array, options?: {
         expiry?: number;
         input_fee_ppk?: number;
         unit?: string;
         versionByte?: number;
     }): KeysetPair;

     /**
      * Create a P2PK secret.
      *
      * @param pubkey - The pubkey to add to Secret.data.
      * @param tags - Optional. Additional P2PK tags.
      */
     export declare function createP2PKsecret(pubkey: string, tags?: string[][]): string;

     /**
      * @deprecated - Use {@link createRandomRawBlindedMessage}
      */
     export declare function createRandomBlindedMessage(_deprecated?: PrivKey): RawBlindedMessage;

     /**
      * Creates a random blinded message.
      *
      * @remarks
      * The secret is a UTF-8 encoded 64-character lowercase hex string, generated from 32 random bytes
      * as recommended by NUT-00.
      * @returns A RawBlindedMessage: {B_, r, secret}
      */
     export declare function createRandomRawBlindedMessage(): RawBlindedMessage;

     export declare function createRandomSecretKey(): Uint8Array<ArrayBufferLike>;

     /**
      * Create a NUT-10 well known secret.
      *
      * @param kind - The secret kind (P2PK, HTLC, etc)
      * @param pubkey - The pubkey to add to Secret.data.
      * @param tags - Optional. Additional P2PK tags.
      */
     export declare function createSecret(kind: SecretKind, data: string, tags?: string[][]): string;

     export declare function decodePaymentRequest(paymentRequest: string): PaymentRequest_2;

     /**
      * Utility function for deep equality comparison of objects.
      */
     export declare function deepEqual<T>(a: T, b: T): boolean;

     export declare const deriveBlindingFactor: (seed: Uint8Array, keysetId: string, counter: number) => Uint8Array;

     /**
      * Returns the keyset id of a set of keys.
      *
      * @param keys Keys object to derive keyset id from.
      * @param options.expiry (optional) expiry of the keyset.
      * @param options.input_fee_ppk (optional) Input fee for keyset (in ppk)
      * @param options.unit (optional) the unit of the keyset. Default: sat.
      * @param options.versionByte (optional) version of the keyset ID. Default: 1.
      * @param options.isDeprecatedBase64 (optional) version of the keyset ID. Default: false.
      * @returns Keyset id of the keys.
      * @throws If keyset versionByte is not valid.
      */
     export declare function deriveKeysetId(keys: Keys, options?: DeriveKeysetIdOptions): string;

     /**
      * @deprecated Use the new options signature, which also adds keysets v2 support:
      *
      *       deriveKeysetId(keys, { unit, expiry, versionByte, input_fee_ppk });
      */
     export declare function deriveKeysetId(keys: Keys, unit?: string, expiry?: number, versionByte?: number, isDeprecatedBase64?: boolean): string;

     export declare type DeriveKeysetIdOptions = {
         expiry?: number;
         input_fee_ppk?: number;
         unit?: string;
         versionByte?: number;
         isDeprecatedBase64?: boolean;
     };

     /**
      * Blind a sequence of public keys using ECDH derived tweaks, one tweak per slot.
      *
      * @remarks
      * Security note: "Ehex" must never be reused. Doing so would create linkability and leak privacy.
      * The only exception is for SIG_ALL proofs, as all secret tags must match.
      *
      * This is the Sender side API.
      * @param pubkeys Ordered SEC1 compressed pubkeys, [data, ...pubkeys, ...refund]
      * @param keysetId Hex keyset identifier, bound into the tweak.
      * @param eBytes Optional. Fixed ephemeral secret key to use (eg for SIG_ALL / testing)
      * @returns Blinded pubkeys in the same order, and Ehex as SEC1 compressed hex, 33 bytes.
      * @throws If a blinded key is at infinity.
      * @experimental
      */
     export declare function deriveP2BKBlindedPubkeys(pubkeys: string[], keysetId: string, eBytes?: Uint8Array): {
         blinded: string[];
         Ehex: string;
     };

     /**
      * Derive a blinded secret key per NUT-26.
      *
      * Unblinds the pubkey (P = P_ - r·G), verifies x-coord against the naturalPub x(P) == x(p·G), then
      * choose skStd = (p + rᵢ) mod n if parity(P) == parity(p·G), otherwise skNeg = (-p + rᵢ) mod n.
      * Returns skStd if no blindPubkey is provided.
      *
      * @remarks
      * Security note, this operates on long lived secrets. JavaScript BigInt arithmetic in a JIT is not
      * guaranteed constant time. Do not expose this function on a server that holds private keys.
      * @param privkey Unblinded private key (p), hex or bigint.
      * @param rBlind Blinding scalar (r), hex or bigint.
      * @param blindPubkey Optional. Blinded pubkey (P_) to match, 33 byte hex.
      * @param naturalPub Optional. Pubkey calculated from private key (P = p·G), 33 byte hex.
      * @returns Derived blinded secret key as 64 char hex.
      * @throws If inputs are out of range, or the derived key would be zero.
      * @experimental
      */
     export declare function deriveP2BKSecretKey(privkey: string | bigint, rBlind: string | bigint, blindPubkey?: Uint8Array, naturalPub?: Uint8Array): string | null;

     /**
      * Derive blinded secret keys that correspond to given P2BK blinded pubkeys.
      *
      * Pubkeys are processed in order, for a proof that is [data, ...pubkeys, ...refund]. Private key
      * order does not matter.
      *
      * @remarks
      * Security note, this operates on long lived secrets. JavaScript BigInt arithmetic in a JIT is not
      * guaranteed constant time. Do not expose this function on a server that holds private keys.
      *
      * This is the Receiver side API.
      * @param Ehex Ephemeral public key (E) as SEC1 hex.
      * @param privateKey Secret key or array of secret keys, hex.
      * @param blindPubKey Blinded public key or array of blinded public keys, hex.
      * @param keysetIdHex Keyset identifier as hex.
      * @returns Array of derived secret keys as 64 char hex.
      * @experimental
      */
     export declare function deriveP2BKSecretKeys(Ehex: string, privateKey: string | string[], blindPubKey: string | string[], keysetIdHex: string): string[];

     export declare const deriveSecret: (seed: Uint8Array, keysetId: string, counter: number) => Uint8Array;

     export declare function deserializeMintKeys(serializedMintKeys: SerializedMintKeys): RawMintKeys;

     export declare const deserializeProof: (proof: SerializedProof) => RawProof;

     export declare type DeviceStartResponse = {
         device_code: string;
         user_code: string;
         verification_uri: string;
         verification_uri_complete?: string;
         interval?: number;
         expires_in?: number;
     };

     export declare type DLEQ = {
         s: Uint8Array;
         e: Uint8Array;
         r?: bigint;
     };

     export declare type Enumerate<N extends number, Acc extends number[] = []> = Acc['length'] extends N ? Acc[number] : Enumerate<N, [...Acc, Acc['length']]>;

     /**
      * Get data field value from a secret.
      *
      * @param secret - The Proof secret.
      * @returns - SecretData.data.
      */
     export declare function getDataField(secret: Secret | string): string;

     /**
      * Helper function to decode cashu tokens into object.
      *
      * @param token An encoded cashu token (cashuB...)
      * @param keysets Optional. Array of full keyset IDs, eg: from KeyChain.getAllKeysetIds()
      * @returns Cashu token object.
      */
     export declare function getDecodedToken(tokenString: string, keysetIds?: readonly string[]): Token;

     /**
      * @deprecated Pass keyset ids as `string[]` instead, eg: using KeyChain.getAllKeysetIds()
      */
     export declare function getDecodedToken(tokenString: string, keysetIds?: readonly HasKeysetId[]): Token;

     export declare function getDecodedTokenBinary(bytes: Uint8Array): Token;

     /**
      * Helper function to encode a cashu token (defaults to v4 if keyset id allows it)
      *
      * @param token
      * @param [opts]
      */
     export declare function getEncodedToken(token: Token, opts?: {
         version?: 3 | 4;
         removeDleq?: boolean;
     }): string;

     export declare function getEncodedTokenBinary(token: Token): Uint8Array;

     /**
      * Helper function to encode a v3 cashu token.
      *
      * @param token To encode.
      * @returns Encoded token.
      */
     export declare function getEncodedTokenV3(token: Token, removeDleq?: boolean): string;

     export declare function getEncodedTokenV4(token: Token, removeDleq?: boolean): string;

     /**
      * Get preimage from a witness if present.
      *
      * @param witness From a Proof.
      * @returns Preimage if present.
      */
     export declare function getHTLCWitnessPreimage(witness: Proof['witness']): string | undefined;

     /**
      * Response from mint at /info endpoint.
      */
     export declare type GetInfoResponse = {
         name: string;
         pubkey: string;
         version: string;
         description?: string;
         description_long?: string;
         icon_url?: string;
         contact: MintContactInfo[];
         nuts: {
             '4': {
                 methods: SwapMethod[];
                 disabled: boolean;
             };
             '5': {
                 methods: SwapMethod[];
                 disabled: boolean;
             };
             '7'?: {
                 supported: boolean;
             };
             '8'?: {
                 supported: boolean;
             };
             '9'?: {
                 supported: boolean;
             };
             '10'?: {
                 supported: boolean;
             };
             '11'?: {
                 supported: boolean;
             };
             '12'?: {
                 supported: boolean;
             };
             '14'?: {
                 supported: boolean;
             };
             '15'?: {
                 methods: MPPMethod[];
             };
             '17'?: {
                 supported: WebSocketSupport[];
             };
             '20'?: {
                 supported: boolean;
             };
             '21'?: {
                 openid_discovery: string;
                 client_id: string;
                 protected_endpoints?: Array<{
                     method: 'GET' | 'POST';
                     path: string;
                 }>;
             };
             '22'?: {
                 bat_max_mint: number;
                 protected_endpoints: Array<{
                     method: 'GET' | 'POST';
                     path: string;
                 }>;
             };
         };
         motd?: string;
     };

     /**
      * Creates a list of amounts to keep based on the proofs we have and the proofs we want to reach.
      *
      * @param proofsWeHave Complete set of proofs stored (from current mint)
      * @param amountToKeep Amount to keep.
      * @param keys Keys of current keyset.
      * @param targetCount The target number of proofs to reach.
      * @returns An array of amounts to keep.
      */
     export declare function getKeepAmounts(proofsWeHave: Proof[], amountToKeep: number, keys: Keys, targetCount: number): number[];

     /**
      * Returns the amounts in the keyset sorted by the order specified.
      *
      * @param keyset To search in.
      * @param order Order to sort the amounts in.
      * @returns The amounts in the keyset sorted by the order specified.
      */
     export declare function getKeysetAmounts(keyset: Keys, order?: 'asc' | 'desc'): number[];

     export declare const getKeysetIdInt: (keysetId: string) => bigint;

     /**
      * NUT-02 Keysets API response (/v1/keysets)
      */
     export declare type GetKeysetsResponse = {
         /**
          * Keysets.
          */
         keysets: MintKeyset[];
     };

     /**
      * NUT-01 Keys API response (/v1/keys)
      */
     export declare type GetKeysResponse = {
         /**
          * Keysets.
          */
         keysets: MintKeys[];
     };

     /**
      * @deprecated - Typo: use {@link getP2PKExpectedWitnessPubkeys} instead.
      */
     export declare function getP2PKExpectedKWitnessPubkeys(secretStr: string | Secret): string[];

     /**
      * Returns the expected witness public keys from a NUT-11 P2PK secret.
      *
      * @remarks
      * Does not tell you the pathway (Locktime or Refund MultiSig), only the keys that CAN currently
      * sign. If no keys are returned, the proof is unlocked.
      * @param secretStr - The NUT-11 P2PK secret.
      * @returns Array of public keys or empty array.
      * @throws If secret is not P2PK.
      */
     export declare function getP2PKExpectedWitnessPubkeys(secretStr: string | Secret): string[];

     /**
      * Interpret the Secret's locktime relative to a given time.
      *
      * - PERMANENT: no valid locktime tag.
      * - ACTIVE: now < locktime.
      * - EXPIRED: now >= locktime.
      *
      * @param secretStr - The NUT-11 P2PK secret.
      * @param nowSeconds - Optional. The unix timestamp in seconds (Default: now)
      */
     export declare function getP2PKLockState(secretStr: Secret | string, nowSeconds?: number): LockState;

     /**
      * Returns the locktime from a NUT-11 P2PK secret or Infinity if no locktime.
      *
      * @param secretStr - The NUT-11 P2PK secret.
      * @returns The locktime unix timestamp or Infinity (permanent lock)
      * @throws If secret is not P2PK.
      */
     export declare function getP2PKLocktime(secretStr: string | Secret): number;

     /**
      * Returns the number of Locktime signatures required for a NUT-11 P2PK secret.
      *
      * @remarks
      * Returns `0` if the proof is unlocked and spendable by anyone (locktime EXPIRED, no refund keys).
      * @param secretStr - The NUT-11 P2PK secret.
      * @returns Number of Locktime signatories (n_sigs) required or `0` if unlocked.
      * @throws If secret is not P2PK.
      */
     export declare function getP2PKNSigs(secretStr: string | Secret): number;

     /**
      * Returns the number of Refund signatures required for a NUT-11 P2PK secret.
      *
      * @remarks
      * Returns `0` if the refund lock is currently inactive.
      *
      * Proof may still be locked - use: getP2PKNSigs() to check!
      * @param secretStr - The NUT-11 P2PK secret.
      * @returns Number of Refund signatories (n_sigs_refund) required, or `0` if lock is inactive.
      * @throws If secret is not P2PK.
      */
     export declare function getP2PKNSigsRefund(secretStr: string | Secret): number;

     /**
      * Returns the sigflag from a NUT-11 P2PK secret.
      *
      * @param secretStr - The NUT-11 P2PK secret.
      * @returns The sigflag or 'SIG_INPUTS' (default)
      * @throws If secret is not P2PK.
      */
     export declare function getP2PKSigFlag(secretStr: string | Secret): SigFlag;

     /**
      * Returns ALL locktime witnesses from a NUT-11 P2PK secret NB: Does not specify if they are
      * expected to sign - see: getP2PKExpectedWitnessPubkeys()
      *
      * @param secretStr - The NUT-11 P2PK secret.
      * @returns Array of public key(s or empty array.
      * @throws If secret is not P2PK.
      */
     export declare function getP2PKWitnessPubkeys(secretStr: string | Secret): string[];

     /**
      * Returns ALL refund witnesses from a NUT-11 P2PK secret NB: Does not specify if they are expected
      * to sign - see: getP2PKExpectedWitnessPubkeys()
      *
      * @param secretStr - The NUT-11 P2PK secret.
      * @returns Array of public keys or empty array.
      * @throws If secret is not P2PK.
      */
     export declare function getP2PKWitnessRefundkeys(secretStr: string | Secret): string[];

     /**
      * Gets witness signatures as an array.
      *
      * @param witness From Proof.
      * @returns Array of witness signatures.
      */
     export declare function getP2PKWitnessSignatures(witness: Proof['witness']): string[];

     export declare function getPubKeyFromPrivKey(privKey: Uint8Array): Uint8Array<ArrayBufferLike>;

     /**
      * Get the SecretData payload (second element) of a Secret.
      *
      * @param secret - The Proof secret.
      */
     export declare function getSecretData(secret: Secret | string): SecretData;

     /**
      * Get the kind (first element) of a Secret.
      *
      * @param secret - The Proof secret.
      */
     export declare function getSecretKind(secret: Secret | string): SecretKind;

     /**
      * Get the values of a tag by key, excluding the key itself.
      *
      * @param secret - The Proof secret.
      * @param key - Tag key to lookup.
      * @returns - Array of Tag values or undefined if not present.
      */
     export declare function getTag(secret: Secret | string, key: string): string[] | undefined;

     /**
      * Get the first scalar value of a tag parsed as base-10 integer, or undefined.
      *
      * @param secret - The Proof secret.
      * @param key - Tag key to lookup.
      * @returns - Tag value as an integer, undefined if not present or invalid.
      */
     export declare function getTagInt(secret: Secret | string, key: string): number | undefined;

     /**
      * Get all tags from a secret.
      *
      * @param secret - The Proof secret.
      * @returns - Array of tag arrays.
      */
     export declare function getTags(secret: Secret | string): string[][];

     /**
      * Get the first scalar value of a tag as a string, or undefined if missing.
      *
      * @param secret - The Proof secret.
      * @param key - Tag key to lookup.
      * @returns - Tag value or undefined if not present.
      */
     export declare function getTagScalar(secret: Secret | string, key: string): string | undefined;

     /**
      * Returns the metadata of a cashu token.
      *
      * @param token An encoded cashu token (cashuB...)
      * @returns Token metadata.
      */
     export declare function getTokenMetadata(token: string): TokenMetadata;

     /**
      * Returns the set of unique public keys that have produced a valid Schnorr signature for a given
      * message.
      *
      * @param signatures - The Schnorr signature(s) (hex-encoded).
      * @param message - The message to verify.
      * @param pubkeys - The Cashu P2PK public key(s) (hex-encoded, X-only or with 02/03 prefix) to
      *   check.
      * @returns Array of public keys who validly signed, duplicates removed.
      */
     export declare function getValidSigners(signatures: string[], message: string, pubkeys: string[]): string[];

     /**
      * Helper function to decode different versions of cashu tokens into an object.
      *
      * @param token An encoded cashu token (cashuB...)
      * @returns Cashu Token object.
      */
     export declare function handleTokens(token: string): Token;

     /**
      * Checks if the provided amount is in the keyset.
      *
      * @param amount Amount to check.
      * @param keyset To search in.
      * @returns True if the amount is in the keyset, false otherwise.
      */
     export declare function hasCorrespondingKey(amount: number, keyset: Keys): boolean;

     export declare function hash_e(pubkeys: Array<WeierstrassPoint<bigint>>): Uint8Array;

     export declare function hashToCurve(secret: Uint8Array): WeierstrassPoint<bigint>;

     /**
      * Minimal key carrier shape for low level helpers.
      *
      * Any type with Keyset `id` can be used, including MintKeyset, MintKeys, HasKeysetKeys, Keyset,
      * KeysetCache.
      */
     export declare type HasKeysetId = {
         id: string;
     };

     /**
      * Minimal key carrier shape for low level helpers.
      *
      * Any type with `id`, and `keys` can be used, including MintKeys, KeysetCache and Keyset.
      */
     export declare type HasKeysetKeys = {
         id: string;
         keys: Keys;
     };

     /**
      * Checks wether a proof or a list of proofs contains a non-hex id.
      *
      * @param p Proof or list of proofs.
      * @returns Boolean.
      */
     export declare function hasNonHexId(p: Proof | Proof[]): boolean;

     /**
      * Verifies a pubkey has signed a P2PK Proof.
      *
      * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).
      * @param proof - A Cashu proof.
      * @param message - Optional. The message that was signed (for SIG_ALL)
      * @returns True if one of the signatures is theirs, false otherwise.
      */
     export declare function hasP2PKSignedProof(pubkey: string, proof: Proof, message?: string): boolean;

     /**
      * Check if a secret has a tag with the given key.
      *
      * @param secret - The Proof secret.
      * @param key - Tag key to lookup.
      * @returns - True if tag exists, False otherwise.
      */
     export declare function hasTag(secret: Secret | string, key: string): boolean;

     /**
      * Checks that the proof has a valid DLEQ proof according to keyset `keys`
      *
      * @param proof The proof subject to verification.
      * @param keyset Object containing keyset keys (eg: Keyset, MintKeys, KeysetCache)
      * @returns True if verification succeeded, false otherwise.
      * @throws Throws if the proof amount does not match any key in the provided keyset.
      */
     export declare function hasValidDleq(proof: Proof, keyset: HasKeysetKeys): boolean;

     /**
      * Converts a hex string to a number.
      *
      * @param hex To convert to number.
      * @returns Number.
      */
     export declare function hexToNumber(hex: string): bigint;

     /**
      * HTLC witness.
      */
     export declare type HTLCWitness = {
         /**
          * Preimage.
          */
         preimage: string;
         /**
          * An array of signatures in hex format.
          */
         signatures?: string[];
     };

     /**
      * This error is thrown when a HTTP response is not 2XX nor a protocol error.
      */
     export declare class HttpResponseError extends Error {
         status: number;
         constructor(message: string, status: number);
     }

     export declare function injectWebSocketImpl(ws: typeof WebSocket): void;

     export declare type IntRange<F extends number, T extends number> = Exclude<Enumerate<T>, Enumerate<F>>;

     /**
      * Detects whether a BOLT-11 Lightning invoice encodes a non-zero amount in the Human-Readable Part
      * (HRP).
      */
     export declare function invoiceHasAmountInHRP(invoice: string): boolean;

     /**
      * Verify HTLC spending conditions for a single input.
      *
      * @param proof - The Proof to check.
      * @param logger - Optional logger (default: NULL_LOGGER)
      * @param message - Optional. The message to sign (for SIG_ALL)
      * @returns True if spending conditions are satisfied, false otherwise.
      * @throws If verification is impossible.
      */
     export declare function isHTLCSpendAuthorised(proof: Proof, logger?: Logger, message?: string): boolean;

     export declare function isObj(v: unknown): v is object;

     /* Excluded from this release type: isP2PKSigAll */

     /**
      * Verify P2PK spending conditions for a single input.
      *
      * @param proof - The Proof to check.
      * @param logger - Optional logger (default: NULL_LOGGER)
      * @param message - Optional. The message to sign (for SIG_ALL)
      * @returns True if the witness threshold was reached, false otherwise.
      * @throws If verification is impossible.
      */
     export declare function isP2PKSpendAuthorised(proof: Proof, logger?: Logger, message?: string): boolean;

     export declare function isValidHex(str: string): boolean;

     export declare function joinUrls(...parts: string[]): string;

     export declare type JsonRpcReqParams = {
         kind: RpcSubKinds;
         filters: string[];
         subId: string;
     };

     /**
      * Manages the unit-specific keysets for a Mint.
      *
      * @remarks
      * Will ONLY load keysets in the KeyChain unit.
      */
     export declare class KeyChain {
         private mint;
         private unit;
         private keysets;
         constructor(mint: string | Mint, unit: string, cachedKeysets?: MintKeyset[], cachedKeys?: MintKeys[] | MintKeys);
         /**
          * Construct a KeyChain from previously cached data.
          *
          * @remarks
          * Does not hit the network. The cache should have been produced by `keyChain.cache`.
          */
         static fromCache(mint: string | Mint, cache: KeyChainCache): KeyChain;
         /**
          * Convert Mint API DTOs into a consolidated KeyChainCache.
          *
          * @remarks
          * This is symmetrical to {@link KeyChain.cacheToMintDTO}. It is used by the `cache` getter and any
          * code that wants to move from raw Mint DTOs to the new cache shape.
          */
         static mintToCacheDTO(unit: string, mintUrl: string, allKeysets: MintKeyset[], allKeys: MintKeys[]): KeyChainCache;
         /**
          * Convert a KeyChainCache back into Mint API DTOs.
          *
          * @remarks
          * This is the inverse of {@link KeyChain.mintToCacheDTO} and is used by `loadFromCache` and the
          * deprecated `getCache()` wrapper.
          */
         static cacheToMintDTO(cache: KeyChainCache): {
             keysets: MintKeyset[];
             keys: MintKeys[];
         };
         /**
          * Asynchronously load keysets and keys from the mint.
          *
          * @remarks
          * Intended for callers that want the freshest data from the mint and can use an asynchronous
          * path.
          * @param forceRefresh If true, re-fetches data even if already loaded.
          */
         init(forceRefresh?: boolean): Promise<void>;
         /**
          * Synchronously load keysets and keys from cached data.
          *
          * @remarks
          * Does not hit the network. Intended for callers that already have a KeyChainCache and want a
          * synchronous path.
          */
         loadFromCache(cache: KeyChainCache): void;
         /**
          * Builds keychain from Mint Keyset and Keys data.
          *
          * @param allKeysets Keyset data from mint.getKeySets() API.
          * @param allKeys Keys data from mint.getKeys() API.
          */
         private buildKeychain;
         /**
          * Get a keyset by ID or the cheapest keyset if no ID is provided.
          *
          * @param id Optional keyset ID.
          * @returns Keyset with keys.
          * @throws If keyset not found or uninitialized.
          */
         getKeyset(id?: string): Keyset;
         /**
          * Get the cheapest active keyset.
          *
          * @remarks
          * Selects active keyset with lowest fee and hex ID.
          * @returns Active Keyset.
          * @throws If none found or uninitialized.
          */
         getCheapestKeyset(): Keyset;
         /**
          * Get list of all keysets for the unit.
          *
          * @returns Array of Keysets.
          * @throws If uninitialized.
          */
         getKeysets(): Keyset[];
         /**
          * Returns all the keys in this KeyChain.
          *
          * @remarks
          * This mirrors the old `wallet.getAllKeys()` behaviour and is the preferred replacement in v3.
          * @returns Array of MintKeys objects.
          * @throws If uninitialized.
          */
         getAllKeys(): MintKeys[];
         /**
          * Returns all the keyset IDs in this KeyChain.
          *
          * @returns Array of keyset IDs.
          * @throws If uninitialized.
          */
         getAllKeysetIds(): string[];
         /**
          * Preferred consolidated cache representation.
          *
          * @remarks
          * Built from the live Keyset instances via their Mint DTO exporters. This is the canonical cache
          * API going forward.
          */
         get cache(): KeyChainCache;
         /**
          * Legacy Mint API cache format.
          *
          * @remarks
          * Useful for instantiating new wallets / keychains without repeatedly calling the mint API.
          * @deprecated Use the `cache` getter which returns a consolidated KeyChainCache.
          */
         getCache(): {
             keysets: MintKeyset[];
             keys: MintKeys[];
             unit: string;
             mintUrl: string;
         };
     }

     /**
      * Cached view of a KeyChain.
      *
      * @remarks
      * This is the preferred format for persisting and restoring keychain state.
      */
     export declare type KeyChainCache = {
         /**
          * Flattened keysets and, optionally, their keys.
          */
         keysets: KeysetCache[];
         /**
          * The unit this keychain is for, for example 'sat', 'usd'.
          */
         unit: string;
         /**
          * Mint URL that this cache belongs to.
          */
         mintUrl: string;
     };

     /**
      * Public keys are a dictionary of number and string. The number represents the amount that the key
      * signs for.
      */
     export declare type Keys = {
         [amount: number]: string;
     };

     export declare class Keyset {
         private _id;
         private _unit;
         private _active;
         private _keys;
         private _input_fee_ppk?;
         private _final_expiry?;
         constructor(id: string, unit: string, active: boolean, input_fee_ppk?: number, final_expiry?: number);
         get id(): string;
         get unit(): string;
         get isActive(): boolean;
         get fee(): number;
         get expiry(): number | undefined;
         get hasKeys(): boolean;
         get hasHexId(): boolean;
         get keys(): Record<number, string>;
         set keys(keys: Record<number, string>);
         /**
          * @deprecated Use `isActive` instead.
          */
         get active(): boolean;
         /**
          * @deprecated Use `fee` instead.
          */
         get input_fee_ppk(): number;
         /**
          * @deprecated Use `expiry` instead.
          */
         get final_expiry(): number | undefined;
         /**
          * To Mint API MintKeyset format.
          *
          * @returns MintKeyset object.
          */
         toMintKeyset(): MintKeyset;
         /**
          * To Mint API MintKeys format.
          *
          * @returns MintKeys object.
          */
         toMintKeys(): MintKeys | null;
         /**
          * Verifies that the keyset's ID matches the derived ID from its keys, unit, and expiry.
          *
          * @returns True if verification succeeds, false otherwise (e.g: no keys or mismatch).
          */
         verify(): boolean;
         /**
          * Verifies that a MintKeys DTO has a correct id for its keys/unit/expiry.
          *
          * @returns True if verification succeeds, false otherwise (e.g: no keys or mismatch).
          */
         static verifyKeysetId(keys: MintKeys): boolean;
         /**
          * Create a Keyset from Mint API DTOs.
          *
          * @param meta The MintKeyset metadata from GetKeysetsResponse.
          * @param keys The MintKeys from GetKeysResponse.
          * @returns Keyset instance.
          */
         static fromMintApi(meta: MintKeyset, keys?: MintKeys): Keyset;
     }

     /**
      * Cached view of a keyset.
      *
      * @remarks
      * This is basically MintKeyset, with optional "keys" field for active, verified keysets.
      */
     export declare type KeysetCache = MintKeyset & {
         /**
          * Optional. Keys for this keyset, if available.
          *
          * Present only when keyset is active and keys have been verified.
          */
         keys?: Keys;
     };

     export declare type KeysetPair = {
         keysetId: string;
         pubKeys: RawMintKeys;
         privKeys: RawMintKeys;
     };

     /**
      * @deprecated - Use MintQuoteBolt11Response.
      */
     export declare type LockedMintQuoteResponse = MintQuoteBolt11Response;

     export declare type LockState = 'PERMANENT' | 'ACTIVE' | 'EXPIRED';

     export declare interface Logger {
         error(message: string, context?: Record<string, unknown>): void;
         warn(message: string, context?: Record<string, unknown>): void;
         info(message: string, context?: Record<string, unknown>): void;
         debug(message: string, context?: Record<string, unknown>): void;
         trace(message: string, context?: Record<string, unknown>): void;
         log(level: LogLevel, message: string, context?: Record<string, unknown>): void;
     }

     /**
      * Defines the available log levels for the logger. Log levels are ordered from most severe (FATAL)
      * to least severe (TRACE).
      */
     export declare type LogLevel = 'error' | 'warn' | 'info' | 'debug' | 'trace';

     /**
      * Derives blinded secret keys for a P2BK proof.
      *
      * @remarks
      * Calculates the deterministic blinding factor for each P2PK pubkey (data, pubkeys, refund) and
      * calling our parity-aware derivation.
      * @param privateKey Secret key (or array of secret keys)
      * @param proof The proof.
      * @returns Deduplicated list of derived secret keys (hex, 64 chars)
      * @experimental
      */
     export declare function maybeDeriveP2BKPrivateKeys(privateKey: string | string[], proof: Proof): string[];

     /**
      * Checks enough unique pubkeys have signed a message.
      *
      * @param signatures - The Schnorr signature(s) (hex-encoded).
      * @param message - The message to verify.
      * @param pubkeys - The Cashu P2PK public key(s) (hex-encoded, X-only or with 02/03 prefix) to
      *   check.
      * @param threshold - The minimum number of unique witnesses required.
      * @returns True if the witness threshold was reached, false otherwise.
      */
     export declare const meetsSignerThreshold: (signatures: string[], message: string, pubkeys: string[], threshold?: number) => boolean;

     /**
      * @deprecated Use wallet.prepareMelt() and store the MeltPreview instead.
      */
     export declare interface MeltBlanks<T extends MeltQuoteBaseResponse = MeltQuoteBolt11Response> {
         method: 'bolt11' | 'bolt12';
         payload: MeltRequest;
         outputData: OutputDataLike[];
         keyset: Keyset;
         quote: T;
     }

     /**
      * Builder for melting proofs to pay a Lightning invoice or BOLT12 offer.
      *
      * @remarks
      * Uses the generic prepareMelt / completeMelt flow under the hood, so it works for any NUT-05 style
      * melt quote, not just BOLT11 / BOLT12.
      * @example
      *
      * ```typescript
      * // Basic BOLT11 melt
      * await wallet.ops.meltBolt11(quote, proofs).run();
      *
      * // BOLT12 melt with deterministic change and NUT-08 blanks callback
      * await wallet.ops
      * 	.meltBolt12(quote12, proofs)
      * 	.asDeterministic() // counter 0 auto reserves
      * 	.onCountersReserved((info) => console.log('Reserved', info))
      * 	.run();
      * ```
      */
     export declare class MeltBuilder<TQuote extends MeltQuoteBaseResponse = MeltQuoteBolt11Response> {
         private wallet;
         private method;
         private quote;
         private proofs;
         private outputType?;
         private config;
         constructor(wallet: Wallet, method: string, quote: TQuote, proofs: Proof[]);
         /**
          * Use random blinding for change outputs.
          *
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         asRandom(denoms?: number[]): this;
         /**
          * Use deterministic outputs for change.
          *
          * @param counter Starting counter. Zero means auto reserve using the wallet’s CounterSource.
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         asDeterministic(counter?: number, denoms?: number[]): this;
         /**
          * Use P2PK-locked change (NUT-11).
          *
          * @param options NUT-11 locking options (e.g., pubkey, locktime).
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         asP2PK(options: P2PKOptions, denoms?: number[]): this;
         /**
          * Use a factory to generate OutputData for change.
          *
          * @param factory Factory used to produce blinded messages.
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         asFactory(factory: OutputDataFactory, denoms?: number[]): this;
         /**
          * Provide pre-created OutputData for change.
          *
          * @param data Fully formed OutputData for the change amount.
          */
         asCustom(data: OutputDataLike[]): this;
         /**
          * Use a specific keyset for the melt operation.
          *
          * @param id Keyset id to use for mint keys and fee lookup.
          */
         keyset(id: string): this;
         /**
          * Private key(s) used to sign P2PK locked proofs.
          *
          * @param k Single key or array of multisig keys.
          */
         privkey(k: string | string[]): this;
         /**
          * Receive a callback once counters are atomically reserved for deterministic outputs.
          *
          * @param cb Called with OperationCounters when counters are reserved.
          */
         onCountersReserved(cb: OnCountersReserved): this;
         /**
          * Receive a callback when NUT-08 blanks (0-sat change outputs) are created for async melts.
          *
          * @remarks
          * You can persist these blanks and later call `wallet.completeMelt(blanks)` to finalize and
          * recover change once the invoice/offer is paid.
          * @deprecated Use prepare() instead of run() and store the MeltPreview instead.
          * @param cb Callback invoked with the created blanks payload.
          */
         onChangeOutputsCreated(cb: NonNullable<MeltProofsConfig['onChangeOutputsCreated']>): this;
         /**
          * Prepare the melt.
          *
          * @remarks
          * Call `wallet.completeMelt(MeltPreview)` to complete the melt.
          * @returns A MeltPreview containing inputs, outputs, amount, and fee.
          */
         prepare(): Promise<MeltPreview<TQuote>>;
         /**
          * Execute the melt against the quote.
          *
          * @returns The melt result: `{ quote, change }`.
          */
         run(): Promise<MeltProofsResponse<TQuote>>;
     }

     /**
      * Preview of a Melt transaction created by prepareMelt.
      */
     export declare interface MeltPreview<TQuote extends MeltQuoteBaseResponse = MeltQuoteBolt11Response> {
         method: string;
         /**
          * Inputs (Proofs) to be melted.
          */
         inputs: Proof[];
         /**
          * Outputs (blinded messages) that can be filled by the mint to return overpaid fees.
          */
         outputData: OutputDataLike[];
         /**
          * Keyset ID used to prepare the outputs.
          */
         keysetId: string;
         /**
          * Melt Quote object.
          */
         quote: TQuote;
     }

     /**
      * Configuration for melting operations.
      *
      * @remarks
      * OnChangeOutputsCreated is deprecated - use wallet.prepareMelt() and store the MeltPreview
      * instead.
      */
     export declare type MeltProofsConfig = {
         keysetId?: string;
         privkey?: string | string[];
         /**
          * @deprecated Use wallet.prepareMelt() and store the MeltPreview instead.
          */
         onChangeOutputsCreated?: (blanks: MeltBlanks<MeltQuoteBaseResponse>) => void;
         onCountersReserved?: OnCountersReserved;
     };

     /**
      * Response after paying a Lightning invoice.
      */
     export declare type MeltProofsResponse<TQuote extends MeltQuoteBaseResponse = MeltQuoteBaseResponse> = {
         /**
          * If false, the proofs have not been invalidated and the payment can be tried later again with
          * the same proofs.
          */
         quote: TQuote;
         /**
          * Return/Change from overpaid fees. This happens due to Lighting fee estimation being inaccurate.
          */
         change: Proof[];
     };

     /**
      * Base melt quote request - all melt quote requests have these fields (NUT-05)
      */
     export declare type MeltQuoteBaseRequest = {
         /**
          * Unit to be melted.
          */
         unit: string;
         /**
          * Request to be melted to.
          */
         request: string;
     };

     /**
      * Base melt quote response - all melt quotes have these fields (NUT-05)
      */
     export declare type MeltQuoteBaseResponse = {
         /**
          * Quote ID.
          */
         quote: string;
         /**
          * Amount to be melted.
          */
         amount: number;
         /**
          * Unit of the melt quote.
          */
         unit: string;
         /**
          * State of the melt quote.
          */
         state: MeltQuoteState;
         /**
          * Timestamp of when the quote expires.
          */
         expiry: number;
         /**
          * Optional change from overpaid fees. If blanks were provided in `outputs`, the mint may return
          * signatures here.
          */
         change?: SerializedBlindedSignature[];
     };

     /**
      * Melt quote payload.
      *
      * Includes options:
      *
      * - Amountless: amountless invoices.
      * - Mpp: multi-path payments (NUT-15)
      */
     export declare type MeltQuoteBolt11Request = MeltQuoteBaseRequest & {
         options?: {
             amountless?: {
                 amount_msat: number;
             };
             mpp?: {
                 amount: number;
             };
         };
     };

     /**
      * Response from the mint after requesting a BOLT11 melt quote. Contains payment details and state
      * for paying Lightning Network offers.
      */
     export declare type MeltQuoteBolt11Response = MeltQuoteBaseResponse & {
         /**
          * Payment request for the melt quote.
          */
         request: string;
         /**
          * Fee reserve to be added to the amount.
          */
         fee_reserve: number;
         /**
          * Preimage of the paid invoice. is null if it the invoice has not been paid yet. can be null,
          * depending on which LN-backend the mint uses.
          */
         payment_preimage: string | null;
     };

     /**
      * Melt quote payload.
      *
      * Includes options:
      *
      * - Amountless: amountless invoices.
      */
     export declare type MeltQuoteBolt12Request = MeltQuoteBaseRequest & {
         options?: {
             amountless?: {
                 amount_msat: number;
             };
         };
     };

     /**
      * Response from the mint after requesting a BOLT12 melt quote.
      *
      * @remarks
      * - Same as Bolt11.
      */
     export declare type MeltQuoteBolt12Response = MeltQuoteBolt11Response;

     /**
      * @deprecated - Use MeltQuoteBolt11Response.
      */
     export declare type MeltQuoteResponse = MeltQuoteBolt11Response;

     export declare const MeltQuoteState: {
         readonly UNPAID: "UNPAID";
         readonly PENDING: "PENDING";
         readonly PAID: "PAID";
     };

     export declare type MeltQuoteState = (typeof MeltQuoteState)[keyof typeof MeltQuoteState];

     /**
      * Generic Melt request payload.
      *
      * NUT-05 core fields plus optional blanks for overpayment change.
      */
     export declare type MeltRequest = {
         /**
          * Quote ID.
          */
         quote: string;
         /**
          * Proofs to melt.
          */
         inputs: Proof[];
         /**
          * Optional blanks for fee change. If present, the mint may return signatures in `change`.
          */
         outputs?: SerializedBlindedMessage[];
     } & Record<string, unknown>;

     export declare function mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array;

     export declare class MessageNode {
         private _value;
         private _next;
         get value(): string;
         set value(message: string);
         get next(): MessageNode | null;
         set next(node: MessageNode | null);
         constructor(message: string);
     }

     export declare class MessageQueue {
         private _first;
         private _last;
         get first(): MessageNode | null;
         set first(messageNode: MessageNode | null);
         get last(): MessageNode | null;
         set last(messageNode: MessageNode | null);
         private _size;
         get size(): number;
         set size(v: number);
         constructor();
         enqueue(message: string): boolean;
         dequeue(): string | null;
     }

     /**
      * Class represents Cashu Mint API.
      *
      * @remarks
      * This class contains lower-level functions that are implemented by Wallet.
      */
     export declare class Mint {
         private ws?;
         private _mintUrl;
         private _request;
         private _logger;
         private _mintInfo?;
         private _authProvider?;
         /**
          * @param mintUrl Requires mint URL to create this object.
          * @param customRequest Optional, for custom network communication with the mint.
          * @param authTokenGetter Optional. Function to obtain a NUT-22 BlindedAuthToken (e.g. from a
          *   database or localstorage)
          */
         constructor(mintUrl: string, options?: {
             customRequest?: RequestFn;
             authProvider?: AuthProvider;
             logger?: Logger;
         });
         get mintUrl(): string;
         /**
          * Create an OIDC client using this mint’s NUT-21 metadata.
          *
          * @example
          *
          * ```ts
          * const oidc = await mint.oidcAuth({ onTokens: (t) => authMgr.setCAT(t.access_token!) });
          * const start = await oidc.deviceStart();
          * // show start.user_code / start.verification_uri to the user
          * const token = await oidc.devicePoll(start.device_code, start.interval ?? 5);
          * // token.access_token is your CAT
          * ```
          */
         oidcAuth(opts?: OIDCAuthOptions): Promise<OIDCAuth>;
         /**
          * Fetches mint's info at the /info endpoint.
          *
          * @param customRequest Optional override for the request function.
          * @returns The mint's information response.
          */
         getInfo(customRequest?: RequestFn): Promise<GetInfoResponse>;
         /**
          * Lazily fetches and caches the mint's info if not already loaded.
          *
          * @returns The parsed MintInfo object.
          */
         getLazyMintInfo(): Promise<MintInfo>;
         /**
          * Performs a swap operation with ecash inputs and outputs.
          *
          * @param swapPayload Payload containing inputs and outputs.
          * @param customRequest Optional override for the request function.
          * @returns Signed outputs.
          */
         swap(swapPayload: SwapRequest, customRequest?: RequestFn): Promise<SwapResponse>;
         /**
          * Requests a new mint quote from the mint.
          *
          * @param mintQuotePayload Payload for creating a new mint quote.
          * @param customRequest Optional override for the request function.
          * @returns A new mint quote containing a payment request for the specified amount and unit.
          */
         createMintQuoteBolt11(mintQuotePayload: MintQuoteBolt11Request, customRequest?: RequestFn): Promise<MintQuoteBolt11Response>;
         /**
          * Requests a new BOLT12 mint quote from the mint using Lightning Network offers.
          *
          * @param mintQuotePayload Payload containing amount, unit, optional description, and required
          *   pubkey.
          * @param customRequest Optional override for the request function.
          * @returns A mint quote containing a BOLT12 offer.
          */
         createMintQuoteBolt12(mintQuotePayload: MintQuoteBolt12Request, customRequest?: RequestFn): Promise<MintQuoteBolt12Response>;
         /**
          * Gets an existing mint quote from the mint.
          *
          * @param quote Quote ID.
          * @param customRequest Optional override for the request function.
          * @returns The status of the mint quote, including payment details and state.
          */
         checkMintQuoteBolt11(quote: string, customRequest?: RequestFn): Promise<MintQuoteBolt11Response>;
         /**
          * Gets an existing BOLT12 mint quote from the mint.
          *
          * @param quote Quote ID to check.
          * @param customRequest Optional override for the request function.
          * @returns Updated quote with current payment and issuance amounts.
          */
         checkMintQuoteBolt12(quote: string, customRequest?: RequestFn): Promise<MintQuoteBolt12Response>;
         /**
          * Mints new tokens by requesting blind signatures on the provided outputs.
          *
          * @param mintPayload Payload containing the outputs to get blind signatures on.
          * @param customRequest Optional override for the request function.
          * @returns Serialized blinded signatures.
          */
         mintBolt11(mintPayload: MintRequest, customRequest?: RequestFn): Promise<MintResponse>;
         /**
          * Mints new tokens using a BOLT12 quote by requesting blind signatures on the provided outputs.
          *
          * @param mintPayload Payload containing the quote ID and outputs to get blind signatures on.
          * @param customRequest Optional override for the request function.
          * @returns Serialized blinded signatures for the requested outputs.
          */
         mintBolt12(mintPayload: MintRequest, customRequest?: RequestFn): Promise<MintResponse>;
         /**
          * Requests a new melt quote from the mint.
          *
          * @param meltQuotePayload Payload for creating a new melt quote.
          * @param customRequest Optional override for the request function.
          * @returns The melt quote response.
          */
         createMeltQuoteBolt11(meltQuotePayload: MeltQuoteBolt11Request, customRequest?: RequestFn): Promise<MeltQuoteBolt11Response>;
         /**
          * Requests a new BOLT12 melt quote from the mint for paying a Lightning Network offer. For
          * amount-less offers, specify the amount in options.amountless.amount_msat.
          *
          * @param meltQuotePayload Payload containing the BOLT12 offer to pay and unit.
          * @param customRequest Optional override for the request function.
          * @returns Melt quote with amount, fee reserve, and payment state.
          */
         createMeltQuoteBolt12(meltQuotePayload: MeltQuoteBolt12Request, customRequest?: RequestFn): Promise<MeltQuoteBolt12Response>;
         /**
          * Gets an existing melt quote.
          *
          * @param quote Quote ID.
          * @param customRequest Optional override for the request function.
          * @returns The melt quote response.
          */
         checkMeltQuoteBolt11(quote: string, customRequest?: RequestFn): Promise<MeltQuoteBolt11Response>;
         /**
          * Gets an existing BOLT12 melt quote from the mint. Returns current payment state (UNPAID,
          * PENDING, or PAID) and payment preimage if paid.
          *
          * @param quote Quote ID to check.
          * @param customRequest Optional override for the request function.
          * @returns Updated quote with current payment state and preimage if available.
          */
         checkMeltQuoteBolt12(quote: string, customRequest?: RequestFn): Promise<MeltQuoteBolt12Response>;
         /**
          * Generic method to melt tokens using any payment method endpoint.
          *
          * @remarks
          * This method enables support for custom payment methods without modifying the Mint class. It
          * constructs the endpoint as `/v1/melt/{method}` and POSTs the payload. The response must contain
          * the common fields: quote, amount, fee_reserve, state, expiry.
          * @example
          *
          * ```ts
          * const response = await mint.melt('bolt11', { quote: 'q1', inputs: [...], outputs: [...] });
          * const response = await mint.melt('custom-payment', { quote: 'c1', inputs: [...], outputs: [...] });
          * ```
          *
          * @param method The payment method (e.g., 'bolt11', 'bolt12', or custom method name).
          * @param meltPayload The melt payload containing inputs and optional outputs.
          * @param options.customRequest Optional override for the request function.
          * @param options.preferAsync Optional override to set 'respond-async' header.
          * @returns A response object with at least the required melt quote fields.
          */
         melt<TRes extends Record<string, unknown> = Record<string, unknown>>(method: string, meltPayload: MeltRequest, options?: {
             customRequest?: RequestFn;
             preferAsync?: boolean;
         }): Promise<MeltQuoteBaseResponse & TRes>;
         /**
          * Requests the mint to pay for a Bolt11 payment request by providing ecash as inputs to be spent.
          * The inputs contain the amount and the fee_reserves for a Lightning payment. The payload can
          * also contain blank outputs in order to receive back overpaid Lightning fees.
          *
          * @param meltPayload The melt payload containing inputs and optional outputs.
          * @param options.customRequest Optional override for the request function.
          * @param options.preferAsync Optional override to set 'respond-async' header.
          * @returns The melt response.
          */
         meltBolt11(meltPayload: MeltRequest, options?: {
             customRequest?: RequestFn;
             preferAsync?: boolean;
         }): Promise<MeltQuoteBolt11Response>;
         /**
          * Requests the mint to pay a BOLT12 offer by providing ecash inputs to be spent. The inputs must
          * cover the amount plus fee reserves. Optional outputs can be included to receive change for
          * overpaid Lightning fees.
          *
          * @param meltPayload Payload containing quote ID, inputs, and optional outputs for change.
          * @param options.customRequest Optional override for the request function.
          * @param options.preferAsync Optional override to set 'respond-async' header.
          * @returns Payment result with state and optional change signatures.
          */
         meltBolt12(meltPayload: MeltRequest, options?: {
             customRequest?: RequestFn;
             preferAsync?: boolean;
         }): Promise<MeltQuoteBolt12Response>;
         /**
          * Checks if specific proofs have already been redeemed.
          *
          * @param checkPayload The payload containing proofs to check.
          * @param customRequest Optional override for the request function.
          * @returns Redeemed and unredeemed ordered list of booleans.
          */
         check(checkPayload: CheckStatePayload, customRequest?: RequestFn): Promise<CheckStateResponse>;
         /**
          * Get the mint's public keys.
          *
          * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the
          *   keys from all active keysets are fetched.
          * @param mintUrl Optional alternative mint URL to use for this request.
          * @param customRequest Optional override for the request function.
          * @returns The mint's public keys.
          */
         getKeys(keysetId?: string, mintUrl?: string, customRequest?: RequestFn): Promise<GetKeysResponse>;
         /**
          * Get the mint's keysets in no specific order.
          *
          * @param customRequest Optional override for the request function.
          * @returns All the mint's past and current keysets.
          */
         getKeySets(customRequest?: RequestFn): Promise<GetKeysetsResponse>;
         /**
          * Restores proofs from the provided blinded messages.
          *
          * @param restorePayload The payload containing outputs to restore.
          * @param customRequest Optional override for the request function.
          * @returns The restore response with outputs and signatures.
          */
         restore(restorePayload: PostRestorePayload, customRequest?: RequestFn): Promise<PostRestoreResponse>;
         /**
          * Tries to establish a websocket connection with the websocket mint url according to NUT-17.
          */
         connectWebSocket(): Promise<void>;
         /**
          * Closes a websocket connection.
          */
         disconnectWebSocket(): void;
         get webSocketConnection(): WSConnection | undefined;
         /**
          * Returns the Clear Authentication Token (CAT) to use in the 'Clear-auth' header, or undefined if
          * not required for the given path and method.
          *
          * @param method The method to call on the path.
          * @param path The API path to check for blind auth requirement.
          * @returns The blind auth token if required, otherwise undefined.
          */
         private handleClearAuth;
         /**
          * Returns a serialized Blind Authentication Token (BAT) to use in the 'Blind-auth' header, or
          * undefined if not required for the given path and method.
          *
          * @param method The method to call on the path.
          * @param path The API path to check for blind auth requirement.
          * @returns The blind auth token if required, otherwise undefined.
          */
         private handleBlindAuth;
         private requestWithAuth;
         private isValidMethodString;
     }

     /**
      * @deprecated - Use GetKeysResponse.
      */
     export declare type MintActiveKeys = GetKeysResponse;

     /**
      * @deprecated - Use GetKeysetsResponse.
      */
     export declare type MintAllKeysets = GetKeysetsResponse;

     /**
      * Builder for minting proofs from a quote.
      *
      * @remarks
      * Bolt12 requires privkey by default, bolt11 only for locked quotes. The compiler will throw an
      * error if bolt12 and privkey() is omitted: MintBuilder<"bolt12", false>' is not assignable...
      * @example
      *
      *     const proofs = await wallet.ops
      *     	.mint(100, quote)
      *     	.asDeterministic() // counter 0 auto reserves
      *     	.onCountersReserved((info) => console.log(info))
      *     	.privkey('sk')
      *     	.run();
      */
     export declare class MintBuilder<M extends MintMethod, HasPrivKey extends boolean = M extends 'bolt12' ? false : true> {
         private wallet;
         private method;
         private amount;
         private quote;
         private outputType?;
         private config;
         private readonly _hasPrivkey;
         constructor(wallet: Wallet, method: M, amount: number, quote: MintQuoteFor<M>);
         /**
          * Use random blinding for the minted proofs.
          *
          * @remarks
          * If denoms specified, proofsWeHave() will have no effect.
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         asRandom(denoms?: number[]): this;
         /**
          * Use deterministic outputs for the minted proofs.
          *
          * @remarks
          * If denoms specified, proofsWeHave() will have no effect.
          * @param counter Starting counter. Zero means auto reserve using the wallet’s CounterSource.
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         asDeterministic(counter?: number, denoms?: number[]): this;
         /**
          * Use P2PK locked outputs for the minted proofs.
          *
          * @remarks
          * If denoms specified, proofsWeHave() will have no effect.
          * @param options NUT 11 options like pubkey and locktime.
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         asP2PK(options: P2PKOptions, denoms?: number[]): this;
         /**
          * Use a factory to generate OutputData for minted proofs.
          *
          * @remarks
          * If denoms specified, proofsWeHave() will have no effect.
          * @param factory OutputDataFactory used to produce blinded messages.
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         asFactory(factory: OutputDataFactory, denoms?: number[]): this;
         /**
          * Provide pre created OutputData for minted proofs.
          *
          * @param data Fully formed OutputData for the final amount.
          */
         asCustom(data: OutputDataLike[]): this;
         /**
          * Use a specific keyset for the operation.
          *
          * @param id Keyset id to use for mint keys and fee lookup.
          */
         keyset(id: string): this;
         /**
          * Private key to sign locked mint quotes.
          *
          * @param k Private key for locked quotes.
          */
         privkey(k: string): MintBuilder<M, true>;
         /**
          * Provide existing proofs to help optimise denomination selection.
          *
          * @remarks
          * Has no effect if denominations (custom split) was specified.
          * @param p Proofs currently held by the wallet, used to hit denomination targets.
          */
         proofsWeHave(p: Proof[]): this;
         /**
          * Receive a callback once counters are atomically reserved for deterministic outputs.
          *
          * @param cb Called with OperationCounters when counters are reserved.
          */
         onCountersReserved(cb: OnCountersReserved): this;
         /**
          * Execute minting against the quote.
          *
          * @remarks
          * This method can only be called for bolt12 quotes when .privkey() is set.
          * @returns The newly minted proofs.
          */
         run(this: MintBuilder<M, true>): Promise<Proof[]>;
     }

     export declare type MintContactInfo = {
         method: string;
         info: string;
     };

     export declare class MintInfo {
         private readonly _mintInfo;
         private readonly _protected22?;
         private readonly _protected21?;
         constructor(info: GetInfoResponse);
         isSupported(num: 4 | 5): {
             disabled: boolean;
             params: SwapMethod[];
         };
         isSupported(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20): {
             supported: boolean;
         };
         isSupported(num: 17): {
             supported: boolean;
             params?: WebSocketSupport[];
         };
         isSupported(num: 15): {
             supported: boolean;
             params?: MPPMethod[];
         };
         requiresBlindAuthToken(method: 'GET' | 'POST', path: string): boolean;
         requiresClearAuthToken(method: 'GET' | 'POST', path: string): boolean;
         private matchesProtected;
         private checkGenericNut;
         private checkMintMelt;
         private checkNut17;
         private checkNut15;
         private toEndpoints;
         private buildIndex;
         get cache(): GetInfoResponse;
         get contact(): MintContactInfo[];
         get description(): string | undefined;
         get description_long(): string | undefined;
         get name(): string;
         get pubkey(): string;
         get nuts(): {
             '4': {
                 methods: SwapMethod[];
                 disabled: boolean;
             };
             '5': {
                 methods: SwapMethod[];
                 disabled: boolean;
             };
             '7'?: {
                 supported: boolean;
             };
             '8'?: {
                 supported: boolean;
             };
             '9'?: {
                 supported: boolean;
             };
             '10'?: {
                 supported: boolean;
             };
             '11'?: {
                 supported: boolean;
             };
             '12'?: {
                 supported: boolean;
             };
             '14'?: {
                 supported: boolean;
             };
             '15'?: {
                 methods: MPPMethod[];
             };
             '17'?: {
                 supported: WebSocketSupport[];
             };
             '20'?: {
                 supported: boolean;
             };
             '21'?: {
                 openid_discovery: string;
                 client_id: string;
                 protected_endpoints?: Array<{
                     method: "GET" | "POST";
                     path: string;
                 }>;
             };
             '22'?: {
                 bat_max_mint: number;
                 protected_endpoints: Array<{
                     method: "GET" | "POST";
                     path: string;
                 }>;
             };
         };
         get version(): string;
         get motd(): string | undefined;
         /**
          * @deprecated Use supportsNut04Description(method, unit)
          */
         get supportsBolt12Description(): boolean;
         /**
          * Checks if the mint supports creating invoices/offers with a description for the specified
          * payment method.
          *
          * @param method - The payment method to check ('bolt11' or 'bolt12')
          * @returns True if the mint supports description for the method, false otherwise.
          */
         supportsNut04Description(method: 'bolt11' | 'bolt12', unit?: string): boolean;
         supportsAmountless(method?: string, unit?: string): boolean;
     }

     /**
      * A mint keyset.
      */
     export declare type MintKeys = {
         /**
          * Keyset ID.
          */
         id: string;
         /**
          * Unit of the keyset.
          */
         unit: string;
         /**
          * Whether the keyset is active or not.
          */
         active?: boolean;
         /**
          * Input fee for keyset (in ppk)
          */
         input_fee_ppk?: number;
         /**
          * Expiry of the keyset.
          */
         final_expiry?: number;
         /**
          * Public keys are a dictionary of number and string. The number represents the amount that the
          * key signs for.
          */
         keys: Keys;
     };

     /**
      * A mint keyset entry.
      */
     export declare type MintKeyset = {
         /**
          * Keyset ID.
          */
         id: string;
         /**
          * Unit of the keyset.
          */
         unit: string;
         /**
          * Whether the keyset is active or not.
          */
         active: boolean;
         /**
          * Input fee for keyset (in ppk)
          */
         input_fee_ppk?: number;
         /**
          * Expiry of the keyset.
          */
         final_expiry?: number;
     };

     export declare type MintMethod = 'bolt11' | 'bolt12';

     /**
      * This error is thrown when a [protocol
      * error](https://github.com/cashubtc/nuts/blob/main/00.md#errors) occurs. See error codes
      * [here](https://github.com/cashubtc/nuts/blob/main/error_codes.md).
      */
     export declare class MintOperationError extends HttpResponseError {
         code: number;
         constructor(code: number, detail: string);
     }

     /**
      * Configuration for minting operations.
      */
     export declare type MintProofsConfig = {
         keysetId?: string;
         privkey?: string;
         proofsWeHave?: Proof[];
         onCountersReserved?: OnCountersReserved;
     };

     /**
      * Base mint quote request - all mint quote requests have these fields (NUT-04) and may have
      * optional fields (NUT-20)
      */
     export declare type MintQuoteBaseRequest = {
         /**
          * Unit to be minted.
          */
         unit: string;
         /**
          * Optional. Public key to lock the quote to (NUT-20).
          */
         pubkey?: string;
     };

     /**
      * Base mint quote response - all mint quotes have these fields (NUT-04) and may have optional
      * fields (NUT-20)
      */
     export declare type MintQuoteBaseResponse = {
         /**
          * Quote ID.
          */
         quote: string;
         /**
          * Payment request.
          */
         request: string;
         /**
          * Unit of the melt quote.
          */
         unit: string;
         /**
          * Optional. Public key the quote is locked to (NUT-20)
          */
         pubkey?: string;
     };

     /**
      * Payload that needs to be sent to the mint when requesting a mint.
      */
     export declare type MintQuoteBolt11Request = MintQuoteBaseRequest & {
         /**
          * Amount to be minted.
          */
         amount: number;
         /**
          * Description for the invoice.
          */
         description?: string;
     };

     /**
      * Response from the mint after requesting a BOLT11 mint quote.
      */
     export declare type MintQuoteBolt11Response = MintQuoteBaseResponse & {
         /**
          * Amount requested for mint quote.
          */
         amount: number;
         /**
          * State of the mint quote.
          */
         state: MintQuoteState;
         /**
          * Timestamp of when the quote expires.
          */
         expiry: number;
     };

     /**
      * Payload that needs to be sent to the mint when requesting a mint.
      */
     export declare type MintQuoteBolt12Request = MintQuoteBaseRequest & {
         /**
          * Optional. Amount to be minted.
          */
         amount?: number;
         /**
          * Optional. Description for the invoice.
          */
         description?: string;
     };

     /**
      * Response from the mint after requesting a BOLT12 mint quote.
      */
     export declare type MintQuoteBolt12Response = MintQuoteBaseResponse & {
         /**
          * Amount requested for mint quote.
          */
         amount?: number;
         /**
          * Timestamp of when the quote expires.
          */
         expiry: number;
         /**
          * Public key the quote is locked to.
          *
          * @remarks
          * Required for bolt12.
          */
         pubkey: string;
         /**
          * The amount that has been paid to the mint via the bolt12 offer. The difference between this and
          * `amount_issued` can be minted.
          */
         amount_paid: number;
         /**
          * The amount of ecash that has been issued for the given mint quote.
          */
         amount_issued: number;
     };

     export declare type MintQuoteFor<M extends MintMethod> = M extends 'bolt11' ? string | MintQuoteBolt11Response : MintQuoteBolt12Response;

     /**
      * Payload that needs to be sent to the mint when requesting a mint.
      *
      * @deprecated - Use MintQuoteBolt11Request.
      */
     export declare type MintQuotePayload = MintQuoteBolt11Request;

     /**
      * @deprecated - Use MintQuoteBolt11Response.
      */
     export declare type MintQuoteResponse = MintQuoteBolt11Response;

     export declare const MintQuoteState: {
         readonly UNPAID: "UNPAID";
         readonly PAID: "PAID";
         readonly ISSUED: "ISSUED";
     };

     export declare type MintQuoteState = (typeof MintQuoteState)[keyof typeof MintQuoteState];

     /**
      * Payload that needs to be sent to the mint when requesting a mint.
      */
     export declare type MintRequest = {
         /**
          * Quote ID received from the mint.
          */
         quote: string;
         /**
          * Outputs (blinded messages) to be signed by the mint.
          */
         outputs: SerializedBlindedMessage[];
         /**
          * Optional. Signature for the Public key the quote is locked to (NUT-20)
          */
         signature?: string;
     };

     /**
      * Response from the mint after requesting a mint.
      */
     export declare type MintResponse = {
         signatures: SerializedBlindedSignature[];
     };

     /**
      * MPP supported methods.
      */
     export declare type MPPMethod = {
         method: string;
         unit: string;
     };

     /**
      * This error is thrown when a network request fails.
      */
     export declare class NetworkError extends Error {
         constructor(message: string);
     }

     /**
      * Converts a number to a hex string of 64 characters.
      *
      * @param number (bigint) to conver to hex.
      * @returns Hex string start-padded to 64 characters.
      */
     export declare function numberToHexPadded64(number: bigint): string;

     /**
      * Used to express a spending condition that proofs should be encumbered with.
      */
     export declare type NUT10Option = {
         /**
          * The kind of spending condition.
          */
         kind: string;
         /**
          * Expresses the spending condition relative to the kind.
          */
         data: string;
         /**
          * Tags associated with the spending condition for additional data.
          */
         tags: string[][];
     };

     export declare class OIDCAuth {
         private readonly discoveryUrl;
         private readonly logger;
         private clientId;
         private scope;
         private config?;
         private onTokens?;
         private tokenListeners;
         static fromMintInfo(info: {
             nuts: GetInfoResponse['nuts'];
         }, opts?: OIDCAuthOptions): OIDCAuth;
         constructor(discoveryUrl: string, opts?: OIDCAuthOptions);
         setClient(id: string): void;
         setScope(scope?: string): void;
         /**
          * Subscribe to token updates. Listeners are called after the primary onTokens callback.
          */
         addTokenListener(fn: (t: TokenResponse) => void | Promise<void>): void;
         loadConfig(): Promise<OIDCConfig>;
         /**
          * Generate a PKCE verifier and S256 challenge.
          *
          * - Verifier: base64url of random bytes, length >= 43, RFC 7636 compliant.
          * - Challenge: base64url(sha256(verifier))
          */
         generatePKCE(): {
             verifier: string;
             challenge: string;
         };
         /**
          * Build an Authorization Code + PKCE URL.
          */
         buildAuthCodeUrl(input: {
             redirectUri: string;
             codeChallenge: string;
             codeChallengeMethod?: 'S256' | 'plain';
             state?: string;
             scope?: string;
         }): Promise<string>;
         /**
          * Exchange an auth code for tokens, using the PKCE verifier.
          */
         exchangeAuthCode(input: {
             code: string;
             redirectUri: string;
             codeVerifier: string;
         }): Promise<TokenResponse>;
         deviceStart(): Promise<DeviceStartResponse>;
         devicePoll(device_code: string, intervalSec?: number): Promise<TokenResponse>;
         /**
          * One call convenience for Device Code flow.
          *
          * @remarks
          * Polling interval will be the MAX of intervalSec and Mint interval.
          * @param intervalSec Desired polling interval in seconds.
          * @returns The start fields and helpers to poll or cancel.
          */
         startDeviceAuth(intervalSec?: number): Promise<DeviceStartResponse & {
             poll: () => Promise<TokenResponse>;
             cancel: () => void;
         }>;
         refresh(refresh_token: string): Promise<TokenResponse>;
         passwordGrant(username: string, password: string): Promise<TokenResponse>;
         /**
          * Fire and forget token fan out. Any listener errors are logged inside safeCallback. Nothing
          * thrown here will come from listeners.
          */
         private handleTokens;
         private toForm;
         private postFormStrict;
         private postFormLoose;
         private sleep;
     }

     export declare type OIDCAuthOptions = {
         clientId?: string;
         scope?: string;
         logger?: Logger;
         onTokens?: (t: TokenResponse) => void | Promise<void>;
     };

     export declare type OIDCConfig = {
         issuer: string;
         authorization_endpoint?: string;
         token_endpoint: string;
         device_authorization_endpoint?: string;
     };

     export declare type OnCountersReserved = (info: OperationCounters) => void;

     /**
      * Counter summary for an operation.
      *
      * - `keysetId` - of the transaction.
      * - `start` - beginning of reservation.
      * - `count` - number of reservations.
      * - `next` - counter available after reservation.
      *
      * @example // Start: 5, Count: 3 => 5,6,7. Next: 8.
      */
     export declare type OperationCounters = {
         keysetId: string;
         start: number;
         count: number;
         next: number;
     };

     /**
      * Output config for send/swap operations.
      *
      * @remarks
      * Defines types for sent and kept proofs.
      *
      * - `send`: Required for recipient proofs.
      * - `keep`: Optional; defaults to wallet defaultOutputType policy.
      *
      * @example
      *
      *     const config: OutputConfig = {
      *     	send: { type: 'random', denominations: [1, 2] },
      *     	keep: { type: 'deterministic', counter: 0 },
      *     };
      *     await wallet.send(3, proofs, config, { includeFees: true });
      */
     export declare interface OutputConfig {
         send: OutputType;
         keep?: OutputType;
     }

     export declare class OutputData implements OutputDataLike<HasKeysetKeys> {
         blindedMessage: SerializedBlindedMessage;
         blindingFactor: bigint;
         secret: Uint8Array;
         constructor(blindedMessage: SerializedBlindedMessage, blindingFactor: bigint, secret: Uint8Array);
         toProof(sig: SerializedBlindedSignature, keyset: HasKeysetKeys): Proof;
         static createP2PKData<T extends HasKeysetKeys>(p2pk: P2PKOptions, amount: number, keyset: T, customSplit?: number[]): OutputData[];
         static createSingleP2PKData(p2pk: P2PKOptions, amount: number, keysetId: string): OutputData;
         static createRandomData<T extends HasKeysetKeys>(amount: number, keyset: T, customSplit?: number[]): OutputData[];
         static createSingleRandomData(amount: number, keysetId: string): OutputData;
         static createDeterministicData<T extends HasKeysetKeys>(amount: number, seed: Uint8Array, counter: number, keyset: T, customSplit?: number[]): OutputData[];
         /**
          * @throws May throw if blinding factor is out of range. Caller should catch, increment counter,
          *   and retry per BIP32-style derivation.
          */
         static createSingleDeterministicData(amount: number, seed: Uint8Array, counter: number, keysetId: string): OutputData;
         /**
          * Calculates the sum of amounts in an array of OutputDataLike objects.
          *
          * @param outputs Array of OutputDataLike objects.
          * @returns The total sum of amounts.
          */
         static sumOutputAmounts(outputs: OutputDataLike[]): number;
     }

     /**
      * Note: OutputData helpers only require keyset `id` and `keys`. If you want richer keyset typing at
      * the call site, use `OutputDataLike<YourType>`.
      *
      * @remarks
      * WARNING: In v4 we may simplify this further by fixing the keyset type to `HasKeysetKeys` and
      * removing the generic.
      */
     export declare type OutputDataFactory<TKeyset extends HasKeysetKeys = HasKeysetKeys> = (amount: number, keys: TKeyset) => OutputDataLike<TKeyset>;

     /**
      * Note: OutputData helpers only require keyset `id` and `keys`. If you want richer keyset typing at
      * the call site, use `OutputDataLike<YourType>`.
      *
      * @remarks
      * WARNING: In v4 we may simplify this further by fixing the keyset type to `HasKeysetKeys` and
      * removing the generic.
      */
     export declare interface OutputDataLike<TKeyset extends HasKeysetKeys = HasKeysetKeys> {
         blindedMessage: SerializedBlindedMessage;
         blindingFactor: bigint;
         secret: Uint8Array;
         toProof: (signature: SerializedBlindedSignature, keyset: TKeyset) => Proof;
     }

     /**
      * Configuration for generating blinded message outputs.
      *
      * @remarks
      * A discriminated union based on the `type` field.
      * @example
      *
      *     // Random with custom splits
      *     const random: OutputType = { type: 'random', denominations: [1, 2, 4] };
      *     // Deterministic
      *     const deterministic: OutputType = { type: 'deterministic', counter: 0 };
      */
     export declare type OutputType = ({
         /**
          * Random blinding factors (default behavior).
          */
         type: 'random';
     } & SharedOutputTypeProps) | ({
         /**
          * Deterministic outputs based on a counter.
          *
          * @remarks
          * Counter: 0 means “auto-assign from wallet’s CounterSource”. Any positive value is used as
          * the exact starting counter without reservation. Negative values are invalid.
          */
         type: 'deterministic';
         counter: number;
     } & SharedOutputTypeProps) | ({
         /**
          * Pay-to-public-key (P2PK) outputs.
          *
          * @see P2PKOptions
          */
         type: 'p2pk';
         options: P2PKOptions;
     } & SharedOutputTypeProps) | ({
         /**
          * Factory-generated OutputData.
          *
          * @remarks
          * Outputs count from denominations or basic split.
          * @see OutputDataFactory
          */
         type: 'factory';
         factory: OutputDataFactory;
     } & SharedOutputTypeProps) | {
         /**
          * Pre-created OutputData, bypassing splitting.
          */
         type: 'custom';
         data: OutputDataLike[];
     };

     /**
      * BIP340-style domain separation tag (DST) for P2BK.
      *
      * @experimental
      */
     export declare const P2BK_DST: Uint8Array<ArrayBufferLike>;

     export declare class P2PKBuilder {
         private lockSet;
         private refundSet;
         private locktime?;
         private nSigs?;
         private nSigsRefund?;
         private extraTags;
         private _blindKeys?;
         private sigFlag?;
         private hashlock?;
         addLockPubkey(pk: string | string[]): this;
         addRefundPubkey(pk: string | string[]): this;
         lockUntil(when: Date | number): this;
         requireLockSignatures(n: number): this;
         requireRefundSignatures(n: number): this;
         addTag(key: string, values?: string[] | string): this;
         addTags(tags: P2PKTag[]): this;
         /**
          * @experimental
          */
         blindKeys(): this;
         sigAll(): this;
         /**
          * Converts a `P2PK` output into a NUT-14 `HTLC` kind output.
          */
         addHashlock(hashlock: string): this;
         toOptions(): P2PKOptions;
         static fromOptions(opts: P2PKOptions): P2PKBuilder;
     }

     /**
      * Options for configuring P2PK (Pay-to-Public-Key) locked proofs according to NUT-11.
      */
     export declare type P2PKOptions = {
         pubkey: string | string[];
         locktime?: number;
         refundKeys?: string[];
         requiredSignatures?: number;
         requiredRefundSignatures?: number;
         additionalTags?: P2PKTag[];
         blindKeys?: boolean;
         sigFlag?: SigFlag;
         hashlock?: string;
     };

     export declare type P2PKSpendingPath = 'MAIN' | 'REFUND' | 'UNLOCKED' | 'FAILED';

     export declare type P2PKTag = [key: string, ...values: string[]];

     export declare interface P2PKVerificationResult {
         success: boolean;
         path: P2PKSpendingPath;
         lockState: LockState;
         requiredSigners: number;
         eligibleSigners: number;
         receivedSigners: string[];
     }

     /**
      * P2PK witness.
      */
     export declare type P2PKWitness = {
         /**
          * An array of signatures in hex format.
          */
         signatures?: string[];
     };

     /**
      * Parse an HTLC Secret and validate NUT-10 shape.
      *
      * @param secret - The Proof secret.
      * @returns Secret object.
      * @throws If the JSON is invalid or NUT-10 secret is malformed.
      */
     export declare function parseHTLCSecret(secret: string | Secret): Secret;

     /**
      * Parse a P2PK Secret and validate NUT-10 shape.
      *
      * @param secret - The Proof secret.
      * @returns Secret object.
      * @throws If the JSON is invalid or NUT-10 secret is malformed.
      */
     export declare function parseP2PKSecret(secret: string | Secret): Secret;

     /**
      * @deprecated Pass a string or Secret instead.
      */
     export declare function parseP2PKSecret(secret: Uint8Array): Secret;

     /**
      * Parse a secret string and validate NUT-10 shape.
      *
      * @param secret - The Proof secret.
      * @returns Secret object.
      * @throws If the JSON is invalid or NUT-10 secret is malformed.
      */
     export declare function parseSecret(secret: string | Secret): Secret;

     /**
      * Response from the mint after requesting a melt quote.
      *
      * @deprecated - Use MeltQuoteBolt11Response.
      */
     export declare type PartialMeltQuoteResponse = MeltQuoteBolt11Response;

     /**
      * Response from the mint after requesting a mint.
      *
      * @deprecated - Use MintQuoteBolt11Response or MintQuoteBolt12Response.
      */
     export declare type PartialMintQuoteResponse = MintQuoteBolt11Response;

     declare class PaymentRequest_2 {
         transport?: PaymentRequestTransport[] | undefined;
         id?: string | undefined;
         amount?: number | undefined;
         unit?: string | undefined;
         mints?: string[] | undefined;
         description?: string | undefined;
         singleUse: boolean;
         nut10?: NUT10Option | undefined;
         nut26: boolean;
         constructor(transport?: PaymentRequestTransport[] | undefined, id?: string | undefined, amount?: number | undefined, unit?: string | undefined, mints?: string[] | undefined, description?: string | undefined, singleUse?: boolean, nut10?: NUT10Option | undefined, nut26?: boolean);
         toRawRequest(): RawPaymentRequest;
         toEncodedRequest(): string;
         /**
          * Encodes the payment request to creqA format (CBOR).
          *
          * @returns A base64 encoded payment request string with 'creqA' prefix.
          */
         toEncodedCreqA(): string;
         /**
          * Encodes the payment request to creqB format (TLV + bech32m).
          *
          * @returns A bech32m encoded payment request string with 'CREQB' prefix.
          * @experimental
          */
         toEncodedCreqB(): string;
         getTransport(type: PaymentRequestTransportType): PaymentRequestTransport | undefined;
         /**
          * Creates a PaymentRequest from a raw payment request. Supports both creqA and creqB versions.
          *
          * @param rawPaymentRequest - The raw payment request string to create a PaymentRequest from.
          * @returns A PaymentRequest object.
          * @throws An error if the raw payment request is not supported.
          */
         static fromRawRequest(rawPaymentRequest: RawPaymentRequest): PaymentRequest_2;
         static fromEncodedRequest(encodedRequest: string): PaymentRequest_2;
     }
     export { PaymentRequest_2 as PaymentRequest }

     export declare type PaymentRequestPayload = {
         id?: string;
         memo?: string;
         unit: string;
         mint: string;
         proofs: Proof[];
     };

     export declare type PaymentRequestTransport = {
         type: PaymentRequestTransportType;
         target: string;
         tags?: string[][];
     };

     export declare enum PaymentRequestTransportType {
         POST = "post",
         NOSTR = "nostr"
     }

     export declare function pointFromBytes(bytes: Uint8Array): WeierstrassPoint<bigint>;

     export declare function pointFromHex(hex: string): WeierstrassPoint<bigint>;

     /**
      * Request to mint at /v1/restore endpoint.
      */
     export declare type PostRestorePayload = {
         outputs: SerializedBlindedMessage[];
     };

     /**
      * Response from mint at /v1/restore endpoint.
      */
     export declare type PostRestoreResponse = {
         outputs: SerializedBlindedMessage[];
         signatures: SerializedBlindedSignature[];
     };

     /**
      * Private key type - can be hex string or Uint8Array.
      */
     export declare type PrivKey = Uint8Array | string;

     /**
      * Represents a single Cashu proof.
      */
     export declare type Proof = {
         /**
          * Keyset id, used to link proofs to a mint an its MintKeys.
          */
         id: string;
         /**
          * Amount denominated in Satoshis. Has to match the amount of the mints signing key.
          */
         amount: number;
         /**
          * The initial secret that was (randomly) chosen for the creation of this proof.
          */
         secret: string;
         /**
          * The unblinded signature for this secret, signed by the mints private key.
          */
         C: string;
         /**
          * DLEQ proof.
          */
         dleq?: SerializedDLEQ;
         /**
          * The P2BK ephemeral pubkey "E" (SEC1-compressed 33-byte hex).
          */
         p2pk_e?: string;
         /**
          * The witness for this proof.
          */
         witness?: string | P2PKWitness | HTLCWitness;
     };

     /**
      * Entries of CheckStateResponse with state of the proof.
      */
     export declare type ProofState = {
         Y: string;
         state: CheckStateEnum;
         witness: string | null;
     };

     export declare type RawBlindedMessage = {
         B_: WeierstrassPoint<bigint>;
         r: bigint;
         secret: Uint8Array;
     };

     export declare type RawMintKeys = {
         [k: string]: Uint8Array;
     };

     export declare type RawNUT10Option = {
         k: string;
         d: string;
         t: string[][];
     };

     export declare type RawPaymentRequest = {
         i?: string;
         a?: number;
         u?: string;
         s?: boolean;
         m?: string[];
         d?: string;
         t?: RawTransport[];
         nut10?: RawNUT10Option;
         nut26?: boolean;
     };

     export declare type RawProof = {
         C: WeierstrassPoint<bigint>;
         secret: Uint8Array;
         amount: number;
         id: string;
         witness?: P2PKWitness;
     };

     export declare type RawTransport = {
         t: PaymentRequestTransportType;
         a: string;
         g?: string[][];
     };

     /**
      * Builder for receiving a token.
      *
      * @remarks
      * If you do not call a type method, the wallet’s policy default is used.
      * @example
      *
      *     const proofs = await wallet.ops
      *     	.receive(token)
      *     	.asDeterministic() // counter 0 auto reserves
      *     	.requireDleq(true)
      *     	.run();
      */
     export declare class ReceiveBuilder {
         private wallet;
         private token;
         private outputType?;
         private config;
         constructor(wallet: Wallet, token: Token | string);
         /**
          * Use random blinding for the received outputs.
          *
          * @remarks
          * If denoms specified, proofsWeHave() will have no effect.
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         asRandom(denoms?: number[]): this;
         /**
          * Use deterministic outputs for the received proofs.
          *
          * @remarks
          * If denoms specified, proofsWeHave() will have no effect.
          * @param counter Starting counter. Zero means auto reserve using the wallet’s CounterSource.
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         asDeterministic(counter?: number, denoms?: number[]): this;
         /**
          * Use P2PK locked outputs for the received proofs.
          *
          * @remarks
          * If denoms specified, proofsWeHave() will have no effect.
          * @param options NUT 11 options like pubkey and locktime.
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         asP2PK(options: P2PKOptions, denoms?: number[]): this;
         /**
          * Use a factory to generate OutputData for received proofs.
          *
          * @remarks
          * If denoms specified, proofsWeHave() will have no effect.
          * @param factory OutputDataFactory used to produce blinded messages.
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         asFactory(factory: OutputDataFactory, denoms?: number[]): this;
         /**
          * Provide pre created OutputData for received proofs.
          *
          * @param data Fully formed OutputData for the final amount.
          */
         asCustom(data: OutputDataLike[]): this;
         /**
          * Use a specific keyset for the operation.
          *
          * @param id Keyset id to use for mint keys and fee lookup.
          */
         keyset(id: string): this;
         /**
          * Require all incoming proofs to have a valid DLEQ for the selected keyset.
          *
          * @param on When true, proofs without DLEQ are rejected.
          */
         requireDleq(on?: boolean): this;
         /**
          * Private key(s) used to sign P2PK locked incoming proofs.
          *
          * @param k Single key or array of multisig keys.
          */
         privkey(k: string | string[]): this;
         /**
          * Provide existing proofs to help optimise denomination selection.
          *
          * @remarks
          * Has no effect if denominations (custom split) was specified.
          * @param p Proofs currently held by the wallet, used to hit denomination targets.
          */
         proofsWeHave(p: Proof[]): this;
         /**
          * Receive a callback once counters are atomically reserved for deterministic outputs.
          *
          * @param cb Called with OperationCounters when counters are reserved.
          */
         onCountersReserved(cb: OnCountersReserved): this;
         /**
          * Prepare the swap to receive.
          *
          * @remarks
          * Call `wallet.completeSwap(SwapPreview)` to complete the receive.
          * @returns A SwapPreview containing inputs, outputs, amount, and fee.
          */
         prepare(): Promise<SwapPreview>;
         /**
          * Execute the receive.
          *
          * @returns The new proofs.
          */
         run(): Promise<Proof[]>;
     }

     /**
      * Configuration for receive operations.
      */
     export declare type ReceiveConfig = {
         keysetId?: string;
         privkey?: string | string[];
         requireDleq?: boolean;
         proofsWeHave?: Proof[];
         onCountersReserved?: OnCountersReserved;
     };

     export declare type RequestArgs = {
         endpoint: string;
         requestBody?: Record<string, unknown>;
         headers?: Record<string, string>;
         logger?: Logger;
     };

     export declare type RequestFn = <T = unknown>(args: RequestOptions) => Promise<T>;

     export declare type RequestOptions = RequestArgs & Omit<RequestInit, 'body' | 'headers'>;

     export declare type RestoreConfig = {
         keysetId?: string;
     };

     export declare type RpcSubKinds = 'bolt11_mint_quote' | 'bolt11_melt_quote' | 'proof_state';

     export declare function sanitizeUrl(url: string): string;

     /**
      * Signs a message string using Schnorr.
      *
      * @remarks
      * Signatures are non-deterministic because schnorr.sign() generates a new random auxiliary value
      * (auxRand) each time it is called.
      * @param message - The message to sign.
      * @param privateKey - The private key to sign with (hex string or Uint8Array).
      * @returns The signature in hex format.
      */
     export declare const schnorrSignMessage: (message: string, privateKey: PrivKey) => string;

     /**
      * Verifies a Schnorr signature on a message.
      *
      * @remarks
      * This function swallows Schnorr verification errors (eg invalid signature / pubkey format) and
      * treats them as false. If you want to throw such errors, use the throws param.
      * @param signature - The Schnorr signature (hex-encoded).
      * @param message - The message to verify.
      * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).
      * @param throws - True: throws on error, False: swallows errors and returns false.
      * @returns True if the signature is valid, false otherwise.
      * @throws If throws param is true and error is encountered.
      */
     export declare const schnorrVerifyMessage: (signature: string, message: string, pubkey: string, throws?: boolean) => boolean;

     export declare type Secret = [SecretKind, SecretData];

     export declare interface SecretData {
         nonce: string;
         data: string;
         tags?: string[][];
     }

     export declare type SecretKind = 'P2PK' | 'HTLC' | (string & {});

     export declare type SecretsPolicy = 'auto' | 'deterministic' | 'random';

     export declare type SelectProofs = (proofs: Proof[], amountToSend: number, keyChain: KeyChain, includeFees?: boolean, exactMatch?: boolean, logger?: Logger) => SendResponse;

     export declare const selectProofsRGLI: SelectProofs;

     /**
      * Builder for composing a send or swap.
      *
      * @remarks
      * If you only customise the send side, keep is omitted so the wallet may still attempt an offline
      * exact match selection where possible.
      * @example
      *
      *     const { keep, send } = await wallet.ops
      *     	.send(5, proofs)
      *     	.asDeterministic() // counter 0 means auto reserve via CounterSource
      *     	.keepAsRandom()
      *     	.includeFees(true) // sender pays receiver’s future spend fee
      *     	.run();
      */
     export declare class SendBuilder {
         private wallet;
         private amount;
         private proofs;
         private sendOT?;
         private keepOT?;
         private config;
         private offlineExact?;
         private offlineClose?;
         constructor(wallet: Wallet, amount: number, proofs: Proof[]);
         /**
          * Use random blinding for the sent outputs.
          *
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         asRandom(denoms?: number[]): this;
         /**
          * Use deterministic outputs for the sent proofs.
          *
          * @param counter Starting counter. Zero means auto reserve using the wallet’s CounterSource.
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         asDeterministic(counter?: number, denoms?: number[]): this;
         /**
          * Use P2PK locked outputs for the sent proofs.
          *
          * @param options NUT 11 options like pubkey and locktime.
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         asP2PK(options: P2PKOptions, denoms?: number[]): this;
         /**
          * Use a factory to generate OutputData for the sent proofs.
          *
          * @param factory OutputDataFactory used to produce blinded messages.
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         asFactory(factory: OutputDataFactory, denoms?: number[]): this;
         /**
          * Provide pre created OutputData for the sent proofs.
          *
          * @param data Fully formed OutputData. Their amounts must sum to the send amount, otherwise the
          *   wallet will throw.
          */
         asCustom(data: OutputDataLike[]): this;
         /**
          * Use random blinding for change outputs.
          *
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         keepAsRandom(denoms?: number[]): this;
         /**
          * Use deterministic outputs for change.
          *
          * @param counter Starting counter. Zero means auto reserve using the wallet’s CounterSource.
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         keepAsDeterministic(counter?: number, denoms?: number[]): this;
         /**
          * Use P2PK locked change (NUT 11).
          *
          * @param options Locking options applied to the kept proofs.
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         keepAsP2PK(options: P2PKOptions, denoms?: number[]): this;
         /**
          * Use a factory to generate OutputData for change.
          *
          * @param factory OutputDataFactory used to produce blinded messages.
          * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.
          */
         keepAsFactory(factory: OutputDataFactory, denoms?: number[]): this;
         /**
          * Provide pre created OutputData for change.
          *
          * @param data Fully formed OutputData for the keep (change) amount.
          */
         keepAsCustom(data: OutputDataLike[]): this;
         /**
          * Make the sender cover the receiver’s future spend fee.
          *
          * @param on When true, include fees in the sent amount. Default true if called.
          */
         includeFees(on?: boolean): this;
         /**
          * Use a specific keyset for the operation.
          *
          * @param id Keyset id to use for mint keys and fee lookup.
          */
         keyset(id: string): this;
         /**
          * Private key(s) used to sign P2PK locked proofs.
          *
          * @param k Single key or array of multisig keys.
          */
         privkey(k: string | string[]): this;
         /**
          * Provide existing proofs to help optimise denomination selection.
          *
          * @remarks
          * Has no effect if denominations (custom split) was specified.
          * @param p Proofs currently held by the wallet, used to hit denomination targets.
          */
         proofsWeHave(p: Proof[]): this;
         /**
          * Receive a callback once counters are atomically reserved for deterministic outputs.
          *
          * @param cb Called with OperationCounters when counters are reserved.
          */
         onCountersReserved(cb: OnCountersReserved): this;
         /**
          * Force a pure offline, exact match selection. No mint calls are made. If an exact match cannot
          * be found, this throws.
          *
          * @param requireDleq Only consider proofs with a DLEQ when true.
          */
         offlineExactOnly(requireDleq?: boolean): this;
         /**
          * Force a pure offline selection that allows a close match, overspend permitted per wallet RGLI.
          * No mint calls are made. Returns the best offline subset found, or throws if funds are
          * insufficient.
          *
          * @param requireDleq Only consider proofs with a DLEQ when true.
          */
         offlineCloseMatch(requireDleq?: boolean): this;
         /**
          * Prepare the swap to send.
          *
          * @remarks
          * Call `wallet.completeSwap(SwapPreview)` to complete the send.
          * @returns A SwapPreview containing inputs, outputs, amount, fee and unselectedProofs.
          */
         prepare(): Promise<SwapPreview>;
         /**
          * Execute the send.
          *
          * @returns The split result with kept and sent proofs.
          */
         run(): Promise<SendResponse>;
     }

     /**
      * Configuration for send operations.
      */
     export declare type SendConfig = {
         keysetId?: string;
         privkey?: string | string[];
         includeFees?: boolean;
         proofsWeHave?: Proof[];
         onCountersReserved?: OnCountersReserved;
     };

     /**
      * Configuration for offline send operations.
      */
     export declare type SendOfflineConfig = {
         requireDleq?: boolean;
         includeFees?: boolean;
         exactMatch?: boolean;
     };

     /**
      * Response after sending.
      */
     export declare type SendResponse = {
         /**
          * Proofs that exceeded the needed amount.
          */
         keep: Proof[];
         /**
          * Proofs to be sent, matching the chosen amount.
          */
         send: Proof[];
         serialized?: Array<{
             proof: Proof;
             keep: boolean;
         }>;
     };

     /**
      * Blinded message for sending to the mint.
      */
     export declare type SerializedBlindedMessage = {
         /**
          * Amount.
          */
         amount: number;
         /**
          * Blinded message.
          */
         B_: string;
         /**
          * Keyset id.
          */
         id: string;
     };

     /**
      * Blinded signature as it is received from the mint.
      */
     export declare type SerializedBlindedSignature = {
         /**
          * Keyset id for indicating which public key was used to sign the blinded message.
          */
         id: string;
         /**
          * Amount denominated in Satoshi.
          */
         amount: number;
         /**
          * Blinded signature.
          */
         C_: string;
         /**
          * DLEQ Proof.
          */
         dleq?: SerializedDLEQ;
     };

     export declare type SerializedDLEQ = {
         s: string;
         e: string;
         r?: string;
     };

     export declare type SerializedMintKeys = {
         [k: string]: string;
     };

     export declare type SerializedProof = {
         C: string;
         secret: string;
         amount: number;
         id: string;
         witness?: string;
     };

     export declare function serializeMintKeys(mintKeys: RawMintKeys): SerializedMintKeys;

     export declare const serializeProof: (proof: RawProof) => SerializedProof;

     /**
      * An object containing any custom settings that you want to apply to the global fetch method.
      *
      * @param options See possible options here:
      *   https://developer.mozilla.org/en-US/docs/Web/API/fetch#options.
      */
     export declare function setGlobalRequestOptions(options: Partial<RequestOptions>): void;

     /**
      * Shared properties for most `OutputType` variants (except 'custom').
      */
     export declare interface SharedOutputTypeProps {
         /**
          * Optional custom amounts for splitting outputs.
          *
          * @default Uses basic splitAmount if omitted.
          */
         denominations?: number[];
     }

     export declare type SigFlag = 'SIG_INPUTS' | 'SIG_ALL';

     export declare function signMintQuote(privkey: string, quote: string, blindedMessages: SerializedBlindedMessage[]): string;

     /**
      * Signs a single proof with the provided private key if required.
      *
      * @remarks
      * Will only sign if the proof requires a signature from the key.
      * @param proof - A proof to sign.
      * @param privateKey - A single private key (hex string or Uint8Array).
      * @param message - Optional. The message to sign (for SIG_ALL)
      * @returns Signed proofs.
      * @throws Error if signature is not required or proof is already signed.
      */
     export declare function signP2PKProof(proof: Proof, privateKey: PrivKey, message?: string): Proof;

     /**
      * Signs proofs with provided private key(s) if required.
      *
      * @remarks
      * NB: Will only sign if the proof requires a signature from the key.
      * @param proofs - An array of proofs to sign.
      * @param privateKey - A single private key or array of private keys (hex string or Uint8Array).
      * @param logger - Optional logger (default: NULL_LOGGER)
      * @param message - Optional. The message to sign (for SIG_ALL)
      * @returns Signed proofs.
      * @throws On general errors.
      */
     export declare function signP2PKProofs(proofs: Proof[], privateKey: PrivKey | PrivKey[], logger?: Logger, message?: string): Proof[];

     /**
      * Signs a P2PK secret using Schnorr.
      *
      * @deprecated Use {@link schnorrSignMessage}
      */
     export declare const signP2PKSecret: (secret: string, privateKey: PrivKey) => string;

     export declare function sortProofsById(proofs: Proof[]): Proof[];

     /**
      * Splits the amount into denominations of the provided keyset.
      *
      * @remarks
      * Partial splits will be filled up to value using minimum splits required. Sorting is only applied
      * if a fill was made - exact custom splits are always returned in the same order.
      * @param value Amount to split.
      * @param keyset Keys to look up split amounts.
      * @param split? Optional custom split amounts.
      * @param order? Optional order for split amounts (if fill was required)
      * @returns Array of split amounts.
      * @throws Error if split sum is greater than value or mint does not have keys for requested split.
      */
     export declare function splitAmount(value: number, keyset: Keys, split?: number[], order?: 'desc' | 'asc'): number[];

     /**
      * Removes all traces of DLEQs from a list of proofs.
      *
      * @param proofs The list of proofs that dleq should be stripped from.
      */
     export declare function stripDleq(proofs: Proof[]): Array<Omit<Proof, 'dleq'>>;

     export declare type SubscribeOpts = {
         signal?: AbortSignal;
     };

     export declare type SubscriptionCanceller = () => void;

     export declare function sumProofs(proofs: Proof[]): number;

     /**
      * Ecash to other MoE swap method, displayed in @type {GetInfoResponse}
      */
     export declare type SwapMethod = {
         method: string;
         unit: string;
         min_amount: number;
         max_amount: number;
         description?: boolean;
         options?: {
             description?: boolean;
             amountless?: boolean;
         };
     };

     /**
      * Payload that needs to be sent to the mint when performing a split action.
      *
      * @deprecated - Use SwapRequest.
      */
     export declare type SwapPayload = SwapRequest;

     /**
      * Preview of a swap transaction created by prepareSend / prepareReceive.
      */
     export declare type SwapPreview = {
         /**
          * Amount being sent or received (excluding fees).
          */
         amount: number;
         /**
          * Total fees for the swap (inc receiver's fees if applicable)
          */
         fees: number;
         /**
          * Keyset ID used to prepare the outputs.
          */
         keysetId: string;
         /**
          * Input Proofs for this transaction.
          */
         inputs: Proof[];
         /**
          * Blinding data to construct proofs to send.
          */
         sendOutputs?: OutputDataLike[];
         /**
          * Blinding data to construct proofs to keep.
          */
         keepOutputs?: OutputDataLike[];
         /**
          * Proofs not selected for this transaction (can be returned to storage).
          */
         unselectedProofs?: Proof[];
     };

     /**
      * Payload that needs to be sent to the mint when performing a split action.
      */
     export declare type SwapRequest = {
         /**
          * Inputs to the split operation.
          */
         inputs: Proof[];
         /**
          * Outputs (blinded messages) to be signed by the mint.
          */
         outputs: SerializedBlindedMessage[];
     };

     /**
      * Response from the mint after performing a split action.
      */
     export declare type SwapResponse = {
         /**
          * Represents the outputs after the split.
          */
         signatures: SerializedBlindedSignature[];
     };

     /**
      * Includes all data required to swap inputs for outputs and construct proofs from them.
      */
     export declare type SwapTransaction = {
         /**
          * Payload that will be sent to the mint for a swap.
          */
         payload: SwapRequest;
         /**
          * Blinding data required to construct proofs.
          */
         outputData: OutputDataLike[];
         /**
          * List of booleans to determine which proofs to keep.
          */
         keepVector: boolean[];
         /**
          * Indices that can be used to restore original output data.
          */
         sortedIndices: number[];
     };

     /**
      * A Cashu token.
      */
     export declare type Token = {
         /**
          * The mints URL.
          */
         mint: string;
         /**
          * A list of proofs.
          */
         proofs: Proof[];
         /**
          * A message to send along with the token.
          */
         memo?: string;
         /**
          * The unit of the token.
          */
         unit?: string;
     };

     /**
      * Metadata for a Cashu token.
      */
     export declare type TokenMetadata = {
         /**
          * The unit of the token.
          */
         unit: string;
         /**
          * The memo of the token.
          */
         memo?: string;
         /**
          * The mint of the token.
          */
         mint: string;
         /**
          * The amount of the token.
          */
         amount: number;
         /**
          * The incomplete proofs of the token.
          */
         incompleteProofs: Array<Omit<Proof, 'id'>>;
     };

     export declare type TokenResponse = {
         access_token?: string;
         token_type?: string;
         expires_in?: number;
         refresh_token?: string;
         id_token?: string;
         scope?: string;
         error?: string;
         error_description?: string;
     };

     export declare function unblindSignature(C_: WeierstrassPoint<bigint>, r: bigint, A: WeierstrassPoint<bigint>): WeierstrassPoint<bigint>;

     /* Excluded from this release type: validateAmount */

     export declare const verifyDLEQProof: (dleq: DLEQ, B_: WeierstrassPoint<bigint>, C_: WeierstrassPoint<bigint>, A: WeierstrassPoint<bigint>) => boolean;

     export declare const verifyDLEQProof_reblind: (secret: Uint8Array, // secret
     dleq: DLEQ, C: WeierstrassPoint<bigint>, // unblinded e-cash signature point
     A: WeierstrassPoint<bigint>) => boolean;

     /**
      * Verify an HTLC hash/preimage pair.
      *
      * @param preimage - As a 64-character lowercase hexadecimal string.
      * @param hash - As a 64-character lowercase hexadecimal string.
      * @returns True if preimage calculates the same hash, False otherwise.
      */
     export declare function verifyHTLCHash(preimage: string, hash: string): boolean;

     /**
      * Verify HTLC spending conditions for a single input.
      *
      * Two spending paths are available:
      *
      * 1. Hashlock path: Preimage + signatures from the main pubkeys (always valid)
      * 2. Refund path: signatures from refund pubkeys (only valid after locktime)
      *
      * In addition, if the lock has expired and no refund keys are present, the proof is considered
      * unlocked and spendable without witness signatures.
      *
      * @remarks
      * Returns a detailed P2PKVerificationResult showing the conditions. If you just want a boolean
      * result, use isP2PKSpendAuthorised().
      * @param proof - The Proof to check.
      * @param logger - Optional logger (default: NULL_LOGGER)
      * @param message - Optional. The message to sign (for SIG_ALL)
      * @returns A P2PKVerificationResult describing the spending outcome.
      * @throws If verification is impossible.
      */
     export declare function verifyHTLCSpendingConditions(proof: Proof, logger?: Logger, message?: string): P2PKVerificationResult;

     /**
      * @deprecated Use Keyset.verifyKeysetId(keys), or init a Keyset and call keyset.verify().
      */
     export declare function verifyKeysetId(keys: MintKeys): boolean;

     export declare function verifyMintQuoteSignature(pubkey: string, quote: string, blindedMessages: SerializedBlindedMessage[], signature: string): boolean;

     /**
      * Verifies a Schnorr signature on a P2PK secret.
      *
      * @deprecated Use {@link schnorrVerifyMessage}
      */
     export declare const verifyP2PKSecretSignature: (signature: string, secret: string, pubkey: string) => boolean;

     /**
      * @deprecated Use {@link isP2PKSpendAuthorised} or {@link verifyP2PKSpendingConditions} instead.
      */
     export declare function verifyP2PKSig(proof: Proof): boolean;

     /**
      * Verify P2PK spending conditions for a single input.
      *
      * Two spending paths are available:
      *
      * 1. Normal path: signatures from the main pubkeys (always valid)
      * 2. Refund path: signatures from refund pubkeys (only valid after locktime)
      *
      * In addition, if the lock has expired and no refund keys are present, the proof is considered
      * unlocked and spendable without witness signatures.
      *
      * @remarks
      * Returns a detailed P2PKVerificationResult showing the conditions. If you just want a boolean
      * result, use isP2PKSpendAuthorised().
      * @param proof - The Proof to check.
      * @param logger - Optional logger (default: NULL_LOGGER)
      * @param message - Optional. The message to sign (for SIG_ALL)
      * @returns A P2PKVerificationResult describing the spending outcome.
      * @throws If verification is impossible.
      */
     export declare function verifyP2PKSpendingConditions(proof: Proof, logger?: Logger, message?: string): P2PKVerificationResult;

     export declare function verifyProof(proof: RawProof, privKey: Uint8Array): boolean;

     /**
      * Class that represents a Cashu wallet.
      *
      * @remarks
      * This class should act as the entry point for this library. Can be instantiated with a mint
      * instance or mint url.
      * @example
      *
      * ```typescript
      * import { Wallet } from '@cashu/cashu-ts';
      * const wallet = new Wallet('http://localhost:3338', { unit: 'sat' });
      * await wallet.loadMint(); // Initialize mint info, keysets, and keys
      * // Wallet is now ready to use, eg:
      * const proofs = [...]; // your array of unspent proofs
      * const { keep, send } = await wallet.send(32, proofs);
      * ```
      */
     export declare class Wallet {
         /**
          * Mint instance - allows direct calls to the mint.
          */
         readonly mint: Mint;
         /**
          * Entry point for the builder.
          *
          * @example
          *
          *     const { keep, send } = await wallet.ops
          *     	.send(5, proofs)
          *     	.asDeterministic() // counter: 0 = auto
          *     	.keepAsRandom()
          *     	.includeFees(true)
          *     	.run();
          *
          *     const proofs = await wallet.ops
          *     	.receive(token)
          *     	.asDeterministic()
          *     	.keyset(wallet.keysetId)
          *     	.run();
          */
         readonly ops: WalletOps;
         /**
          * Convenience wrapper for events.
          */
         readonly on: WalletEvents;
         /**
          * Developer-friendly counters API.
          */
         readonly counters: WalletCounters;
         private _keyChain;
         private _seed;
         private _unit;
         private _mintInfo;
         private _denominationTarget;
         private _secretsPolicy;
         private _counterSource;
         private _boundKeysetId;
         private _selectProofs;
         private _logger;
         /**
          * Create a wallet for a given mint and unit. Call `loadMint` before use.
          *
          * Binding, if `options.keysetId` is omitted, the wallet binds to the cheapest active keyset for
          * this unit during `loadMint`. The keychain only loads keysets for this unit.
          *
          * Caching, to preload, provide both `keysets` and `keys`, otherwise the cache is ignored.
          *
          * Deterministic secrets, pass `bip39seed` and optionally `secretsPolicy`. Deterministic outputs
          * reserve counters from `counterSource`, or an ephemeral in memory source if not supplied.
          * `initialCounter` applies only with a supplied `keysetId` and the ephemeral source.
          *
          * Splitting, `denominationTarget` guides proof splits, default is 3. Override coin selection with
          * `selectProofs` if needed. Logging defaults to a null logger.
          *
          * @remarks
          * The options.keys, options.keysets, options.mintInfo options are deprecated. Use
          * wallet.loadMintFromCache() after init to load cached mint data.
          * @param mint Mint instance or URL.
          * @param options Optional settings.
          * @param options.unit Wallet unit, default 'sat'.
          * @param options.keysetId Bind to this keyset id, else bind on `loadMint`.
          * @param options.bip39seed BIP39 seed for deterministic secrets.
          * @param options.secretsPolicy Secrets policy, default 'auto'.
          * @param options.counterSource Counter source for deterministic outputs. If provided, this takes
          *   precedence over counterInit. Use when you need persistence across processes or devices.
          * @param options.counterInit Seed values for the built-in EphemeralCounterSource. Ignored if
          *   counterSource is also provided.
          * @param options.keys DEPRECATED: Use `wallet.loadMintFromCache` after init.
          * @param options.keysets DEPRECATED: Use `wallet.loadMintFromCache` after init.
          * @param options.mintInfo DEPRECATED: Use `wallet.loadMintFromCache` after init.
          * @param options.denominationTarget Target proofs per denomination, default 3.
          * @param options.selectProofs Custom proof selection function.
          * @param options.logger Logger instance, default null logger.
          */
         constructor(mint: Mint | string, options?: {
             unit?: string;
             authProvider?: AuthProvider;
             keysetId?: string;
             bip39seed?: Uint8Array;
             secretsPolicy?: SecretsPolicy;
             counterSource?: CounterSource;
             counterInit?: Record<string, number>;
             /**
              * @deprecated Use `wallet.loadMintFromCache` after init.
              */
             keys?: MintKeys[] | MintKeys;
             /**
              * @deprecated Use `wallet.loadMintFromCache` after init.
              */
             keysets?: MintKeyset[];
             /**
              * @deprecated Use `wallet.loadMintFromCache` after init.
              */
             mintInfo?: GetInfoResponse;
             denominationTarget?: number;
             selectProofs?: SelectProofs;
             logger?: Logger;
         });
         private fail;
         private failIf;
         private failIfNullish;
         private safeCallback;
         /**
          * Asserts amount is a positive, safe integer.
          *
          * @param amount To check.
          * @param op Caller method name (or other identifier) for debug.
          * @throws If not.
          */
         private assertAmount;
         /**
          * Load mint information, keysets, and keys.
          *
          * @remarks
          * Must be called before using other methods, unless loading mint from cache. See:
          * `loadMintFromCache`.
          * @param forceRefresh If true, re-fetches data even if cached.
          * @throws If fetching mint info, keysets, or keys fails.
          */
         loadMint(forceRefresh?: boolean): Promise<void>;
         /**
          * Load mint information, keysets, and keys from cached data.
          *
          * @remarks
          * Use this when you already have cached mint info and keychain cache and want to avoid network
          * calls.
          *
          * The `cache` argument should usually come from `wallet.keyChain.cache`.
          */
         loadMintFromCache(mintInfo: GetInfoResponse, cache: KeyChainCache): void;
         /**
          * Finishes wiring up the wallet instance and checks we are "Go for launch".
          */
         private finishInit;
         /**
          * Get the wallet's KeyChain.
          *
          * @returns The Keychain.
          */
         get keyChain(): KeyChain;
         /**
          * Get the wallet's unit.
          *
          * @returns The unit (e.g., 'sat').
          */
         get unit(): string;
         /**
          * Get information about the mint.
          *
          * @remarks
          * Returns cached mint info. Call `loadMint` first to initialize the wallet.
          * @returns Mint info.
          * @throws If mint info is not initialized.
          */
         getMintInfo(): MintInfo;
         /**
          * The keyset ID bound to this wallet instance.
          */
         get keysetId(): string;
         /**
          * Gets the requested keyset or the keyset bound to the wallet.
          *
          * @remarks
          * This method enforces wallet policies. If `id` is omitted, it returns the keyset bound to this
          * wallet, including validation that:
          *
          * - The keyset exists in the keychain,
          * - The unit matches the wallet's unit,
          * - Keys are loaded for that keyset.
          *
          * Contrast with `keyChain.getKeyset(id?)`, which, when called without an id, returns the cheapest
          * active keyset for the unit, ignoring the wallet binding.
          * @param id Optional keyset id to resolve. If omitted, the wallet's bound keyset is used.
          * @returns The resolved `Keyset`.
          * @throws If the keyset is not found, has no keys, or its unit differs from the wallet.
          */
         getKeyset(id?: string): Keyset;
         get logger(): Logger;
         private reserveFor;
         private countersNeeded;
         private addCountersToOutputTypes;
         /**
          * Bind this wallet to a specific keyset id.
          *
          * @remarks
          * This changes the default keyset used by all operations that do not explicitly pass a keysetId.
          * The method validates that the keyset exists in the keychain, matches the wallet unit, and has
          * keys loaded.
          *
          * Typical uses:
          *
          * 1. After loadMint, to pin the wallet to a particular active keyset.
          * 2. After a refresh, to rebind deliberately rather than falling back to cheapest.
          *
          * @param id The keyset identifier to bind to.
          * @throws If keyset not found, if it has no keys loaded, or if its unit is not the wallet unit.
          */
         bindKeyset(id: string): void;
         /**
          * Creates a new Wallet bound to a different keyset, sharing the same CounterSource.
          *
          * Use this to operate on multiple keysets concurrently without mutating your original wallet.
          * Counters remain monotonic across instances because the same CounterSource is reused.
          *
          * Do NOT pass a fresh CounterSource for the same seed unless you know exactly why. Reusing
          * counters can recreate secrets that a mint will reject.
          *
          * @param id The keyset identifier to bind to.
          * @throws If keyset not found, if it has no keys loaded, or if its unit is not the wallet unit.
          */
         withKeyset(id: string, opts?: {
             counterSource?: CounterSource;
         }): Wallet;
         /**
          * Returns the default OutputType for this wallet, based on its configured secrets policy
          * (options?.secretsPolicy) and seed state.
          *
          * - If the secrets policy is 'random', returns { type: 'random' }.
          * - If the policy is 'deterministic', requires a seed and returns { type: 'deterministic', counter:
          *   0 }. Counter 0 is a flag meaning "auto-increment from current state".
          * - If no explicit policy is set, falls back to:
          *
          *   - Deterministic if a seed is present.
          *   - Random if no seed is present.
          *
          * @returns An OutputType object describing the default output strategy.
          * @throws Error if the policy is 'deterministic' but no seed has been set.
          */
         defaultOutputType(): OutputType;
         /**
          * Configures output denominations with fee adjustments and optimization.
          *
          * @remarks
          * If 'custom' outputType, data outputs MUST sum to the amount. Other outputTypes may supply
          * denominations. If no denominations are passed in, they will be calculated based on proofsWeHave
          * or the default split. If partial denominations are passed in, the balance will be added using
          * default split. Additional denominations to cover fees will then be added if required.
          * @param amount The total amount for outputs.
          * @param keyset The mint keyset.
          * @param outputType The output configuration.
          * @param includeFees Whether to include swap fees in the output amount.
          * @param proofsWeHave Optional proofs for optimizing denomination splitting.
          * @returns OutputType with required denominations.
          */
         private configureOutputs;
         /**
          * Sum total implied by a prepared OutputType. Note: Empty denomination is valid (e.g: zero
          * change).
          */
         private preparedTotal;
         /**
          * Generates blinded messages based on the specified output type.
          *
          * @param amount The total amount for outputs.
          * @param keyset The mint keys.
          * @param outputType The output configuration.
          * @returns Prepared output data.
          */
         private createOutputData;
         /**
          * Creates a swap transaction with sorted outputs for privacy. This prevents a mint working out
          * which proofs will be sent or kept.
          *
          * @param inputs Prepared input proofs.
          * @param keepOutputs Outputs to keep (change or receiver's proofs).
          * @param sendOutputs Outputs to send (optional, default empty for receive/mint).
          * @returns Swap transaction with payload and metadata for processing signatures.
          */
         private createSwapTransaction;
         /**
          * Receive a token (swaps with mint for new proofs)
          *
          * @example
          *
          * ```typescript
          * const result = await wallet.receive(
          * 	token,
          * 	{ includeFees: true },
          * 	{ type: 'deterministic', counter: 0 },
          * );
          * ```
          *
          * @param token Token string or decoded token.
          * @param config Optional receive config.
          * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
          * @returns Newly minted proofs.
          */
         receive(token: Token | string, config?: ReceiveConfig, outputType?: OutputType): Promise<Proof[]>;
         /**
          * Prepare A Receive Transaction.
          *
          * @remarks
          * Allows you to preview fees for a receive, get concrete outputs for P2PK SIG_ALL transactions,
          * and do any pre-swap tasks (such as marking proofs in-flight etc)
          * @example
          *
          * ```typescript
          * // Prepare transaction
          * const txn = await wallet.prepareSwapToReceive(token, { requireDleq: true });
          * const fees = txn.fees;
          *
          * // Complete transaction
          * const { keep } = await wallet.completeSwap(txn);
          * ```
          *
          * @param token Token string or decoded token.
          * @param config Optional receive config.
          * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
          * @returns SwapPreview with metadata for swap transaction.
          */
         prepareSwapToReceive(token: Token | string, config?: ReceiveConfig, outputType?: OutputType): Promise<SwapPreview>;
         /**
          * Sends proofs of a given amount from provided proofs.
          *
          * @remarks
          * If proofs are P2PK-locked to your public key, call signP2PKProofs first to sign them. The
          * default config uses exact match selection, and does not includeFees or requireDleq. Because the
          * send is offline, the user will unlock the signed proofs when they receive them online.
          * @param amount Amount to send.
          * @param proofs Array of proofs (must sum >= amount; pre-sign if P2PK-locked).
          * @param config Optional parameters for the send.
          * @returns SendResponse with keep/send proofs.
          * @throws Throws if the send cannot be completed offline.
          */
         sendOffline(amount: number, proofs: Proof[], config?: SendOfflineConfig): SendResponse;
         /**
          * Send proofs with online swap if necessary.
          *
          * @example
          *
          * ```typescript
          * // Simple send
          * const result = await wallet.send(5, proofs);
          *
          * // With a SendConfig
          * const result = await wallet.send(5, proofs, { includeFees: true });
          *
          * // With Custom output configuration
          * const customConfig: OutputConfig = {
          * 	send: { type: 'p2pk', options: { pubkey: '...' } },
          * 	keep: { type: 'deterministic', counter: 0 },
          * };
          * const customResult = await wallet.send(5, proofs, { includeFees: true }, customConfig);
          * ```
          *
          * @param amount Amount to send (receiver gets this net amount).
          * @param proofs Array of proofs to split.
          * @param config Optional parameters for the swap.
          * @returns SendResponse with keep/send proofs.
          * @throws Throws if the send cannot be completed offline or if funds are insufficient.
          */
         send(amount: number, proofs: Proof[], config?: SendConfig, outputConfig?: OutputConfig): Promise<SendResponse>;
         /**
          * Prepare A Send Transaction.
          *
          * @remarks
          * Allows you to preview fees for a send, get concrete outputs for P2PK SIG_ALL transactions, and
          * do any pre-swap tasks (such as marking proofs in-flight etc)
          * @example
          *
          * ```typescript
          * // Prepare transaction
          * const txn = await wallet.prepareSwapToSend(5, proofs, { includeFees: true });
          * const fees = txn.fees;
          *
          * // Complete transaction
          * const { keep, send } = await wallet.completeSwap(txn);
          * ```
          *
          * @param amount Amount to send (receiver gets this net amount).
          * @param proofs Array of proofs to split.
          * @param config Optional parameters for the swap.
          * @returns SwapPreview with metadata for swap transaction.
          * @throws Throws if the send cannot be completed offline or if funds are insufficient.
          */
         prepareSwapToSend(amount: number, proofs: Proof[], config?: SendConfig, outputConfig?: OutputConfig): Promise<SwapPreview>;
         /**
          * Complete a prepared swap transaction.
          *
          * @example
          *
          * ```typescript
          * // Prepare transaction
          * const txn = await wallet.prepareSwapToSend(5, proofs, { includeFees: true });
          *
          * // Complete transaction
          * const result = await wallet.completeSwap(txn);
          * ```
          *
          * @param swapPreview With metadata for swap transaction.
          * @param privkey The private key(s) for signing.
          * @returns SendResponse with keep/send proofs.
          */
         completeSwap(swapPreview: SwapPreview, privkey?: string | string[]): Promise<SendResponse>;
         /**
          * @deprecated - Use send()
          */
         readonly swap: (amount: number, proofs: Proof[], config?: SendConfig, outputConfig?: OutputConfig) => Promise<SendResponse>;
         /**
          * Selects proofs to send based on amount and fee inclusion.
          *
          * @remarks
          * Uses an adapted Randomized Greedy with Local Improvement (RGLI) algorithm, which has a time
          * complexity O(n log n) and space complexity O(n).
          * @param proofs Array of Proof objects available to select from.
          * @param amountToSend The target amount to send.
          * @param includeFees Optional boolean to include fees; Default: false.
          * @param exactMatch Optional boolean to require exact match; Default: false.
          * @returns SendResponse containing proofs to keep and proofs to send.
          * @throws Throws an error if an exact match cannot be found within MAX_TIMEMS.
          * @see https://crypto.ethz.ch/publications/files/Przyda02.pdf
          */
         selectProofsToSend(proofs: Proof[], amountToSend: number, includeFees?: boolean, exactMatch?: boolean): SendResponse;
         /**
          * Prepares proofs for sending by signing P2PK-locked proofs.
          *
          * @remarks
          * Call this method before operations like send if the proofs are P2PK-locked and need unlocking.
          * This is a public wrapper for signing.
          * @param proofs The proofs to sign.
          * @param privkey The private key(s) for signing.
          * @param outputData Optional. For signing of SIG_ALL transactions.
          * @param quoteId Optional. For signing SIG_ALL melt transactions.
          * @returns Signed proofs.
          */
         signP2PKProofs(proofs: Proof[], privkey: string | string[], outputData?: OutputDataLike[], quoteId?: string): Proof[];
         /**
          * Calculates the fees based on inputs (proofs)
          *
          * @param proofs Input proofs to calculate fees for.
          * @returns Fee amount.
          * @throws Throws an error if the proofs keyset is unknown.
          */
         getFeesForProofs(proofs: Proof[]): number;
         /**
          * Returns the current fee PPK for a proof according to the cached keyset.
          *
          * @param proof {Proof} A single proof.
          * @returns FeePPK {number} The feePPK for the selected proof.
          * @throws Throws an error if the proofs keyset is unknown.
          */
         private getProofFeePPK;
         /**
          * Calculates the fees based on inputs for a given keyset.
          *
          * @param nInputs Number of inputs.
          * @param keysetId KeysetId used to lookup `input_fee_ppk`
          * @returns Fee amount.
          */
         getFeesForKeyset(nInputs: number, keysetId: string): number;
         /**
          * Prepares inputs for a mint operation.
          *
          * @remarks
          * Internal method; strips DLEQ (NUT-12) and p2pk_e (NUT-26) for privacy and serializes witnesses.
          * Returns an array of new proof objects - does not mutate the originals.
          * @param proofs The proofs to prepare.
          * @param keepDleq Optional boolean to keep DLEQ (default: false, strips for privacy).
          * @returns Prepared proofs for mint payload.
          */
         private _prepareInputsForMint;
         /**
          * Decodes a string token.
          *
          * @remarks
          * Rehydrates a token from the space-saving CBOR format, including mapping short keyset ids to
          * their full representation.
          * @param token The token in string format (cashuB...)
          * @returns Token object.
          */
         decodeToken(token: string): Token;
         /**
          * Restores batches of deterministic proofs until no more signatures are returned from the mint.
          *
          * @param [gapLimit=300] The amount of empty counters that should be returned before restoring
          *   ends (defaults to 300). Default is `300`
          * @param [batchSize=100] The amount of proofs that should be restored at a time (defaults to
          *   100). Default is `100`
          * @param [counter=0] The counter that should be used as a starting point (defaults to 0). Default
          *   is `0`
          * @param [keysetId] Which keysetId to use for the restoration. If none is passed the instance's
          *   default one will be used.
          */
         batchRestore(gapLimit?: number, batchSize?: number, counter?: number, keysetId?: string): Promise<{
             proofs: Proof[];
             lastCounterWithSignature?: number;
         }>;
         /**
          * Regenerates.
          *
          * @param start Set starting point for count (first cycle for each keyset should usually be 0)
          * @param count Set number of blinded messages that should be generated.
          * @param options.keysetId Set a custom keysetId to restore from. @see `keyChain)`
          */
         restore(start: number, count: number, config?: RestoreConfig): Promise<{
             proofs: Proof[];
             lastCounterWithSignature?: number;
         }>;
         /**
          * @deprecated Use createMintQuoteBolt11()
          */
         createMintQuote(amount: number, description?: string): Promise<MintQuoteBolt11Response>;
         /**
          * Requests a mint quote from the mint. Response returns a Lightning payment request for the
          * requested given amount and unit.
          *
          * @param amount Amount requesting for mint.
          * @param description Optional description for the mint quote.
          * @param pubkey Optional public key to lock the quote to.
          * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the
          *   specified amount and unit.
          */
         createMintQuoteBolt11(amount: number, description?: string): Promise<MintQuoteBolt11Response>;
         /**
          * Requests a mint quote from the mint that is locked to a public key.
          *
          * @param amount Amount requesting for mint.
          * @param pubkey Public key to lock the quote to.
          * @param description Optional description for the mint quote.
          * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the
          *   specified amount and unit. The quote will be locked to the specified `pubkey`.
          */
         createLockedMintQuote(amount: number, pubkey: string, description?: string): Promise<MintQuoteBolt11Response>;
         /**
          * Requests a mint quote from the mint. Response returns a Lightning BOLT12 offer for the
          * requested given amount and unit.
          *
          * @param pubkey Public key to lock the quote to.
          * @param options.amount BOLT12 offer amount requesting for mint. If not specified, the offer will
          *   be amountless.
          * @param options.description Description for the mint quote.
          * @returns The mint will return a mint quote with a BOLT12 offer for minting tokens of the
          *   specified amount and unit.
          */
         createMintQuoteBolt12(pubkey: string, options?: {
             amount?: number;
             description?: string;
         }): Promise<MintQuoteBolt12Response>;
         /**
          * @deprecated Use checkMintQuoteBolt11()
          */
         checkMintQuote(quote: string | MintQuoteBolt11Response): Promise<MintQuoteBolt11Response>;
         /**
          * Gets an existing mint quote from the mint.
          *
          * @param quote Quote ID.
          * @returns The mint will create and return a Lightning invoice for the specified amount.
          */
         checkMintQuoteBolt11(quote: string | MintQuoteBolt11Response): Promise<MintQuoteBolt11Response>;
         /**
          * Gets an existing BOLT12 mint quote from the mint.
          *
          * @param quote Quote ID.
          * @returns The latest mint quote for the given quote ID.
          */
         checkMintQuoteBolt12(quote: string): Promise<MintQuoteBolt12Response>;
         /**
          * @deprecated Use mintProofsBolt11()
          */
         mintProofs(amount: number, quote: string | MintQuoteBolt11Response, config?: MintProofsConfig, outputType?: OutputType): Promise<Proof[]>;
         /**
          * Mint proofs for a bolt11 quote.
          *
          * @param amount Amount to mint.
          * @param quote Mint quote ID or object (bolt11).
          * @param config Optional parameters (e.g. privkey for locked quotes).
          * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
          * @returns Minted proofs.
          */
         mintProofsBolt11(amount: number, quote: string | MintQuoteBolt11Response, config?: MintProofsConfig, outputType?: OutputType): Promise<Proof[]>;
         /**
          * Mints proofs for a bolt12 quote.
          *
          * @param amount Amount to mint.
          * @param quote Bolt12 mint quote.
          * @param privkey Private key to unlock the quote.
          * @param config Optional parameters (e.g. keysetId).
          * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
          * @returns Minted proofs.
          */
         mintProofsBolt12(amount: number, quote: MintQuoteBolt12Response, privkey: string, config?: {
             keysetId?: string;
         }, outputType?: OutputType): Promise<Proof[]>;
         /**
          * Internal helper for minting proofs with bolt11 or bolt12.
          *
          * @remarks
          * Handles blinded messages, signatures, and proof construction. Use public methods like
          * mintProofs or helpers for API access.
          * @param method 'bolt11' or 'bolt12'.
          * @param amount Amount to mint (must be positive).
          * @param quote Quote ID or object.
          * @param config Optional (privkey, keysetId).
          * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
          * @returns Minted proofs.
          * @throws If params are invalid or mint returns errors.
          */
         private _mintProofs;
         /**
          * @deprecated Use createMeltQuoteBolt11.
          */
         createMeltQuote(invoice: string, amountMsat?: number): Promise<MeltQuoteBolt11Response>;
         /**
          * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order
          * to pay a Lightning invoice.
          *
          * @param invoice LN invoice that needs to get a fee estimate.
          * @param amountMsat Optional amount in millisatoshis to attach for amountless invoices, must not
          *   be provided for invoices that already encode an amount.
          * @returns The mint will create and return a melt quote for the invoice with an amount and fee
          *   reserve.
          */
         createMeltQuoteBolt11(invoice: string, amountMsat?: number): Promise<MeltQuoteBolt11Response>;
         /**
          * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order
          * to pay a BOLT12 offer.
          *
          * @param offer BOLT12 offer that needs to get a fee estimate.
          * @param amountMsat Amount in millisatoshis for amount-less offers. If this is defined and the
          *   offer has an amount, they **MUST** be equal.
          * @returns The mint will create and return a melt quote for the offer with an amount and fee
          *   reserve.
          */
         createMeltQuoteBolt12(offer: string, amountMsat?: number): Promise<MeltQuoteBolt12Response>;
         /**
          * Requests a multi path melt quote from the mint.
          *
          * @remarks
          * Uses NUT-15 Partial multi-path payments for BOLT11.
          * @param invoice LN invoice that needs to get a fee estimate.
          * @param partialAmount The partial amount of the invoice's total to be paid by this instance.
          * @returns The mint will create and return a melt quote for the invoice with an amount and fee
          *   reserve.
          * @see https://github.com/cashubtc/nuts/blob/main/15.md
          */
         createMultiPathMeltQuote(invoice: string, millisatPartialAmount: number): Promise<MeltQuoteBolt11Response>;
         /**
          * @deprecated Use checkMeltQuoteBolt11()
          */
         checkMeltQuote(quote: string | MeltQuoteBolt11Response): Promise<MeltQuoteBolt11Response>;
         /**
          * Returns an existing bolt11 melt quote from the mint.
          *
          * @param quote ID of the melt quote.
          * @returns The mint will return an existing melt quote.
          */
         checkMeltQuoteBolt11(quote: string | MeltQuoteBolt11Response): Promise<MeltQuoteBolt11Response>;
         /**
          * Returns an existing bolt12 melt quote from the mint.
          *
          * @param quote ID of the melt quote.
          * @returns The mint will return an existing melt quote.
          */
         checkMeltQuoteBolt12(quote: string): Promise<MeltQuoteBolt12Response>;
         /**
          * @deprecated Use meltProofsBolt11()
          */
         meltProofs(meltQuote: MeltQuoteBolt11Response, proofsToSend: Proof[], config?: MeltProofsConfig, outputType?: OutputType): Promise<MeltProofsResponse<MeltQuoteBolt11Response>>;
         /**
          * Melt proofs for a bolt11 melt quote.
          *
          * @remarks
          * ProofsToSend must be at least amount+fee_reserve from the melt quote. This function does not
          * perform coin selection!.
          * @param meltQuote ID of the melt quote.
          * @param proofsToSend Proofs to melt.
          * @param config Optional parameters.
          * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
          * @returns MeltProofsResponse with quote and change proofs.
          */
         meltProofsBolt11(meltQuote: MeltQuoteBolt11Response, proofsToSend: Proof[], config?: MeltProofsConfig, outputType?: OutputType): Promise<MeltProofsResponse<MeltQuoteBolt11Response>>;
         /**
          * Melt proofs for a bolt12 melt quote, returns change proofs using specified outputType.
          *
          * @remarks
          * ProofsToSend must be at least amount+fee_reserve from the melt quote. This function does not
          * perform coin selection!.
          * @param meltQuote ID of the melt quote.
          * @param proofsToSend Proofs to melt.
          * @param config Optional parameters.
          * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
          * @returns MeltProofsResponse with quote and change proofs.
          */
         meltProofsBolt12(meltQuote: MeltQuoteBolt12Response, proofsToSend: Proof[], config?: MeltProofsConfig, outputType?: OutputType): Promise<MeltProofsResponse<MeltQuoteBolt12Response>>;
         /**
          * Prepare A Melt Transaction.
          *
          * @remarks
          * Allows you to preview fees for a melt, get concrete outputs for P2PK SIG_ALL melts, and do any
          * pre-melt tasks (such as marking proofs in-flight etc). Creates NUT-08 blanks (1-sat) for
          * Lightning fee return and returns a MeltPreview, which you can melt using completeMelt.
          * @param method Payment method of the quote.
          * @param meltQuote The melt quote.
          * @param proofsToSend Proofs to melt.
          * @param config Optional (keysetId, onChangeOutputsCreated).
          * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().
          * @returns MeltPreview.
          * @throws If params are invalid.
          * @see https://github.com/cashubtc/nuts/blob/main/08.md.
          */
         prepareMelt<TQuote extends MeltQuoteBaseResponse>(method: string, meltQuote: TQuote, proofsToSend: Proof[], config?: MeltProofsConfig, outputType?: OutputType): Promise<MeltPreview<TQuote>>;
         /**
          * Completes a pending melt by calling the melt endpoint and constructing change proofs.
          *
          * @remarks
          * Use with a MeltPreview returned from prepareMelt or the legacy MeltBlanks object returned by
          * the meltBlanksCreated or onChangeOutputsCreated callback. This method lets you sign P2PK locked
          * proofs before melting. If the payment is pending or unpaid, the change array will be empty.
          * @param meltPreview The preview from prepareMelt().
          * @param privkey The private key(s) for signing.
          * @param preferAsync Optional override to set 'respond-async' header.
          * @returns Updated MeltProofsResponse.
          * @throws If melt fails or signatures don't match output count.
          */
         completeMelt<TQuote extends MeltQuoteBaseResponse>(meltPreview: MeltPreview<TQuote> | MeltBlanks<TQuote>, privkey?: string | string[], preferAsync?: boolean): Promise<MeltProofsResponse<TQuote>>;
         /**
          * Helper to ease transition from MeltBlanks to MeltPreview.
          */
         private maybeConvertMeltBlanks;
         /**
          * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)
          *
          * @param proofs (only the `secret` field is required)
          * @returns NUT-07 state for each proof, in same order.
          */
         checkProofsStates(proofs: Array<Pick<Proof, 'secret'>>): Promise<ProofState[]>;
         /**
          * Groups proofs by their corresponding state, preserving order within each group.
          *
          * @param proofs (only the `secret` field is required)
          * @returns An object with arrays of proofs grouped by CheckStateEnum state.
          */
         groupProofsByState(proofs: Proof[]): Promise<{
             unspent: Proof[];
             pending: Proof[];
             spent: Proof[];
         }>;
     }

     /**
      * Developer friendly view of the wallet's deterministic output counters.
      */
     export declare class WalletCounters {
         private readonly src;
         constructor(src: CounterSource);
         /**
          * Returns the "next" counter for a specified keyset.
          */
         peekNext(keysetId: string): Promise<number>;
         /**
          * Bumps the counter if it is behind `minNext` (no-op if ahead).
          */
         advanceToAtLeast(keysetId: string, minNext: number): Promise<void>;
         /**
          * Hard-sets the cursor (useful for tests or migrations).
          *
          * @throws If the CounterSource does not support setNext()
          */
         setNext(keysetId: string, next: number): Promise<void>;
         /**
          * Returns the current "next" per keyset (what will be reserved next).
          *
          * @throws If the CounterSource does not support snapshot()
          */
         snapshot(): Promise<Record<string, number>>;
     }

     export declare class WalletEvents {
         private wallet;
         constructor(wallet: Wallet);
         private countersReservedHandlers;
         private meltBlanksHandlers;
         private withAbort;
         private waitUntilPaid;
         /**
          * Register a callback that fires whenever deterministic counters are reserved.
          *
          * Timing: the callback is invoked synchronously _after_ a successful reservation and _before_ the
          * enclosing wallet method returns. The wallet does **not** await your callback, it is
          * fire-and-forget.
          *
          * Responsibility for async work is on the consumer. If your handler calls an async function (e.g.
          * persisting `start + count` to storage), make sure to handle errors inside it to avoid unhandled
          * rejections.
          *
          * Typical use: persist `start + count` for the `keysetId` so counters survive restarts.
          *
          * @example
          *
          * ```ts
          * wallet.on.countersReserved(({ keysetId, start, count, next }) => {
          * 	saveNextToDb(keysetId, start + count); // handle async errors inside saveNextToDb
          * });
          * ```
          *
          * @param cb Handler called with { keysetId, start, count }.
          * @returns A function that unsubscribes the handler.
          */
         countersReserved(cb: (payload: OperationCounters) => void, opts?: SubscribeOpts): SubscriptionCanceller;
         /* Excluded from this release type: _emitCountersReserved */
         /**
          * Register a callback fired whenever NUT-08 blanks are created during a melt.
          *
          * Called synchronously right after blanks are prepared (before the melt request), and the wallet
          * does not await your handler.
          *
          * Typical use: persist `payload` so you can later call `wallet.completeMelt(payload)`.
          *
          * @deprecated Use wallet.prepareMelt() and store the MeltPreview instead.
          */
         meltBlanksCreated(cb: (payload: MeltBlanks<MeltQuoteBaseResponse>) => void, opts?: SubscribeOpts): SubscriptionCanceller;
         /* Excluded from this release type: _emitMeltBlanksCreated */
         /**
          * Register a callback to be called whenever a mint quote's state changes.
          *
          * @param quoteIds List of mint quote IDs that should be subscribed to.
          * @param callback Callback function that will be called whenever a mint quote state changes.
          * @param errorCallback
          * @returns
          */
         mintQuoteUpdates(ids: string[], cb: (p: MintQuoteBolt11Response) => void, err: (e: Error) => void, opts?: SubscribeOpts): Promise<SubscriptionCanceller>;
         /**
          * Register a callback to be called when a single mint quote gets paid.
          *
          * @param quoteId Mint quote id that should be subscribed to.
          * @param callback Callback function that will be called when this mint quote gets paid.
          * @param errorCallback
          * @returns
          */
         mintQuotePaid(id: string, cb: (p: MintQuoteBolt11Response) => void, err: (e: Error) => void, opts?: SubscribeOpts): Promise<SubscriptionCanceller>;
         /**
          * Register a callback to be called whenever a melt quote’s state changes.
          *
          * @param quoteId Melt quote id that should be subscribed to.
          * @param callback Callback function that will be called when this melt quote gets paid.
          * @param errorCallback
          * @returns
          */
         meltQuoteUpdates(ids: string[], cb: (p: MeltQuoteBolt11Response) => void, err: (e: Error) => void, opts?: SubscribeOpts): Promise<SubscriptionCanceller>;
         /**
          * Register a callback to be called when a single melt quote gets paid.
          *
          * @param quoteIds List of melt quote IDs that should be subscribed to.
          * @param callback Callback function that will be called whenever a melt quote state changes.
          * @param errorCallback
          * @returns
          */
         meltQuotePaid(id: string, cb: (p: MeltQuoteBolt11Response) => void, err: (e: Error) => void, opts?: SubscribeOpts): Promise<SubscriptionCanceller>;
         /**
          * Register a callback to be called whenever a subscribed proof state changes.
          *
          * @param proofs List of proofs that should be subscribed to.
          * @param callback Callback function that will be called whenever a proof's state changes.
          * @param errorCallback
          * @returns
          */
         proofStateUpdates(proofs: Proof[], cb: (payload: ProofState & {
             proof: Proof;
         }) => void, err: (e: Error) => void, opts?: SubscribeOpts): Promise<SubscriptionCanceller>;
         /**
          * Resolve once a mint quote transitions to PAID, with automatic unsubscription, optional abort
          * signal, and optional timeout.
          *
          * The underlying subscription is always cancelled after resolution or rejection, including on
          * timeout or abort.
          *
          * @example
          *
          * ```ts
          * const ac = new AbortController();
          * // Cancel if the user navigates away
          * window.addEventListener('beforeunload', () => ac.abort(), { once: true });
          *
          * try {
          * 	const paid = await wallet.on.onceMintPaid(quoteId, {
          * 		signal: ac.signal,
          * 		timeoutMs: 60_000,
          * 	});
          * 	console.log('Mint paid, amount', paid.amount);
          * } catch (e) {
          * 	if ((e as Error).name === 'AbortError') {
          * 		console.log('User aborted');
          * 	} else {
          * 		console.error('Mint not paid', e);
          * 	}
          * }
          * ```
          *
          * @param id Mint quote id to watch.
          * @param opts Optional controls.
          * @param opts.signal AbortSignal to cancel the wait early.
          * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.
          * @returns A promise that resolves with the latest `MintQuoteBolt11Response` once PAID.
          */
         onceMintPaid(id: string, opts?: {
             signal?: AbortSignal;
             timeoutMs?: number;
         }): Promise<MintQuoteBolt11Response>;
         /**
          * Resolve when ANY of several mint quotes is PAID, cancelling the rest.
          *
          * Subscribes to all distinct ids, resolves with `{ id, quote }` for the first PAID, and cancels
          * all remaining subscriptions.
          *
          * Errors from individual subscriptions are ignored by default so a single noisy stream does not
          * abort the whole race. Set `failOnError: true` to reject on the first error instead. If all
          * subscriptions error and none paid, the promise rejects with the last seen error.
          *
          * @example
          *
          * ```ts
          * // Race multiple quotes obtained from splitting a large top up
          * const { id, quote } = await wallet.on.onceAnyMintPaid(batchQuoteIds, {
          * 	timeoutMs: 120_000,
          * });
          * console.log('First top up paid', id, quote.preimage?.length);
          * ```
          *
          * @param ids Array of mint quote ids (duplicates are ignored).
          * @param opts Optional controls.
          * @param opts.signal AbortSignal to cancel the wait early.
          * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.
          * @param opts.failOnError When true, reject on first error. Default false.
          * @returns A promise resolving to the id that won and its `MintQuoteBolt11Response`.
          */
         onceAnyMintPaid(ids: string[], opts?: {
             signal?: AbortSignal;
             timeoutMs?: number;
             failOnError?: boolean;
         }): Promise<{
             id: string;
             quote: MintQuoteBolt11Response;
         }>;
         /**
          * Resolve once a melt quote transitions to PAID, with automatic unsubscription, optional abort
          * signal, and optional timeout.
          *
          * Mirrors onceMintPaid, but for melts.
          *
          * @example
          *
          * ```ts
          * try {
          * 	const paid = await wallet.on.onceMeltPaid(meltId, { timeoutMs: 45_000 });
          * 	console.log('Invoice paid by mint, paid msat', paid.paid ?? 0);
          * } catch (e) {
          * 	console.error('Payment did not complete in time', e);
          * }
          * ```
          *
          * @param id Melt quote id to watch.
          * @param opts Optional controls.
          * @param opts.signal AbortSignal to cancel the wait early.
          * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.
          * @returns A promise that resolves with the `MeltQuoteBolt11Response` once PAID.
          */
         onceMeltPaid(id: string, opts?: {
             signal?: AbortSignal;
             timeoutMs?: number;
         }): Promise<MeltQuoteBolt11Response>;
         /**
          * Async iterable that yields proof state updates for the provided proofs.
          *
          * Adds a bounded buffer option:
          *
          * - If `maxBuffer` is set and the queue is full when a new payload arrives, either drop the oldest
          *   queued payload (`drop: 'oldest'`, default) or the incoming payload (`drop: 'newest'`). In
          *   both cases `onDrop` is invoked with the dropped payload.
          *
          * The stream ends and cleans up on abort or on the wallet error callback. Errors from the wallet
          * are treated as a graceful end for this iterator.
          *
          * @example
          *
          * ```ts
          * const ac = new AbortController();
          * try {
          * 	for await (const update of wallet.on.proofStatesStream(myProofs)) {
          * 		if (update.state === CheckStateEnum.SPENT) {
          * 			console.warn('Spent proof', update.proof.id);
          * 		}
          * 	}
          * } catch (e) {
          * 	if ((e as Error).name !== 'AbortError') {
          * 		console.error('Stream error', e);
          * 	}
          * }
          * ```
          *
          * @param proofs The proofs to subscribe to. Only `secret` is required.
          * @param opts Optional controls.
          * @param opts.signal AbortSignal that stops the stream when aborted.
          * @param opts.maxBuffer Maximum number of queued items before applying the drop strategy.
          * @param opts.drop Overflow strategy when `maxBuffer` is reached, 'oldest' | 'newest'. Default
          *   'oldest'.
          * @param opts.onDrop Callback invoked with the payload that was dropped.
          * @returns An async iterable of update payloads.
          */
         proofStatesStream<T = unknown>(proofs: Proof[], opts?: {
             signal?: AbortSignal;
             maxBuffer?: number;
             drop?: 'oldest' | 'newest';
             onDrop?: (payload: T) => void;
         }): AsyncIterable<T>;
         /**
          * Create a composite canceller that can collect many subscriptions and dispose them all in one
          * call.
          *
          * Accepts both a `SubscriptionCanceller` and a `Promise<SubscriptionCanceller>`. When the
          * composite canceller is called, all collected cancellations are invoked. Errors from individual
          * cancellers are caught and ignored.
          *
          * The returned function also has an `.add()` method to register more cancellers, and a
          * `.cancelled` boolean property for debugging.
          *
          * @example
          *
          * ```ts
          * const cancelAll = wallet.on.group();
          * cancelAll.add(wallet.on.mintQuotes(ids, onUpdate, onErr));
          * cancelAll.add(asyncSubscribeElsewhere());
          *
          * // later
          * cancelAll(); // disposes everything
          * ```
          *
          * @returns Composite canceller function with `.add()` and `.cancelled` members.
          */
         group(): SubscriptionCanceller & {
             add: (c: CancellerLike) => CancellerLike;
             cancelled: boolean;
         };
     }

     /**
      * Fluent operations builder for a Wallet instance.
      *
      * @remarks
      * Provides chainable builders for sending, receiving, and minting. Each builder is single use. If
      * you do not customise an output side, the wallet’s policy defaults apply.
      */
     export declare class WalletOps {
         private wallet;
         constructor(wallet: Wallet);
         send(amount: number, proofs: Proof[]): SendBuilder;
         receive(token: Token | string): ReceiveBuilder;
         mintBolt11(amount: number, quote: MintQuoteFor<'bolt11'>): MintBuilder<"bolt11", true>;
         mintBolt12(amount: number, quote: MintQuoteFor<'bolt12'>): MintBuilder<"bolt12", false>;
         meltBolt11(quote: MeltQuoteBolt11Response, proofs: Proof[]): MeltBuilder<MeltQuoteBolt11Response>;
         meltBolt12(quote: MeltQuoteBolt12Response, proofs: Proof[]): MeltBuilder<MeltQuoteBolt11Response>;
     }

     /**
      * WebSocket supported methods.
      */
     export declare type WebSocketSupport = {
         method: string;
         unit: string;
         commands: string[];
     };

     /**
      * @deprecated - Use SecretKind for NUT-10 kinds.
      */
     export declare type WellKnownSecret = 'P2PK';

     export declare class WSConnection {
         readonly url: URL;
         private readonly _WS;
         private ws;
         private connectionPromise;
         private subListeners;
         private rpcListeners;
         private messageQueue;
         private handlingInterval?;
         private rpcId;
         private _logger;
         private onCloseCallbacks;
         constructor(url: string, logger?: Logger);
         setLogger(logger: Logger): void;
         connect(timeoutMs?: number): Promise<void>;
         sendRequest(method: 'subscribe', params: JsonRpcReqParams): void;
         sendRequest(method: 'unsubscribe', params: {
             subId: string;
         }): void;
         /**
          * @deprecated Use cancelSubscription for JSONRPC compliance.
          */
         closeSubscription(subId: string): void;
         addSubListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void): void;
         private stopMessageHandling;
         private failPendingRpc;
         private sendRpcMessage;
         private addRpcListener;
         private removeRpcListener;
         private removeListener;
         ensureConnection(timeoutMs?: number): Promise<void>;
         private handleNextMessage;
         createSubscription<TPayload = unknown>(params: Omit<JsonRpcReqParams, 'subId'>, callback: (payload: TPayload) => void, errorCallback: (e: Error) => void): string;
         /**
          * Cancels a subscription, sending an unsubscribe request and handling responses.
          *
          * @param subId The subscription ID to cancel.
          * @param callback The original payload callback to remove.
          * @param errorCallback Optional callback for unsubscribe errors (defaults to logging).
          */
         cancelSubscription<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void, errorCallback?: (e: Error) => void): void;
         get activeSubscriptions(): string[];
         close(): void;
         onClose(callback: (e: CloseEvent) => void): void;
     }

     export { }
