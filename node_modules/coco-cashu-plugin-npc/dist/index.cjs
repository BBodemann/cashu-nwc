//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let npubcash_sdk = require("npubcash-sdk");
npubcash_sdk = __toESM(npubcash_sdk);
let coco_cashu_core = require("coco-cashu-core");
coco_cashu_core = __toESM(coco_cashu_core);

//#region src/sync/sinceStore.ts
/**
* In-memory implementation of SinceStore.
*
* Note: State is lost on restart. Use a database-backed
* implementation for production use cases that require durability.
*
* @example
* ```typescript
* const store = new MemorySinceStore(0);
* await store.set(Date.now());
* const since = await store.get(); // Returns the stored timestamp
* ```
*/
var MemorySinceStore = class {
	since;
	/**
	* Creates a new MemorySinceStore.
	* @param initialSince - Initial timestamp value (default: 0)
	*/
	constructor(initialSince = 0) {
		this.since = initialSince;
	}
	async get() {
		return this.since;
	}
	async set(since) {
		this.since = since;
	}
};
/**
* LocalStorage-based implementation of SinceStore.
*
* Persists the timestamp to browser localStorage, allowing state
* to survive page refreshes and browser restarts.
*
* Note: Only works in browser environments where localStorage is available.
* Will throw an error if localStorage is not accessible.
*
* @example
* ```typescript
* const store = new LocalStorageSinceStore("my-app-npc-since");
* await store.set(Date.now());
* const since = await store.get(); // Returns the stored timestamp
* ```
*/
var LocalStorageSinceStore = class {
	key;
	fallbackValue;
	/**
	* Creates a new LocalStorageSinceStore.
	* @param key - The localStorage key to use for storing the timestamp
	* @param fallbackValue - Value to return if no timestamp is stored (default: 0)
	* @throws {Error} If localStorage is not available
	*/
	constructor(key, fallbackValue = 0) {
		if (typeof localStorage === "undefined") throw new Error("LocalStorageSinceStore requires localStorage to be available");
		this.key = key;
		this.fallbackValue = fallbackValue;
	}
	async get() {
		const value = localStorage.getItem(this.key);
		if (value === null) return this.fallbackValue;
		const parsed = Number(value);
		return Number.isNaN(parsed) ? this.fallbackValue : parsed;
	}
	async set(since) {
		localStorage.setItem(this.key, String(since));
	}
	/**
	* Removes the stored timestamp from localStorage.
	*/
	async clear() {
		localStorage.removeItem(this.key);
	}
};

//#endregion
//#region src/types.ts
/**
* Creates a child logger if the logger supports it, otherwise returns the original
*/
function createChildLogger(logger, bindings) {
	if (!logger) return void 0;
	if (typeof logger.child === "function") return logger.child(bindings);
	return logger;
}
/**
* Formats a log message with optional context data
*/
function formatLogMessage(message, data) {
	if (!data || Object.keys(data).length === 0) return message;
	return `${message} ${JSON.stringify(data)}`;
}
/**
* Default values for quote transformation
*/
const QUOTE_DEFAULTS = {
	UNIT: "sat",
	STATE_PAID: "PAID"
};
/**
* Validates that a quote has required fields
*/
function isValidQuote(quote) {
	if (!quote || typeof quote !== "object") return false;
	const q = quote;
	return typeof q.quoteId === "string" && typeof q.mintUrl === "string" && typeof q.paidAt === "number";
}
/**
* Validates that a string is a valid URL
*/
function isValidUrl(url) {
	try {
		new URL(url);
		return true;
	} catch {
		return false;
	}
}

//#endregion
//#region src/PluginApi.ts
var PluginApi = class {
	prService;
	client;
	constructor(prService, client) {
		this.prService = prService;
		this.client = client;
	}
	async getInfo() {
		return this.client.getInfo();
	}
	async setUsername(username) {
		try {
			await this.client.setUsername(username);
			return { success: true };
		} catch (e) {
			if (!(e instanceof npubcash_sdk.PaymentRequiredError)) throw e;
			const creq = e.paymentRequest.toEncodedRequest();
			const cocoReq = await this.prService.processPaymentRequest(creq);
			if (!cocoReq.matchingMints[0]) throw new Error("No matching mints");
			const tx = await this.prService.preparePaymentRequestTransaction(cocoReq.matchingMints[0], cocoReq);
			return {
				success: false,
				pr: cocoReq.paymentRequest,
				acceptHandler: async () => {
					await this.prService.handleInbandPaymentRequest(tx, async (token) => {
						const tokenString = (0, coco_cashu_core.getEncodedToken)(token);
						await this.client.setUsername(username, tokenString);
					});
				}
			};
		}
	}
};

//#endregion
//#region src/plugins/NPCPlugin.ts
const requiredServices = [
	"mintQuoteService",
	"mintService",
	"paymentRequestService"
];
/** Default WebSocket reconnection settings */
const WEBSOCKET_DEFAULTS = {
	INITIAL_DELAY_MS: 5e3,
	MAX_DELAY_MS: 6e4,
	BACKOFF_MULTIPLIER: 2
};
/**
* NPubCash plugin for coco-cashu-core.
*
* This plugin bridges an NPubCash server with the coco-cashu wallet,
* polling for newly paid quotes and forwarding them to the mint quote service.
*/
var NPCPlugin = class {
	name = "npc";
	required = requiredServices;
	npcClient;
	sinceStore;
	logger;
	intervalMs;
	useWebsocket;
	isRunning = false;
	hasPendingUpdate = false;
	runPromise;
	unsubscribe;
	intervalTimer;
	isReady = false;
	isWebSocketConnected = false;
	wsReconnectAttempts = 0;
	wsReconnectTimer;
	ctx;
	isShuttingDown = false;
	/**
	* Creates a new NPCPlugin instance.
	*
	* @param baseUrl - The base URL of the NPubCash server
	* @param signer - Signer instance for JWT authentication
	* @param options - Plugin configuration options
	* @throws {Error} If baseUrl is not a valid URL
	*/
	constructor(baseUrl, signer, options) {
		if (!isValidUrl(baseUrl)) throw new Error(`Invalid baseUrl: ${baseUrl}`);
		const { syncIntervalMs, useWebsocket, sinceStore, logger } = options ?? {};
		this.sinceStore = sinceStore ?? new MemorySinceStore(0);
		this.logger = createChildLogger(logger, { module: "npc" });
		this.intervalMs = syncIntervalMs;
		this.useWebsocket = !!useWebsocket;
		const npcLogger = createChildLogger(logger, { module: "npc-client" });
		this.npcClient = new npubcash_sdk.NPCClient(baseUrl, new npubcash_sdk.JWTAuthProvider(baseUrl, signer, npcLogger));
	}
	/**
	* Returns the current status of the plugin.
	*/
	getStatus() {
		return {
			isInitialized: this.ctx !== void 0,
			isReady: this.isReady,
			isSyncing: this.isRunning,
			isWebSocketConnected: this.isWebSocketConnected
		};
	}
	/**
	* Called by coco-cashu-core during plugin initialization.
	* @internal
	*/
	onInit(ctx) {
		this.ctx = ctx;
		ctx.registerExtension("npc", new PluginApi(ctx.services.paymentRequestService, this.npcClient));
		return async () => {
			await this.shutdown();
		};
	}
	/**
	* Called by coco-cashu-core when the host is ready.
	* @internal
	*/
	onReady() {
		this.isReady = true;
		if (!this.ctx) return;
		if (this.useWebsocket) this.connectWebSocket();
		if (this.intervalMs !== void 0) this.armIntervalTimer();
	}
	/**
	* Manually triggers a sync operation.
	* If a sync is already in progress, returns the existing promise.
	*
	* @returns Promise that resolves when the sync completes
	*/
	async sync() {
		await this.requestSync("manual");
	}
	/**
	* Gracefully shuts down the plugin.
	* Waits for any in-flight sync operations to complete.
	*/
	async shutdown() {
		this.isShuttingDown = true;
		this.teardown();
		if (this.runPromise) try {
			await this.runPromise;
		} catch {}
	}
	teardown() {
		if (this.intervalTimer) {
			clearTimeout(this.intervalTimer);
			this.intervalTimer = void 0;
		}
		if (this.wsReconnectTimer) {
			clearTimeout(this.wsReconnectTimer);
			this.wsReconnectTimer = void 0;
		}
		if (this.unsubscribe) {
			try {
				this.unsubscribe();
			} catch (err) {
				this.logger?.warn?.(formatLogMessage("Error during WebSocket unsubscribe", { err: String(err) }));
			}
			this.unsubscribe = void 0;
			this.isWebSocketConnected = false;
		}
	}
	connectWebSocket() {
		if (this.isShuttingDown || this.unsubscribe) return;
		try {
			this.unsubscribe = this.npcClient.subscribe(() => {
				this.isWebSocketConnected = true;
				this.wsReconnectAttempts = 0;
				this.requestSync("websocket");
			}, (error) => {
				this.isWebSocketConnected = false;
				this.logger?.error?.(formatLogMessage("WebSocket error", {
					err: String(error),
					attempts: this.wsReconnectAttempts
				}));
				this.scheduleWebSocketReconnect();
			});
			this.isWebSocketConnected = true;
		} catch (err) {
			this.logger?.error?.(formatLogMessage("Failed to connect WebSocket", { err: String(err) }));
			this.scheduleWebSocketReconnect();
		}
	}
	scheduleWebSocketReconnect() {
		if (this.isShuttingDown || this.wsReconnectTimer) return;
		this.unsubscribe = void 0;
		this.isWebSocketConnected = false;
		const delay = Math.min(WEBSOCKET_DEFAULTS.INITIAL_DELAY_MS * Math.pow(WEBSOCKET_DEFAULTS.BACKOFF_MULTIPLIER, this.wsReconnectAttempts), WEBSOCKET_DEFAULTS.MAX_DELAY_MS);
		this.wsReconnectAttempts++;
		this.logger?.info?.(formatLogMessage("Scheduling WebSocket reconnect", {
			delay,
			attempt: this.wsReconnectAttempts
		}));
		this.wsReconnectTimer = setTimeout(() => {
			this.wsReconnectTimer = void 0;
			this.connectWebSocket();
		}, delay);
	}
	armIntervalTimer() {
		if (this.intervalMs === void 0 || this.isShuttingDown) return;
		if (this.intervalTimer) {
			clearTimeout(this.intervalTimer);
			this.intervalTimer = void 0;
		}
		this.intervalTimer = setTimeout(() => {
			this.requestSync("interval");
		}, this.intervalMs);
	}
	async requestSync(trigger) {
		if (!this.isReady || this.isShuttingDown) return;
		if (trigger === "interval") this.armIntervalTimer();
		if (this.isRunning) {
			this.hasPendingUpdate = true;
			return this.runPromise ?? Promise.resolve();
		}
		this.hasPendingUpdate = true;
		this.startRunner(trigger);
		return this.runPromise ?? Promise.resolve();
	}
	startRunner(trigger) {
		const ctx = this.ctx;
		if (!ctx) return;
		this.isRunning = true;
		this.runPromise = (async () => {
			try {
				do {
					this.hasPendingUpdate = false;
					await this.syncPaidQuotesOnce({
						mintQuoteService: ctx.services.mintQuoteService,
						mintService: ctx.services.mintService,
						trigger
					});
				} while (this.hasPendingUpdate && !this.isShuttingDown);
			} catch (err) {
				this.logger?.error?.(formatLogMessage("Sync failed", {
					err: String(err),
					trigger
				}));
			} finally {
				this.isRunning = false;
				this.runPromise = void 0;
			}
		})();
	}
	async syncPaidQuotesOnce(options) {
		const { mintQuoteService, mintService, trigger } = options;
		const since = await this.sinceStore.get();
		this.logger?.debug?.(formatLogMessage("Starting sync", {
			since,
			trigger
		}));
		const rawQuotes = await this.npcClient.getQuotesSince(since);
		if (!rawQuotes || rawQuotes.length === 0) {
			this.logger?.debug?.("No new quotes");
			return;
		}
		const quotes = [];
		for (const raw of rawQuotes) if (isValidQuote(raw)) if (isValidUrl(raw.mintUrl)) quotes.push(raw);
		else this.logger?.warn?.(formatLogMessage("Skipping quote with invalid mintUrl", {
			quoteId: raw.quoteId,
			mintUrl: raw.mintUrl
		}));
		else this.logger?.warn?.(formatLogMessage("Skipping invalid quote", { raw: JSON.stringify(raw) }));
		if (quotes.length === 0) {
			this.logger?.debug?.("No valid quotes after filtering");
			return;
		}
		const mintUrlToQuotes = /* @__PURE__ */ new Map();
		for (const quote of quotes) {
			const existing = mintUrlToQuotes.get(quote.mintUrl);
			if (existing) existing.push(quote);
			else mintUrlToQuotes.set(quote.mintUrl, [quote]);
		}
		await Promise.all(Array.from(mintUrlToQuotes.entries()).map(async ([mintUrl, list]) => {
			try {
				await mintService.addMintByUrl(mintUrl, { trusted: true });
				const transformedQuotes = list.map((quote) => ({
					...quote,
					unit: QUOTE_DEFAULTS.UNIT,
					expiry: quote.expiresAt,
					state: QUOTE_DEFAULTS.STATE_PAID,
					quote: quote.quoteId,
					request: quote.request ?? ""
				}));
				await mintQuoteService.addExistingMintQuotes(mintUrl, transformedQuotes);
				this.logger?.debug?.(formatLogMessage("Processed quotes for mint", {
					mintUrl,
					count: list.length
				}));
			} catch (err) {
				this.logger?.error?.(formatLogMessage("Failed to process quotes for mint", {
					err: String(err),
					mintUrl,
					quoteCount: list.length
				}));
				throw err;
			}
		}));
		const latestTimestamp = quotes.reduce((max, q) => Math.max(max, q.paidAt), since);
		if (latestTimestamp > since) {
			await this.sinceStore.set(latestTimestamp);
			this.logger?.debug?.(formatLogMessage("Updated since timestamp", {
				oldSince: since,
				newSince: latestTimestamp
			}));
		}
	}
};

//#endregion
exports.LocalStorageSinceStore = LocalStorageSinceStore;
exports.MemorySinceStore = MemorySinceStore;
exports.NPCPlugin = NPCPlugin;
exports.PluginApi = PluginApi;
exports.QUOTE_DEFAULTS = QUOTE_DEFAULTS;
exports.createChildLogger = createChildLogger;
exports.formatLogMessage = formatLogMessage;
exports.isValidQuote = isValidQuote;
exports.isValidUrl = isValidUrl;