import { normalizeMintUrl } from "coco-cashu-core";

//#region src/db.ts
/**
* Wrapper around sqlite3.Database providing async/await API and transaction management.
*
* Transaction behavior:
* - Nested transactions within the same scope are "rolled up" - they reuse the parent transaction
* - Concurrent transactions from different scopes are queued and executed serially
* - Each top-level transaction gets a unique scope token for identification
*/
var SqliteDb = class SqliteDb {
	root;
	/** Unique identifier for this instance's transaction scope (null for root instances) */
	scopeToken;
	constructor(optionsOrRoot, scopeToken = null) {
		if ("database" in optionsOrRoot) {
			this.root = {
				db: optionsOrRoot.database,
				transactionQueue: Promise.resolve(),
				currentScope: null,
				scopeDepth: 0
			};
			this.scopeToken = null;
		} else {
			this.root = optionsOrRoot;
			this.scopeToken = scopeToken;
		}
	}
	get raw() {
		return this.root.db;
	}
	exec(sql) {
		return new Promise((resolve, reject) => {
			this.root.db.exec(sql, (err) => {
				if (err) return reject(err);
				resolve();
			});
		});
	}
	run(sql, params = []) {
		return new Promise((resolve, reject) => {
			this.root.db.run(sql, params, function(err) {
				if (err) return reject(err);
				resolve({
					lastID: this.lastID,
					changes: this.changes
				});
			});
		});
	}
	get(sql, params = []) {
		return new Promise((resolve, reject) => {
			this.root.db.get(sql, params, (err, row) => {
				if (err) return reject(err);
				resolve(row);
			});
		});
	}
	all(sql, params = []) {
		return new Promise((resolve, reject) => {
			this.root.db.all(sql, params, (err, rows) => {
				if (err) return reject(err);
				resolve(rows);
			});
		});
	}
	/**
	* Execute a function within a database transaction.
	*
	* Transaction Semantics:
	*
	* 1. NESTED TRANSACTIONS (same scope):
	*    When transaction() is called from within an active transaction using the same
	*    scoped SqliteDb instance, the inner call is treated as part of the outer transaction.
	*    No new BEGIN/COMMIT is issued - the transaction is "rolled up".
	*
	* 2. CONCURRENT TRANSACTIONS (different scopes):
	*    When transaction() is called while another transaction is active but from a
	*    different scope (e.g., parallel calls), the new transaction waits in a queue.
	*    Transactions execute serially to prevent "cannot start a transaction within a transaction".
	*
	* 3. ERROR HANDLING:
	*    If the transaction function throws an error, ROLLBACK is executed and the error
	*    is re-thrown. The transaction queue is properly released even on error, allowing
	*    subsequent transactions to proceed.
	*
	* @param fn - Function to execute within the transaction, receives a scoped SqliteDb instance
	* @returns Promise that resolves with the return value of fn
	* @throws Re-throws any error from fn after rolling back the transaction
	*/
	async transaction(fn) {
		const { root } = this;
		if (this.scopeToken && root.currentScope === this.scopeToken) {
			root.scopeDepth++;
			try {
				return await fn(this);
			} finally {
				root.scopeDepth--;
			}
		}
		const scopeToken = Symbol("sqlite3-transaction");
		const scopedDb = new SqliteDb(root, scopeToken);
		const previousTransaction = root.transactionQueue;
		let resolver;
		root.transactionQueue = new Promise((resolve) => {
			resolver = resolve;
		});
		try {
			await previousTransaction;
			root.currentScope = scopeToken;
			root.scopeDepth = 1;
			await scopedDb.exec("BEGIN");
			try {
				const result = await fn(scopedDb);
				await scopedDb.exec("COMMIT");
				return result;
			} catch (error) {
				try {
					await scopedDb.exec("ROLLBACK");
				} catch {}
				throw error;
			}
		} finally {
			root.scopeDepth = 0;
			root.currentScope = null;
			resolver();
		}
	}
	close() {
		return new Promise((resolve, reject) => {
			this.root.db.close((err) => {
				if (err) return reject(err);
				resolve();
			});
		});
	}
};
function getUnixTimeSeconds() {
	return Math.floor(Date.now() / 1e3);
}

//#endregion
//#region src/schema.ts
const MIGRATIONS = [
	{
		id: "001_initial",
		sql: `
      CREATE TABLE IF NOT EXISTS coco_cashu_mints (
        mintUrl   TEXT PRIMARY KEY,
        name      TEXT NOT NULL,
        mintInfo  TEXT NOT NULL,
        createdAt INTEGER NOT NULL,
        updatedAt INTEGER NOT NULL
      );

      CREATE TABLE IF NOT EXISTS coco_cashu_keysets (
        mintUrl   TEXT NOT NULL,
        id        TEXT NOT NULL,
        keypairs  TEXT NOT NULL,
        active    INTEGER NOT NULL,
        feePpk    INTEGER NOT NULL,
        updatedAt INTEGER NOT NULL,
        PRIMARY KEY (mintUrl, id)
      );

      CREATE TABLE IF NOT EXISTS coco_cashu_counters (
        mintUrl  TEXT NOT NULL,
        keysetId TEXT NOT NULL,
        counter  INTEGER NOT NULL,
        PRIMARY KEY (mintUrl, keysetId)
      );

      CREATE TABLE IF NOT EXISTS coco_cashu_proofs (
        mintUrl   TEXT NOT NULL,
        id        TEXT NOT NULL,
        amount    INTEGER NOT NULL,
        secret    TEXT NOT NULL,
        C         TEXT NOT NULL,
        dleqJson  TEXT,
        witnessJson   TEXT,
        state     TEXT NOT NULL CHECK (state IN ('inflight', 'ready', 'spent')),
        createdAt INTEGER NOT NULL,
        PRIMARY KEY (mintUrl, secret)
      );

      CREATE INDEX IF NOT EXISTS idx_coco_cashu_proofs_state ON coco_cashu_proofs(state);
      CREATE INDEX IF NOT EXISTS idx_coco_cashu_proofs_mint_state ON coco_cashu_proofs(mintUrl, state);
      CREATE INDEX IF NOT EXISTS idx_coco_cashu_proofs_mint_id_state ON coco_cashu_proofs(mintUrl, id, state);

      CREATE TABLE IF NOT EXISTS coco_cashu_mint_quotes (
        mintUrl TEXT NOT NULL,
        quote   TEXT NOT NULL,
        state   TEXT NOT NULL CHECK (state IN ('UNPAID','PAID','ISSUED')),
        request TEXT NOT NULL,
        amount  INTEGER NOT NULL,
        unit    TEXT NOT NULL,
        expiry  INTEGER NOT NULL,
        pubkey  TEXT,
        PRIMARY KEY (mintUrl, quote)
      );

      CREATE INDEX IF NOT EXISTS idx_coco_cashu_mint_quotes_state ON coco_cashu_mint_quotes(state);
      CREATE INDEX IF NOT EXISTS idx_coco_cashu_mint_quotes_mint ON coco_cashu_mint_quotes(mintUrl);
    `
	},
	{
		id: "002_melt_quotes",
		sql: `
      CREATE TABLE IF NOT EXISTS coco_cashu_melt_quotes (
        mintUrl TEXT NOT NULL,
        quote   TEXT NOT NULL,
        state   TEXT NOT NULL CHECK (state IN ('UNPAID','PENDING','PAID')),
        request TEXT NOT NULL,
        amount  INTEGER NOT NULL,
        unit    TEXT NOT NULL,
        expiry  INTEGER NOT NULL,
        fee_reserve INTEGER NOT NULL,
        payment_preimage TEXT,
        PRIMARY KEY (mintUrl, quote)
      );

      CREATE INDEX IF NOT EXISTS idx_coco_cashu_melt_quotes_state ON coco_cashu_melt_quotes(state);
      CREATE INDEX IF NOT EXISTS idx_coco_cashu_melt_quotes_mint ON coco_cashu_melt_quotes(mintUrl);
    `
	},
	{
		id: "003_history",
		sql: `
      CREATE TABLE IF NOT EXISTS coco_cashu_history (
        id        INTEGER PRIMARY KEY AUTOINCREMENT,
        mintUrl   TEXT NOT NULL,
        type      TEXT NOT NULL CHECK (type IN ('mint','melt','send','receive')),
        unit      TEXT NOT NULL,
        amount    INTEGER NOT NULL,
        createdAt INTEGER NOT NULL,
        quoteId   TEXT,
        state     TEXT,
        paymentRequest TEXT,
        tokenJson TEXT,
        metadata  TEXT
      );

      CREATE INDEX IF NOT EXISTS idx_coco_cashu_history_mint_createdAt
        ON coco_cashu_history(mintUrl, createdAt DESC);
      CREATE INDEX IF NOT EXISTS idx_coco_cashu_history_mint_quote
        ON coco_cashu_history(mintUrl, quoteId);
      CREATE INDEX IF NOT EXISTS idx_coco_cashu_history_type
        ON coco_cashu_history(type);
      CREATE UNIQUE INDEX IF NOT EXISTS ux_coco_cashu_history_mint_quote_mint
        ON coco_cashu_history(mintUrl, quoteId, type)
        WHERE type = 'mint' AND quoteId IS NOT NULL;
      CREATE UNIQUE INDEX IF NOT EXISTS ux_coco_cashu_history_mint_quote_melt
        ON coco_cashu_history(mintUrl, quoteId, type)
        WHERE type = 'melt' AND quoteId IS NOT NULL;
    `
	},
	{
		id: "004_mint_trusted_field",
		sql: `
      ALTER TABLE coco_cashu_mints ADD COLUMN trusted INTEGER NOT NULL DEFAULT 1;
    `
	},
	{
		id: "005_keyset_unit_field",
		sql: `
      ALTER TABLE coco_cashu_keysets ADD COLUMN unit TEXT;
    `
	},
	{
		id: "006_keypairs",
		sql: `
      CREATE TABLE IF NOT EXISTS coco_cashu_keypairs (
        publicKey TEXT PRIMARY KEY,
        secretKey TEXT NOT NULL,
        createdAt INTEGER NOT NULL,
        derivationIndex INTEGER
      );

      CREATE INDEX IF NOT EXISTS idx_coco_cashu_keypairs_createdAt ON coco_cashu_keypairs(createdAt DESC);
      CREATE INDEX IF NOT EXISTS idx_coco_cashu_keypairs_derivationIndex ON coco_cashu_keypairs(derivationIndex DESC) WHERE derivationIndex IS NOT NULL;
    `
	},
	{
		id: "007_normalize_mint_urls",
		run: async (db) => {
			const mints = await db.all("SELECT mintUrl FROM coco_cashu_mints");
			const urlMapping = /* @__PURE__ */ new Map();
			for (const { mintUrl } of mints) {
				const normalized = normalizeMintUrl(mintUrl);
				urlMapping.set(mintUrl, normalized);
			}
			const normalizedToOriginal = /* @__PURE__ */ new Map();
			for (const [original, normalized] of urlMapping) {
				const existing = normalizedToOriginal.get(normalized);
				if (existing && existing !== original) throw new Error(`Mint URL normalization conflict: "${existing}" and "${original}" both normalize to "${normalized}". Please manually resolve this conflict before running the migration.`);
				normalizedToOriginal.set(normalized, original);
			}
			const tables = [
				"coco_cashu_mints",
				"coco_cashu_keysets",
				"coco_cashu_counters",
				"coco_cashu_proofs",
				"coco_cashu_mint_quotes",
				"coco_cashu_melt_quotes",
				"coco_cashu_history"
			];
			for (const [original, normalized] of urlMapping) {
				if (original === normalized) continue;
				for (const table of tables) await db.run(`UPDATE ${table} SET mintUrl = ? WHERE mintUrl = ?`, [normalized, original]);
			}
		}
	},
	{
		id: "008_send_operations",
		sql: `
      CREATE TABLE IF NOT EXISTS coco_cashu_send_operations (
        id         TEXT PRIMARY KEY,
        mintUrl    TEXT NOT NULL,
        amount     INTEGER NOT NULL,
        state      TEXT NOT NULL CHECK (state IN ('init', 'prepared', 'executing', 'pending', 'completed', 'rolling_back', 'rolled_back')),
        createdAt  INTEGER NOT NULL,
        updatedAt  INTEGER NOT NULL,
        error      TEXT,
        needsSwap  INTEGER,
        fee        INTEGER,
        inputAmount INTEGER,
        inputProofSecretsJson TEXT,
        outputDataJson TEXT
      );

      CREATE INDEX IF NOT EXISTS idx_coco_cashu_send_operations_state ON coco_cashu_send_operations(state);
      CREATE INDEX IF NOT EXISTS idx_coco_cashu_send_operations_mint ON coco_cashu_send_operations(mintUrl);

      ALTER TABLE coco_cashu_proofs ADD COLUMN usedByOperationId TEXT;
      ALTER TABLE coco_cashu_proofs ADD COLUMN createdByOperationId TEXT;

      CREATE INDEX IF NOT EXISTS idx_coco_cashu_proofs_usedByOp ON coco_cashu_proofs(usedByOperationId) WHERE usedByOperationId IS NOT NULL;
      CREATE INDEX IF NOT EXISTS idx_coco_cashu_proofs_createdByOp ON coco_cashu_proofs(createdByOperationId) WHERE createdByOperationId IS NOT NULL;
    `
	},
	{
		id: "009_history_send_operation",
		sql: `
      ALTER TABLE coco_cashu_history ADD COLUMN operationId TEXT;

      CREATE UNIQUE INDEX IF NOT EXISTS ux_coco_cashu_history_mint_operation_send
        ON coco_cashu_history(mintUrl, operationId)
        WHERE type = 'send' AND operationId IS NOT NULL;
    `
	},
	{
		id: "010_rename_completed_to_finalized",
		run: async (db) => {
			await db.run(`UPDATE coco_cashu_history SET state = 'finalized' WHERE type = 'send' AND state = 'completed'`);
			await db.exec(`
        CREATE TABLE coco_cashu_send_operations_new (
          id         TEXT PRIMARY KEY,
          mintUrl    TEXT NOT NULL,
          amount     INTEGER NOT NULL,
          state      TEXT NOT NULL CHECK (state IN ('init', 'prepared', 'executing', 'pending', 'finalized', 'rolling_back', 'rolled_back')),
          createdAt  INTEGER NOT NULL,
          updatedAt  INTEGER NOT NULL,
          error      TEXT,
          needsSwap  INTEGER,
          fee        INTEGER,
          inputAmount INTEGER,
          inputProofSecretsJson TEXT,
          outputDataJson TEXT
        );

        INSERT INTO coco_cashu_send_operations_new 
        SELECT 
          id, mintUrl, amount,
          CASE WHEN state = 'completed' THEN 'finalized' ELSE state END,
          createdAt, updatedAt, error, needsSwap, fee, inputAmount,
          inputProofSecretsJson, outputDataJson
        FROM coco_cashu_send_operations;

        DROP TABLE coco_cashu_send_operations;

        ALTER TABLE coco_cashu_send_operations_new RENAME TO coco_cashu_send_operations;

        CREATE INDEX IF NOT EXISTS idx_coco_cashu_send_operations_state ON coco_cashu_send_operations(state);
        CREATE INDEX IF NOT EXISTS idx_coco_cashu_send_operations_mint ON coco_cashu_send_operations(mintUrl);
      `);
		}
	},
	{
		id: "011_melt_operations",
		sql: `
      CREATE TABLE IF NOT EXISTS coco_cashu_melt_operations (
        id TEXT PRIMARY KEY,
        mintUrl TEXT NOT NULL,
        state TEXT NOT NULL CHECK (state IN ('init', 'prepared', 'executing', 'pending', 'finalized', 'rolling_back', 'rolled_back')),
        createdAt INTEGER NOT NULL,
        updatedAt INTEGER NOT NULL,
        error TEXT,
        method TEXT NOT NULL,
        methodDataJson TEXT NOT NULL,
        quoteId TEXT,
        amount INTEGER,
        fee_reserve INTEGER,
        swap_fee INTEGER,
        needsSwap INTEGER,
        inputAmount INTEGER,
        inputProofSecretsJson TEXT,
        changeOutputDataJson TEXT,
        swapOutputDataJson TEXT
      );

      CREATE INDEX IF NOT EXISTS idx_coco_cashu_melt_operations_state
        ON coco_cashu_melt_operations(state);
      CREATE INDEX IF NOT EXISTS idx_coco_cashu_melt_operations_mint
        ON coco_cashu_melt_operations(mintUrl);
      CREATE UNIQUE INDEX IF NOT EXISTS ux_coco_cashu_melt_operations_mint_quote
        ON coco_cashu_melt_operations(mintUrl, quoteId)
        WHERE quoteId IS NOT NULL;
    `
	}
];
/**
* Ensures the database schema is up to date by running all pending migrations.
*/
async function ensureSchema(db) {
	await ensureSchemaUpTo(db);
}
/**
* Run migrations up to (but not including) a specific migration ID.
* If stopBeforeId is not provided, runs all migrations.
* Used for testing migration behavior.
*/
async function ensureSchemaUpTo(db, stopBeforeId) {
	await db.exec(`
    PRAGMA foreign_keys = ON;
    PRAGMA journal_mode = WAL;
    PRAGMA synchronous = NORMAL;
  `);
	await db.exec(`
    CREATE TABLE IF NOT EXISTS coco_cashu_migrations (
      id        TEXT PRIMARY KEY,
      appliedAt INTEGER NOT NULL
    );
  `);
	const appliedRows = await db.all("SELECT id FROM coco_cashu_migrations ORDER BY id ASC");
	const applied = new Set(appliedRows.map((r) => r.id));
	for (const migration of MIGRATIONS) {
		if (stopBeforeId && migration.id === stopBeforeId) break;
		if (applied.has(migration.id)) continue;
		await db.transaction(async (tx) => {
			if (migration.sql) await tx.exec(migration.sql);
			if (migration.run) await migration.run(tx);
			await tx.run("INSERT INTO coco_cashu_migrations (id, appliedAt) VALUES (?, ?)", [migration.id, getUnixTimeSeconds()]);
		});
	}
}

//#endregion
//#region src/repositories/MintRepository.ts
var SqliteMintRepository = class {
	db;
	constructor(db) {
		this.db = db;
	}
	async isTrustedMint(mintUrl) {
		return (await this.db.get("SELECT trusted FROM coco_cashu_mints WHERE mintUrl = ? LIMIT 1", [mintUrl]))?.trusted === 1;
	}
	async getMintByUrl(mintUrl) {
		const row = await this.db.get("SELECT mintUrl, name, mintInfo, trusted, createdAt, updatedAt FROM coco_cashu_mints WHERE mintUrl = ? LIMIT 1", [mintUrl]);
		if (!row) throw new Error(`Mint not found: ${mintUrl}`);
		return {
			mintUrl: row.mintUrl,
			name: row.name,
			mintInfo: JSON.parse(row.mintInfo),
			trusted: row.trusted === 1,
			createdAt: row.createdAt,
			updatedAt: row.updatedAt
		};
	}
	async getAllMints() {
		return (await this.db.all("SELECT mintUrl, name, mintInfo, trusted, createdAt, updatedAt FROM coco_cashu_mints")).map((r) => ({
			mintUrl: r.mintUrl,
			name: r.name,
			mintInfo: JSON.parse(r.mintInfo),
			trusted: r.trusted === 1,
			createdAt: r.createdAt,
			updatedAt: r.updatedAt
		}));
	}
	async getAllTrustedMints() {
		return (await this.db.all("SELECT mintUrl, name, mintInfo, trusted, createdAt, updatedAt FROM coco_cashu_mints WHERE trusted = 1")).map((r) => ({
			mintUrl: r.mintUrl,
			name: r.name,
			mintInfo: JSON.parse(r.mintInfo),
			trusted: r.trusted === 1,
			createdAt: r.createdAt,
			updatedAt: r.updatedAt
		}));
	}
	async addNewMint(mint) {
		await this.db.run(`INSERT INTO coco_cashu_mints (mintUrl, name, mintInfo, trusted, createdAt, updatedAt)
       VALUES (?, ?, ?, ?, ?, ?)
       ON CONFLICT(mintUrl) DO UPDATE SET
         name=excluded.name,
         mintInfo=excluded.mintInfo,
         trusted=excluded.trusted,
         createdAt=excluded.createdAt,
         updatedAt=excluded.updatedAt`, [
			mint.mintUrl,
			mint.name,
			JSON.stringify(mint.mintInfo),
			mint.trusted ? 1 : 0,
			mint.createdAt,
			mint.updatedAt
		]);
	}
	async addOrUpdateMint(mint) {
		await this.db.run(`INSERT INTO coco_cashu_mints (mintUrl, name, mintInfo, trusted, createdAt, updatedAt)
       VALUES (?, ?, ?, ?, ?, ?)
       ON CONFLICT(mintUrl) DO UPDATE SET
         name=excluded.name,
         mintInfo=excluded.mintInfo,
         trusted=excluded.trusted,
         updatedAt=excluded.updatedAt`, [
			mint.mintUrl,
			mint.name,
			JSON.stringify(mint.mintInfo),
			mint.trusted ? 1 : 0,
			mint.createdAt,
			mint.updatedAt
		]);
	}
	async updateMint(mint) {
		await this.addNewMint(mint);
	}
	async setMintTrusted(mintUrl, trusted) {
		await this.db.run("UPDATE coco_cashu_mints SET trusted = ? WHERE mintUrl = ?", [trusted ? 1 : 0, mintUrl]);
	}
	async deleteMint(mintUrl) {
		await this.db.run("DELETE FROM coco_cashu_mints WHERE mintUrl = ?", [mintUrl]);
	}
};

//#endregion
//#region src/repositories/KeysetRepository.ts
var SqliteKeysetRepository = class {
	db;
	constructor(db) {
		this.db = db;
	}
	async getKeysetsByMintUrl(mintUrl) {
		return (await this.db.all("SELECT mintUrl, id, unit, keypairs, active, feePpk, updatedAt FROM coco_cashu_keysets WHERE mintUrl = ?", [mintUrl])).map((r) => ({
			mintUrl: r.mintUrl,
			id: r.id,
			unit: r.unit ?? "",
			keypairs: JSON.parse(r.keypairs),
			active: !!r.active,
			feePpk: r.feePpk,
			updatedAt: r.updatedAt
		}));
	}
	async getKeysetById(mintUrl, id) {
		const row = await this.db.get("SELECT mintUrl, id, unit, keypairs, active, feePpk, updatedAt FROM coco_cashu_keysets WHERE mintUrl = ? AND id = ? LIMIT 1", [mintUrl, id]);
		if (!row) return null;
		return {
			mintUrl: row.mintUrl,
			id: row.id,
			unit: row.unit ?? "",
			keypairs: JSON.parse(row.keypairs),
			active: !!row.active,
			feePpk: row.feePpk,
			updatedAt: row.updatedAt
		};
	}
	async updateKeyset(keyset) {
		const now = getUnixTimeSeconds();
		if (!await this.db.get("SELECT keypairs FROM coco_cashu_keysets WHERE mintUrl = ? AND id = ? LIMIT 1", [keyset.mintUrl, keyset.id])) {
			await this.db.run("INSERT INTO coco_cashu_keysets (mintUrl, id, unit, keypairs, active, feePpk, updatedAt) VALUES (?, ?, ?, ?, ?, ?, ?)", [
				keyset.mintUrl,
				keyset.id,
				keyset.unit,
				JSON.stringify({}),
				keyset.active ? 1 : 0,
				keyset.feePpk,
				now
			]);
			return;
		}
		await this.db.run("UPDATE coco_cashu_keysets SET unit = ?, active = ?, feePpk = ?, updatedAt = ? WHERE mintUrl = ? AND id = ?", [
			keyset.unit,
			keyset.active ? 1 : 0,
			keyset.feePpk,
			now,
			keyset.mintUrl,
			keyset.id
		]);
	}
	async addKeyset(keyset) {
		const now = getUnixTimeSeconds();
		await this.db.run(`INSERT INTO coco_cashu_keysets (mintUrl, id, unit, keypairs, active, feePpk, updatedAt)
       VALUES (?, ?, ?, ?, ?, ?, ?)
       ON CONFLICT(mintUrl, id) DO UPDATE SET
         unit=excluded.unit,
         keypairs=excluded.keypairs,
         active=excluded.active,
         feePpk=excluded.feePpk,
         updatedAt=excluded.updatedAt`, [
			keyset.mintUrl,
			keyset.id,
			keyset.unit,
			JSON.stringify(keyset.keypairs ?? {}),
			keyset.active ? 1 : 0,
			keyset.feePpk,
			now
		]);
	}
	async deleteKeyset(mintUrl, keysetId) {
		await this.db.run("DELETE FROM coco_cashu_keysets WHERE mintUrl = ? AND id = ?", [mintUrl, keysetId]);
	}
};

//#endregion
//#region src/utils.ts
/**
* Safely converts a hex string to Uint8Array with validation
* @throws Error if the hex string is invalid or malformed
*/
function hexToBytes(hexString) {
	if (!/^[0-9a-fA-F]+$/.test(hexString)) throw new Error(`Invalid hex string: contains non-hex characters`);
	if (hexString.length % 2 !== 0) throw new Error(`Invalid hex string: odd length (${hexString.length})`);
	const matches = hexString.match(/.{2}/g);
	if (!matches) throw new Error(`Failed to parse hex string`);
	return new Uint8Array(matches.map((byte) => parseInt(byte, 16)));
}
/**
* Converts a Uint8Array to hex string
*/
function bytesToHex(bytes) {
	return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}

//#endregion
//#region src/repositories/KeyRingRepository.ts
var SqliteKeyRingRepository = class {
	db;
	constructor(db) {
		this.db = db;
	}
	async getPersistedKeyPair(publicKey) {
		const row = await this.db.get("SELECT publicKey, secretKey, derivationIndex FROM coco_cashu_keypairs WHERE publicKey = ? LIMIT 1", [publicKey]);
		if (!row) return null;
		try {
			const secretKeyBytes = hexToBytes(row.secretKey);
			return {
				publicKeyHex: row.publicKey,
				secretKey: secretKeyBytes,
				derivationIndex: row.derivationIndex ?? void 0
			};
		} catch (error) {
			throw new Error(`Failed to parse secret key for public key ${publicKey}: ${error instanceof Error ? error.message : "unknown error"}`);
		}
	}
	async setPersistedKeyPair(keyPair) {
		const secretKeyHex = bytesToHex(keyPair.secretKey);
		await this.db.run(`INSERT INTO coco_cashu_keypairs (publicKey, secretKey, createdAt, derivationIndex)
       VALUES (?, ?, ?, ?)
       ON CONFLICT(publicKey) DO UPDATE SET
         secretKey=excluded.secretKey,
         derivationIndex=COALESCE(excluded.derivationIndex, coco_cashu_keypairs.derivationIndex)`, [
			keyPair.publicKeyHex,
			secretKeyHex,
			Date.now(),
			keyPair.derivationIndex ?? null
		]);
	}
	async deletePersistedKeyPair(publicKey) {
		await this.db.run("DELETE FROM coco_cashu_keypairs WHERE publicKey = ?", [publicKey]);
	}
	async getAllPersistedKeyPairs() {
		return (await this.db.all("SELECT publicKey, secretKey, derivationIndex FROM coco_cashu_keypairs")).map((row) => {
			try {
				const secretKeyBytes = hexToBytes(row.secretKey);
				return {
					publicKeyHex: row.publicKey,
					secretKey: secretKeyBytes,
					derivationIndex: row.derivationIndex ?? void 0
				};
			} catch (error) {
				throw new Error(`Failed to parse secret key for public key ${row.publicKey}: ${error instanceof Error ? error.message : "unknown error"}`);
			}
		});
	}
	async getLatestKeyPair() {
		const row = await this.db.get("SELECT publicKey, secretKey, derivationIndex FROM coco_cashu_keypairs ORDER BY createdAt DESC LIMIT 1");
		if (!row) return null;
		try {
			const secretKeyBytes = hexToBytes(row.secretKey);
			return {
				publicKeyHex: row.publicKey,
				secretKey: secretKeyBytes,
				derivationIndex: row.derivationIndex ?? void 0
			};
		} catch (error) {
			throw new Error(`Failed to parse latest secret key for public key ${row.publicKey}: ${error instanceof Error ? error.message : "unknown error"}`);
		}
	}
	async getLastDerivationIndex() {
		return (await this.db.get("SELECT derivationIndex FROM coco_cashu_keypairs WHERE derivationIndex IS NOT NULL ORDER BY derivationIndex DESC LIMIT 1"))?.derivationIndex ?? -1;
	}
};

//#endregion
//#region src/repositories/CounterRepository.ts
var SqliteCounterRepository = class {
	db;
	constructor(db) {
		this.db = db;
	}
	async getCounter(mintUrl, keysetId) {
		const row = await this.db.get("SELECT counter FROM coco_cashu_counters WHERE mintUrl = ? AND keysetId = ? LIMIT 1", [mintUrl, keysetId]);
		if (!row) return null;
		return {
			mintUrl,
			keysetId,
			counter: row.counter
		};
	}
	async setCounter(mintUrl, keysetId, counter) {
		await this.db.run(`INSERT INTO coco_cashu_counters (mintUrl, keysetId, counter)
       VALUES (?, ?, ?)
       ON CONFLICT(mintUrl, keysetId) DO UPDATE SET counter = excluded.counter`, [
			mintUrl,
			keysetId,
			counter
		]);
	}
};

//#endregion
//#region src/repositories/ProofRepository.ts
function rowToProof(r) {
	return {
		id: r.id,
		amount: r.amount,
		secret: r.secret,
		C: r.C,
		...r.dleqJson ? { dleq: JSON.parse(r.dleqJson) } : {},
		...r.witnessJson ? { witness: JSON.parse(r.witnessJson) } : {},
		mintUrl: r.mintUrl,
		state: r.state,
		...r.usedByOperationId ? { usedByOperationId: r.usedByOperationId } : {},
		...r.createdByOperationId ? { createdByOperationId: r.createdByOperationId } : {}
	};
}
var SqliteProofRepository = class {
	db;
	constructor(db) {
		this.db = db;
	}
	async saveProofs(mintUrl, proofs) {
		if (!proofs || proofs.length === 0) return;
		const now = getUnixTimeSeconds();
		await this.db.transaction(async (tx) => {
			const selectSql = "SELECT 1 AS x FROM coco_cashu_proofs WHERE mintUrl = ? AND secret = ? LIMIT 1";
			for (const p of proofs) if (await tx.get(selectSql, [mintUrl, p.secret])) throw new Error(`Proof with secret already exists: ${p.secret}`);
			const insertSql = "INSERT INTO coco_cashu_proofs (mintUrl, id, amount, secret, C, dleqJson, witnessJson, state, createdAt, usedByOperationId, createdByOperationId) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
			for (const p of proofs) {
				const dleqJson = p.dleq ? JSON.stringify(p.dleq) : null;
				const witnessJson = p.witness ? JSON.stringify(p.witness) : null;
				await tx.run(insertSql, [
					mintUrl,
					p.id,
					p.amount,
					p.secret,
					p.C,
					dleqJson,
					witnessJson,
					p.state,
					now,
					p.usedByOperationId ?? null,
					p.createdByOperationId ?? null
				]);
			}
		});
	}
	async getReadyProofs(mintUrl) {
		return (await this.db.all("SELECT mintUrl, id, amount, secret, C, dleqJson, witnessJson, state, usedByOperationId, createdByOperationId FROM coco_cashu_proofs WHERE mintUrl = ? AND state = \"ready\"", [mintUrl])).map(rowToProof);
	}
	async getInflightProofs(mintUrls) {
		if (!mintUrls || mintUrls.length === 0) return (await this.db.all("SELECT mintUrl, id, amount, secret, C, dleqJson, witnessJson, state, usedByOperationId, createdByOperationId FROM coco_cashu_proofs WHERE state = \"inflight\"")).map(rowToProof);
		const mintUrlList = mintUrls.map((url) => url.trim()).filter((url) => url.length > 0);
		if (mintUrlList.length === 0) return [];
		const uniqueMintUrls = Array.from(new Set(mintUrlList));
		const placeholders = uniqueMintUrls.map(() => "?").join(", ");
		return (await this.db.all(`SELECT mintUrl, id, amount, secret, C, dleqJson, witnessJson, state, usedByOperationId, createdByOperationId FROM coco_cashu_proofs WHERE state = "inflight" AND mintUrl IN (${placeholders})`, uniqueMintUrls)).map(rowToProof);
	}
	async getAllReadyProofs() {
		return (await this.db.all("SELECT mintUrl, id, amount, secret, C, dleqJson, witnessJson, state, usedByOperationId, createdByOperationId FROM coco_cashu_proofs WHERE state = \"ready\"")).map(rowToProof);
	}
	async getProofsByKeysetId(mintUrl, keysetId) {
		return (await this.db.all("SELECT mintUrl, id, amount, secret, C, dleqJson, witnessJson, state, usedByOperationId, createdByOperationId FROM coco_cashu_proofs WHERE mintUrl = ? AND id = ? AND state = \"ready\"", [mintUrl, keysetId])).map(rowToProof);
	}
	async setProofState(mintUrl, secrets, state) {
		if (!secrets || secrets.length === 0) return;
		await this.db.transaction(async (tx) => {
			const updateSql = "UPDATE coco_cashu_proofs SET state = ? WHERE mintUrl = ? AND secret = ?";
			for (const s of secrets) await tx.run(updateSql, [
				state,
				mintUrl,
				s
			]);
		});
	}
	async deleteProofs(mintUrl, secrets) {
		if (!secrets || secrets.length === 0) return;
		await this.db.transaction(async (tx) => {
			const delSql = "DELETE FROM coco_cashu_proofs WHERE mintUrl = ? AND secret = ?";
			for (const s of secrets) await tx.run(delSql, [mintUrl, s]);
		});
	}
	async wipeProofsByKeysetId(mintUrl, keysetId) {
		await this.db.run("DELETE FROM coco_cashu_proofs WHERE mintUrl = ? AND id = ?;", [mintUrl, keysetId]);
	}
	async reserveProofs(mintUrl, secrets, operationId) {
		if (!secrets || secrets.length === 0) return;
		await this.db.transaction(async (tx) => {
			const selectSql = "SELECT secret, state, usedByOperationId FROM coco_cashu_proofs WHERE mintUrl = ? AND secret = ?";
			for (const secret of secrets) {
				const row = await tx.get(selectSql, [mintUrl, secret]);
				if (!row) throw new Error(`Proof with secret not found: ${secret}`);
				if (row.state !== "ready") throw new Error(`Proof is not ready, cannot reserve: ${secret}`);
				if (row.usedByOperationId) throw new Error(`Proof already reserved by operation ${row.usedByOperationId}: ${secret}`);
			}
			const updateSql = "UPDATE coco_cashu_proofs SET usedByOperationId = ? WHERE mintUrl = ? AND secret = ?";
			for (const secret of secrets) await tx.run(updateSql, [
				operationId,
				mintUrl,
				secret
			]);
		});
	}
	async releaseProofs(mintUrl, secrets) {
		if (!secrets || secrets.length === 0) return;
		await this.db.transaction(async (tx) => {
			const updateSql = "UPDATE coco_cashu_proofs SET usedByOperationId = NULL WHERE mintUrl = ? AND secret = ?";
			for (const secret of secrets) await tx.run(updateSql, [mintUrl, secret]);
		});
	}
	async setCreatedByOperation(mintUrl, secrets, operationId) {
		if (!secrets || secrets.length === 0) return;
		await this.db.transaction(async (tx) => {
			const updateSql = "UPDATE coco_cashu_proofs SET createdByOperationId = ? WHERE mintUrl = ? AND secret = ?";
			for (const secret of secrets) await tx.run(updateSql, [
				operationId,
				mintUrl,
				secret
			]);
		});
	}
	async getProofBySecret(mintUrl, secret) {
		const row = await this.db.get("SELECT mintUrl, id, amount, secret, C, dleqJson, witnessJson, state, usedByOperationId, createdByOperationId FROM coco_cashu_proofs WHERE mintUrl = ? AND secret = ?", [mintUrl, secret]);
		return row ? rowToProof(row) : null;
	}
	async getProofsByOperationId(mintUrl, operationId) {
		return (await this.db.all("SELECT mintUrl, id, amount, secret, C, dleqJson, witnessJson, state, usedByOperationId, createdByOperationId FROM coco_cashu_proofs WHERE mintUrl = ? AND (usedByOperationId = ? OR createdByOperationId = ?)", [
			mintUrl,
			operationId,
			operationId
		])).map(rowToProof);
	}
	async getAvailableProofs(mintUrl) {
		return (await this.db.all("SELECT mintUrl, id, amount, secret, C, dleqJson, witnessJson, state, usedByOperationId, createdByOperationId FROM coco_cashu_proofs WHERE mintUrl = ? AND state = \"ready\" AND usedByOperationId IS NULL", [mintUrl])).map(rowToProof);
	}
	async getReservedProofs() {
		return (await this.db.all("SELECT mintUrl, id, amount, secret, C, dleqJson, witnessJson, state, usedByOperationId, createdByOperationId FROM coco_cashu_proofs WHERE state = \"ready\" AND usedByOperationId IS NOT NULL")).map(rowToProof);
	}
};

//#endregion
//#region src/repositories/MintQuoteRepository.ts
var SqliteMintQuoteRepository = class {
	db;
	constructor(db) {
		this.db = db;
	}
	async getMintQuote(mintUrl, quoteId) {
		const row = await this.db.get(`SELECT mintUrl, quote, state, request, amount, unit, expiry, pubkey
       FROM coco_cashu_mint_quotes WHERE mintUrl = ? AND quote = ? LIMIT 1`, [mintUrl, quoteId]);
		if (!row) return null;
		return {
			mintUrl: row.mintUrl,
			quote: row.quote,
			state: row.state,
			request: row.request,
			amount: row.amount,
			unit: row.unit,
			expiry: row.expiry,
			pubkey: row.pubkey ?? void 0
		};
	}
	async addMintQuote(quote) {
		await this.db.run(`INSERT INTO coco_cashu_mint_quotes (mintUrl, quote, state, request, amount, unit, expiry, pubkey)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)
       ON CONFLICT(mintUrl, quote) DO UPDATE SET
         state=excluded.state,
         request=excluded.request,
         amount=excluded.amount,
         unit=excluded.unit,
         expiry=excluded.expiry,
         pubkey=excluded.pubkey`, [
			quote.mintUrl,
			quote.quote,
			quote.state,
			quote.request,
			quote.amount,
			quote.unit,
			quote.expiry,
			quote.pubkey ?? null
		]);
	}
	async setMintQuoteState(mintUrl, quoteId, state) {
		await this.db.run("UPDATE coco_cashu_mint_quotes SET state = ? WHERE mintUrl = ? AND quote = ?", [
			state,
			mintUrl,
			quoteId
		]);
	}
	async getPendingMintQuotes() {
		return (await this.db.all(`SELECT mintUrl, quote, state, request, amount, unit, expiry, pubkey
       FROM coco_cashu_mint_quotes WHERE state != 'ISSUED'`)).map((row) => ({
			mintUrl: row.mintUrl,
			quote: row.quote,
			state: row.state,
			request: row.request,
			amount: row.amount,
			unit: row.unit,
			expiry: row.expiry,
			pubkey: row.pubkey ?? void 0
		}));
	}
};

//#endregion
//#region src/repositories/MeltQuoteRepository.ts
var SqliteMeltQuoteRepository = class {
	db;
	constructor(db) {
		this.db = db;
	}
	async getMeltQuote(mintUrl, quoteId) {
		const row = await this.db.get(`SELECT mintUrl, quote, state, request, amount, unit, expiry, fee_reserve, payment_preimage
       FROM coco_cashu_melt_quotes WHERE mintUrl = ? AND quote = ? LIMIT 1`, [mintUrl, quoteId]);
		if (!row) return null;
		return {
			mintUrl: row.mintUrl,
			quote: row.quote,
			state: row.state,
			request: row.request,
			amount: row.amount,
			unit: row.unit,
			expiry: row.expiry,
			fee_reserve: row.fee_reserve,
			payment_preimage: row.payment_preimage
		};
	}
	async addMeltQuote(quote) {
		await this.db.run(`INSERT INTO coco_cashu_melt_quotes (mintUrl, quote, state, request, amount, unit, expiry, fee_reserve, payment_preimage)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
       ON CONFLICT(mintUrl, quote) DO UPDATE SET
         state=excluded.state,
         request=excluded.request,
         amount=excluded.amount,
         unit=excluded.unit,
         expiry=excluded.expiry,
         fee_reserve=excluded.fee_reserve,
         payment_preimage=excluded.payment_preimage`, [
			quote.mintUrl,
			quote.quote,
			quote.state,
			quote.request,
			quote.amount,
			quote.unit,
			quote.expiry,
			quote.fee_reserve,
			quote.payment_preimage ?? null
		]);
	}
	async setMeltQuoteState(mintUrl, quoteId, state) {
		await this.db.run("UPDATE coco_cashu_melt_quotes SET state = ? WHERE mintUrl = ? AND quote = ?", [
			state,
			mintUrl,
			quoteId
		]);
	}
	async getPendingMeltQuotes() {
		return (await this.db.all(`SELECT mintUrl, quote, state, request, amount, unit, expiry, fee_reserve, payment_preimage
       FROM coco_cashu_melt_quotes WHERE state != 'PAID'`)).map((row) => ({
			mintUrl: row.mintUrl,
			quote: row.quote,
			state: row.state,
			request: row.request,
			amount: row.amount,
			unit: row.unit,
			expiry: row.expiry,
			fee_reserve: row.fee_reserve,
			payment_preimage: row.payment_preimage
		}));
	}
};

//#endregion
//#region src/repositories/HistoryRepository.ts
var SqliteHistoryRepository = class {
	db;
	constructor(db) {
		this.db = db;
	}
	async getPaginatedHistoryEntries(limit, offset) {
		return (await this.db.all(`SELECT id, mintUrl, type, unit, amount, createdAt, quoteId, state, paymentRequest, tokenJson, metadata, operationId
       FROM coco_cashu_history
       ORDER BY createdAt DESC, id DESC
       LIMIT ? OFFSET ?`, [limit, offset])).map((r) => this.rowToEntry(r));
	}
	async getHistoryEntryById(id) {
		const row = await this.db.get(`SELECT id, mintUrl, type, unit, amount, createdAt, quoteId, state, paymentRequest, tokenJson, metadata, operationId
       FROM coco_cashu_history WHERE id = ?`, [id]);
		if (!row) return null;
		return this.rowToEntry(row);
	}
	async addHistoryEntry(history) {
		const baseParams = [
			history.mintUrl,
			history.type,
			history.unit,
			history.amount,
			history.createdAt
		];
		let quoteId = null;
		let state = null;
		let paymentRequest = null;
		let tokenJson = null;
		let metadata = history.metadata ? JSON.stringify(history.metadata) : null;
		let operationId = null;
		switch (history.type) {
			case "mint": {
				const h = history;
				quoteId = h.quoteId;
				state = h.state;
				paymentRequest = h.paymentRequest;
				break;
			}
			case "melt": {
				const h = history;
				quoteId = h.quoteId;
				state = h.state;
				break;
			}
			case "send": {
				const h = history;
				tokenJson = h.token ? JSON.stringify(h.token) : null;
				operationId = h.operationId;
				state = h.state;
				break;
			}
			case "receive": {
				const h = history;
				tokenJson = h.token ? JSON.stringify(h.token) : null;
				break;
			}
		}
		const id = (await this.db.run(`INSERT INTO coco_cashu_history (mintUrl, type, unit, amount, createdAt, quoteId, state, paymentRequest, tokenJson, metadata, operationId)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`, [
			...baseParams,
			quoteId,
			state,
			paymentRequest,
			tokenJson,
			metadata,
			operationId
		])).lastID;
		const row = await this.db.get(`SELECT id, mintUrl, type, unit, amount, createdAt, quoteId, state, paymentRequest, tokenJson, metadata, operationId
       FROM coco_cashu_history WHERE id = ?`, [id]);
		if (!row) throw new Error("History insert failed to return row");
		return this.rowToEntry(row);
	}
	async getMintHistoryEntry(mintUrl, quoteId) {
		const row = await this.db.get(`SELECT id, mintUrl, type, unit, amount, createdAt, quoteId, state, paymentRequest, tokenJson, metadata, operationId
       FROM coco_cashu_history WHERE mintUrl = ? AND quoteId = ? AND type = 'mint'
       ORDER BY createdAt DESC, id DESC LIMIT 1`, [mintUrl, quoteId]);
		if (!row) return null;
		const entry = this.rowToEntry(row);
		return entry.type === "mint" ? entry : null;
	}
	async getMeltHistoryEntry(mintUrl, quoteId) {
		const row = await this.db.get(`SELECT id, mintUrl, type, unit, amount, createdAt, quoteId, state, paymentRequest, tokenJson, metadata, operationId
       FROM coco_cashu_history WHERE mintUrl = ? AND quoteId = ? AND type = 'melt'
       ORDER BY createdAt DESC, id DESC LIMIT 1`, [mintUrl, quoteId]);
		if (!row) return null;
		const entry = this.rowToEntry(row);
		return entry.type === "melt" ? entry : null;
	}
	async getSendHistoryEntry(mintUrl, operationId) {
		const row = await this.db.get(`SELECT id, mintUrl, type, unit, amount, createdAt, quoteId, state, paymentRequest, tokenJson, metadata, operationId
       FROM coco_cashu_history WHERE mintUrl = ? AND operationId = ? AND type = 'send'
       ORDER BY createdAt DESC, id DESC LIMIT 1`, [mintUrl, operationId]);
		if (!row) return null;
		const entry = this.rowToEntry(row);
		return entry.type === "send" ? entry : null;
	}
	async updateHistoryEntry(history) {
		let state = null;
		let paymentRequest = null;
		let tokenJson = null;
		if (history.type === "mint") {
			const h = history;
			if (!h.quoteId) throw new Error("quoteId required for mint entry");
			state = h.state;
			paymentRequest = h.paymentRequest;
			await this.db.run(`UPDATE coco_cashu_history SET unit = ?, amount = ?, state = ?, paymentRequest = ?, metadata = ?
         WHERE mintUrl = ? AND quoteId = ? AND type = 'mint'`, [
				history.unit,
				history.amount,
				state,
				paymentRequest,
				history.metadata ? JSON.stringify(history.metadata) : null,
				history.mintUrl,
				h.quoteId
			]);
			const row = await this.db.get(`SELECT id, mintUrl, type, unit, amount, createdAt, quoteId, state, paymentRequest, tokenJson, metadata, operationId
         FROM coco_cashu_history WHERE mintUrl = ? AND quoteId = ? AND type = 'mint'
         ORDER BY createdAt DESC, id DESC LIMIT 1`, [history.mintUrl, h.quoteId]);
			if (!row) throw new Error("Updated history entry not found");
			return this.rowToEntry(row);
		} else if (history.type === "melt") {
			const h = history;
			if (!h.quoteId) throw new Error("quoteId required for melt entry");
			state = h.state;
			await this.db.run(`UPDATE coco_cashu_history SET unit = ?, amount = ?, state = ?, metadata = ?
         WHERE mintUrl = ? AND quoteId = ? AND type = 'melt'`, [
				history.unit,
				history.amount,
				state,
				history.metadata ? JSON.stringify(history.metadata) : null,
				history.mintUrl,
				h.quoteId
			]);
			const row = await this.db.get(`SELECT id, mintUrl, type, unit, amount, createdAt, quoteId, state, paymentRequest, tokenJson, metadata, operationId
         FROM coco_cashu_history WHERE mintUrl = ? AND quoteId = ? AND type = 'melt'
         ORDER BY createdAt DESC, id DESC LIMIT 1`, [history.mintUrl, h.quoteId]);
			if (!row) throw new Error("Updated history entry not found");
			return this.rowToEntry(row);
		} else if (history.type === "send") {
			const h = history;
			if (!h.operationId) throw new Error("operationId required for send entry");
			state = h.state;
			tokenJson = h.token ? JSON.stringify(h.token) : null;
			await this.db.run(`UPDATE coco_cashu_history SET unit = ?, amount = ?, state = ?, tokenJson = ?, metadata = ?
         WHERE mintUrl = ? AND operationId = ? AND type = 'send'`, [
				history.unit,
				history.amount,
				state,
				tokenJson,
				history.metadata ? JSON.stringify(history.metadata) : null,
				history.mintUrl,
				h.operationId
			]);
			const row = await this.db.get(`SELECT id, mintUrl, type, unit, amount, createdAt, quoteId, state, paymentRequest, tokenJson, metadata, operationId
         FROM coco_cashu_history WHERE mintUrl = ? AND operationId = ? AND type = 'send'
         ORDER BY createdAt DESC, id DESC LIMIT 1`, [history.mintUrl, h.operationId]);
			if (!row) throw new Error("Updated history entry not found");
			return this.rowToEntry(row);
		} else throw new Error("updateHistoryEntry does not support receive entries");
	}
	async updateSendHistoryState(mintUrl, operationId, state) {
		await this.db.run(`UPDATE coco_cashu_history SET state = ?
       WHERE mintUrl = ? AND operationId = ? AND type = 'send'`, [
			state,
			mintUrl,
			operationId
		]);
	}
	async deleteHistoryEntry(mintUrl, quoteId) {
		await this.db.run("DELETE FROM coco_cashu_history WHERE mintUrl = ? AND quoteId = ?", [mintUrl, quoteId]);
	}
	rowToEntry(row) {
		const base = {
			id: String(row.id),
			createdAt: row.createdAt,
			mintUrl: row.mintUrl,
			unit: row.unit,
			metadata: row.metadata ? JSON.parse(row.metadata) : void 0
		};
		if (row.type === "mint") return {
			...base,
			type: "mint",
			paymentRequest: row.paymentRequest ?? "",
			quoteId: row.quoteId ?? "",
			state: row.state ?? "UNPAID",
			amount: row.amount
		};
		if (row.type === "melt") return {
			...base,
			type: "melt",
			quoteId: row.quoteId ?? "",
			state: row.state ?? "UNPAID",
			amount: row.amount
		};
		if (row.type === "send") return {
			...base,
			type: "send",
			amount: row.amount,
			operationId: row.operationId ?? "",
			state: row.state ?? "pending",
			token: row.tokenJson ? JSON.parse(row.tokenJson) : void 0
		};
		const token = row.tokenJson ? JSON.parse(row.tokenJson) : void 0;
		return {
			...base,
			type: "receive",
			amount: row.amount,
			token
		};
	}
};

//#endregion
//#region src/repositories/SendOperationRepository.ts
function rowToOperation$1(row) {
	const base = {
		id: row.id,
		mintUrl: row.mintUrl,
		amount: row.amount,
		createdAt: row.createdAt * 1e3,
		updatedAt: row.updatedAt * 1e3,
		error: row.error ?? void 0
	};
	if (row.state === "init") return {
		...base,
		state: "init"
	};
	const preparedData = {
		needsSwap: row.needsSwap === 1,
		fee: row.fee ?? 0,
		inputAmount: row.inputAmount ?? 0,
		inputProofSecrets: row.inputProofSecretsJson ? JSON.parse(row.inputProofSecretsJson) : [],
		outputData: row.outputDataJson ? JSON.parse(row.outputDataJson) : void 0
	};
	switch (row.state) {
		case "prepared": return {
			...base,
			state: "prepared",
			...preparedData
		};
		case "executing": return {
			...base,
			state: "executing",
			...preparedData
		};
		case "pending": return {
			...base,
			state: "pending",
			...preparedData
		};
		case "finalized": return {
			...base,
			state: "finalized",
			...preparedData
		};
		case "rolled_back": return {
			...base,
			state: "rolled_back",
			...preparedData
		};
		default: throw new Error(`Unknown state: ${row.state}`);
	}
}
function operationToParams$1(op) {
	const createdAtSeconds = Math.floor(op.createdAt / 1e3);
	const updatedAtSeconds = Math.floor(op.updatedAt / 1e3);
	if (op.state === "init") return [
		op.id,
		op.mintUrl,
		op.amount,
		op.state,
		createdAtSeconds,
		updatedAtSeconds,
		op.error ?? null,
		null,
		null,
		null,
		null,
		null
	];
	return [
		op.id,
		op.mintUrl,
		op.amount,
		op.state,
		createdAtSeconds,
		updatedAtSeconds,
		op.error ?? null,
		op.needsSwap ? 1 : 0,
		op.fee,
		op.inputAmount,
		JSON.stringify(op.inputProofSecrets),
		op.outputData ? JSON.stringify(op.outputData) : null
	];
}
var SqliteSendOperationRepository = class {
	db;
	constructor(db) {
		this.db = db;
	}
	async create(operation) {
		if (await this.db.get("SELECT id FROM coco_cashu_send_operations WHERE id = ? LIMIT 1", [operation.id])) throw new Error(`SendOperation with id ${operation.id} already exists`);
		const params = operationToParams$1(operation);
		await this.db.run(`INSERT INTO coco_cashu_send_operations 
        (id, mintUrl, amount, state, createdAt, updatedAt, error, needsSwap, fee, inputAmount, inputProofSecretsJson, outputDataJson)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`, params);
	}
	async update(operation) {
		if (!await this.db.get("SELECT id FROM coco_cashu_send_operations WHERE id = ? LIMIT 1", [operation.id])) throw new Error(`SendOperation with id ${operation.id} not found`);
		const updatedAtSeconds = getUnixTimeSeconds();
		if (operation.state === "init") await this.db.run(`UPDATE coco_cashu_send_operations 
         SET state = ?, updatedAt = ?, error = ?
         WHERE id = ?`, [
			operation.state,
			updatedAtSeconds,
			operation.error ?? null,
			operation.id
		]);
		else await this.db.run(`UPDATE coco_cashu_send_operations 
         SET state = ?, updatedAt = ?, error = ?, needsSwap = ?, fee = ?, inputAmount = ?, inputProofSecretsJson = ?, outputDataJson = ?
         WHERE id = ?`, [
			operation.state,
			updatedAtSeconds,
			operation.error ?? null,
			operation.needsSwap ? 1 : 0,
			operation.fee,
			operation.inputAmount,
			JSON.stringify(operation.inputProofSecrets),
			operation.outputData ? JSON.stringify(operation.outputData) : null,
			operation.id
		]);
	}
	async getById(id) {
		const row = await this.db.get("SELECT * FROM coco_cashu_send_operations WHERE id = ?", [id]);
		return row ? rowToOperation$1(row) : null;
	}
	async getByState(state) {
		return (await this.db.all("SELECT * FROM coco_cashu_send_operations WHERE state = ?", [state])).map(rowToOperation$1);
	}
	async getPending() {
		return (await this.db.all("SELECT * FROM coco_cashu_send_operations WHERE state IN (\"executing\", \"pending\", \"rolling_back\")")).map(rowToOperation$1);
	}
	async getByMintUrl(mintUrl) {
		return (await this.db.all("SELECT * FROM coco_cashu_send_operations WHERE mintUrl = ?", [mintUrl])).map(rowToOperation$1);
	}
	async delete(id) {
		await this.db.run("DELETE FROM coco_cashu_send_operations WHERE id = ?", [id]);
	}
};

//#endregion
//#region src/repositories/MeltOperationRepository.ts
const preparedStates = [
	"prepared",
	"executing",
	"pending",
	"finalized",
	"rolling_back",
	"rolled_back"
];
const isPreparedState = (state) => preparedStates.includes(state);
const rowToOperation = (row) => {
	const base = {
		id: row.id,
		mintUrl: row.mintUrl,
		method: row.method,
		methodData: JSON.parse(row.methodDataJson),
		createdAt: row.createdAt * 1e3,
		updatedAt: row.updatedAt * 1e3,
		error: row.error ?? void 0
	};
	if (!isPreparedState(row.state)) return {
		...base,
		state: "init"
	};
	const preparedData = {
		quoteId: row.quoteId ?? "",
		amount: row.amount ?? 0,
		fee_reserve: row.fee_reserve ?? 0,
		swap_fee: row.swap_fee ?? 0,
		needsSwap: row.needsSwap === 1,
		inputAmount: row.inputAmount ?? 0,
		inputProofSecrets: row.inputProofSecretsJson ? JSON.parse(row.inputProofSecretsJson) : [],
		changeOutputData: row.changeOutputDataJson ? JSON.parse(row.changeOutputDataJson) : {
			keep: [],
			send: []
		},
		swapOutputData: row.swapOutputDataJson ? JSON.parse(row.swapOutputDataJson) : void 0
	};
	return {
		...base,
		state: row.state,
		...preparedData
	};
};
const operationToParams = (operation) => {
	const createdAtSeconds = Math.floor(operation.createdAt / 1e3);
	const updatedAtSeconds = Math.floor(operation.updatedAt / 1e3);
	const methodDataJson = JSON.stringify(operation.methodData);
	if (operation.state === "init") return [
		operation.id,
		operation.mintUrl,
		operation.state,
		createdAtSeconds,
		updatedAtSeconds,
		operation.error ?? null,
		operation.method,
		methodDataJson,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null,
		null
	];
	return [
		operation.id,
		operation.mintUrl,
		operation.state,
		createdAtSeconds,
		updatedAtSeconds,
		operation.error ?? null,
		operation.method,
		methodDataJson,
		operation.quoteId,
		operation.amount,
		operation.fee_reserve,
		operation.swap_fee,
		operation.needsSwap ? 1 : 0,
		operation.inputAmount,
		JSON.stringify(operation.inputProofSecrets),
		JSON.stringify(operation.changeOutputData),
		operation.swapOutputData ? JSON.stringify(operation.swapOutputData) : null
	];
};
var SqliteMeltOperationRepository = class {
	db;
	constructor(db) {
		this.db = db;
	}
	async create(operation) {
		if (operation.state === "failed") throw new Error("Cannot persist failed melt operation");
		if (await this.db.get("SELECT id FROM coco_cashu_melt_operations WHERE id = ? LIMIT 1", [operation.id])) throw new Error(`MeltOperation with id ${operation.id} already exists`);
		const params = operationToParams(operation);
		await this.db.run(`INSERT INTO coco_cashu_melt_operations
        (id, mintUrl, state, createdAt, updatedAt, error, method, methodDataJson, quoteId, amount, fee_reserve, swap_fee, needsSwap, inputAmount, inputProofSecretsJson, changeOutputDataJson, swapOutputDataJson)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`, params);
	}
	async update(operation) {
		if (operation.state === "failed") throw new Error("Cannot persist failed melt operation");
		if (!await this.db.get("SELECT id FROM coco_cashu_melt_operations WHERE id = ? LIMIT 1", [operation.id])) throw new Error(`MeltOperation with id ${operation.id} not found`);
		const updatedAtSeconds = getUnixTimeSeconds();
		if (operation.state === "init") {
			await this.db.run(`UPDATE coco_cashu_melt_operations
         SET state = ?, updatedAt = ?, error = ?, method = ?, methodDataJson = ?
         WHERE id = ?`, [
				operation.state,
				updatedAtSeconds,
				operation.error ?? null,
				operation.method,
				JSON.stringify(operation.methodData),
				operation.id
			]);
			return;
		}
		await this.db.run(`UPDATE coco_cashu_melt_operations
       SET state = ?, updatedAt = ?, error = ?, method = ?, methodDataJson = ?, quoteId = ?, amount = ?, fee_reserve = ?, swap_fee = ?, needsSwap = ?, inputAmount = ?, inputProofSecretsJson = ?, changeOutputDataJson = ?, swapOutputDataJson = ?
       WHERE id = ?`, [
			operation.state,
			updatedAtSeconds,
			operation.error ?? null,
			operation.method,
			JSON.stringify(operation.methodData),
			operation.quoteId,
			operation.amount,
			operation.fee_reserve,
			operation.swap_fee,
			operation.needsSwap ? 1 : 0,
			operation.inputAmount,
			JSON.stringify(operation.inputProofSecrets),
			JSON.stringify(operation.changeOutputData),
			operation.swapOutputData ? JSON.stringify(operation.swapOutputData) : null,
			operation.id
		]);
	}
	async getById(id) {
		const row = await this.db.get("SELECT * FROM coco_cashu_melt_operations WHERE id = ?", [id]);
		return row ? rowToOperation(row) : null;
	}
	async getByState(state) {
		return (await this.db.all("SELECT * FROM coco_cashu_melt_operations WHERE state = ?", [state])).map(rowToOperation);
	}
	async getPending() {
		return (await this.db.all("SELECT * FROM coco_cashu_melt_operations WHERE state IN (\"executing\", \"pending\")")).map(rowToOperation);
	}
	async getByMintUrl(mintUrl) {
		return (await this.db.all("SELECT * FROM coco_cashu_melt_operations WHERE mintUrl = ?", [mintUrl])).map(rowToOperation);
	}
	async getByQuoteId(mintUrl, quoteId) {
		return (await this.db.all("SELECT * FROM coco_cashu_melt_operations WHERE mintUrl = ? AND quoteId = ?", [mintUrl, quoteId])).map(rowToOperation);
	}
	async delete(id) {
		await this.db.run("DELETE FROM coco_cashu_melt_operations WHERE id = ?", [id]);
	}
};

//#endregion
//#region src/index.ts
var SqliteRepositories = class {
	mintRepository;
	keyRingRepository;
	counterRepository;
	keysetRepository;
	proofRepository;
	mintQuoteRepository;
	meltQuoteRepository;
	historyRepository;
	sendOperationRepository;
	meltOperationRepository;
	db;
	constructor(options) {
		this.db = new SqliteDb(options);
		this.mintRepository = new SqliteMintRepository(this.db);
		this.keyRingRepository = new SqliteKeyRingRepository(this.db);
		this.counterRepository = new SqliteCounterRepository(this.db);
		this.keysetRepository = new SqliteKeysetRepository(this.db);
		this.proofRepository = new SqliteProofRepository(this.db);
		this.mintQuoteRepository = new SqliteMintQuoteRepository(this.db);
		this.meltQuoteRepository = new SqliteMeltQuoteRepository(this.db);
		this.historyRepository = new SqliteHistoryRepository(this.db);
		this.sendOperationRepository = new SqliteSendOperationRepository(this.db);
		this.meltOperationRepository = new SqliteMeltOperationRepository(this.db);
	}
	async init() {
		await ensureSchema(this.db);
	}
	async withTransaction(fn) {
		return this.db.transaction(async (txDb) => {
			return fn({
				mintRepository: new SqliteMintRepository(txDb),
				keyRingRepository: new SqliteKeyRingRepository(txDb),
				counterRepository: new SqliteCounterRepository(txDb),
				keysetRepository: new SqliteKeysetRepository(txDb),
				proofRepository: new SqliteProofRepository(txDb),
				mintQuoteRepository: new SqliteMintQuoteRepository(txDb),
				meltQuoteRepository: new SqliteMeltQuoteRepository(txDb),
				historyRepository: new SqliteHistoryRepository(txDb),
				sendOperationRepository: new SqliteSendOperationRepository(txDb),
				meltOperationRepository: new SqliteMeltOperationRepository(txDb)
			});
		});
	}
};

//#endregion
export { MIGRATIONS, SqliteCounterRepository, SqliteDb, SqliteHistoryRepository, SqliteKeyRingRepository, SqliteKeysetRepository, SqliteMeltOperationRepository, SqliteMeltQuoteRepository, SqliteMintQuoteRepository, SqliteMintRepository, SqliteProofRepository, SqliteRepositories, SqliteSendOperationRepository, ensureSchema, ensureSchemaUpTo };