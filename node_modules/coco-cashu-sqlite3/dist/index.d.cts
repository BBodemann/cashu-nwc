import { CoreProof, Counter, CounterRepository, HistoryEntry, HistoryRepository, KeyRingRepository, Keypair, Keyset, KeysetRepository, MeltHistoryEntry, MeltOperationRepository, MeltQuote, MeltQuoteRepository, Mint, MintHistoryEntry, MintQuote, MintQuoteRepository, MintRepository, ProofRepository, ProofState, Repositories, RepositoryTransactionScope, SendHistoryEntry, SendHistoryState, SendOperation, SendOperationRepository, SendOperationState } from "coco-cashu-core";

//#region src/db.d.ts
interface DatabaseLike {
  exec(sql: string, cb: (err: Error | null) => void): void;
  run(sql: string, params: any[], cb: (this: {
    lastID: number;
    changes: number;
  }, err: Error | null) => void): void;
  get(sql: string, params: any[], cb: (err: Error | null, row: any) => void): void;
  all(sql: string, params: any[], cb: (err: Error | null, rows: any[]) => void): void;
  close(cb: (err: Error | null) => void): void;
}
interface SqliteDbOptions {
  database: DatabaseLike;
}
/**
 * Shared state for transaction management across all SqliteDb instances.
 * All instances created from the same root share this state to coordinate transactions.
 */
interface SqliteDbRootState {
  /** The underlying sqlite3 Database instance */
  readonly db: DatabaseLike;
  /** Promise chain used to serialize concurrent transactions */
  transactionQueue: Promise<void>;
  /** Unique identifier for the currently active transaction scope (null if no transaction) */
  currentScope: symbol | null;
  /** Current nesting depth of transactions (1 = top-level, 2+ = nested) */
  scopeDepth: number;
}
/**
 * Wrapper around sqlite3.Database providing async/await API and transaction management.
 *
 * Transaction behavior:
 * - Nested transactions within the same scope are "rolled up" - they reuse the parent transaction
 * - Concurrent transactions from different scopes are queued and executed serially
 * - Each top-level transaction gets a unique scope token for identification
 */
declare class SqliteDb {
  private readonly root;
  /** Unique identifier for this instance's transaction scope (null for root instances) */
  private readonly scopeToken;
  constructor(optionsOrRoot: SqliteDbOptions | SqliteDbRootState, scopeToken?: symbol | null);
  get raw(): DatabaseLike;
  exec(sql: string): Promise<void>;
  run(sql: string, params?: any[]): Promise<{
    lastID: number;
    changes: number;
  }>;
  get<T = unknown>(sql: string, params?: any[]): Promise<T | undefined>;
  all<T = unknown>(sql: string, params?: any[]): Promise<T[]>;
  /**
   * Execute a function within a database transaction.
   *
   * Transaction Semantics:
   *
   * 1. NESTED TRANSACTIONS (same scope):
   *    When transaction() is called from within an active transaction using the same
   *    scoped SqliteDb instance, the inner call is treated as part of the outer transaction.
   *    No new BEGIN/COMMIT is issued - the transaction is "rolled up".
   *
   * 2. CONCURRENT TRANSACTIONS (different scopes):
   *    When transaction() is called while another transaction is active but from a
   *    different scope (e.g., parallel calls), the new transaction waits in a queue.
   *    Transactions execute serially to prevent "cannot start a transaction within a transaction".
   *
   * 3. ERROR HANDLING:
   *    If the transaction function throws an error, ROLLBACK is executed and the error
   *    is re-thrown. The transaction queue is properly released even on error, allowing
   *    subsequent transactions to proceed.
   *
   * @param fn - Function to execute within the transaction, receives a scoped SqliteDb instance
   * @returns Promise that resolves with the return value of fn
   * @throws Re-throws any error from fn after rolling back the transaction
   */
  transaction<T>(fn: (tx: SqliteDb) => Promise<T>): Promise<T>;
  close(): Promise<void>;
}
//#endregion
//#region src/schema.d.ts
interface Migration {
  id: string;
  sql?: string;
  run?: (db: SqliteDb) => Promise<void>;
}
declare const MIGRATIONS: readonly Migration[];
/**
 * Ensures the database schema is up to date by running all pending migrations.
 */
declare function ensureSchema(db: SqliteDb): Promise<void>;
/**
 * Run migrations up to (but not including) a specific migration ID.
 * If stopBeforeId is not provided, runs all migrations.
 * Used for testing migration behavior.
 */
declare function ensureSchemaUpTo(db: SqliteDb, stopBeforeId?: string): Promise<void>;
//#endregion
//#region src/repositories/MintRepository.d.ts
declare class SqliteMintRepository implements MintRepository {
  private readonly db;
  constructor(db: SqliteDb);
  isTrustedMint(mintUrl: string): Promise<boolean>;
  getMintByUrl(mintUrl: string): Promise<Mint>;
  getAllMints(): Promise<Mint[]>;
  getAllTrustedMints(): Promise<Mint[]>;
  addNewMint(mint: Mint): Promise<void>;
  addOrUpdateMint(mint: Mint): Promise<void>;
  updateMint(mint: Mint): Promise<void>;
  setMintTrusted(mintUrl: string, trusted: boolean): Promise<void>;
  deleteMint(mintUrl: string): Promise<void>;
}
//#endregion
//#region src/repositories/KeysetRepository.d.ts
declare class SqliteKeysetRepository implements KeysetRepository {
  private readonly db;
  constructor(db: SqliteDb);
  getKeysetsByMintUrl(mintUrl: string): Promise<Keyset[]>;
  getKeysetById(mintUrl: string, id: string): Promise<Keyset | null>;
  updateKeyset(keyset: Omit<Keyset, 'keypairs' | 'updatedAt'>): Promise<void>;
  addKeyset(keyset: Omit<Keyset, 'updatedAt'>): Promise<void>;
  deleteKeyset(mintUrl: string, keysetId: string): Promise<void>;
}
//#endregion
//#region src/repositories/KeyRingRepository.d.ts
declare class SqliteKeyRingRepository implements KeyRingRepository {
  private readonly db;
  constructor(db: SqliteDb);
  getPersistedKeyPair(publicKey: string): Promise<Keypair | null>;
  setPersistedKeyPair(keyPair: Keypair): Promise<void>;
  deletePersistedKeyPair(publicKey: string): Promise<void>;
  getAllPersistedKeyPairs(): Promise<Keypair[]>;
  getLatestKeyPair(): Promise<Keypair | null>;
  getLastDerivationIndex(): Promise<number>;
}
//#endregion
//#region src/repositories/CounterRepository.d.ts
declare class SqliteCounterRepository implements CounterRepository {
  private readonly db;
  constructor(db: SqliteDb);
  getCounter(mintUrl: string, keysetId: string): Promise<Counter | null>;
  setCounter(mintUrl: string, keysetId: string, counter: number): Promise<void>;
}
//#endregion
//#region src/repositories/ProofRepository.d.ts
declare class SqliteProofRepository implements ProofRepository {
  private readonly db;
  constructor(db: SqliteDb);
  saveProofs(mintUrl: string, proofs: CoreProof[]): Promise<void>;
  getReadyProofs(mintUrl: string): Promise<CoreProof[]>;
  getInflightProofs(mintUrls?: string[]): Promise<CoreProof[]>;
  getAllReadyProofs(): Promise<CoreProof[]>;
  getProofsByKeysetId(mintUrl: string, keysetId: string): Promise<CoreProof[]>;
  setProofState(mintUrl: string, secrets: string[], state: ProofState): Promise<void>;
  deleteProofs(mintUrl: string, secrets: string[]): Promise<void>;
  wipeProofsByKeysetId(mintUrl: string, keysetId: string): Promise<void>;
  reserveProofs(mintUrl: string, secrets: string[], operationId: string): Promise<void>;
  releaseProofs(mintUrl: string, secrets: string[]): Promise<void>;
  setCreatedByOperation(mintUrl: string, secrets: string[], operationId: string): Promise<void>;
  getProofBySecret(mintUrl: string, secret: string): Promise<CoreProof | null>;
  getProofsByOperationId(mintUrl: string, operationId: string): Promise<CoreProof[]>;
  getAvailableProofs(mintUrl: string): Promise<CoreProof[]>;
  getReservedProofs(): Promise<CoreProof[]>;
}
//#endregion
//#region src/repositories/MintQuoteRepository.d.ts
declare class SqliteMintQuoteRepository implements MintQuoteRepository {
  private readonly db;
  constructor(db: SqliteDb);
  getMintQuote(mintUrl: string, quoteId: string): Promise<MintQuote | null>;
  addMintQuote(quote: MintQuote): Promise<void>;
  setMintQuoteState(mintUrl: string, quoteId: string, state: MintQuote['state']): Promise<void>;
  getPendingMintQuotes(): Promise<MintQuote[]>;
}
//#endregion
//#region src/repositories/MeltQuoteRepository.d.ts
declare class SqliteMeltQuoteRepository implements MeltQuoteRepository {
  private readonly db;
  constructor(db: SqliteDb);
  getMeltQuote(mintUrl: string, quoteId: string): Promise<MeltQuote | null>;
  addMeltQuote(quote: MeltQuote): Promise<void>;
  setMeltQuoteState(mintUrl: string, quoteId: string, state: MeltQuote['state']): Promise<void>;
  getPendingMeltQuotes(): Promise<MeltQuote[]>;
}
//#endregion
//#region src/repositories/HistoryRepository.d.ts
declare class SqliteHistoryRepository implements HistoryRepository {
  private readonly db;
  constructor(db: SqliteDb);
  getPaginatedHistoryEntries(limit: number, offset: number): Promise<HistoryEntry[]>;
  getHistoryEntryById(id: string): Promise<HistoryEntry | null>;
  addHistoryEntry(history: Omit<HistoryEntry, 'id'>): Promise<HistoryEntry>;
  getMintHistoryEntry(mintUrl: string, quoteId: string): Promise<MintHistoryEntry | null>;
  getMeltHistoryEntry(mintUrl: string, quoteId: string): Promise<MeltHistoryEntry | null>;
  getSendHistoryEntry(mintUrl: string, operationId: string): Promise<SendHistoryEntry | null>;
  updateHistoryEntry(history: Omit<HistoryEntry, 'id' | 'createdAt'>): Promise<HistoryEntry>;
  updateSendHistoryState(mintUrl: string, operationId: string, state: SendHistoryState): Promise<void>;
  deleteHistoryEntry(mintUrl: string, quoteId: string): Promise<void>;
  private rowToEntry;
}
//#endregion
//#region src/repositories/SendOperationRepository.d.ts
declare class SqliteSendOperationRepository implements SendOperationRepository {
  private readonly db;
  constructor(db: SqliteDb);
  create(operation: SendOperation): Promise<void>;
  update(operation: SendOperation): Promise<void>;
  getById(id: string): Promise<SendOperation | null>;
  getByState(state: SendOperationState): Promise<SendOperation[]>;
  getPending(): Promise<SendOperation[]>;
  getByMintUrl(mintUrl: string): Promise<SendOperation[]>;
  delete(id: string): Promise<void>;
}
//#endregion
//#region src/repositories/MeltOperationRepository.d.ts
type MeltOperation = NonNullable<Awaited<ReturnType<MeltOperationRepository['getById']>>>;
type MeltOperationState = Parameters<MeltOperationRepository['getByState']>[0];
declare class SqliteMeltOperationRepository implements MeltOperationRepository {
  private readonly db;
  constructor(db: SqliteDb);
  create(operation: MeltOperation): Promise<void>;
  update(operation: MeltOperation): Promise<void>;
  getById(id: string): Promise<MeltOperation | null>;
  getByState(state: MeltOperationState): Promise<MeltOperation[]>;
  getPending(): Promise<MeltOperation[]>;
  getByMintUrl(mintUrl: string): Promise<MeltOperation[]>;
  getByQuoteId(mintUrl: string, quoteId: string): Promise<MeltOperation[]>;
  delete(id: string): Promise<void>;
}
//#endregion
//#region src/index.d.ts
interface SqliteRepositoriesOptions extends SqliteDbOptions {}
declare class SqliteRepositories implements Repositories {
  readonly mintRepository: MintRepository;
  readonly keyRingRepository: KeyRingRepository;
  readonly counterRepository: CounterRepository;
  readonly keysetRepository: KeysetRepository;
  readonly proofRepository: ProofRepository;
  readonly mintQuoteRepository: MintQuoteRepository;
  readonly meltQuoteRepository: MeltQuoteRepository;
  readonly historyRepository: SqliteHistoryRepository;
  readonly sendOperationRepository: SendOperationRepository;
  readonly meltOperationRepository: MeltOperationRepository;
  readonly db: SqliteDb;
  constructor(options: SqliteRepositoriesOptions);
  init(): Promise<void>;
  withTransaction<T>(fn: (repos: RepositoryTransactionScope) => Promise<T>): Promise<T>;
}
//#endregion
export { MIGRATIONS, type Migration, SqliteCounterRepository, SqliteDb, SqliteHistoryRepository, SqliteKeyRingRepository, SqliteKeysetRepository, SqliteMeltOperationRepository, SqliteMeltQuoteRepository, SqliteMintQuoteRepository, SqliteMintRepository, SqliteProofRepository, SqliteRepositories, SqliteRepositoriesOptions, SqliteSendOperationRepository, ensureSchema, ensureSchemaUpTo };