{"version":3,"file":"cashu-ts.cjs","sources":["../src/model/Errors.ts","../src/logger/NullLogger.ts","../src/logger/helpers.ts","../src/logger/ConsoleLogger.ts","../src/transport/request.ts","../src/transport/ws.ts","../src/utils/Bytes.ts","../src/utils/base64.ts","../src/utils/bech32m.ts","../src/utils/cbor.ts","../node_modules/@noble/hashes/utils.js","../node_modules/@noble/hashes/_md.js","../node_modules/@noble/hashes/_u64.js","../node_modules/@noble/hashes/sha2.js","../node_modules/@noble/curves/utils.js","../node_modules/@noble/curves/abstract/modular.js","../node_modules/@noble/curves/abstract/curve.js","../node_modules/@noble/hashes/hmac.js","../node_modules/@noble/curves/abstract/weierstrass.js","../node_modules/@noble/curves/secp256k1.js","../src/crypto/core.ts","../node_modules/@noble/hashes/legacy.js","../node_modules/@scure/bip32/index.js","../src/crypto/NUT01.ts","../src/crypto/NUT10.ts","../src/crypto/NUT26.ts","../src/crypto/NUT11.ts","../src/crypto/NUT12.ts","../src/crypto/NUT13.ts","../src/crypto/NUT14.ts","../src/crypto/NUT20.ts","../src/wallet/types/payment-requests.ts","../src/utils/tlv.ts","../src/model/PaymentRequest.ts","../src/utils/core.ts","../src/transport/WSConnection.ts","../src/model/types/NUT04.ts","../src/model/types/NUT05.ts","../src/model/types/NUT07.ts","../src/legacy/nut-05.ts","../src/legacy/nut-04.ts","../src/legacy/nut-06.ts","../src/model/MintInfo.ts","../src/auth/OIDCAuth.ts","../src/mint/Mint.ts","../src/wallet/Keyset.ts","../src/wallet/KeyChain.ts","../src/model/BlindedMessage.ts","../src/model/OutputData.ts","../src/wallet/P2PKBuilder.ts","../src/wallet/SelectProofs.ts","../src/wallet/CounterSource.ts","../src/wallet/WalletOps.ts","../src/wallet/WalletEvents.ts","../src/wallet/WalletCounters.ts","../src/wallet/Wallet.ts","../src/auth/AuthManager.ts","../src/auth/createAuthWallet.ts"],"sourcesContent":["/**\n * This error is thrown when a HTTP response is not 2XX nor a protocol error.\n */\nexport class HttpResponseError extends Error {\n\tstatus: number;\n\tconstructor(message: string, status: number) {\n\t\tsuper(message);\n\t\tthis.status = status;\n\t\tthis.name = 'HttpResponseError';\n\t\tObject.setPrototypeOf(this, HttpResponseError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a network request fails.\n */\nexport class NetworkError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = 'NetworkError';\n\t\tObject.setPrototypeOf(this, NetworkError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a [protocol\n * error](https://github.com/cashubtc/nuts/blob/main/00.md#errors) occurs. See error codes\n * [here](https://github.com/cashubtc/nuts/blob/main/error_codes.md).\n */\nexport class MintOperationError extends HttpResponseError {\n\tcode: number;\n\tconstructor(code: number, detail: string) {\n\t\tsuper(detail || 'Unknown mint operation error', 400);\n\t\tthis.code = code;\n\t\tthis.name = 'MintOperationError';\n\t\tObject.setPrototypeOf(this, MintOperationError.prototype);\n\t}\n}\n","import type { Logger } from './Logger';\n\n// The default logger implementation - does nothing\n/* eslint-disable @typescript-eslint/no-empty-function */\nexport const NULL_LOGGER: Logger = {\n\terror() {},\n\twarn() {},\n\tinfo() {},\n\tdebug() {},\n\ttrace() {},\n\tlog() {},\n};\n/* eslint-enable @typescript-eslint/no-empty-function */\n","import { type Logger } from './Logger';\nimport { NULL_LOGGER } from './NullLogger';\n\n/**\n * Log at ERROR and throw. Always throws.\n *\n * @param message - Error message to log and throw.\n * @param logger - Logger to use, defaults to NULL_LOGGER.\n * @param context - Optional structured context for the log.\n * @throws {Error} Always throws with the given message.\n */\nexport function fail(\n\tmessage: string,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): never {\n\tlogger.error(message, context);\n\tthrow new Error(message);\n}\n\n/**\n * Throw if a Boolean condition is true. On return, the compiler knows the condition is false.\n *\n * @param condition - Condition that must be false to continue.\n * @param message - Error message if condition is true.\n * @param logger - Logger to use, defaults to NULL_LOGGER.\n * @param context - Optional structured context for the log.\n * @throws {Error} If condition is true, throws with the given message.\n */\nexport function failIf(\n\tcondition: boolean,\n\tmessage: string,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): asserts condition is false {\n\tif (condition) fail(message, logger, context);\n}\n\n/**\n * Throw if a value is null or undefined. Value is narrowed thereafter.\n *\n * @typeParam T - The value type to check.\n * @param value - The value to validate.\n * @param message - Error message if value is nullish.\n * @param logger - Logger to use, defaults to NULL_LOGGER.\n * @param context - Optional structured context for the log.\n * @throws {Error} If value is null or undefined.\n */\nexport function failIfNullish<T>(\n\tvalue: T,\n\tmessage: string,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): asserts value is Exclude<T, null | undefined> {\n\tif (value == null) fail(message, logger, context);\n}\n\n/**\n * Invoke a user-supplied callback safely in a fire-and-forget manner.\n *\n * Used for per-operation hooks (e.g. `onCountersReserved`) where user code must never break the\n * walletâ€™s control flow. The callback is invoked synchronously, exceptions are caught and logged\n * (as a warning), and then swallowed.\n *\n * The wallet never `await`s the callback.\n *\n * @example\n *\n * ```ts\n * if (autoCounters.used) {\n * \tsafeCallback(onCountersReserved, autoCounters.used, _logger, { keysetId });\n * }\n * ```\n *\n * @typeParam T Type of the payload passed to the callback.\n * @param cb The callback to invoke, or `undefined`.\n * @param payload The payload to pass to the callback.\n * @param logger Logger to use (defaults to NULL_LOGGER).\n * @param context Optional structured context for the log.\n */\nexport function safeCallback<T>(\n\tcb: ((p: T) => void | Promise<void>) | undefined,\n\tpayload: T,\n\tlogger: Logger = NULL_LOGGER,\n\tcontext?: Record<string, unknown>,\n): void {\n\tif (!cb) return;\n\n\ttry {\n\t\tconst maybePromise = cb(payload);\n\t\tif (maybePromise && typeof maybePromise.then === 'function') {\n\t\t\tmaybePromise.catch((error) => {\n\t\t\t\ttry {\n\t\t\t\t\tlogger.warn('callback failed', {\n\t\t\t\t\t\t...(context ?? {}),\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tcb: cb.name ?? '',\n\t\t\t\t\t});\n\t\t\t\t} catch {\n\t\t\t\t\t/* ignore logger errors */\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t} catch (error) {\n\t\ttry {\n\t\t\tlogger.warn('callback failed', {\n\t\t\t\t...(context ?? {}),\n\t\t\t\terror,\n\t\t\t\tcb: cb.name ?? '',\n\t\t\t});\n\t\t} catch {\n\t\t\t/* ignore logger errors */\n\t\t}\n\t}\n}\n","import { type Logger, type LogLevel } from './Logger';\n\nconst LEVEL_ORDER: Record<LogLevel, number> = {\n\terror: 0,\n\twarn: 1,\n\tinfo: 2,\n\tdebug: 3,\n\ttrace: 4,\n};\n\n/**\n * Outputs messages to the console based on the specified log level.\n *\n * Supports placeholder substitution in messages (e.g., `{key}`) using values from the optional\n * `context` object. Context keys not used in substitution are appended to the output as additional\n * data. Each log message is prefixed with the log level in square brackets (e.g., `[INFO]`).\n *\n * @example Const logger = new ConsoleLogger(LogLevel.DEBUG); logger.info('User {username} logged\n * in', { username: 'alice', ip: '127.0.0.1' }); // Output: [INFO] User alice logged in { ip:\n * \"127.0.0.1\" }\n */\nexport class ConsoleLogger implements Logger {\n\tprivate minLevel: LogLevel;\n\n\tconstructor(minLevel: LogLevel = 'info') {\n\t\tthis.minLevel = minLevel;\n\t}\n\n\tprivate should(level: LogLevel): boolean {\n\t\treturn LEVEL_ORDER[level] <= LEVEL_ORDER[this.minLevel];\n\t}\n\tprivate method(level: LogLevel): (msg: string, ...rest: unknown[]) => void {\n\t\tswitch (level) {\n\t\t\tcase 'error':\n\t\t\t\treturn console.error;\n\t\t\tcase 'warn':\n\t\t\t\treturn console.warn;\n\t\t\tcase 'info':\n\t\t\t\treturn console.info;\n\t\t\tcase 'debug':\n\t\t\t\treturn console.debug;\n\t\t\tcase 'trace':\n\t\t\t\treturn console.trace;\n\t\t\tdefault:\n\t\t\t\treturn console.log;\n\t\t}\n\t}\n\tprivate header(level: LogLevel, message: string): string {\n\t\treturn `[${level.toUpperCase()}] ${message}`;\n\t}\n\tprivate flattenContext(ctx?: Record<string, unknown>): Record<string, unknown> | undefined {\n\t\tif (!ctx) return undefined;\n\t\tconst out: Record<string, unknown> = {};\n\t\tfor (const [k, v] of Object.entries(ctx)) {\n\t\t\tout[k] = v instanceof Error ? { message: v.message, stack: v.stack } : v;\n\t\t}\n\t\treturn out;\n\t}\n\tprivate emit(level: LogLevel, message: string, context?: Record<string, unknown>) {\n\t\tif (!this.should(level)) return;\n\t\tconst line = this.header(level, message);\n\t\tconst ctx = this.flattenContext(context);\n\t\tconst fn = this.method(level);\n\t\tif (ctx && Object.keys(ctx).length) fn(line, ctx);\n\t\telse fn(line);\n\t}\n\n\terror(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('error', msg, ctx);\n\t}\n\twarn(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('warn', msg, ctx);\n\t}\n\tinfo(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('info', msg, ctx);\n\t}\n\tdebug(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('debug', msg, ctx);\n\t}\n\ttrace(msg: string, ctx?: Record<string, unknown>) {\n\t\tthis.emit('trace', msg, ctx);\n\t}\n\n\tlog(level: LogLevel, message: string, context?: Record<string, unknown>) {\n\t\tthis.emit(level, message, context);\n\t}\n}\n\n/**\n * Creates a timer to measure elapsed time in milliseconds.\n *\n * @example Const timer = measureTime(); // ... some code ... const duration = timer.elapsed();\n *\n * @returns An object with an `elapsed` method to retrieve the duration since the timer started.\n */\nexport function measureTime() {\n\tconst start = Date.now();\n\treturn {\n\t\telapsed: () => {\n\t\t\treturn Date.now() - start;\n\t\t},\n\t};\n}\n","import { HttpResponseError, NetworkError, MintOperationError } from '../model/Errors';\nimport { type Logger, NULL_LOGGER } from '../logger';\n\n// Generic request function type so callers can do requestInstance<T>(...)\nexport type RequestFn = <T = unknown>(args: RequestOptions) => Promise<T>;\n\nexport type RequestArgs = {\n\tendpoint: string;\n\trequestBody?: Record<string, unknown>;\n\theaders?: Record<string, string>;\n\tlogger?: Logger;\n};\n\nexport type RequestOptions = RequestArgs & Omit<RequestInit, 'body' | 'headers'>;\n\n/**\n * Cashu api error.\n *\n * - Error: Brief error message.\n * - Code: HTTP error code.\n * - Detail: Detailed error message.\n */\nexport type ApiError = {\n\terror?: string;\n\tcode?: number;\n\tdetail?: string;\n};\n\nlet globalRequestOptions: Partial<RequestOptions> = {};\nlet requestLogger = NULL_LOGGER;\n\n/**\n * An object containing any custom settings that you want to apply to the global fetch method.\n *\n * @param options See possible options here:\n *   https://developer.mozilla.org/en-US/docs/Web/API/fetch#options.\n */\nexport function setGlobalRequestOptions(options: Partial<RequestOptions>): void {\n\tglobalRequestOptions = options;\n}\n\n/**\n * Allows a logger to be set.\n *\n * @param {Logger} logger The logger instance to use.\n */\nexport function setRequestLogger(logger: Logger): void {\n\trequestLogger = logger;\n}\n\nasync function _request({\n\tendpoint,\n\trequestBody,\n\theaders: requestHeaders,\n\t...options\n}: RequestOptions): Promise<unknown> {\n\tconst body = requestBody ? JSON.stringify(requestBody) : undefined;\n\tconst headers = {\n\t\t...{ Accept: 'application/json, text/plain, */*' },\n\t\t...(body ? { 'Content-Type': 'application/json' } : undefined),\n\t\t...requestHeaders,\n\t};\n\n\tlet response: Response;\n\ttry {\n\t\tresponse = await fetch(endpoint, { body, headers, ...options });\n\t} catch (err) {\n\t\t// A fetch() promise only rejects when the request fails,\n\t\t// for example, because of a badly-formed request URL or a network error.\n\t\tthrow new NetworkError(err instanceof Error ? err.message : 'Network request failed');\n\t}\n\n\tif (!response.ok) {\n\t\tlet errorData: ApiError;\n\t\ttry {\n\t\t\terrorData = (await response.json()) as ApiError;\n\t\t} catch {\n\t\t\terrorData = { error: 'bad response' };\n\t\t}\n\n\t\tif (\n\t\t\tresponse.status === 400 &&\n\t\t\t'code' in errorData &&\n\t\t\ttypeof errorData.code === 'number' &&\n\t\t\t'detail' in errorData &&\n\t\t\ttypeof errorData.detail === 'string'\n\t\t) {\n\t\t\tthrow new MintOperationError(errorData.code, errorData.detail);\n\t\t}\n\n\t\tlet errorMessage = 'HTTP request failed';\n\t\tif ('error' in errorData && typeof errorData.error === 'string') {\n\t\t\terrorMessage = errorData.error;\n\t\t} else if ('detail' in errorData && typeof errorData.detail === 'string') {\n\t\t\terrorMessage = errorData.detail;\n\t\t}\n\n\t\tthrow new HttpResponseError(errorMessage, response.status);\n\t}\n\n\ttry {\n\t\treturn await response.json();\n\t} catch (err) {\n\t\trequestLogger.error('Failed to parse HTTP response', { err });\n\t\tthrow new HttpResponseError('bad response', response.status);\n\t}\n}\n\nexport default async function request<T>(options: RequestOptions): Promise<T> {\n\tconst data = await _request({ ...options, ...globalRequestOptions });\n\treturn data as T;\n}\n","let _WS: typeof WebSocket | undefined;\n\nif (typeof WebSocket !== 'undefined') {\n\t_WS = WebSocket;\n}\n\nexport function injectWebSocketImpl(ws: typeof WebSocket) {\n\t_WS = ws;\n}\n\nexport function getWebSocketImpl() {\n\tif (_WS === undefined) {\n\t\tthrow new Error('WebSocket implementation not initialized');\n\t}\n\treturn _WS;\n}\n","export class Bytes {\n\tstatic fromHex(hex: string): Uint8Array {\n\t\thex = hex.trim();\n\t\tif (hex.length === 0) {\n\t\t\treturn new Uint8Array(0);\n\t\t}\n\t\tif (hex.length < 2 || hex.length & 1) {\n\t\t\tthrow new Error('Invalid hex string: odd length.');\n\t\t}\n\t\tif (hex.startsWith('0x') || hex.startsWith('0X')) {\n\t\t\thex = hex.slice(2);\n\t\t}\n\t\tconst match = hex.match(/^[0-9a-fA-F]*$/);\n\t\tif (!match) {\n\t\t\tthrow new Error('Invalid hex string: contains non-hex characters');\n\t\t}\n\t\tconst matches = hex.match(/.{1,2}/g);\n\t\tif (!matches) {\n\t\t\tthrow new Error('Invalid hex string');\n\t\t}\n\t\treturn new Uint8Array(matches.map((byte) => parseInt(byte, 16)));\n\t}\n\n\tstatic toHex(bytes: Uint8Array): string {\n\t\treturn Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0')).join('');\n\t}\n\n\tstatic fromString(str: string): Uint8Array {\n\t\tstr = str.trim();\n\t\treturn new TextEncoder().encode(str);\n\t}\n\n\tstatic toString(bytes: Uint8Array): string {\n\t\treturn new TextDecoder('utf-8').decode(bytes);\n\t}\n\n\tstatic concat(...arrays: Uint8Array[]): Uint8Array {\n\t\tconst totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);\n\t\tconst result = new Uint8Array(totalLength);\n\t\tlet offset = 0;\n\t\tfor (const arr of arrays) {\n\t\t\tresult.set(arr, offset);\n\t\t\toffset += arr.length;\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic alloc(size: number): Uint8Array {\n\t\treturn new Uint8Array(size);\n\t}\n\n\tstatic writeBigUint64BE(value: bigint): Uint8Array {\n\t\tconst buffer = new ArrayBuffer(8);\n\t\tnew DataView(buffer).setBigUint64(0, value, false);\n\t\treturn new Uint8Array(buffer);\n\t}\n\n\tstatic toBase64(bytes: Uint8Array): string {\n\t\tif (typeof Buffer !== 'undefined') {\n\t\t\treturn Buffer.from(bytes).toString('base64');\n\t\t}\n\t\t// preventing stack overflow by chunking\n\t\tif (bytes.length > 32768) {\n\t\t\tlet result = '';\n\t\t\tfor (let i = 0; i < bytes.length; i += 32768) {\n\t\t\t\tconst chunk = bytes.slice(i, i + 32768);\n\t\t\t\tresult += btoa(String.fromCharCode(...chunk));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn btoa(String.fromCharCode(...bytes));\n\t}\n\n\tstatic fromBase64(base64: string): Uint8Array {\n\t\tbase64 = base64.trim();\n\t\t// normalise base64url to base64 and pad\n\t\tlet normalizedBase64 = base64.replace(/-/g, '+').replace(/_/g, '/');\n\t\twhile (normalizedBase64.length % 4) {\n\t\t\tnormalizedBase64 += '=';\n\t\t}\n\t\tif (typeof Buffer !== 'undefined') {\n\t\t\treturn new Uint8Array(Buffer.from(normalizedBase64, 'base64'));\n\t\t}\n\t\treturn new Uint8Array([...atob(normalizedBase64)].map((c) => c.charCodeAt(0)));\n\t}\n\t// NOTE: MUST remain a constant-time implementation (full byte check)\n\t// because callers rely on it (e.g. deriveP2BKSecretKey).\n\tstatic equals(a: Uint8Array, b: Uint8Array): boolean {\n\t\tif (a.length !== b.length) return false;\n\t\tlet result = 0;\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tresult |= a[i] ^ b[i];\n\t\t}\n\t\treturn result === 0;\n\t}\n\n\tstatic compare(a: Uint8Array, b: Uint8Array): number {\n\t\tconst minLength = Math.min(a.length, b.length);\n\t\tfor (let i = 0; i < minLength; i++) {\n\t\t\tif (a[i] < b[i]) return -1;\n\t\t\tif (a[i] > b[i]) return 1;\n\t\t}\n\t\treturn a.length - b.length;\n\t}\n\n\tstatic toBigInt(bytes: Uint8Array): bigint {\n\t\tlet result = 0n;\n\t\tfor (const byte of bytes) {\n\t\t\tresult = (result << 8n) | BigInt(byte);\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic fromBigInt(value: bigint): Uint8Array {\n\t\tif (value < 0n) {\n\t\t\tthrow new RangeError('value must be non-negative');\n\t\t}\n\t\tif (value === 0n) {\n\t\t\treturn new Uint8Array([0]);\n\t\t}\n\t\t// Calculate Uint8Array length\n\t\tlet temp = value;\n\t\tlet length = 0;\n\t\twhile (temp > 0n) {\n\t\t\tlength++;\n\t\t\ttemp >>= 8n;\n\t\t}\n\t\t// Fill it from the end (big endian)\n\t\tconst out = new Uint8Array(length);\n\t\ttemp = value;\n\t\tfor (let i = length - 1; i >= 0; i--) {\n\t\t\tout[i] = Number(temp & 0xffn);\n\t\t\ttemp >>= 8n;\n\t\t}\n\t\treturn out;\n\t}\n}\n","import { Bytes } from './Bytes';\n\nfunction encodeUint8toBase64(uint8array: Uint8Array): string {\n\treturn Bytes.toBase64(uint8array);\n}\n\nfunction encodeUint8toBase64Url(bytes: Uint8Array): string {\n\treturn Bytes.toBase64(bytes)\n\t\t.replace(/\\+/g, '-') // Replace + with -\n\t\t.replace(/\\//g, '_') // Replace / with _\n\t\t.replace(/=+$/, ''); // Remove padding characters\n}\n\nfunction encodeBase64toUint8(base64String: string): Uint8Array {\n\treturn Bytes.fromBase64(base64String);\n}\n\nfunction encodeJsonToBase64(jsonObj: unknown): string {\n\tconst jsonString = JSON.stringify(jsonObj);\n\treturn base64urlFromBase64(Bytes.toBase64(Bytes.fromString(jsonString)));\n}\n\nfunction encodeBase64ToJson<T extends object>(base64String: string): T {\n\tconst jsonString = Bytes.toString(Bytes.fromBase64(base64urlToBase64(base64String)));\n\tconst jsonObj = JSON.parse(jsonString) as T;\n\treturn jsonObj;\n}\n\nfunction base64urlToBase64(str: string) {\n\treturn str.replace(/-/g, '+').replace(/_/g, '/').split('=')[0];\n\t// .replace(/./g, '=');\n}\n\nfunction base64urlFromBase64(str: string) {\n\treturn str.replace(/\\+/g, '-').replace(/\\//g, '_').split('=')[0];\n\t// .replace(/=/g, '.');\n}\n\nfunction isBase64String(s: string): boolean {\n\tif (typeof s !== 'string' || s.length === 0) return false;\n\n\t// Accept both base64 and base64url char sets\n\tconst base64url = /^[A-Za-z0-9\\-_]+={0,2}$/;\n\tconst base64 = /^[A-Za-z0-9+/]+={0,2}$/;\n\n\t// Quick character-set check\n\tif (!base64url.test(s) && !base64.test(s)) return false;\n\n\t// Normalize base64url to standard base64 for decoding\n\tconst normalized = s.replace(/-/g, '+').replace(/_/g, '/');\n\n\t// Padding: length must be multiple of 4. Add '=' padding if needed (but no more than 2)\n\tconst padLength = (4 - (normalized.length % 4)) % 4;\n\tif (padLength > 2) return false; // should never happen but keep safe\n\tconst padded = normalized + '='.repeat(padLength);\n\n\ttry {\n\t\tconst decoded = Bytes.fromBase64(padded);\n\n\t\t// Re-encode and compare to the original (allowing either standard or url-safe representation)\n\t\tconst reStandard = Bytes.toBase64(decoded);\n\t\tconst reUrl = reStandard.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n\n\t\t// Also compare against original normalized-without-padding variant\n\t\tconst originalNoPad = normalized.replace(/=+$/, '');\n\n\t\tif (reStandard.replace(/=+$/, '') === originalNoPad) return true;\n\t\tif (reUrl === originalNoPad) return true;\n\n\t\treturn false;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport {\n\tencodeUint8toBase64,\n\tencodeUint8toBase64Url,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeBase64ToJson,\n\tisBase64String,\n};\n","import { bech32m } from '@scure/base';\n\ntype Bech32mString = `${string}1${string}`;\n\nconst LIMIT_LENGTH = 1023;\n\n/**\n * Asserts that a string has valid bech32m format (contains separator '1' with content on both\n * sides). Per BIP-173/BIP-350, the last '1' in the string is the separator between HRP and data.\n *\n * @param str - The string to validate.\n * @throws Error if the string doesn't have a valid bech32m separator structure.\n */\nfunction assertBech32mFormat(str: string): asserts str is Bech32mString {\n\tconst separatorIndex = str.lastIndexOf('1');\n\tif (separatorIndex < 1 || separatorIndex === str.length - 1) {\n\t\tthrow new Error('Invalid bech32m string: missing or misplaced separator');\n\t}\n}\n\n/**\n * Encodes a Uint8Array to a bech32m string with the given human-readable part (HRP).\n *\n * @param hrp - The human-readable prefix (e.g., 'cashu', 'bc')\n * @param data - The data to encode.\n * @returns The bech32m encoded string.\n */\nfunction encodeBech32m(hrp: string, data: Uint8Array, limitLength = LIMIT_LENGTH): string {\n\tconst words = bech32m.toWords(data);\n\treturn bech32m.encode(hrp, words, limitLength);\n}\n\n/**\n * Decodes a bech32m string back to its components.\n *\n * @param encoded - The bech32m encoded string.\n * @returns An object containing the human-readable part (hrp) and the decoded data.\n */\nfunction decodeBech32m(\n\tencoded: string,\n\tlimitLength = LIMIT_LENGTH,\n): { hrp: string; data: Uint8Array } {\n\tassertBech32mFormat(encoded);\n\tconst { prefix, words } = bech32m.decode(encoded, limitLength);\n\tconst data = bech32m.fromWords(words);\n\treturn { hrp: prefix, data };\n}\n\n/**\n * Decodes a bech32m string and returns only the data portion.\n *\n * @param encoded - The bech32m encoded string.\n * @returns The decoded data as Uint8Array.\n */\nfunction decodeBech32mToBytes(encoded: string, limitLength = LIMIT_LENGTH): Uint8Array {\n\treturn decodeBech32m(encoded, limitLength).data;\n}\n\n/**\n * Checks if a string is a valid bech32m encoded string.\n *\n * @param str - The string to check.\n * @param expectedHrp - Optional: verify the HRP matches this value.\n * @returns True if the string is valid bech32m (and matches expectedHrp if provided)\n */\nfunction isBech32m(str: string, expectedHrp?: string, limitLength = LIMIT_LENGTH): boolean {\n\ttry {\n\t\tconst { hrp } = decodeBech32m(str, limitLength);\n\t\tif (expectedHrp !== undefined && hrp !== expectedHrp) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport { encodeBech32m, decodeBech32m, decodeBech32mToBytes, isBech32m };\n","/*\n * Lightweight CBOR encoder/decoder (purpose and limitations)\n *\n * Supported\n * - Major types: 0 (unsigned), 1 (negative), 2 (byte string), 3 (text string),\n *   4 (array), 5 (map), 7 (simple values & floats).\n * - Additional-info lengths: short (0..23), 1-, 2- and 4-byte length forms are\n *   encoded by the encoder. The decoder understands 8-byte length fields\n *   (additional-info 27) and will decode them into a JavaScript Number\n *   (hi * 2**32 + lo) but the encoder intentionally does not emit 8-byte\n *   integer forms (see 'Not implemented' below).\n * - Floating point: decoder supports float16/float32/float64. Encoder emits\n *   float64 for non-integers.\n * - Guardrails: explicit throws for unsupported types and sizes (e.g. huge\n *   strings/byte arrays/arrays/maps > 2**32-1, integers larger than 32-bit for\n *   encoding). DataView out-of-bounds reads are normalized to\n *   \"Unexpected end of data\" for clearer errors.\n *\n * Not implemented / intentionally out of scope\n * - Indefinite-length (streaming) containers (indefinite-length arrays,\n *   maps, byte/text strings) are not supported. Test vectors with streaming\n *   markers are skipped in the test harness.\n * - Semantic tags (major type 6) are not interpreted; tagged values are\n *   skipped in encode-roundtrip tests. Implementing tags should return a\n *   wrapper object or otherwise surface the tag + value.\n * - Big integers / bignum handling: this implementation does not return\n *   BigInt for values outside Number.isSafeInteger nor emit CBOR bignum tags\n *   (tag 2/3). Decode may parse 8-byte unsigned/negative integers into a\n *   Number which can overflow JS precision; callers who need accurate bignum\n *   support should add BigInt decoding and encoder support.\n * - Encoder does not emit float16/float32 or 8-byte integer (additional-info\n *   27) forms. It intentionally limits integer encoding to <= 32-bit and\n *   uses float64 for non-integers to keep the implementation small.\n *\n * Guidance for contributors\n * - To add streaming support, implement indefinite-length decoders that\n *   concatenate chunks until the break byte (0xff) and update decodeItem\n *   accordingly.\n * - To add BigInt/bignum support, change decode paths to return BigInt when\n *   required, add fixture representation for BigInt in tests, and emit proper\n *   tag-2/3 bignum encodings or 8-byte integer forms in the encoder.\n */\n\n/* Reference: CBOR specification (RFC 8949) https://www.rfc-editor.org/rfc/rfc8949.html */\n\ntype SimpleValue = boolean | null | undefined;\n\nexport type ResultObject = { [key: string]: ResultValue };\nexport type ResultValue = SimpleValue | number | string | Uint8Array | ResultValue[] | ResultObject;\n\ntype ResultKeyType = Extract<ResultValue, number | string>;\nexport type ValidDecodedType = Extract<ResultValue, ResultObject>;\n\nfunction isResultKeyType(value: ResultValue): value is ResultKeyType {\n\treturn typeof value === 'number' || typeof value === 'string';\n}\n\ntype DecodeResult<T extends ResultValue> = {\n\tvalue: T;\n\toffset: number;\n};\n\nexport function encodeCBOR(value: unknown): Uint8Array {\n\tconst buffer: number[] = [];\n\tencodeItem(value, buffer);\n\treturn new Uint8Array(buffer);\n}\n\nfunction encodeItem(value: unknown, buffer: number[]) {\n\tif (value === null) {\n\t\tbuffer.push(0xf6);\n\t} else if (value === undefined) {\n\t\tbuffer.push(0xf7);\n\t} else if (typeof value === 'boolean') {\n\t\tbuffer.push(value ? 0xf5 : 0xf4);\n\t} else if (typeof value === 'number') {\n\t\tencodeNumber(value, buffer);\n\t} else if (typeof value === 'string') {\n\t\tencodeString(value, buffer);\n\t} else if (Array.isArray(value)) {\n\t\tencodeArray(value, buffer);\n\t} else if (value instanceof Uint8Array) {\n\t\tencodeByteString(value, buffer);\n\t} else if (\n\t\t// Defensive: POJO only (null/array handled above)\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t!Array.isArray(value)\n\t) {\n\t\tencodeObject(value as Record<string, unknown>, buffer);\n\t} else {\n\t\tthrow new Error('Unsupported type');\n\t}\n}\n\nfunction encodeUnsigned(value: number, buffer: number[]) {\n\tif (value < 24) {\n\t\tbuffer.push(value);\n\t} else if (value < 256) {\n\t\tbuffer.push(0x18, value);\n\t} else if (value < 65536) {\n\t\tbuffer.push(0x19, (value >>> 8) & 0xff, value & 0xff);\n\t} else if (value < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x1a,\n\t\t\t(value >>> 24) & 0xff,\n\t\t\t(value >>> 16) & 0xff,\n\t\t\t(value >>> 8) & 0xff,\n\t\t\tvalue & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Unsupported integer size');\n\t}\n}\n\nfunction encodeSigned(value: number, buffer: number[]) {\n\t// CBOR negative integer encoding: store -1 - value as unsigned under major type 1\n\tconst unsigned = -1 - value;\n\tif (unsigned < 24) {\n\t\tbuffer.push(0x20 | unsigned);\n\t} else if (unsigned < 256) {\n\t\tbuffer.push(0x38, unsigned & 0xff);\n\t} else if (unsigned < 65536) {\n\t\tbuffer.push(0x39, (unsigned >>> 8) & 0xff, unsigned & 0xff);\n\t} else if (unsigned < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x3a,\n\t\t\t(unsigned >>> 24) & 0xff,\n\t\t\t(unsigned >>> 16) & 0xff,\n\t\t\t(unsigned >>> 8) & 0xff,\n\t\t\tunsigned & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Unsupported integer size');\n\t}\n}\n\nfunction encodeFloat64(value: number, buffer: number[]) {\n\t// major type 7, additional info 27 (0xfb) followed by 8 bytes IEEE 754 big-endian\n\tconst ab = new ArrayBuffer(8);\n\tconst dv = new DataView(ab);\n\tdv.setFloat64(0, value, false);\n\tbuffer.push(0xfb);\n\tfor (let i = 0; i < 8; i++) buffer.push(dv.getUint8(i));\n}\n\nfunction encodeNumber(value: number, buffer: number[]) {\n\tif (Number.isInteger(value)) {\n\t\tif (value >= 0) {\n\t\t\t// unsigned\n\t\t\tencodeUnsigned(value, buffer);\n\t\t} else {\n\t\t\t// negative integer\n\t\t\tencodeSigned(value, buffer);\n\t\t}\n\t} else {\n\t\t// encode non-integer numbers as float64 for simplicity\n\t\tencodeFloat64(value, buffer);\n\t}\n}\n\nfunction encodeByteString(value: Uint8Array, buffer: number[]) {\n\tconst length = value.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x40 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x58, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x59, (length >> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x5a,\n\t\t\t(length >>> 24) & 0xff,\n\t\t\t(length >>> 16) & 0xff,\n\t\t\t(length >>> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Byte string too long to encode');\n\t}\n\n\tfor (let i = 0; i < value.length; i++) {\n\t\tbuffer.push(value[i]);\n\t}\n}\n\nfunction encodeString(value: string, buffer: number[]) {\n\tconst utf8 = new TextEncoder().encode(value);\n\tconst length = utf8.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x60 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x78, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x79, (length >>> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x7a,\n\t\t\t(length >>> 24) & 0xff,\n\t\t\t(length >>> 16) & 0xff,\n\t\t\t(length >>> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('String too long to encode');\n\t}\n\n\tfor (let i = 0; i < utf8.length; i++) {\n\t\tbuffer.push(utf8[i]);\n\t}\n}\n\nfunction encodeArray(value: unknown[], buffer: number[]) {\n\tconst length = value.length;\n\tif (length < 24) {\n\t\tbuffer.push(0x80 | length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x98, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x99, (length >>> 8) & 0xff, length & 0xff);\n\t} else {\n\t\tthrow new Error('Unsupported array length');\n\t}\n\n\tfor (const item of value) {\n\t\tencodeItem(item, buffer);\n\t}\n}\n\nfunction encodeObject(value: Record<string, unknown>, buffer: number[]) {\n\tconst keys = Object.keys(value);\n\tconst length = keys.length;\n\n\t// Guardrail: we only support map lengths up to 2^32-1 (same as encodeUnsigned max)\n\tif (length >= 4294967296) {\n\t\tthrow new Error('Object has too many keys to encode');\n\t}\n\n\t// Write initial byte for major type 5 (map) and additional info based on length\n\tif (length < 24) {\n\t\tbuffer.push(0xa0 | length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0xb8, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0xb9, (length >> 8) & 0xff, length & 0xff);\n\t} else {\n\t\tbuffer.push(\n\t\t\t0xba,\n\t\t\t(length >> 24) & 0xff,\n\t\t\t(length >> 16) & 0xff,\n\t\t\t(length >> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t}\n\tfor (const key of keys) {\n\t\tencodeString(key, buffer);\n\t\tencodeItem(value[key], buffer);\n\t}\n}\n\nexport function decodeCBOR(data: Uint8Array): ResultValue {\n\tconst view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\tconst result = decodeItem(view, 0);\n\treturn result.value;\n}\n\nfunction decodeItem(view: DataView, offset: number): DecodeResult<ResultValue> {\n\tif (offset >= view.byteLength) {\n\t\tthrow new Error('Unexpected end of data');\n\t}\n\tconst initialByte = view.getUint8(offset++);\n\tconst majorType = initialByte >> 5;\n\tconst additionalInfo = initialByte & 0x1f;\n\n\tswitch (majorType) {\n\t\tcase 0:\n\t\t\treturn decodeUnsigned(view, offset, additionalInfo);\n\t\tcase 1:\n\t\t\treturn decodeSigned(view, offset, additionalInfo);\n\t\tcase 2:\n\t\t\treturn decodeByteString(view, offset, additionalInfo);\n\t\tcase 3:\n\t\t\treturn decodeString(view, offset, additionalInfo);\n\t\tcase 4:\n\t\t\treturn decodeArray(view, offset, additionalInfo);\n\t\tcase 5:\n\t\t\treturn decodeMap(view, offset, additionalInfo);\n\t\tcase 7:\n\t\t\treturn decodeSimpleAndFloat(view, offset, additionalInfo);\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported major type: ${majorType}`);\n\t}\n}\n\nfunction ensureAvailable(view: DataView, offset: number, needed: number) {\n\tif (offset + needed > view.byteLength) {\n\t\tthrow new Error('Unexpected end of data');\n\t}\n}\n\nfunction decodeLength(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tif (additionalInfo < 24) return { value: additionalInfo, offset };\n\tif (additionalInfo === 24) {\n\t\tensureAvailable(view, offset, 1);\n\t\treturn { value: view.getUint8(offset++), offset };\n\t}\n\tif (additionalInfo === 25) {\n\t\tensureAvailable(view, offset, 2);\n\t\tconst value = view.getUint16(offset, false);\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tensureAvailable(view, offset, 4);\n\t\tconst value = view.getUint32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tensureAvailable(view, offset, 8);\n\t\tconst hi = view.getUint32(offset, false);\n\t\tconst lo = view.getUint32(offset + 4, false);\n\t\toffset += 8;\n\t\treturn { value: hi * 2 ** 32 + lo, offset };\n\t}\n\tthrow new Error(`Unsupported length: ${additionalInfo}`);\n}\n\nfunction decodeUnsigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value, offset: newOffset };\n}\n\nfunction decodeSigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value: -1 - value, offset: newOffset };\n}\n\nfunction decodeByteString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<Uint8Array> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('Byte string length exceeds data length');\n\t}\n\tconst value = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<string> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('String length exceeds data length');\n\t}\n\tconst bytes = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\tconst value = new TextDecoder().decode(bytes);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeArray(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<ResultValue[]> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst array = [];\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst result = decodeItem(view, currentOffset);\n\t\tarray.push(result.value);\n\t\tcurrentOffset = result.offset;\n\t}\n\treturn { value: array, offset: currentOffset };\n}\n\nfunction decodeMap(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<Record<string, ResultValue>> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst map: { [key: string]: ResultValue } = {};\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst keyResult = decodeItem(view, currentOffset);\n\t\tif (!isResultKeyType(keyResult.value)) {\n\t\t\tthrow new Error('Invalid key type');\n\t\t}\n\t\tconst valueResult = decodeItem(view, keyResult.offset);\n\t\tmap[keyResult.value] = valueResult.value;\n\t\tcurrentOffset = valueResult.offset;\n\t}\n\treturn { value: map, offset: currentOffset };\n}\n\nfunction decodeFloat16(uint16: number): number {\n\tconst exponent = (uint16 & 0x7c00) >> 10;\n\tconst fraction = uint16 & 0x03ff;\n\tconst sign = uint16 & 0x8000 ? -1 : 1;\n\n\tif (exponent === 0) {\n\t\treturn sign * 2 ** -14 * (fraction / 1024);\n\t} else if (exponent === 0x1f) {\n\t\treturn fraction ? NaN : sign * Infinity;\n\t}\n\treturn sign * 2 ** (exponent - 15) * (1 + fraction / 1024);\n}\n\nfunction decodeSimpleAndFloat(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<SimpleValue | number> {\n\tif (additionalInfo < 24) {\n\t\tswitch (additionalInfo) {\n\t\t\tcase 20:\n\t\t\t\treturn { value: false, offset };\n\t\t\tcase 21:\n\t\t\t\treturn { value: true, offset };\n\t\t\tcase 22:\n\t\t\t\treturn { value: null, offset };\n\t\t\tcase 23:\n\t\t\t\treturn { value: undefined, offset };\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown simple value: ${additionalInfo}`);\n\t\t}\n\t}\n\tif (additionalInfo === 24) {\n\t\tensureAvailable(view, offset, 1);\n\t\treturn { value: view.getUint8(offset++), offset };\n\t}\n\tif (additionalInfo === 25) {\n\t\tensureAvailable(view, offset, 2);\n\t\tconst value = decodeFloat16(view.getUint16(offset, false));\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tensureAvailable(view, offset, 4);\n\t\tconst value = view.getFloat32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tensureAvailable(view, offset, 8);\n\t\tconst value = view.getFloat64(offset, false);\n\t\toffset += 8;\n\t\treturn { value, offset };\n\t}\n\tthrow new Error(`Unknown simple or float value: ${additionalInfo}`);\n}\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nexport function anumber(n, title = '') {\n    if (!Number.isSafeInteger(n) || n < 0) {\n        const prefix = title && `\"${title}\" `;\n        throw new Error(`${prefix}expected integer >= 0, got ${n}`);\n    }\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(value, length, title = '') {\n    const bytes = isBytes(value);\n    const len = value?.length;\n    const needsLen = length !== undefined;\n    if (!bytes || (needsLen && len !== length)) {\n        const prefix = title && `\"${title}\" `;\n        const ofLen = needsLen ? ` of length ${length}` : '';\n        const got = bytes ? `length=${len}` : `type=${typeof value}`;\n        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n    }\n    return value;\n}\n/** Asserts something is hash */\nexport function ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash must wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n    abytes(out, undefined, 'digestInto() output');\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('\"digestInto() output\" expected to be of length >=' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nexport function byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexport const swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * Built-in doesn't validate input to be string: we do the check.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data, errorTitle = '') {\n    if (typeof data === 'string')\n        return utf8ToBytes(data);\n    return abytes(data, undefined, errorTitle);\n}\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n/** Merges default options and passed options. */\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options must be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** Creates function with outputLen, blockLen, create properties from a class constructor. */\nexport function createHasher(hashCons, info = {}) {\n    const hashC = (msg, opts) => hashCons(opts).update(msg).digest();\n    const tmp = hashCons(undefined);\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    Object.assign(hashC, info);\n    return Object.freeze(hashC);\n}\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32) {\n    const cr = typeof globalThis === 'object' ? globalThis.crypto : null;\n    if (typeof cr?.getRandomValues !== 'function')\n        throw new Error('crypto.getRandomValues must be defined');\n    return cr.getRandomValues(new Uint8Array(bytesLength));\n}\n/** Creates OID opts for NIST hashes, with prefix 06 09 60 86 48 01 65 03 04 02. */\nexport const oidNist = (suffix) => ({\n    oid: Uint8Array.from([0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, suffix]),\n});\n//# sourceMappingURL=utils.js.map","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { abytes, aexists, aoutput, clean, createView } from \"./utils.js\";\n/** Choice: a ? b : c */\nexport function Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD {\n    blockLen;\n    outputLen;\n    padOffset;\n    isLE;\n    // For partial updates less than block size\n    buffer;\n    view;\n    finished = false;\n    length = 0;\n    pos = 0;\n    destroyed = false;\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        abytes(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        clean(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which must be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen must be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to ||= new this.constructor();\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://www.rfc-editor.org/rfc/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from \"./_md.js\";\nimport * as u64 from \"./_u64.js\";\nimport { clean, createHasher, oidNist, rotr } from \"./utils.js\";\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\n/** Internal 32-byte base SHA2 hash class. */\nclass SHA2_32B extends HashMD {\n    constructor(outputLen) {\n        super(64, outputLen, 8, false);\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        clean(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\n/** Internal SHA2-256 hash class. */\nexport class _SHA256 extends SHA2_32B {\n    // We cannot use array here since array allows indexing by variable\n    // which means optimizer/compiler cannot use registers.\n    A = SHA256_IV[0] | 0;\n    B = SHA256_IV[1] | 0;\n    C = SHA256_IV[2] | 0;\n    D = SHA256_IV[3] | 0;\n    E = SHA256_IV[4] | 0;\n    F = SHA256_IV[5] | 0;\n    G = SHA256_IV[6] | 0;\n    H = SHA256_IV[7] | 0;\n    constructor() {\n        super(32);\n    }\n}\n/** Internal SHA2-224 hash class. */\nexport class _SHA224 extends SHA2_32B {\n    A = SHA224_IV[0] | 0;\n    B = SHA224_IV[1] | 0;\n    C = SHA224_IV[2] | 0;\n    D = SHA224_IV[3] | 0;\n    E = SHA224_IV[4] | 0;\n    F = SHA224_IV[5] | 0;\n    G = SHA224_IV[6] | 0;\n    H = SHA224_IV[7] | 0;\n    constructor() {\n        super(28);\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n/** Internal 64-byte base SHA2 hash class. */\nclass SHA2_64B extends HashMD {\n    constructor(outputLen) {\n        super(128, outputLen, 16, false);\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        clean(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/** Internal SHA2-512 hash class. */\nexport class _SHA512 extends SHA2_64B {\n    Ah = SHA512_IV[0] | 0;\n    Al = SHA512_IV[1] | 0;\n    Bh = SHA512_IV[2] | 0;\n    Bl = SHA512_IV[3] | 0;\n    Ch = SHA512_IV[4] | 0;\n    Cl = SHA512_IV[5] | 0;\n    Dh = SHA512_IV[6] | 0;\n    Dl = SHA512_IV[7] | 0;\n    Eh = SHA512_IV[8] | 0;\n    El = SHA512_IV[9] | 0;\n    Fh = SHA512_IV[10] | 0;\n    Fl = SHA512_IV[11] | 0;\n    Gh = SHA512_IV[12] | 0;\n    Gl = SHA512_IV[13] | 0;\n    Hh = SHA512_IV[14] | 0;\n    Hl = SHA512_IV[15] | 0;\n    constructor() {\n        super(64);\n    }\n}\n/** Internal SHA2-384 hash class. */\nexport class _SHA384 extends SHA2_64B {\n    Ah = SHA384_IV[0] | 0;\n    Al = SHA384_IV[1] | 0;\n    Bh = SHA384_IV[2] | 0;\n    Bl = SHA384_IV[3] | 0;\n    Ch = SHA384_IV[4] | 0;\n    Cl = SHA384_IV[5] | 0;\n    Dh = SHA384_IV[6] | 0;\n    Dl = SHA384_IV[7] | 0;\n    Eh = SHA384_IV[8] | 0;\n    El = SHA384_IV[9] | 0;\n    Fh = SHA384_IV[10] | 0;\n    Fl = SHA384_IV[11] | 0;\n    Gh = SHA384_IV[12] | 0;\n    Gl = SHA384_IV[13] | 0;\n    Hh = SHA384_IV[14] | 0;\n    Hl = SHA384_IV[15] | 0;\n    constructor() {\n        super(48);\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n/** Internal SHA2-512/224 hash class. */\nexport class _SHA512_224 extends SHA2_64B {\n    Ah = T224_IV[0] | 0;\n    Al = T224_IV[1] | 0;\n    Bh = T224_IV[2] | 0;\n    Bl = T224_IV[3] | 0;\n    Ch = T224_IV[4] | 0;\n    Cl = T224_IV[5] | 0;\n    Dh = T224_IV[6] | 0;\n    Dl = T224_IV[7] | 0;\n    Eh = T224_IV[8] | 0;\n    El = T224_IV[9] | 0;\n    Fh = T224_IV[10] | 0;\n    Fl = T224_IV[11] | 0;\n    Gh = T224_IV[12] | 0;\n    Gl = T224_IV[13] | 0;\n    Hh = T224_IV[14] | 0;\n    Hl = T224_IV[15] | 0;\n    constructor() {\n        super(28);\n    }\n}\n/** Internal SHA2-512/256 hash class. */\nexport class _SHA512_256 extends SHA2_64B {\n    Ah = T256_IV[0] | 0;\n    Al = T256_IV[1] | 0;\n    Bh = T256_IV[2] | 0;\n    Bl = T256_IV[3] | 0;\n    Ch = T256_IV[4] | 0;\n    Cl = T256_IV[5] | 0;\n    Dh = T256_IV[6] | 0;\n    Dl = T256_IV[7] | 0;\n    Eh = T256_IV[8] | 0;\n    El = T256_IV[9] | 0;\n    Fh = T256_IV[10] | 0;\n    Fl = T256_IV[11] | 0;\n    Gh = T256_IV[12] | 0;\n    Gl = T256_IV[13] | 0;\n    Hh = T256_IV[14] | 0;\n    Hl = T256_IV[15] | 0;\n    constructor() {\n        super(32);\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634. In JS it's the fastest: even faster than Blake3. Some info:\n *\n * - Trying 2^128 hashes would get 50% chance of collision, using birthday attack.\n * - BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n * - Each sha256 hash is executing 2^18 bit operations.\n * - Good 2024 ASICs can do 200Th/sec with 3500 watts of power, corresponding to 2^36 hashes/joule.\n */\nexport const sha256 = /* @__PURE__ */ createHasher(() => new _SHA256(), \n/* @__PURE__ */ oidNist(0x01));\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224 = /* @__PURE__ */ createHasher(() => new _SHA224(), \n/* @__PURE__ */ oidNist(0x04));\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512 = /* @__PURE__ */ createHasher(() => new _SHA512(), \n/* @__PURE__ */ oidNist(0x03));\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384 = /* @__PURE__ */ createHasher(() => new _SHA384(), \n/* @__PURE__ */ oidNist(0x02));\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256 = /* @__PURE__ */ createHasher(() => new _SHA512_256(), \n/* @__PURE__ */ oidNist(0x06));\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224 = /* @__PURE__ */ createHasher(() => new _SHA512_224(), \n/* @__PURE__ */ oidNist(0x05));\n//# sourceMappingURL=sha2.js.map","/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { abytes as abytes_, anumber, bytesToHex as bytesToHex_, concatBytes as concatBytes_, hexToBytes as hexToBytes_, } from '@noble/hashes/utils.js';\nexport { abytes, anumber, bytesToHex, concatBytes, hexToBytes, isBytes, randomBytes, } from '@noble/hashes/utils.js';\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport function abool(value, title = '') {\n    if (typeof value !== 'boolean') {\n        const prefix = title && `\"${title}\" `;\n        throw new Error(prefix + 'expected boolean, got type=' + typeof value);\n    }\n    return value;\n}\n// Used in weierstrass, der\nfunction abignumber(n) {\n    if (typeof n === 'bigint') {\n        if (!isPosBig(n))\n            throw new Error('positive bigint expected, got ' + n);\n    }\n    else\n        anumber(n);\n    return n;\n}\nexport function asafenumber(value, title = '') {\n    if (!Number.isSafeInteger(value)) {\n        const prefix = title && `\"${title}\" `;\n        throw new Error(prefix + 'expected safe integer, got type=' + typeof value);\n    }\n}\nexport function numberToHexUnpadded(num) {\n    const hex = abignumber(num).toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex_(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    return hexToNumber(bytesToHex_(copyBytes(abytes_(bytes)).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    anumber(len);\n    n = abignumber(n);\n    const res = hexToBytes_(n.toString(16).padStart(len * 2, '0'));\n    if (res.length !== len)\n        throw new Error('number too large');\n    return res;\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes_(numberToHexUnpadded(abignumber(n)));\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */\nexport function copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n}\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as `TextEncoder` for ASCII or throws.\n */\nexport function asciiToBytes(ascii) {\n    return Uint8Array.from(ascii, (c, i) => {\n        const charCode = c.charCodeAt(0);\n        if (c.length !== 1 || charCode > 127) {\n            throw new Error(`string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`);\n        }\n        return charCode;\n    });\n}\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nexport function inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_1n << BigInt(n)) - _1n;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    anumber(hashLen, 'hashLen');\n    anumber(qByteLen, 'qByteLen');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    const u8n = (len) => new Uint8Array(len); // creates Uint8Array\n    const NULL = Uint8Array.of();\n    const byte0 = Uint8Array.of(0x00);\n    const byte1 = Uint8Array.of(0x01);\n    const _maxDrbgIters = 1000;\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...msgs) => hmacFn(k, concatBytes_(v, ...msgs)); // hmac(k)(v, ...values)\n    const reseed = (seed = NULL) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(byte0, seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(byte1, seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= _maxDrbgIters)\n            throw new Error('drbg: tried max amount of iterations');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes_(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\nexport function validateObject(object, fields = {}, optFields = {}) {\n    if (!object || typeof object !== 'object')\n        throw new Error('expected valid options object');\n    function checkField(fieldName, expectedType, isOpt) {\n        const val = object[fieldName];\n        if (isOpt && val === undefined)\n            return;\n        const current = typeof val;\n        if (current !== expectedType || val === null)\n            throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n    }\n    const iter = (f, isOpt) => Object.entries(f).forEach(([k, v]) => checkField(k, v, isOpt));\n    iter(fields, false);\n    iter(optFields, true);\n}\n/**\n * throws not implemented error\n */\nexport const notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map","/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { abytes, anumber, bytesToNumberBE, bytesToNumberLE, numberToBytesBE, numberToBytesLE, validateObject, } from \"../utils.js\";\n// Numbers aren't used in x25519 / x448 builds\n// prettier-ignore\nconst _0n = /* @__PURE__ */ BigInt(0), _1n = /* @__PURE__ */ BigInt(1), _2n = /* @__PURE__ */ BigInt(2);\n// prettier-ignore\nconst _3n = /* @__PURE__ */ BigInt(3), _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5);\n// prettier-ignore\nconst _7n = /* @__PURE__ */ BigInt(7), _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9);\nconst _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction assertIsSquare(Fp, root, n) {\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    assertIsSquare(Fp, root, n);\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    assertIsSquare(Fp, root, n);\n    return root;\n}\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P) {\n    const Fp_ = Field(P);\n    const tn = tonelliShanks(P);\n    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    return (Fp, n) => {\n        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4\n        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1\n        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1\n        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1\n        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n        assertIsSquare(Fp, root, n);\n        return root;\n    };\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Initialization (precomputation).\n    // Caching initialization could boost perf by 7%.\n    if (P < _3n)\n        throw new Error('sqrt is not defined for small field');\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while (Q % _2n === _0n) {\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while (FpLegendre(_Fp, Z) === 1) {\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000)\n            throw new Error('Cannot find square root: probably non-prime P');\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1)\n        return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n))\n            return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1)\n            throw new Error('Cannot find square root');\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while (!Fp.eql(t, Fp.ONE)) {\n            if (Fp.is0(t))\n                return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i) â‰¡ 1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while (!Fp.eql(t_tmp, Fp.ONE)) {\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M)\n                    throw new Error('Cannot find square root');\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P â‰¡ 3 (mod 4)\n * 2. P â‰¡ 5 (mod 8)\n * 3. P â‰¡ 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P) {\n    // P â‰¡ 3 (mod 4) => âˆšn = n^((P+1)/4)\n    if (P % _4n === _3n)\n        return sqrt3mod4;\n    // P â‰¡ 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n)\n        return sqrt5mod8;\n    // P â‰¡ 9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n    if (P % _16n === _9n)\n        return sqrt9mod16(P);\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        BYTES: 'number',\n        BITS: 'number',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    validateObject(field, opts);\n    // const max = 16384;\n    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n    return field;\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(Fp, num, power) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return Fp.ONE;\n    if (power === _1n)\n        return num;\n    let p = Fp.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nexport function FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) â‰¡ 1    if a is a square (mod p), quadratic residue\n * * (a | p) â‰¡ -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) â‰¡ 0    if a â‰¡ 0 (mod p)\n */\nexport function FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no)\n        throw new Error('invalid Legendre symbol result');\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined)\n        anumber(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\nclass _Field {\n    ORDER;\n    BITS;\n    BYTES;\n    isLE;\n    ZERO = _0n;\n    ONE = _1n;\n    _lengths;\n    _sqrt; // cached sqrt\n    _mod;\n    constructor(ORDER, opts = {}) {\n        if (ORDER <= _0n)\n            throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n        let _nbitLength = undefined;\n        this.isLE = false;\n        if (opts != null && typeof opts === 'object') {\n            if (typeof opts.BITS === 'number')\n                _nbitLength = opts.BITS;\n            if (typeof opts.sqrt === 'function')\n                this.sqrt = opts.sqrt;\n            if (typeof opts.isLE === 'boolean')\n                this.isLE = opts.isLE;\n            if (opts.allowedLengths)\n                this._lengths = opts.allowedLengths?.slice();\n            if (typeof opts.modFromBytes === 'boolean')\n                this._mod = opts.modFromBytes;\n        }\n        const { nBitLength, nByteLength } = nLength(ORDER, _nbitLength);\n        if (nByteLength > 2048)\n            throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n        this.ORDER = ORDER;\n        this.BITS = nBitLength;\n        this.BYTES = nByteLength;\n        this._sqrt = undefined;\n        Object.preventExtensions(this);\n    }\n    create(num) {\n        return mod(num, this.ORDER);\n    }\n    isValid(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('invalid field element: expected bigint, got ' + typeof num);\n        return _0n <= num && num < this.ORDER; // 0 is valid element, but it's not invertible\n    }\n    is0(num) {\n        return num === _0n;\n    }\n    // is valid and invertible\n    isValidNot0(num) {\n        return !this.is0(num) && this.isValid(num);\n    }\n    isOdd(num) {\n        return (num & _1n) === _1n;\n    }\n    neg(num) {\n        return mod(-num, this.ORDER);\n    }\n    eql(lhs, rhs) {\n        return lhs === rhs;\n    }\n    sqr(num) {\n        return mod(num * num, this.ORDER);\n    }\n    add(lhs, rhs) {\n        return mod(lhs + rhs, this.ORDER);\n    }\n    sub(lhs, rhs) {\n        return mod(lhs - rhs, this.ORDER);\n    }\n    mul(lhs, rhs) {\n        return mod(lhs * rhs, this.ORDER);\n    }\n    pow(num, power) {\n        return FpPow(this, num, power);\n    }\n    div(lhs, rhs) {\n        return mod(lhs * invert(rhs, this.ORDER), this.ORDER);\n    }\n    // Same as above, but doesn't normalize\n    sqrN(num) {\n        return num * num;\n    }\n    addN(lhs, rhs) {\n        return lhs + rhs;\n    }\n    subN(lhs, rhs) {\n        return lhs - rhs;\n    }\n    mulN(lhs, rhs) {\n        return lhs * rhs;\n    }\n    inv(num) {\n        return invert(num, this.ORDER);\n    }\n    sqrt(num) {\n        // Caching _sqrt speeds up sqrt9mod16 by 5x and tonneli-shanks by 10%\n        if (!this._sqrt)\n            this._sqrt = FpSqrt(this.ORDER);\n        return this._sqrt(this, num);\n    }\n    toBytes(num) {\n        return this.isLE ? numberToBytesLE(num, this.BYTES) : numberToBytesBE(num, this.BYTES);\n    }\n    fromBytes(bytes, skipValidation = false) {\n        abytes(bytes);\n        const { _lengths: allowedLengths, BYTES, isLE, ORDER, _mod: modFromBytes } = this;\n        if (allowedLengths) {\n            if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n                throw new Error('Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length);\n            }\n            const padded = new Uint8Array(BYTES);\n            // isLE add 0 to right, !isLE to the left.\n            padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n            bytes = padded;\n        }\n        if (bytes.length !== BYTES)\n            throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n        let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        if (modFromBytes)\n            scalar = mod(scalar, ORDER);\n        if (!skipValidation)\n            if (!this.isValid(scalar))\n                throw new Error('invalid field element: outside of range 0..ORDER');\n        // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n        // protocol may allow non-reduced scalar that reduced later or changed some other way.\n        return scalar;\n    }\n    // TODO: we don't need it here, move out to separate fn\n    invertBatch(lst) {\n        return FpInvertBatch(this, lst);\n    }\n    // We can't move this out because Fp6, Fp12 implement it\n    // and it's unclear what to return in there.\n    cmov(a, b, condition) {\n        return condition ? b : a;\n    }\n}\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, opts = {}) {\n    return new _Field(ORDER, opts);\n}\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.Point.Fn.ORDER)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    abytes(key);\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitLen, bitMask } from \"../utils.js\";\nimport { Field, FpInvertBatch, validateField } from \"./modular.js\";\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport function negateCt(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */\nexport function normalizeZ(c, points) {\n    const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));\n    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = bitMask(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return { windows, windowSize, mask, maxNumber, shiftBy };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    // To disable precomputes:\n    // return 1;\n    return pointWindowSizes.get(P) || 1;\n}\nfunction assert0(n) {\n    if (n !== _0n)\n        throw new Error('invalid wNAF');\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ð‘Š) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport class wNAF {\n    BASE;\n    ZERO;\n    Fn;\n    bits;\n    // Parametrized with a given Point class (not individual point)\n    constructor(Point, bits) {\n        this.BASE = Point.BASE;\n        this.ZERO = Point.ZERO;\n        this.Fn = Point.Fn;\n        this.bits = bits;\n    }\n    // non-const time multiplication ladder\n    _unsafeLadder(elm, n, p = this.ZERO) {\n        let d = elm;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(ð‘Šâˆ’1) * (Math.ceil(ð‘› / ð‘Š) + 1), where:\n     * - ð‘Š is the window size\n     * - ð‘› is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param point Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(point, W) {\n        const { windows, windowSize } = calcWOpts(W, this.bits);\n        const points = [];\n        let p = point;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            // i=1, bc we skip 0\n            for (let i = 1; i < windowSize; i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * More compact implementation:\n     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W, precomputes, n) {\n        // Scalar should be smaller than field order\n        if (!this.Fn.isValid(n))\n            throw new Error('invalid scalar');\n        // Accumulators\n        let p = this.ZERO;\n        let f = this.BASE;\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n        const wo = calcWOpts(W, this.bits);\n        for (let window = 0; window < wo.windows; window++) {\n            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // bits are 0: add garbage to fake point\n                // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                f = f.add(negateCt(isNegF, precomputes[offsetF]));\n            }\n            else {\n                // bits are 1: add to result point\n                p = p.add(negateCt(isNeg, precomputes[offset]));\n            }\n        }\n        assert0(n);\n        // Return both real and fake points: JIT won't eliminate f.\n        // At this point there is a way to F be infinity-point even if p is not,\n        // which makes it less const-time: around 1 bigint multiply.\n        return { p, f };\n    }\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {\n        const wo = calcWOpts(W, this.bits);\n        for (let window = 0; window < wo.windows; window++) {\n            if (n === _0n)\n                break; // Early-exit, skip 0 value\n            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // Window bits are 0: skip processing.\n                // Move to next window.\n                continue;\n            }\n            else {\n                const item = precomputes[offset];\n                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n            }\n        }\n        assert0(n);\n        return acc;\n    }\n    getPrecomputes(W, point, transform) {\n        // Calculate precomputes on a first run, reuse them after\n        let comp = pointPrecomputes.get(point);\n        if (!comp) {\n            comp = this.precomputeWindow(point, W);\n            if (W !== 1) {\n                // Doing transform outside of if brings 15% perf hit\n                if (typeof transform === 'function')\n                    comp = transform(comp);\n                pointPrecomputes.set(point, comp);\n            }\n        }\n        return comp;\n    }\n    cached(point, scalar, transform) {\n        const W = getW(point);\n        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n    }\n    unsafe(point, scalar, transform, prev) {\n        const W = getW(point);\n        if (W === 1)\n            return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n    }\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    createCache(P, W) {\n        validateW(W, this.bits);\n        pointWindowSizes.set(P, W);\n        pointPrecomputes.delete(P);\n    }\n    hasCache(elm) {\n        return getW(elm) !== 1;\n    }\n}\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */\nexport function mulEndoUnsafe(Point, point, k1, k2) {\n    let acc = point;\n    let p1 = Point.ZERO;\n    let p2 = Point.ZERO;\n    while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n)\n            p1 = p1.add(acc);\n        if (k2 & _1n)\n            p2 = p2.add(acc);\n        acc = acc.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n    }\n    return { p1, p2 };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */\nexport function pippenger(c, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    const fieldN = c.Fn;\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength)\n        throw new Error('arrays of points and scalars must have equal length');\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = bitLen(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12)\n        windowSize = wbits - 3;\n    else if (wbits > 4)\n        windowSize = wbits - 2;\n    else if (wbits > 0)\n        windowSize = 2;\n    const MASK = bitMask(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < slength; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe(c, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar Ã— 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 Ã— 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 Ã— 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    const fieldN = c.Fn;\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = bitMask(windowSize);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction createField(order, field, isLE) {\n    if (field) {\n        if (field.ORDER !== order)\n            throw new Error('Field.ORDER must match order: Fp == p, Fn == n');\n        validateField(field);\n        return field;\n    }\n    else {\n        return Field(order, { isLE });\n    }\n}\n/** Validates CURVE opts and creates fields */\nexport function createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {\n    if (FpFnLE === undefined)\n        FpFnLE = type === 'edwards';\n    if (!CURVE || typeof CURVE !== 'object')\n        throw new Error(`expected valid ${type} CURVE object`);\n    for (const p of ['p', 'n', 'h']) {\n        const val = CURVE[p];\n        if (!(typeof val === 'bigint' && val > _0n))\n            throw new Error(`CURVE.${p} must be positive bigint`);\n    }\n    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n    const _b = type === 'weierstrass' ? 'b' : 'd';\n    const params = ['Gx', 'Gy', 'a', _b];\n    for (const p of params) {\n        // @ts-ignore\n        if (!Fp.isValid(CURVE[p]))\n            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n    }\n    CURVE = Object.freeze(Object.assign({}, CURVE));\n    return { CURVE, Fp, Fn };\n}\nexport function createKeygen(randomSecretKey, getPublicKey) {\n    return function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return { secretKey, publicKey: getPublicKey(secretKey) };\n    };\n}\n//# sourceMappingURL=curve.js.map","/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean } from \"./utils.js\";\n/** Internal class for HMAC. */\nexport class _HMAC {\n    oHash;\n    iHash;\n    blockLen;\n    outputLen;\n    finished = false;\n    destroyed = false;\n    constructor(hash, key) {\n        ahash(hash);\n        abytes(key, undefined, 'key');\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        clean(pad);\n    }\n    update(buf) {\n        aexists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        abytes(out, this.outputLen, 'output');\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to ||= Object.create(Object.getPrototypeOf(this), {});\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac = (hash, key, message) => new _HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new _HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","/**\n * Short Weierstrass curve methods. The formula is: yÂ² = xÂ³ + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac as nobleHmac } from '@noble/hashes/hmac.js';\nimport { ahash } from '@noble/hashes/utils.js';\nimport { abool, abytes, aInRange, bitLen, bitMask, bytesToHex, bytesToNumberBE, concatBytes, createHmacDrbg, hexToBytes, isBytes, memoized, numberToHexUnpadded, validateObject, randomBytes as wcRandomBytes, } from \"../utils.js\";\nimport { createCurveFields, createKeygen, mulEndoUnsafe, negateCt, normalizeZ, wNAF, } from \"./curve.js\";\nimport { FpInvertBatch, getMinHashLength, mapHashToField, validateField, } from \"./modular.js\";\n// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)\nconst divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;\n/**\n * Splits scalar for GLV endomorphism.\n */\nexport function _splitEndoScalar(k, basis, n) {\n    // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`\n    // Since part can be negative, we need to do this on point.\n    // TODO: verifyScalar function which consumes lambda\n    const [[a1, b1], [a2, b2]] = basis;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    // |k1|/|k2| is < sqrt(N), but can be negative.\n    // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.\n    let k1 = k - c1 * a1 - c2 * a2;\n    let k2 = -c1 * b1 - c2 * b2;\n    const k1neg = k1 < _0n;\n    const k2neg = k2 < _0n;\n    if (k1neg)\n        k1 = -k1;\n    if (k2neg)\n        k2 = -k2;\n    // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.\n    // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.\n    const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n; // Half bits of N\n    if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {\n        throw new Error('splitScalar (endomorphism): failed, k=' + k);\n    }\n    return { k1neg, k1, k2neg, k2 };\n}\nfunction validateSigFormat(format) {\n    if (!['compact', 'recovered', 'der'].includes(format))\n        throw new Error('Signature format must be \"compact\", \"recovered\", or \"der\"');\n    return format;\n}\nfunction validateSigOpts(opts, def) {\n    const optsn = {};\n    for (let optName of Object.keys(def)) {\n        // @ts-ignore\n        optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];\n    }\n    abool(optsn.lowS, 'lowS');\n    abool(optsn.prehash, 'prehash');\n    if (optsn.format !== undefined)\n        validateSigFormat(optsn.format);\n    return optsn;\n}\nexport class DERErr extends Error {\n    constructor(m = '') {\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = numberToHexUnpadded(dataLen);\n            if ((len.length / 2) & 0b1000_0000)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? numberToHexUnpadded((len.length / 2) | 0b1000_0000) : '';\n            const t = numberToHexUnpadded(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 0b1000_0000); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 0b0111_1111;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = DER;\n            if (data[0] & 0b1000_0000)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 0b1000_0000))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return bytesToNumberBE(data);\n        },\n    },\n    toSig(bytes) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = abytes(bytes, undefined, 'signature');\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n/**\n * Creates weierstrass Point constructor, based on specified curve options.\n *\n * See {@link WeierstrassOpts}.\n *\n * @example\n```js\nconst opts = {\n  p: 0xfffffffffffffffffffffffffffffffeffffac73n,\n  n: 0x100000000000000000001b8fa16dfab9aca16b6b3n,\n  h: 1n,\n  a: 0n,\n  b: 7n,\n  Gx: 0x3b4c382ce37aa192a4019e763036f4f5dd4d7ebbn,\n  Gy: 0x938cf935318fdced6bc28286531733c3f03c4feen,\n};\nconst secp160k1_Point = weierstrass(opts);\n```\n */\nexport function weierstrass(params, extraOpts = {}) {\n    const validated = createCurveFields('weierstrass', params, extraOpts);\n    const { Fp, Fn } = validated;\n    let CURVE = validated.CURVE;\n    const { h: cofactor, n: CURVE_ORDER } = CURVE;\n    validateObject(extraOpts, {}, {\n        allowInfinityPoint: 'boolean',\n        clearCofactor: 'function',\n        isTorsionFree: 'function',\n        fromBytes: 'function',\n        toBytes: 'function',\n        endo: 'object',\n    });\n    const { endo } = extraOpts;\n    if (endo) {\n        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n        if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"basises\": array');\n        }\n    }\n    const lengths = getWLengths(Fp, Fn);\n    function assertCompressionIsSupported() {\n        if (!Fp.isOdd)\n            throw new Error('compression is not supported: Field does not have .isOdd()');\n    }\n    // Implements IEEE P1363 point encoding\n    function pointToBytes(_c, point, isCompressed) {\n        const { x, y } = point.toAffine();\n        const bx = Fp.toBytes(x);\n        abool(isCompressed, 'isCompressed');\n        if (isCompressed) {\n            assertCompressionIsSupported();\n            const hasEvenY = !Fp.isOdd(y);\n            return concatBytes(pprefix(hasEvenY), bx);\n        }\n        else {\n            return concatBytes(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n        }\n    }\n    function pointFromBytes(bytes) {\n        abytes(bytes, undefined, 'Point');\n        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65\n        const length = bytes.length;\n        const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // No actual validation is done here: use .assertValidity()\n        if (length === comp && (head === 0x02 || head === 0x03)) {\n            const x = Fp.fromBytes(tail);\n            if (!Fp.isValid(x))\n                throw new Error('bad point: is not on curve, wrong x');\n            const y2 = weierstrassEquation(x); // yÂ² = xÂ³ + ax + b\n            let y;\n            try {\n                y = Fp.sqrt(y2); // y = yÂ² ^ (p+1)/4\n            }\n            catch (sqrtError) {\n                const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                throw new Error('bad point: is not on curve, sqrt error' + err);\n            }\n            assertCompressionIsSupported();\n            const evenY = Fp.isOdd(y);\n            const evenH = (head & 1) === 1; // ECDSA-specific\n            if (evenH !== evenY)\n                y = Fp.neg(y);\n            return { x, y };\n        }\n        else if (length === uncomp && head === 0x04) {\n            // TODO: more checks\n            const L = Fp.BYTES;\n            const x = Fp.fromBytes(tail.subarray(0, L));\n            const y = Fp.fromBytes(tail.subarray(L, L * 2));\n            if (!isValidXY(x, y))\n                throw new Error('bad point: is not on curve');\n            return { x, y };\n        }\n        else {\n            throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);\n        }\n    }\n    const encodePoint = extraOpts.toBytes || pointToBytes;\n    const decodePoint = extraOpts.fromBytes || pointFromBytes;\n    function weierstrassEquation(x) {\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // xÂ² * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // xÂ³ + a * x + b\n    }\n    // TODO: move top-level\n    /** Checks whether equation holds for given x, y: yÂ² == xÂ³ + ax + b */\n    function isValidXY(x, y) {\n        const left = Fp.sqr(y); // yÂ²\n        const right = weierstrassEquation(x); // xÂ³ + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation yÂ² = xÂ³ + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy))\n        throw new Error('bad curve params: generator point');\n    // Test 2: discriminant Î” part should be non-zero: 4aÂ³ + 27bÂ² != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2)))\n        throw new Error('bad curve params: a or b');\n    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */\n    function acoord(title, n, banZero = false) {\n        if (!Fp.isValid(n) || (banZero && Fp.is0(n)))\n            throw new Error(`bad point coordinate ${title}`);\n        return n;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('Weierstrass Point expected');\n    }\n    function splitEndoScalarN(k) {\n        if (!endo || !endo.basises)\n            throw new Error('no endo');\n        return _splitEndoScalar(k, endo.basises, Fn.ORDER);\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z) âˆ‹ (x=X/Z, y=Y/Z)\n    const toAffineMemo = memoized((p, iz) => {\n        const { X, Y, Z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(Z, Fp.ONE))\n            return { x: X, y: Y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(Z);\n        const x = Fp.mul(X, iz);\n        const y = Fp.mul(Y, iz);\n        const zz = Fp.mul(Z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x, y };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = memoized((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not field elements');\n        if (!isValidXY(x, y))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {\n        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);\n        k1p = negateCt(k1neg, k1p);\n        k2p = negateCt(k2neg, k2p);\n        return k1p.add(k2p);\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z) âˆ‹ (x=X/Z, y=Y/Z).\n     * Default Point works in 2d / affine coordinates: (x, y).\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        // base / generator point\n        static BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n        // zero / infinity / identity point\n        static ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n        // math field\n        static Fp = Fp;\n        // scalar field\n        static Fn = Fn;\n        X;\n        Y;\n        Z;\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n        constructor(X, Y, Z) {\n            this.X = acoord('x', X);\n            this.Y = acoord('y', Y, true);\n            this.Z = acoord('z', Z);\n            Object.freeze(this);\n        }\n        static CURVE() {\n            return CURVE;\n        }\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n            if (Fp.is0(x) && Fp.is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        static fromBytes(bytes) {\n            const P = Point.fromAffine(decodePoint(abytes(bytes, undefined, 'point')));\n            P.assertValidity();\n            return P;\n        }\n        static fromHex(hex) {\n            return Point.fromBytes(hexToBytes(hex));\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         *\n         * @param windowSize\n         * @param isLazy true will defer table computation until the first multiplication\n         * @returns\n         */\n        precompute(windowSize = 8, isLazy = true) {\n            wnaf.createCache(this, windowSize);\n            if (!isLazy)\n                this.multiply(_3n); // random number\n            return this;\n        }\n        // TODO: return `this`\n        /** A point on curve is valid if it conforms to equation. */\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (!Fp.isOdd)\n                throw new Error(\"Field doesn't support isOdd\");\n            return !Fp.isOdd(y);\n        }\n        /** Compare one point to another. */\n        equals(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n        negate() {\n            return new Point(this.X, Fp.neg(this.Y), this.Z);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo } = extraOpts;\n            if (!Fn.isValidNot0(scalar))\n                throw new Error('invalid scalar: out of range'); // 0 is invalid\n            let point, fake; // Fake point is used to const-time mult\n            const mul = (n) => wnaf.cached(this, n, (p) => normalizeZ(Point, p));\n            /** See docs for {@link EndomorphismOpts} */\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);\n                const { p: k1p, f: k1f } = mul(k1);\n                const { p: k2p, f: k2f } = mul(k2);\n                fake = k1f.add(k2f);\n                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n            }\n            else {\n                const { p, f } = mul(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return normalizeZ(Point, [point, fake])[0];\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed secret key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo } = extraOpts;\n            const p = this;\n            if (!Fn.isValid(sc))\n                throw new Error('invalid scalar: out of range'); // 0 is valid\n            if (sc === _0n || p.is0())\n                return Point.ZERO; // 0\n            if (sc === _1n)\n                return p; // 1\n            if (wnaf.hasCache(this))\n                return this.multiply(sc); // precomputes\n            // We don't have method for double scalar multiplication (aP + bQ):\n            // Even with using Strauss-Shamir trick, it's 35% slower than naÃ¯ve mul+add.\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);\n                const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2); // 30% faster vs wnaf.unsafe\n                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n            }\n            else {\n                return wnaf.unsafe(p, sc);\n            }\n        }\n        /**\n         * Converts Projective point to affine (x, y) coordinates.\n         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n         */\n        toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        /**\n         * Checks whether Point is free of torsion elements (is in prime subgroup).\n         * Always torsion-free for cofactor=1 curves.\n         */\n        isTorsionFree() {\n            const { isTorsionFree } = extraOpts;\n            if (cofactor === _1n)\n                return true;\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            return wnaf.unsafe(this, CURVE_ORDER).is0();\n        }\n        clearCofactor() {\n            const { clearCofactor } = extraOpts;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(cofactor);\n        }\n        isSmallOrder() {\n            // can we use this.clearCofactor()?\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        toBytes(isCompressed = true) {\n            abool(isCompressed, 'isCompressed');\n            this.assertValidity();\n            return encodePoint(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return bytesToHex(this.toBytes(isCompressed));\n        }\n        toString() {\n            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n        }\n    }\n    const bits = Fn.BITS;\n    const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);\n    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    return Point;\n}\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY) {\n    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n    validateField(Fp);\n    const { A, B, Z } = opts;\n    if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\n    if (!Fp.isOdd)\n        throw new Error('Field does not have .isOdd()');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\nfunction getWLengths(Fp, Fn) {\n    return {\n        secretKey: Fn.BYTES,\n        publicKey: 1 + Fp.BYTES,\n        publicKeyUncompressed: 1 + 2 * Fp.BYTES,\n        publicKeyHasPrefix: true,\n        signature: 2 * Fn.BYTES,\n    };\n}\n/**\n * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.\n * This helper ensures no signature functionality is present. Less code, smaller bundle size.\n */\nexport function ecdh(Point, ecdhOpts = {}) {\n    const { Fn } = Point;\n    const randomBytes_ = ecdhOpts.randomBytes || wcRandomBytes;\n    const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });\n    function isValidSecretKey(secretKey) {\n        try {\n            const num = Fn.fromBytes(secretKey);\n            return Fn.isValidNot0(num);\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    function isValidPublicKey(publicKey, isCompressed) {\n        const { publicKey: comp, publicKeyUncompressed } = lengths;\n        try {\n            const l = publicKey.length;\n            if (isCompressed === true && l !== comp)\n                return false;\n            if (isCompressed === false && l !== publicKeyUncompressed)\n                return false;\n            return !!Point.fromBytes(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    /**\n     * Produces cryptographically secure secret key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    function randomSecretKey(seed = randomBytes_(lengths.seed)) {\n        return mapHashToField(abytes(seed, lengths.seed, 'seed'), Fn.ORDER);\n    }\n    /**\n     * Computes public key for a secret key. Checks for validity of the secret key.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(secretKey, isCompressed = true) {\n        return Point.BASE.multiply(Fn.fromBytes(secretKey)).toBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const { secretKey, publicKey, publicKeyUncompressed } = lengths;\n        if (!isBytes(item))\n            return undefined;\n        if (('_lengths' in Fn && Fn._lengths) || secretKey === publicKey)\n            return undefined;\n        const l = abytes(item, undefined, 'key').length;\n        return l === publicKey || l === publicKeyUncompressed;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from secret key A and public key B.\n     * Checks: 1) secret key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {\n        if (isProbPub(secretKeyA) === true)\n            throw new Error('first arg must be private key');\n        if (isProbPub(publicKeyB) === false)\n            throw new Error('second arg must be public key');\n        const s = Fn.fromBytes(secretKeyA);\n        const b = Point.fromBytes(publicKeyB); // checks for being on-curve\n        return b.multiply(s).toBytes(isCompressed);\n    }\n    const utils = {\n        isValidSecretKey,\n        isValidPublicKey,\n        randomSecretKey,\n    };\n    const keygen = createKeygen(randomSecretKey, getPublicKey);\n    return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });\n}\n/**\n * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.\n *\n * @param Point created using {@link weierstrass} function\n * @param hash used for 1) message prehash-ing 2) k generation in `sign`, using hmac_drbg(hash)\n * @param ecdsaOpts rarely needed, see {@link ECDSAOpts}\n *\n * @example\n * ```js\n * const p256_Point = weierstrass(...);\n * const p256_sha256 = ecdsa(p256_Point, sha256);\n * const p256_sha224 = ecdsa(p256_Point, sha224);\n * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });\n * ```\n */\nexport function ecdsa(Point, hash, ecdsaOpts = {}) {\n    ahash(hash);\n    validateObject(ecdsaOpts, {}, {\n        hmac: 'function',\n        lowS: 'boolean',\n        randomBytes: 'function',\n        bits2int: 'function',\n        bits2int_modN: 'function',\n    });\n    ecdsaOpts = Object.assign({}, ecdsaOpts);\n    const randomBytes = ecdsaOpts.randomBytes || wcRandomBytes;\n    const hmac = ecdsaOpts.hmac || ((key, msg) => nobleHmac(hash, key, msg));\n    const { Fp, Fn } = Point;\n    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;\n    const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);\n    const defaultSigOpts = {\n        prehash: true,\n        lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : true,\n        format: 'compact',\n        extraEntropy: false,\n    };\n    const hasLargeCofactor = CURVE_ORDER * _2n < Fp.ORDER; // Won't CURVE().h > 2n be more effective?\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function validateRS(title, num) {\n        if (!Fn.isValidNot0(num))\n            throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);\n        return num;\n    }\n    function assertSmallCofactor() {\n        // ECDSA recovery is hard for cofactor > 1 curves.\n        // In sign, `r = q.x mod n`, and here we recover q.x from r.\n        // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n        // However, for cofactor>1, r+n may not get q.x:\n        // r+n*i would need to be done instead where i is unknown.\n        // To easily get i, we either need to:\n        // a. increase amount of valid recid values (4, 5...); OR\n        // b. prohibit non-prime-order signatures (recid > 1).\n        if (hasLargeCofactor)\n            throw new Error('\"recovered\" sig type is not supported for cofactor >2 curves');\n    }\n    function validateSigLength(bytes, format) {\n        validateSigFormat(format);\n        const size = lengths.signature;\n        const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;\n        return abytes(bytes, sizer);\n    }\n    /**\n     * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.\n     */\n    class Signature {\n        r;\n        s;\n        recovery;\n        constructor(r, s, recovery) {\n            this.r = validateRS('r', r); // r in [1..N-1];\n            this.s = validateRS('s', s); // s in [1..N-1];\n            if (recovery != null) {\n                assertSmallCofactor();\n                if (![0, 1, 2, 3].includes(recovery))\n                    throw new Error('invalid recovery id');\n                this.recovery = recovery;\n            }\n            Object.freeze(this);\n        }\n        static fromBytes(bytes, format = defaultSigOpts.format) {\n            validateSigLength(bytes, format);\n            let recid;\n            if (format === 'der') {\n                const { r, s } = DER.toSig(abytes(bytes));\n                return new Signature(r, s);\n            }\n            if (format === 'recovered') {\n                recid = bytes[0];\n                format = 'compact';\n                bytes = bytes.subarray(1);\n            }\n            const L = lengths.signature / 2;\n            const r = bytes.subarray(0, L);\n            const s = bytes.subarray(L, L * 2);\n            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);\n        }\n        static fromHex(hex, format) {\n            return this.fromBytes(hexToBytes(hex), format);\n        }\n        assertRecovery() {\n            const { recovery } = this;\n            if (recovery == null)\n                throw new Error('invalid recovery id: must be present');\n            return recovery;\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(messageHash) {\n            const { r, s } = this;\n            const recovery = this.assertRecovery();\n            const radj = recovery === 2 || recovery === 3 ? r + CURVE_ORDER : r;\n            if (!Fp.isValid(radj))\n                throw new Error('invalid recovery id: sig.r+curve.n != R.x');\n            const x = Fp.toBytes(radj);\n            const R = Point.fromBytes(concatBytes(pprefix((recovery & 1) === 0), x));\n            const ir = Fn.inv(radj); // r^-1\n            const h = bits2int_modN(abytes(messageHash, undefined, 'msgHash')); // Truncate hash\n            const u1 = Fn.create(-h * ir); // -hr^-1\n            const u2 = Fn.create(s * ir); // sr^-1\n            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n            if (Q.is0())\n                throw new Error('invalid recovery: point at infinify');\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        toBytes(format = defaultSigOpts.format) {\n            validateSigFormat(format);\n            if (format === 'der')\n                return hexToBytes(DER.hexFromSig(this));\n            const { r, s } = this;\n            const rb = Fn.toBytes(r);\n            const sb = Fn.toBytes(s);\n            if (format === 'recovered') {\n                assertSmallCofactor();\n                return concatBytes(Uint8Array.of(this.assertRecovery()), rb, sb);\n            }\n            return concatBytes(rb, sb);\n        }\n        toHex(format) {\n            return bytesToHex(this.toBytes(format));\n        }\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = ecdsaOpts.bits2int ||\n        function bits2int_def(bytes) {\n            // Our custom check \"just in case\", for protection against DoS\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = ecdsaOpts.bits2int_modN ||\n        function bits2int_modN_def(bytes) {\n            return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // Pads output with zero as per spec\n    const ORDER_MASK = bitMask(fnBits);\n    /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */\n    function int2octets(num) {\n        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n        aInRange('num < 2^' + fnBits, num, _0n, ORDER_MASK);\n        return Fn.toBytes(num);\n    }\n    function validateMsgAndHash(message, prehash) {\n        abytes(message, undefined, 'message');\n        return prehash ? abytes(hash(message), undefined, 'prehashed message') : message;\n    }\n    /**\n     * Steps A, D of RFC6979 3.2.\n     * Creates RFC6979 seed; converts msg/privKey to numbers.\n     * Used only in sign, not in verify.\n     *\n     * Warning: we cannot assume here that message has same amount of bytes as curve order,\n     * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.\n     */\n    function prepSig(message, secretKey, opts) {\n        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);\n        message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(message);\n        const d = Fn.fromBytes(secretKey); // validate secret key, convert to bigint\n        if (!Fn.isValidNot0(d))\n            throw new Error('invalid private key');\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (extraEntropy != null && extraEntropy !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            // gen random bytes OR pass as-is\n            const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;\n            seedArgs.push(abytes(e, undefined, 'extraEntropy')); // check for being bytes\n        }\n        const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        // To transform k => Signature:\n        // q = kâ‹…G\n        // r = q.x mod n\n        // s = k^-1(m + rd) mod n\n        // Can use scalar blinding b^-1(bm + bdr) where b âˆˆ [1,qâˆ’1] according to\n        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            // Important: all mod() calls here must be done over N\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!Fn.isValidNot0(k))\n                return; // Valid scalars (including k) must be in 1..N-1\n            const ik = Fn.inv(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = kâ‹…G\n            const r = Fn.create(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            const s = Fn.create(ik * Fn.create(m + r * d)); // s = k^-1(m + rd) mod n\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3 when q.x>n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = Fn.neg(s); // if lowS was passed, ensure s is always in the bottom half of N\n                recovery ^= 1;\n            }\n            return new Signature(r, normS, hasLargeCofactor ? undefined : recovery);\n        }\n        return { seed, k2sig };\n    }\n    /**\n     * Signs message hash with a secret key.\n     *\n     * ```\n     * sign(m, d) where\n     *   k = rfc6979_hmac_drbg(m, d)\n     *   (x, y) = G Ã— k\n     *   r = x mod n\n     *   s = (m + dr) / k mod n\n     * ```\n     */\n    function sign(message, secretKey, opts = {}) {\n        const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.\n        const drbg = createHmacDrbg(hash.outputLen, Fn.BYTES, hmac);\n        const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G\n        return sig.toBytes(opts.format);\n    }\n    /**\n     * Verifies a signature against message and public key.\n     * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.\n     * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   u1 = hs^-1 mod n\n     *   u2 = rs^-1 mod n\n     *   R = u1â‹…G + u2â‹…P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, message, publicKey, opts = {}) {\n        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);\n        publicKey = abytes(publicKey, undefined, 'publicKey');\n        message = validateMsgAndHash(message, prehash);\n        if (!isBytes(signature)) {\n            const end = signature instanceof Signature ? ', use sig.toBytes()' : '';\n            throw new Error('verify expects Uint8Array signature' + end);\n        }\n        validateSigLength(signature, format); // execute this twice because we want loud error\n        try {\n            const sig = Signature.fromBytes(signature, format);\n            const P = Point.fromBytes(publicKey);\n            if (lowS && sig.hasHighS())\n                return false;\n            const { r, s } = sig;\n            const h = bits2int_modN(message); // mod n, not mod p\n            const is = Fn.inv(s); // s^-1 mod n\n            const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n            const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n            const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1â‹…G + u2â‹…P\n            if (R.is0())\n                return false;\n            const v = Fn.create(R.x); // v = r.x mod n\n            return v === r;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    function recoverPublicKey(signature, message, opts = {}) {\n        const { prehash } = validateSigOpts(opts, defaultSigOpts);\n        message = validateMsgAndHash(message, prehash);\n        return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();\n    }\n    return Object.freeze({\n        keygen,\n        getPublicKey,\n        getSharedSecret,\n        utils,\n        lengths,\n        Point,\n        sign,\n        verify,\n        recoverPublicKey,\n        Signature,\n        hash,\n    });\n}\n//# sourceMappingURL=weierstrass.js.map","/**\n * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism Ïˆ,\n * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { randomBytes } from '@noble/hashes/utils.js';\nimport { createKeygen } from \"./abstract/curve.js\";\nimport { createHasher, isogenyMap } from \"./abstract/hash-to-curve.js\";\nimport { Field, mapHashToField, pow2 } from \"./abstract/modular.js\";\nimport { ecdsa, mapToCurveSimpleSWU, weierstrass, } from \"./abstract/weierstrass.js\";\nimport { abytes, asciiToBytes, bytesToNumberBE, concatBytes } from \"./utils.js\";\n// Seems like generator was produced from some seed:\n// `Pointk1.BASE.multiply(Pointk1.Fn.inv(2n, N)).toAffine().x`\n// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n\nconst secp256k1_CURVE = {\n    p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n    h: BigInt(1),\n    a: BigInt(0),\n    b: BigInt(7),\n    Gx: BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n    Gy: BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'),\n};\nconst secp256k1_ENDO = {\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n    basises: [\n        [BigInt('0x3086d221a7d46bcde86c90e49284eb15'), -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')],\n        [BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'), BigInt('0x3086d221a7d46bcde86c90e49284eb15')],\n    ],\n};\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _2n = /* @__PURE__ */ BigInt(2);\n/**\n * âˆšn = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1_CURVE.p;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = (pow2(b3, _3n, P) * b3) % P;\n    const b9 = (pow2(b6, _3n, P) * b3) % P;\n    const b11 = (pow2(b9, _2n, P) * b2) % P;\n    const b22 = (pow2(b11, _11n, P) * b11) % P;\n    const b44 = (pow2(b22, _22n, P) * b22) % P;\n    const b88 = (pow2(b44, _44n, P) * b44) % P;\n    const b176 = (pow2(b88, _88n, P) * b88) % P;\n    const b220 = (pow2(b176, _44n, P) * b44) % P;\n    const b223 = (pow2(b220, _3n, P) * b3) % P;\n    const t1 = (pow2(b223, _23n, P) * b22) % P;\n    const t2 = (pow2(t1, _6n, P) * b2) % P;\n    const root = pow2(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });\nconst Pointk1 = /* @__PURE__ */ weierstrass(secp256k1_CURVE, {\n    Fp: Fpk1,\n    endo: secp256k1_ENDO,\n});\n/**\n * secp256k1 curve: ECDSA and ECDH methods.\n *\n * Uses sha256 to hash messages. To use a different hash,\n * pass `{ prehash: false }` to sign / verify.\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1.js';\n * const { secretKey, publicKey } = secp256k1.keygen();\n * // const publicKey = secp256k1.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello noble');\n * const sig = secp256k1.sign(msg, secretKey);\n * const isValid = secp256k1.verify(sig, msg, publicKey);\n * // const sigKeccak = secp256k1.sign(keccak256(msg), secretKey, { prehash: false });\n * ```\n */\nexport const secp256k1 = /* @__PURE__ */ ecdsa(Pointk1, sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = sha256(asciiToBytes(tag));\n        tagP = concatBytes(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return sha256(concatBytes(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toBytes(true).slice(1);\nconst hasEven = (y) => y % _2n === _0n;\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    const { Fn, BASE } = Pointk1;\n    const d_ = Fn.fromBytes(priv);\n    const p = BASE.multiply(d_); // P = d'â‹…G; 0 < d' < n check is done inside\n    const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);\n    return { scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    const Fp = Fpk1;\n    if (!Fp.isValidNot0(x))\n        throw new Error('invalid x: Fail if x â‰¥ p');\n    const xx = Fp.create(x * x);\n    const c = Fp.create(xx * x + BigInt(7)); // Let c = xÂ³ + 7 mod p.\n    let y = Fp.sqrt(c); // Let y = c^(p+1)/4 mod p. Same as sqrt().\n    // Return the unique point P such that x(P) = x and\n    // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    if (!hasEven(y))\n        y = Fp.neg(y);\n    const p = Pointk1.fromAffine({ x, y });\n    p.assertValidity();\n    return p;\n}\nconst num = bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return Pointk1.Fn.create(num(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(secretKey) {\n    return schnorrGetExtPubKey(secretKey).bytes; // d'=int(sk). Fail if d'=0 or d'â‰¥n. Ret bytes(d'â‹…G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, secretKey, auxRand = randomBytes(32)) {\n    const { Fn } = Pointk1;\n    const m = abytes(message, undefined, 'message');\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey); // checks for isWithinCurveOrder\n    const a = abytes(auxRand, 32, 'auxRand'); // Auxiliary random data a: a 32-byte array\n    const t = Fn.toBytes(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    // Let k' = int(rand) mod n. Fail if k' = 0. Let R = k'â‹…G\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const { Fp, Fn, BASE } = Pointk1;\n    const sig = abytes(signature, 64, 'signature');\n    const m = abytes(message, undefined, 'message');\n    const pub = abytes(publicKey, 32, 'publicKey');\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r â‰¥ p.\n        if (!Fp.isValidNot0(r))\n            return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s â‰¥ n.\n        if (!Fn.isValidNot0(s))\n            return false;\n        const e = challenge(Fn.toBytes(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        // R = sâ‹…G - eâ‹…P, where -eP == (n-e)P\n        const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));\n        const { x, y } = R.toAffine();\n        // Fail if is_infinite(R) / not has_even_y(R) / x(R) â‰  r.\n        if (R.is0() || !hasEven(y) || x !== r)\n            return false;\n        return true;\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1.js';\n * const { secretKey, publicKey } = schnorr.keygen();\n * // const publicKey = schnorr.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, secretKey);\n * const isValid = schnorr.verify(sig, msg, publicKey);\n * ```\n */\nexport const schnorr = /* @__PURE__ */ (() => {\n    const size = 32;\n    const seedLength = 48;\n    const randomSecretKey = (seed = randomBytes(seedLength)) => {\n        return mapHashToField(seed, secp256k1_CURVE.n);\n    };\n    return {\n        keygen: createKeygen(randomSecretKey, schnorrGetPublicKey),\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        Point: Pointk1,\n        utils: {\n            randomSecretKey,\n            taggedHash,\n            lift_x,\n            pointToBytes,\n        },\n        lengths: {\n            secretKey: size,\n            publicKey: size,\n            publicKeyHasPrefix: false,\n            signature: size * 2,\n            seed: seedLength,\n        },\n    };\n})();\nconst isoMap = /* @__PURE__ */ (() => isogenyMap(Fpk1, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n}))();\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */\nexport const secp256k1_hasher = /* @__PURE__ */ (() => createHasher(Pointk1, (scalars) => {\n    const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fpk1.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n}))();\n//# sourceMappingURL=secp256k1.js.map","import { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass.js';\nimport { schnorr, secp256k1 } from '@noble/curves/secp256k1.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { utf8ToBytes } from '@noble/hashes/utils.js';\nimport { randomBytes, bytesToHex, hexToBytes } from '@noble/curves/utils.js';\n\n/**\n * Private key type - can be hex string or Uint8Array.\n */\nexport type PrivKey = Uint8Array | string;\nimport { Bytes, hexToNumber, encodeBase64toUint8 } from '../utils';\nimport { type P2PKWitness } from '../model/types';\n\nexport type BlindSignature = {\n\tC_: WeierstrassPoint<bigint>;\n\tamount: number;\n\tid: string;\n};\n\nexport type RawBlindedMessage = {\n\tB_: WeierstrassPoint<bigint>;\n\tr: bigint;\n\tsecret: Uint8Array;\n};\n\n/**\n * @deprecated - Use {@link RawBlindedMessage}.\n */\nexport type BlindedMessage = RawBlindedMessage;\n\nexport type DLEQ = {\n\ts: Uint8Array; // signature\n\te: Uint8Array; // challenge\n\tr?: bigint; // optional: blinding factor\n};\n\nexport type RawProof = {\n\tC: WeierstrassPoint<bigint>;\n\tsecret: Uint8Array;\n\tamount: number;\n\tid: string;\n\twitness?: P2PKWitness;\n};\n\nexport type SerializedProof = {\n\tC: string;\n\tsecret: string;\n\tamount: number;\n\tid: string;\n\twitness?: string;\n};\n\nconst DOMAIN_SEPARATOR = utf8ToBytes('Secp256k1_HashToCurve_Cashu_');\n\nexport function hashToCurve(secret: Uint8Array): WeierstrassPoint<bigint> {\n\tconst msgToHash = sha256(Bytes.concat(DOMAIN_SEPARATOR, secret));\n\tconst counter = new Uint32Array(1);\n\tconst maxIterations = 2 ** 16;\n\tfor (let i = 0; i < maxIterations; i++) {\n\t\tconst counterBytes = new Uint8Array(counter.buffer);\n\t\tconst hash = sha256(Bytes.concat(msgToHash, counterBytes));\n\t\ttry {\n\t\t\treturn pointFromHex(bytesToHex(Bytes.concat(new Uint8Array([0x02]), hash)));\n\t\t} catch {\n\t\t\tcounter[0]++;\n\t\t}\n\t}\n\tthrow new Error('No valid point found');\n}\n\nexport function hash_e(pubkeys: Array<WeierstrassPoint<bigint>>): Uint8Array {\n\tconst hexStrings = pubkeys.map((p) => p.toHex(false));\n\tconst e_ = hexStrings.join('');\n\treturn sha256(new TextEncoder().encode(e_));\n}\n\nexport function pointFromBytes(bytes: Uint8Array) {\n\treturn secp256k1.Point.fromHex(bytesToHex(bytes));\n}\n\nexport function pointFromHex(hex: string) {\n\treturn secp256k1.Point.fromHex(hex);\n}\n\nexport const getKeysetIdInt = (keysetId: string): bigint => {\n\tlet keysetIdInt: bigint;\n\tif (/^[a-fA-F0-9]+$/.test(keysetId)) {\n\t\tkeysetIdInt = hexToNumber(keysetId) % BigInt(2 ** 31 - 1);\n\t} else {\n\t\t//legacy keyset compatibility\n\t\tkeysetIdInt = Bytes.toBigInt(encodeBase64toUint8(keysetId)) % BigInt(2 ** 31 - 1);\n\t}\n\treturn keysetIdInt;\n};\n\nexport function createRandomSecretKey() {\n\treturn secp256k1.utils.randomSecretKey();\n}\n\nexport function createBlindSignature(\n\tB_: WeierstrassPoint<bigint>,\n\tprivateKey: Uint8Array,\n\tamount: number,\n\tid: string,\n): BlindSignature {\n\tconst a = secp256k1.Point.Fn.fromBytes(privateKey);\n\tconst C_: WeierstrassPoint<bigint> = B_.multiply(a);\n\treturn { C_, amount, id };\n}\n\n/**\n * @deprecated - Use {@link createRandomRawBlindedMessage}\n */\nexport function createRandomBlindedMessage(_deprecated?: PrivKey): RawBlindedMessage {\n\tvoid _deprecated; // intentionally unused\n\treturn createRandomRawBlindedMessage();\n}\n\n/**\n * Creates a random blinded message.\n *\n * @remarks\n * The secret is a UTF-8 encoded 64-character lowercase hex string, generated from 32 random bytes\n * as recommended by NUT-00.\n * @returns A RawBlindedMessage: {B_, r, secret}\n */\nexport function createRandomRawBlindedMessage(): RawBlindedMessage {\n\tconst secretStr = bytesToHex(randomBytes(32)); // 64 char ASCII hex string\n\tconst secretBytes = new TextEncoder().encode(secretStr); // UTF-8 of the hex\n\treturn blindMessage(secretBytes);\n}\n\n/**\n * Blind a secret message.\n *\n * @param secret A UTF-8 byte encoded string.\n * @param r Optional. Deterministic blinding scalar to use (eg: for testing / seeded)\n * @returns A RawBlindedMessage: {B_, r, secret}\n */\nexport function blindMessage(secret: Uint8Array, r?: bigint): RawBlindedMessage {\n\tconst Y = hashToCurve(secret);\n\tif (!r) {\n\t\tr = secp256k1.Point.Fn.fromBytes(createRandomSecretKey());\n\t}\n\tconst rG = secp256k1.Point.BASE.multiply(r);\n\tconst B_ = Y.add(rG);\n\treturn { B_, r, secret };\n}\n\nexport function unblindSignature(\n\tC_: WeierstrassPoint<bigint>,\n\tr: bigint,\n\tA: WeierstrassPoint<bigint>,\n): WeierstrassPoint<bigint> {\n\tconst C = C_.subtract(A.multiply(r));\n\treturn C;\n}\n\nexport function constructProofFromPromise(\n\tpromise: BlindSignature,\n\tr: bigint,\n\tsecret: Uint8Array,\n\tkey: WeierstrassPoint<bigint>,\n): RawProof {\n\tconst A = key;\n\tconst C = unblindSignature(promise.C_, r, A);\n\tconst proof = {\n\t\tid: promise.id,\n\t\tamount: promise.amount,\n\t\tsecret,\n\t\tC,\n\t};\n\treturn proof;\n}\n\nexport const serializeProof = (proof: RawProof): SerializedProof => {\n\treturn {\n\t\tamount: proof.amount,\n\t\tC: proof.C.toHex(true),\n\t\tid: proof.id,\n\t\tsecret: new TextDecoder().decode(proof.secret),\n\t\twitness: JSON.stringify(proof.witness),\n\t};\n};\n\nexport const deserializeProof = (proof: SerializedProof): RawProof => {\n\treturn {\n\t\tamount: proof.amount,\n\t\tC: pointFromHex(proof.C),\n\t\tid: proof.id,\n\t\tsecret: new TextEncoder().encode(proof.secret),\n\t\twitness: proof.witness ? (JSON.parse(proof.witness) as P2PKWitness) : undefined,\n\t};\n};\n\n// ------------------------------\n// Schnorr Signing / Verififcaton\n// ------------------------------\n\n/**\n * Signs a message string using Schnorr.\n *\n * @remarks\n * Signatures are non-deterministic because schnorr.sign() generates a new random auxiliary value\n * (auxRand) each time it is called.\n * @param message - The message to sign.\n * @param privateKey - The private key to sign with (hex string or Uint8Array).\n * @returns The signature in hex format.\n */\nexport const schnorrSignMessage = (message: string, privateKey: PrivKey): string => {\n\tconst msghash = sha256(new TextEncoder().encode(message));\n\tconst privKeyBytes = typeof privateKey === 'string' ? hexToBytes(privateKey) : privateKey;\n\tconst sig = schnorr.sign(msghash, privKeyBytes); // auxRand is random by default\n\treturn bytesToHex(sig);\n};\n\n/**\n * Verifies a Schnorr signature on a message.\n *\n * @remarks\n * This function swallows Schnorr verification errors (eg invalid signature / pubkey format) and\n * treats them as false. If you want to throw such errors, use the throws param.\n * @param signature - The Schnorr signature (hex-encoded).\n * @param message - The message to verify.\n * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).\n * @param throws - True: throws on error, False: swallows errors and returns false.\n * @returns True if the signature is valid, false otherwise.\n * @throws If throws param is true and error is encountered.\n */\nexport const schnorrVerifyMessage = (\n\tsignature: string,\n\tmessage: string,\n\tpubkey: string,\n\tthrows: boolean = false,\n): boolean => {\n\ttry {\n\t\tconst msghash = sha256(new TextEncoder().encode(message));\n\t\t// Use X-only pubkey: strip 02/03 prefix if pubkey is 66 hex chars (33 bytes)\n\t\tconst pubkeyX = pubkey.length === 66 ? pubkey.slice(2) : pubkey;\n\t\treturn schnorr.verify(hexToBytes(signature), msghash, hexToBytes(pubkeyX));\n\t} catch (e) {\n\t\tif (throws) {\n\t\t\tthrow e;\n\t\t}\n\t}\n\treturn false; // default fail\n};\n\n/**\n * Returns the set of unique public keys that have produced a valid Schnorr signature for a given\n * message.\n *\n * @param signatures - The Schnorr signature(s) (hex-encoded).\n * @param message - The message to verify.\n * @param pubkeys - The Cashu P2PK public key(s) (hex-encoded, X-only or with 02/03 prefix) to\n *   check.\n * @returns Array of public keys who validly signed, duplicates removed.\n */\nexport function getValidSigners(\n\tsignatures: string[],\n\tmessage: string,\n\tpubkeys: string[],\n): string[] {\n\tconst uniquePubs = Array.from(new Set(pubkeys));\n\treturn uniquePubs.filter((pubkey) =>\n\t\tsignatures.some((sig) => schnorrVerifyMessage(sig, message, pubkey)),\n\t);\n}\n\n/**\n * Checks enough unique pubkeys have signed a message.\n *\n * @param signatures - The Schnorr signature(s) (hex-encoded).\n * @param message - The message to verify.\n * @param pubkeys - The Cashu P2PK public key(s) (hex-encoded, X-only or with 02/03 prefix) to\n *   check.\n * @param threshold - The minimum number of unique witnesses required.\n * @returns True if the witness threshold was reached, false otherwise.\n */\nexport const meetsSignerThreshold = (\n\tsignatures: string[],\n\tmessage: string,\n\tpubkeys: string[],\n\tthreshold: number = 1,\n): boolean => {\n\tconst validSigners = getValidSigners(signatures, message, pubkeys);\n\treturn validSigners.length >= threshold;\n};\n","/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://www.rfc-editor.org/rfc/rfc6151\n * @module\n */\nimport { Chi, HashMD, Maj } from \"./_md.js\";\nimport { clean, createHasher, rotl } from \"./utils.js\";\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n/** Internal SHA1 legacy hash class. */\nexport class _SHA1 extends HashMD {\n    A = SHA1_IV[0] | 0;\n    B = SHA1_IV[1] | 0;\n    C = SHA1_IV[2] | 0;\n    D = SHA1_IV[3] | 0;\n    E = SHA1_IV[4] | 0;\n    constructor() {\n        super(64, 20, 8, false);\n    }\n    get() {\n        const { A, B, C, D, E } = this;\n        return [A, B, C, D, E];\n    }\n    set(A, B, C, D, E) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA1_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 80; i++)\n            SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n        // Compression function main loop, 80 rounds\n        let { A, B, C, D, E } = this;\n        for (let i = 0; i < 80; i++) {\n            let F, K;\n            if (i < 20) {\n                F = Chi(B, C, D);\n                K = 0x5a827999;\n            }\n            else if (i < 40) {\n                F = B ^ C ^ D;\n                K = 0x6ed9eba1;\n            }\n            else if (i < 60) {\n                F = Maj(B, C, D);\n                K = 0x8f1bbcdc;\n            }\n            else {\n                F = B ^ C ^ D;\n                K = 0xca62c1d6;\n            }\n            const T = (rotl(A, 5) + F + E + K + SHA1_W[i]) | 0;\n            E = D;\n            D = C;\n            C = rotl(B, 30);\n            B = A;\n            A = T;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        this.set(A, B, C, D, E);\n    }\n    roundClean() {\n        clean(SHA1_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexport const sha1 = /* @__PURE__ */ createHasher(() => new _SHA1());\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** Internal MD5 legacy hash class. */\nexport class _MD5 extends HashMD {\n    A = MD5_IV[0] | 0;\n    B = MD5_IV[1] | 0;\n    C = MD5_IV[2] | 0;\n    D = MD5_IV[3] | 0;\n    constructor() {\n        super(64, 16, 8, true);\n    }\n    get() {\n        const { A, B, C, D } = this;\n        return [A, B, C, D];\n    }\n    set(A, B, C, D) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            MD5_W[i] = view.getUint32(offset, true);\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D } = this;\n        for (let i = 0; i < 64; i++) {\n            let F, g, s;\n            if (i < 16) {\n                F = Chi(B, C, D);\n                g = i;\n                s = [7, 12, 17, 22];\n            }\n            else if (i < 32) {\n                F = Chi(D, B, C);\n                g = (5 * i + 1) % 16;\n                s = [5, 9, 14, 20];\n            }\n            else if (i < 48) {\n                F = B ^ C ^ D;\n                g = (3 * i + 5) % 16;\n                s = [4, 11, 16, 23];\n            }\n            else {\n                F = C ^ (B | ~D);\n                g = (7 * i) % 16;\n                s = [6, 10, 15, 21];\n            }\n            F = F + A + K[i] + MD5_W[g];\n            A = D;\n            D = C;\n            C = B;\n            B = B + rotl(F, s[i % 4]);\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        this.set(A, B, C, D);\n    }\n    roundClean() {\n        clean(MD5_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexport const md5 = /* @__PURE__ */ createHasher(() => new _MD5());\n// RIPEMD-160\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n    const L = [Id160];\n    const R = [Pi160];\n    const res = [L, R];\n    for (let i = 0; i < 4; i++)\n        for (let j of res)\n            j.push(j[i].map((k) => Rho160[k]));\n    return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\nconst shifts160 = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    if (group === 1)\n        return (x & y) | (~x & z);\n    if (group === 2)\n        return (x | ~y) ^ z;\n    if (group === 3)\n        return (x & z) | (y & ~z);\n    return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nexport class _RIPEMD160 extends HashMD {\n    h0 = 0x67452301 | 0;\n    h1 = 0xefcdab89 | 0;\n    h2 = 0x98badcfe | 0;\n    h3 = 0x10325476 | 0;\n    h4 = 0xc3d2e1f0 | 0;\n    constructor() {\n        super(64, 20, 8, true);\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF_160[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        clean(BUF_160);\n    }\n    destroy() {\n        this.destroyed = true;\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexport const ripemd160 = /* @__PURE__ */ createHasher(() => new _RIPEMD160());\n//# sourceMappingURL=legacy.js.map","/**\n * BIP32 hierarchical deterministic (HD) wallets over secp256k1.\n * @module\n * @example\n * ```js\n * import { HDKey } from \"@scure/bip32\";\n * const hdkey1 = HDKey.fromMasterSeed(seed);\n * const hdkey2 = HDKey.fromExtendedKey(base58key);\n * const hdkey3 = HDKey.fromJSON({ xpriv: string });\n *\n * // props\n * [hdkey1.depth, hdkey1.index, hdkey1.chainCode];\n * console.log(hdkey2.privateKey, hdkey2.publicKey);\n * console.log(hdkey3.derive(\"m/0/2147483647'/1\"));\n * const sig = hdkey3.sign(hash);\n * hdkey3.verify(hash, sig);\n * ```\n */\n/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { secp256k1 as secp } from '@noble/curves/secp256k1.js';\nimport { hmac } from '@noble/hashes/hmac.js';\nimport { ripemd160 } from '@noble/hashes/legacy.js';\nimport { sha256, sha512 } from '@noble/hashes/sha2.js';\nimport { abytes, concatBytes, createView } from '@noble/hashes/utils.js';\nimport { createBase58check } from '@scure/base';\nconst Point = secp.Point;\nconst { Fn } = Point;\nconst base58check = createBase58check(sha256);\nconst MASTER_SECRET = Uint8Array.from('Bitcoin seed'.split(''), (char) => char.charCodeAt(0));\nconst BITCOIN_VERSIONS = { private: 0x0488ade4, public: 0x0488b21e };\n/** Hardened offset from Bitcoin, default */\nexport const HARDENED_OFFSET = 0x80000000;\nconst hash160 = (data) => ripemd160(sha256(data));\nconst fromU32 = (data) => createView(data).getUint32(0, false);\nconst toU32 = (n) => {\n    if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {\n        throw new Error('invalid number, should be from 0 to 2**32-1, got ' + n);\n    }\n    const buf = new Uint8Array(4);\n    createView(buf).setUint32(0, n, false);\n    return buf;\n};\n/**\n * HDKey from BIP32\n * @example\n```js\nconst hdkey1 = HDKey.fromMasterSeed(seed);\nconst hdkey2 = HDKey.fromExtendedKey(base58key);\nconst hdkey3 = HDKey.fromJSON({ xpriv: string });\n```\n */\nexport class HDKey {\n    get fingerprint() {\n        if (!this.pubHash) {\n            throw new Error('No publicKey set!');\n        }\n        return fromU32(this.pubHash);\n    }\n    get identifier() {\n        return this.pubHash;\n    }\n    get pubKeyHash() {\n        return this.pubHash;\n    }\n    get privateKey() {\n        return this._privateKey || null;\n    }\n    get publicKey() {\n        return this._publicKey || null;\n    }\n    get privateExtendedKey() {\n        const priv = this._privateKey;\n        if (!priv) {\n            throw new Error('No private key');\n        }\n        return base58check.encode(this.serialize(this.versions.private, concatBytes(Uint8Array.of(0), priv)));\n    }\n    get publicExtendedKey() {\n        if (!this._publicKey) {\n            throw new Error('No public key');\n        }\n        return base58check.encode(this.serialize(this.versions.public, this._publicKey));\n    }\n    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {\n        abytes(seed);\n        if (8 * seed.length < 128 || 8 * seed.length > 512) {\n            throw new Error('HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got ' +\n                seed.length);\n        }\n        const I = hmac(sha512, MASTER_SECRET, seed);\n        const privateKey = I.slice(0, 32);\n        const chainCode = I.slice(32);\n        return new HDKey({ versions, chainCode, privateKey });\n    }\n    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {\n        // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        const keyBuffer = base58check.decode(base58key);\n        const keyView = createView(keyBuffer);\n        const version = keyView.getUint32(0, false);\n        const opt = {\n            versions,\n            depth: keyBuffer[4],\n            parentFingerprint: keyView.getUint32(5, false),\n            index: keyView.getUint32(9, false),\n            chainCode: keyBuffer.slice(13, 45),\n        };\n        const key = keyBuffer.slice(45);\n        const isPriv = key[0] === 0;\n        if (version !== versions[isPriv ? 'private' : 'public']) {\n            throw new Error('Version mismatch');\n        }\n        if (isPriv) {\n            return new HDKey({ ...opt, privateKey: key.slice(1) });\n        }\n        else {\n            return new HDKey({ ...opt, publicKey: key });\n        }\n    }\n    static fromJSON(json) {\n        return HDKey.fromExtendedKey(json.xpriv);\n    }\n    versions;\n    depth = 0;\n    index = 0;\n    chainCode = null;\n    parentFingerprint = 0;\n    _privateKey;\n    _publicKey;\n    pubHash;\n    constructor(opt) {\n        if (!opt || typeof opt !== 'object') {\n            throw new Error('HDKey.constructor must not be called directly');\n        }\n        this.versions = opt.versions || BITCOIN_VERSIONS;\n        this.depth = opt.depth || 0;\n        this.chainCode = opt.chainCode || null;\n        this.index = opt.index || 0;\n        this.parentFingerprint = opt.parentFingerprint || 0;\n        if (!this.depth) {\n            if (this.parentFingerprint || this.index) {\n                throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');\n            }\n        }\n        if (this.depth > 255) {\n            throw new Error('HDKey: depth exceeds the serializable value 255');\n        }\n        if (opt.publicKey && opt.privateKey) {\n            throw new Error('HDKey: publicKey and privateKey at same time.');\n        }\n        if (opt.privateKey) {\n            if (!secp.utils.isValidSecretKey(opt.privateKey))\n                throw new Error('Invalid private key');\n            this._privateKey = opt.privateKey;\n            this._publicKey = secp.getPublicKey(opt.privateKey, true);\n        }\n        else if (opt.publicKey) {\n            this._publicKey = Point.fromBytes(opt.publicKey).toBytes(true); // force compressed point\n        }\n        else {\n            throw new Error('HDKey: no public or private key provided');\n        }\n        this.pubHash = hash160(this._publicKey);\n    }\n    derive(path) {\n        if (!/^[mM]'?/.test(path)) {\n            throw new Error('Path must start with \"m\" or \"M\"');\n        }\n        if (/^[mM]'?$/.test(path)) {\n            return this;\n        }\n        const parts = path.replace(/^[mM]'?\\//, '').split('/');\n        // tslint:disable-next-line\n        let child = this;\n        for (const c of parts) {\n            const m = /^(\\d+)('?)$/.exec(c);\n            const m1 = m && m[1];\n            if (!m || m.length !== 3 || typeof m1 !== 'string')\n                throw new Error('invalid child index: ' + c);\n            let idx = +m1;\n            if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {\n                throw new Error('Invalid index');\n            }\n            // hardened key\n            if (m[2] === \"'\") {\n                idx += HARDENED_OFFSET;\n            }\n            child = child.deriveChild(idx);\n        }\n        return child;\n    }\n    deriveChild(index) {\n        if (!this._publicKey || !this.chainCode) {\n            throw new Error('No publicKey or chainCode set');\n        }\n        let data = toU32(index);\n        if (index >= HARDENED_OFFSET) {\n            // Hardened\n            const priv = this._privateKey;\n            if (!priv) {\n                throw new Error('Could not derive hardened child key');\n            }\n            // Hardened child: 0x00 || ser256(kpar) || ser32(index)\n            data = concatBytes(Uint8Array.of(0), priv, data);\n        }\n        else {\n            // Normal child: serP(point(kpar)) || ser32(index)\n            data = concatBytes(this._publicKey, data);\n        }\n        const I = hmac(sha512, this.chainCode, data);\n        const childTweak = I.slice(0, 32);\n        const chainCode = I.slice(32);\n        if (!secp.utils.isValidSecretKey(childTweak)) {\n            throw new Error('Tweak bigger than curve order');\n        }\n        const opt = {\n            versions: this.versions,\n            chainCode,\n            depth: this.depth + 1,\n            parentFingerprint: this.fingerprint,\n            index,\n        };\n        const ctweak = Fn.fromBytes(childTweak);\n        try {\n            // Private parent key -> private child key\n            if (this._privateKey) {\n                const added = Fn.create(Fn.fromBytes(this._privateKey) + ctweak);\n                if (!Fn.isValidNot0(added)) {\n                    throw new Error('The tweak was out of range or the resulted private key is invalid');\n                }\n                opt.privateKey = Fn.toBytes(added);\n            }\n            else {\n                const added = Point.fromBytes(this._publicKey).add(Point.BASE.multiply(ctweak));\n                // Cryptographically impossible: hmac-sha512 preimage would need to be found\n                if (added.equals(Point.ZERO)) {\n                    throw new Error('The tweak was equal to negative P, which made the result key invalid');\n                }\n                opt.publicKey = added.toBytes(true);\n            }\n            return new HDKey(opt);\n        }\n        catch (err) {\n            return this.deriveChild(index + 1);\n        }\n    }\n    sign(hash) {\n        if (!this._privateKey) {\n            throw new Error('No privateKey set!');\n        }\n        abytes(hash, 32);\n        return secp.sign(hash, this._privateKey, { prehash: false });\n    }\n    verify(hash, signature) {\n        abytes(hash, 32);\n        abytes(signature, 64);\n        if (!this._publicKey) {\n            throw new Error('No publicKey set!');\n        }\n        return secp.verify(signature, hash, this._publicKey, { prehash: false });\n    }\n    wipePrivateData() {\n        if (this._privateKey) {\n            this._privateKey.fill(0);\n            this._privateKey = undefined;\n        }\n        return this;\n    }\n    toJSON() {\n        return {\n            xpriv: this.privateExtendedKey,\n            xpub: this.publicExtendedKey,\n        };\n    }\n    serialize(version, key) {\n        if (!this.chainCode) {\n            throw new Error('No chainCode set');\n        }\n        abytes(key, 33);\n        // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        return concatBytes(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);\n    }\n}\n//# sourceMappingURL=index.js.map","import { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass.js';\nimport { bytesToHex, hexToBytes } from '@noble/curves/utils.js';\nimport { secp256k1 } from '@noble/curves/secp256k1.js';\nimport { type RawProof, createRandomSecretKey, hashToCurve } from './core';\nimport { HDKey } from '@scure/bip32';\nimport { deriveKeysetId } from '../utils';\n\nconst DERIVATION_PATH = \"m/0'/0'/0'\";\n\nexport type RawMintKeys = { [k: string]: Uint8Array };\n\nexport type SerializedMintKeys = {\n\t[k: string]: string;\n};\n\nexport type Enumerate<N extends number, Acc extends number[] = []> = Acc['length'] extends N\n\t? Acc[number]\n\t: Enumerate<N, [...Acc, Acc['length']]>;\n\nexport type IntRange<F extends number, T extends number> = Exclude<Enumerate<T>, Enumerate<F>>;\n\nexport type KeysetPair = {\n\tkeysetId: string;\n\tpubKeys: RawMintKeys;\n\tprivKeys: RawMintKeys;\n};\n\nexport function serializeMintKeys(mintKeys: RawMintKeys): SerializedMintKeys {\n\tconst serializedMintKeys: SerializedMintKeys = {};\n\tObject.keys(mintKeys).forEach((p) => {\n\t\tserializedMintKeys[p] = bytesToHex(mintKeys[p]);\n\t});\n\treturn serializedMintKeys;\n}\n\nexport function deserializeMintKeys(serializedMintKeys: SerializedMintKeys): RawMintKeys {\n\tconst mintKeys: RawMintKeys = {};\n\tObject.keys(serializedMintKeys).forEach((p) => {\n\t\tmintKeys[p] = hexToBytes(serializedMintKeys[p]);\n\t});\n\treturn mintKeys;\n}\n\nexport function getPubKeyFromPrivKey(privKey: Uint8Array) {\n\treturn secp256k1.getPublicKey(privKey, true);\n}\n\n/**\n * Creates new mint keys.\n *\n * @param pow2height Number of powers of 2 to create (Max 65).\n * @param seed (Optional). Seed for key derivation.\n * @param options.expiry (optional) expiry of the keyset.\n * @param options.input_fee_ppk (optional) Input fee for keyset (in ppk)\n * @param options.unit (optional) the unit of the keyset. Default: sat.\n * @param options.versionByte (optional) version of the keyset ID. Default: 1.\n * @returns KeysetPair object.\n * @throws If keyset versionByte is not valid.\n */\nexport function createNewMintKeys(\n\tpow2height: IntRange<0, 65>,\n\tseed?: Uint8Array,\n\toptions?: {\n\t\texpiry?: number;\n\t\tinput_fee_ppk?: number;\n\t\tunit?: string;\n\t\tversionByte?: number;\n\t},\n): KeysetPair {\n\tconst { expiry, input_fee_ppk, unit = 'sat', versionByte = 1 } = options || {};\n\tlet counter = 0n;\n\tconst pubKeys: RawMintKeys = {};\n\tconst privKeys: RawMintKeys = {};\n\tlet masterKey;\n\tif (seed) {\n\t\tmasterKey = HDKey.fromMasterSeed(seed);\n\t}\n\twhile (counter < pow2height) {\n\t\tconst index: string = (2n ** counter).toString();\n\t\tif (masterKey) {\n\t\t\tconst k = masterKey.derive(`${DERIVATION_PATH}/${counter}`).privateKey;\n\t\t\tif (k) {\n\t\t\t\tprivKeys[index] = k;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Could not derive Private key from: ${DERIVATION_PATH}/${counter}`);\n\t\t\t}\n\t\t} else {\n\t\t\tprivKeys[index] = createRandomSecretKey();\n\t\t}\n\n\t\tpubKeys[index] = getPubKeyFromPrivKey(privKeys[index]);\n\t\tcounter++;\n\t}\n\tconst keysetId = deriveKeysetId(serializeMintKeys(pubKeys), {\n\t\texpiry,\n\t\tinput_fee_ppk,\n\t\tunit,\n\t\tversionByte,\n\t});\n\treturn { pubKeys, privKeys, keysetId };\n}\n\nexport function verifyProof(proof: RawProof, privKey: Uint8Array): boolean {\n\tconst Y: WeierstrassPoint<bigint> = hashToCurve(proof.secret);\n\tconst a = secp256k1.Point.Fn.fromBytes(privKey);\n\tconst aY: WeierstrassPoint<bigint> = Y.multiply(a);\n\treturn aY.equals(proof.C);\n}\n","import { bytesToHex, randomBytes } from '@noble/curves/utils.js';\n\nexport type SecretKind = 'P2PK' | 'HTLC' | (string & {}); // union with any string\n\nexport interface SecretData {\n\tnonce: string;\n\tdata: string;\n\ttags?: string[][];\n}\n\nexport type Secret = [SecretKind, SecretData];\n\n// ------------------------------\n// NUT-10 Secrets\n// ------------------------------\n\n/**\n * Create a NUT-10 well known secret.\n *\n * @param kind - The secret kind (P2PK, HTLC, etc)\n * @param pubkey - The pubkey to add to Secret.data.\n * @param tags - Optional. Additional P2PK tags.\n */\nexport function createSecret(kind: SecretKind, data: string, tags?: string[][]): string {\n\tconst newSecret: Secret = [\n\t\tkind,\n\t\t{\n\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\tdata,\n\t\t\ttags,\n\t\t},\n\t];\n\treturn JSON.stringify(newSecret);\n}\n\n/**\n * Parse a secret string and validate NUT-10 shape.\n *\n * @param secret - The Proof secret.\n * @returns Secret object.\n * @throws If the JSON is invalid or NUT-10 secret is malformed.\n */\nexport function parseSecret(secret: string | Secret): Secret {\n\tlet parsed: unknown;\n\ttry {\n\t\tif (typeof secret === 'string') {\n\t\t\tparsed = JSON.parse(secret) as Secret;\n\t\t} else {\n\t\t\tparsed = secret; // Pass through\n\t\t}\n\t} catch {\n\t\tthrow new Error(\"Can't parse secret\");\n\t}\n\n\t// Validate NUT-10 shape\n\tif (\n\t\t!Array.isArray(parsed) ||\n\t\tparsed.length !== 2 ||\n\t\ttypeof parsed[0] !== 'string' || // kind\n\t\ttypeof parsed[1] !== 'object' || // data\n\t\tparsed[0].trim().length === 0 ||\n\t\tparsed[1] === null\n\t) {\n\t\tthrow new Error('Invalid NUT-10 secret');\n\t}\n\tconst [kind, data] = parsed as [SecretKind, Record<string, unknown>];\n\tif (typeof data.nonce !== 'string' || typeof data.data !== 'string') {\n\t\tthrow new Error('Invalid NUT-10 secret nonce / data');\n\t}\n\tif (data.tags) {\n\t\t// Check data.tags is an array\n\t\tif (!Array.isArray(data.tags)) {\n\t\t\tthrow new Error('Invalid NUT-10 secret tags');\n\t\t}\n\t\t// Check individual tags are non-empty arrays of strings\n\t\tconst invalid = data.tags.some(\n\t\t\t(t) =>\n\t\t\t\t!Array.isArray(t) || t.length === 0 || t.some((tt) => typeof tt !== 'string' || !tt.length),\n\t\t);\n\t\tif (invalid) {\n\t\t\tthrow new Error('Invalid NUT-10 tag(s)');\n\t\t}\n\t}\n\n\treturn [\n\t\tkind,\n\t\t{\n\t\t\tnonce: data.nonce,\n\t\t\tdata: data.data,\n\t\t\ttags: data.tags,\n\t\t} as SecretData,\n\t];\n}\n\n// ------------------------------\n// Secret Kind / Data\n// ------------------------------\n\n/**\n * Assert that a Secret is of the expected kind.\n *\n * @param allowed - NUT-10 Kind(s) allowed.\n * @param secret - The Proof secret.\n * @returns Parsed Secret if the kind matches.\n * @throws If secret kind is not as expected.\n */\nexport function assertSecretKind(\n\tallowed: SecretKind | SecretKind[],\n\tsecret: Secret | string,\n): Secret {\n\tconst kinds = Array.isArray(allowed) ? allowed : [allowed];\n\tconst parsed = parseSecret(secret);\n\tconst actual = parsed[0];\n\tif (!kinds.includes(actual)) {\n\t\tthrow new Error(`Invalid secret kind: ${actual} Allowed: ${kinds.join(', ')}`);\n\t}\n\treturn parsed;\n}\n\n/**\n * Get the kind (first element) of a Secret.\n *\n * @param secret - The Proof secret.\n */\nexport function getSecretKind(secret: Secret | string): SecretKind {\n\treturn parseSecret(secret)[0];\n}\n\n/**\n * Get the SecretData payload (second element) of a Secret.\n *\n * @param secret - The Proof secret.\n */\nexport function getSecretData(secret: Secret | string): SecretData {\n\treturn parseSecret(secret)[1];\n}\n\n/**\n * Get data field value from a secret.\n *\n * @param secret - The Proof secret.\n * @returns - SecretData.data.\n */\nexport function getDataField(secret: Secret | string): string {\n\tconst { data } = getSecretData(secret);\n\treturn data;\n}\n\n// ------------------------------\n// Secret Tags\n// ------------------------------\n\n/**\n * Get all tags from a secret.\n *\n * @param secret - The Proof secret.\n * @returns - Array of tag arrays.\n */\nexport function getTags(secret: Secret | string): string[][] {\n\tconst { tags } = getSecretData(secret);\n\treturn tags ?? [];\n}\n\n/**\n * Check if a secret has a tag with the given key.\n *\n * @param secret - The Proof secret.\n * @param key - Tag key to lookup.\n * @returns - True if tag exists, False otherwise.\n */\nexport function hasTag(secret: Secret | string, key: string): boolean {\n\treturn getTags(secret).some((t) => t[0] === key);\n}\n\n/**\n * Get the values of a tag by key, excluding the key itself.\n *\n * @param secret - The Proof secret.\n * @param key - Tag key to lookup.\n * @returns - Array of Tag values or undefined if not present.\n */\nexport function getTag(secret: Secret | string, key: string): string[] | undefined {\n\tconst tag = getTags(secret).find((t) => t[0] === key);\n\tif (!tag || tag.length <= 1) return undefined;\n\treturn tag.slice(1);\n}\n\n/**\n * Get the first scalar value of a tag as a string, or undefined if missing.\n *\n * @param secret - The Proof secret.\n * @param key - Tag key to lookup.\n * @returns - Tag value or undefined if not present.\n */\nexport function getTagScalar(secret: Secret | string, key: string): string | undefined {\n\tconst vals = getTag(secret, key);\n\treturn vals && vals.length > 0 ? vals[0] : undefined;\n}\n\n/**\n * Get the first scalar value of a tag parsed as base-10 integer, or undefined.\n *\n * @param secret - The Proof secret.\n * @param key - Tag key to lookup.\n * @returns - Tag value as an integer, undefined if not present or invalid.\n */\nexport function getTagInt(secret: Secret | string, key: string): number | undefined {\n\tconst v = getTagScalar(secret, key);\n\tif (v === undefined) return undefined;\n\tconst n = Number.parseInt(v, 10);\n\treturn Number.isFinite(n) ? n : undefined;\n}\n","import { secp256k1 } from '@noble/curves/secp256k1.js';\nimport { Bytes, hexToNumber, numberToHexPadded64 } from '../utils';\nimport { pointFromHex } from './core';\nimport { bytesToHex, hexToBytes, utf8ToBytes } from '@noble/hashes/utils.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass.js';\n\n/**\n * BIP340-style domain separation tag (DST) for P2BK.\n *\n * @experimental\n */\nexport const P2BK_DST = utf8ToBytes('Cashu_P2BK_v1');\n\n/**\n * Blind a sequence of public keys using ECDH derived tweaks, one tweak per slot.\n *\n * @remarks\n * Security note: \"Ehex\" must never be reused. Doing so would create linkability and leak privacy.\n * The only exception is for SIG_ALL proofs, as all secret tags must match.\n *\n * This is the Sender side API.\n * @param pubkeys Ordered SEC1 compressed pubkeys, [data, ...pubkeys, ...refund]\n * @param keysetId Hex keyset identifier, bound into the tweak.\n * @param eBytes Optional. Fixed ephemeral secret key to use (eg for SIG_ALL / testing)\n * @returns Blinded pubkeys in the same order, and Ehex as SEC1 compressed hex, 33 bytes.\n * @throws If a blinded key is at infinity.\n * @experimental\n */\nexport function deriveP2BKBlindedPubkeys(\n\tpubkeys: string[],\n\tkeysetId: string,\n\teBytes?: Uint8Array,\n): { blinded: string[]; Ehex: string } {\n\tif (!pubkeys.length) return { blinded: [], Ehex: '' };\n\t// Create fresh ephemeral secret (e) if not supplied, and calculate pubkey (E)\n\teBytes = eBytes ?? secp256k1.utils.randomSecretKey(); // 32 bytes\n\tconst e = secp256k1.Point.Fn.fromBytes(eBytes); // bigint in [1..n-1]\n\tconst E = secp256k1.getPublicKey(eBytes, true); // SEC1 compressed (bytes)\n\tconst kid = hexToBytes(keysetId);\n\t// Blind each pubkey in turn\n\tconst blinded = pubkeys.map((pubkey, i) => {\n\t\tconst P = pointFromHex(pubkey);\n\t\tconst r = deriveP2BKBlindingTweakFromECDH(P, e, kid, i);\n\t\tconst P_ = P.add(secp256k1.Point.BASE.multiply(r));\n\t\tif (P_.equals(secp256k1.Point.ZERO)) throw new Error('Blinded key at infinity');\n\t\treturn P_.toHex(true);\n\t});\n\treturn { blinded, Ehex: bytesToHex(E) };\n}\n\n/**\n * Derive blinded secret keys that correspond to given P2BK blinded pubkeys.\n *\n * Pubkeys are processed in order, for a proof that is [data, ...pubkeys, ...refund]. Private key\n * order does not matter.\n *\n * @remarks\n * Security note, this operates on long lived secrets. JavaScript BigInt arithmetic in a JIT is not\n * guaranteed constant time. Do not expose this function on a server that holds private keys.\n *\n * This is the Receiver side API.\n * @param Ehex Ephemeral public key (E) as SEC1 hex.\n * @param privateKey Secret key or array of secret keys, hex.\n * @param blindPubKey Blinded public key or array of blinded public keys, hex.\n * @param keysetIdHex Keyset identifier as hex.\n * @returns Array of derived secret keys as 64 char hex.\n * @experimental\n */\nexport function deriveP2BKSecretKeys(\n\tEhex: string,\n\tprivateKey: string | string[],\n\tblindPubKey: string | string[],\n\tkeysetIdHex: string,\n): string[] {\n\tconst privs = Array.isArray(privateKey) ? privateKey : [privateKey];\n\tconst pubs = Array.isArray(blindPubKey) ? blindPubKey : [blindPubKey];\n\tconst out = new Set<string>();\n\tconst E = secp256k1.Point.fromHex(Ehex);\n\tconst kid = hexToBytes(keysetIdHex);\n\tfor (const privHex of privs) {\n\t\tconst p = secp256k1.Point.Fn.fromBytes(hexToBytes(privHex));\n\t\tconst P = secp256k1.getPublicKey(hexToBytes(privHex), true); // 33 bytes, validates on curve\n\t\tpubs.forEach((hexP_, i) => {\n\t\t\tconst r = deriveP2BKBlindingTweakFromECDH(E, p, kid, i);\n\t\t\tconst P_ = hexToBytes(hexP_);\n\t\t\tconst kHex = deriveP2BKSecretKey(privHex, r, P_, P);\n\t\t\tif (kHex) out.add(kHex); // add only when this priv matches this Pâ€²\n\t\t});\n\t}\n\treturn Array.from(out);\n}\n\n/**\n * Derive a blinded secret key per NUT-26.\n *\n * Unblinds the pubkey (P = P_ - rÂ·G), verifies x-coord against the naturalPub x(P) == x(pÂ·G), then\n * choose skStd = (p + ráµ¢) mod n if parity(P) == parity(pÂ·G), otherwise skNeg = (-p + ráµ¢) mod n.\n * Returns skStd if no blindPubkey is provided.\n *\n * @remarks\n * Security note, this operates on long lived secrets. JavaScript BigInt arithmetic in a JIT is not\n * guaranteed constant time. Do not expose this function on a server that holds private keys.\n * @param privkey Unblinded private key (p), hex or bigint.\n * @param rBlind Blinding scalar (r), hex or bigint.\n * @param blindPubkey Optional. Blinded pubkey (P_) to match, 33 byte hex.\n * @param naturalPub Optional. Pubkey calculated from private key (P = pÂ·G), 33 byte hex.\n * @returns Derived blinded secret key as 64 char hex.\n * @throws If inputs are out of range, or the derived key would be zero.\n * @experimental\n */\nexport function deriveP2BKSecretKey(\n\tprivkey: string | bigint,\n\trBlind: string | bigint,\n\tblindPubkey?: Uint8Array,\n\tnaturalPub?: Uint8Array,\n): string | null {\n\t// Implementation note: must keep algorithmic constant time!\n\tconst n = secp256k1.Point.CURVE().n;\n\tconst p = typeof privkey === 'string' ? hexToNumber(privkey) : privkey;\n\tconst r = typeof rBlind === 'string' ? hexToNumber(rBlind) : rBlind;\n\tif (p <= 0n || p >= n) throw new Error('Invalid private key');\n\tif (r <= 0n || r >= n) throw new Error('Invalid scalar r');\n\t// If caller didn't provide P = pÂ·G, compute it in compressed form (33 bytes)\n\tnaturalPub = naturalPub ?? secp256k1.Point.BASE.multiply(p).toBytes(true);\n\tif (naturalPub.length !== 33) throw new Error('naturalPub must be 33 bytes');\n\t// Calculate both sk candidates for constant time (add/subtract is cheap)\n\tconst skStd: bigint = (p + r) % n;\n\tconst skNeg: bigint = (n - p + r) % n;\n\t// Return skStd if no blinded pubkey was provided to verify against\n\tif (!blindPubkey) {\n\t\tif (skStd === 0n) throw new Error('Derived secret key is zero');\n\t\treturn numberToHexPadded64(skStd);\n\t}\n\tif (blindPubkey.length !== 33) throw new Error('blindPubkey must be 33 bytes');\n\t// Decode Pâ€², compute R and unblind\n\tconst P_ = secp256k1.Point.fromHex(bytesToHex(blindPubkey)); // valid point\n\tconst R = secp256k1.Point.BASE.multiply(r); // R = rÂ·G\n\tconst P = P_.subtract(R); // P = P_ - R\n\tif (P.equals(secp256k1.Point.ZERO)) return null;\n\t// Check x only equality, using constant time compare\n\tconst xP = P.toBytes(true).slice(1);\n\tconst xNaturalPub = naturalPub.slice(1);\n\tif (!Bytes.equals(xP, xNaturalPub)) {\n\t\treturn null; // this P' is not for this privkey\n\t}\n\t// Select by parity, comparing the low bit only\n\tconst yP = P.toBytes(true)[0] & 1;\n\tconst yNaturalPub = naturalPub[0] & 1;\n\tconst out = yP === yNaturalPub ? skStd : skNeg;\n\tif (out === 0n) throw new Error('Derived secret key is zero');\n\treturn numberToHexPadded64(out);\n}\n\n/**\n * Internal helper, derive P2BK blinding tweak using ECDH.\n *\n * @remarks\n * Computes the shared point Z = scalarÂ·point, takes its 32 byte x coordinate Zx, then derives:\n *\n *     ráµ¢ = SHA - 256(P2BK_DST || Zx || keysetId || i); // all inputs as raw bytes\n *\n * If the result reduces to zero, or is >= curve order (n), retries once with an extra 0xff byte\n * appended to the message. Throws if the retry also reduces to zero.\n *\n * This function is symmetric. It can be called with either.\n *\n * - The receiver's private key (p) and the sender's ephemeral public key (E)\n * - The sender's ephemeral secret (e) and the receiver's public key (P)\n *\n * Both yield the same Z and therefore the same r thanks to the magic of ECDH!\n * @param point Ephemeral public key (E) or recipient public key (P)\n * @param scalar Private scalar (p) or ephemeral scalar (e) in [1, n âˆ’ 1]\n * @param keysetId Keyset identifier as raw bytes.\n * @param slotIndex Zero based slot index, only lowest 8 bits (0â€“255) are used.\n * @returns Tweak (r) in [1, n âˆ’ 1]\n * @throws If r reduces to zero after the retry.\n * @experimental\n */\nfunction deriveP2BKBlindingTweakFromECDH(\n\tpoint: WeierstrassPoint<bigint>, // E or P\n\tscalar: bigint, // p or e\n\tkeysetId: Uint8Array, // kid\n\tslotIndex: number, // i\n): bigint {\n\t// Calculate x-only ECDH shared point (Zx)\n\tconst Zx = point.multiply(scalar).toBytes(true).slice(1);\n\tconst iByte = new Uint8Array([slotIndex & 0xff]);\n\t// Derive deterministic blinding factor (r):\n\t// Note: Bytes.toBigInt is safe here because we explicitly guard against\n\t// out-of-range values below, throwing rather than silently normalizing.\n\tlet r = Bytes.toBigInt(sha256(Bytes.concat(P2BK_DST, Zx, keysetId, iByte)));\n\tif (r === 0n || r >= secp256k1.Point.CURVE().n) {\n\t\t// Very unlikely to get here!\n\t\tr = Bytes.toBigInt(sha256(Bytes.concat(P2BK_DST, Zx, keysetId, iByte, new Uint8Array([0xff]))));\n\t\tif (r === 0n || r >= secp256k1.Point.CURVE().n) {\n\t\t\tthrow new Error('P2BK: tweak derivation failed');\n\t\t}\n\t}\n\treturn r;\n}\n","import { bytesToHex, hexToBytes } from '@noble/curves/utils.js';\nimport { schnorr } from '@noble/curves/secp256k1.js';\nimport { type HTLCWitness, type P2PKWitness, type Proof } from '../model/types';\nimport { getValidSigners, schnorrSignMessage, schnorrVerifyMessage, type PrivKey } from './core';\nimport { deriveP2BKSecretKeys } from './NUT26';\nimport { type Logger, NULL_LOGGER } from '../logger';\nimport { type OutputDataLike } from '../model/OutputData';\nimport {\n\tgetTagInt,\n\tgetTagScalar,\n\tgetDataField,\n\tgetTag,\n\tassertSecretKind,\n\tcreateSecret,\n\ttype Secret,\n\tgetSecretKind,\n} from './NUT10';\n\nexport type SigFlag = 'SIG_INPUTS' | 'SIG_ALL';\n\nexport type LockState = 'PERMANENT' | 'ACTIVE' | 'EXPIRED';\n\nexport type P2PKSpendingPath = 'MAIN' | 'REFUND' | 'UNLOCKED' | 'FAILED';\n\nexport interface P2PKVerificationResult {\n\tsuccess: boolean;\n\tpath: P2PKSpendingPath;\n\tlockState: LockState;\n\trequiredSigners: number;\n\teligibleSigners: number;\n\treceivedSigners: string[]; // hex pubkeys that actually signed\n}\n\n/**\n * @internal\n */\ntype WitnessData = {\n\tpreimage?: string;\n\tsignatures: string[];\n};\n\n// ------------------------------\n// NUT-11 Secrets\n// ------------------------------\n\n/**\n * Create a P2PK secret.\n *\n * @param pubkey - The pubkey to add to Secret.data.\n * @param tags - Optional. Additional P2PK tags.\n */\nexport function createP2PKsecret(pubkey: string, tags?: string[][]): string {\n\treturn createSecret('P2PK', pubkey, tags);\n}\n\n/**\n * Parse a P2PK Secret and validate NUT-10 shape.\n *\n * @param secret - The Proof secret.\n * @returns Secret object.\n * @throws If the JSON is invalid or NUT-10 secret is malformed.\n */\nexport function parseP2PKSecret(secret: string | Secret): Secret;\n/**\n * @deprecated Pass a string or Secret instead.\n */\nexport function parseP2PKSecret(secret: Uint8Array): Secret;\nexport function parseP2PKSecret(secret: string | Uint8Array | Secret): Secret {\n\t// Handle deprecated format\n\tif (secret instanceof Uint8Array) {\n\t\tsecret = new TextDecoder().decode(secret);\n\t}\n\t// HTLC extends P2PK, so we include it in our expected list.\n\treturn assertSecretKind(['P2PK', 'HTLC'], secret);\n}\n\n// ------------------------------\n// Spending Condition Helpers\n// ------------------------------\n\n/**\n * Returns the expected witness public keys from a NUT-11 P2PK secret.\n *\n * @remarks\n * Does not tell you the pathway (Locktime or Refund MultiSig), only the keys that CAN currently\n * sign. If no keys are returned, the proof is unlocked.\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns Array of public keys or empty array.\n * @throws If secret is not P2PK.\n */\nexport function getP2PKExpectedWitnessPubkeys(secretStr: string | Secret): string[] {\n\ttry {\n\t\tconst secret: Secret = parseP2PKSecret(secretStr); // decode JSON once\n\t\tconst lockState: LockState = getP2PKLockState(secret);\n\t\tconst locktimeKeys = getP2PKWitnessPubkeys(secret);\n\t\tconst refundKeys = getP2PKWitnessRefundkeys(secret);\n\n\t\t// Locktime pathway active?\n\t\tif (lockState === 'ACTIVE' || lockState === 'PERMANENT') {\n\t\t\treturn locktimeKeys;\n\t\t}\n\n\t\t// Refund pathway active?\n\t\tif (lockState === 'EXPIRED' && refundKeys.length) {\n\t\t\tconst allKeys = [...locktimeKeys, ...refundKeys];\n\t\t\treturn Array.from(new Set(allKeys));\n\t\t}\n\t} catch {\n\t\t// do nothing\n\t}\n\treturn []; // Unlocked, malformed or expired with no refund keys\n}\n\n/**\n * Returns ALL locktime witnesses from a NUT-11 P2PK secret NB: Does not specify if they are\n * expected to sign - see: getP2PKExpectedWitnessPubkeys()\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns Array of public key(s or empty array.\n * @throws If secret is not P2PK.\n */\nexport function getP2PKWitnessPubkeys(secretStr: string | Secret): string[] {\n\tconst secret = parseP2PKSecret(secretStr); // decode JSON once\n\n\t// Add data field if P2PK\n\tlet data: string = '';\n\tif (getSecretKind(secret) === 'P2PK') {\n\t\tdata = getDataField(secret);\n\t}\n\n\t// Add pubkeys\n\tconst pubkeys = getTag(secret, 'pubkeys') ?? [];\n\tconst allKeys = [data, ...pubkeys].filter(Boolean); // filter empty\n\treturn Array.from(new Set(allKeys)); // unique keys\n}\n\n/**\n * Returns ALL refund witnesses from a NUT-11 P2PK secret NB: Does not specify if they are expected\n * to sign - see: getP2PKExpectedWitnessPubkeys()\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns Array of public keys or empty array.\n * @throws If secret is not P2PK.\n */\nexport function getP2PKWitnessRefundkeys(secretStr: string | Secret): string[] {\n\tconst secret = parseP2PKSecret(secretStr);\n\treturn getTag(secret, 'refund') ?? [];\n}\n\n/**\n * Returns the locktime from a NUT-11 P2PK secret or Infinity if no locktime.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns The locktime unix timestamp or Infinity (permanent lock)\n * @throws If secret is not P2PK.\n */\nexport function getP2PKLocktime(secretStr: string | Secret): number {\n\tconst secret = parseP2PKSecret(secretStr);\n\tconst ts = getTagInt(secret, 'locktime');\n\tif (ts === undefined || !Number.isFinite(ts) || ts <= 0) {\n\t\treturn Infinity;\n\t}\n\treturn ts;\n}\n\n/**\n * Interpret the Secret's locktime relative to a given time.\n *\n * - PERMANENT: no valid locktime tag.\n * - ACTIVE: now < locktime.\n * - EXPIRED: now >= locktime.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @param nowSeconds - Optional. The unix timestamp in seconds (Default: now)\n */\nexport function getP2PKLockState(\n\tsecretStr: Secret | string,\n\tnowSeconds: number = Math.floor(Date.now() / 1000),\n): LockState {\n\tconst secret = parseP2PKSecret(secretStr);\n\tconst locktime = getP2PKLocktime(secret);\n\tif (!Number.isFinite(locktime)) {\n\t\treturn 'PERMANENT';\n\t}\n\treturn nowSeconds < locktime ? 'ACTIVE' : 'EXPIRED';\n}\n\n/**\n * Returns the number of Locktime signatures required for a NUT-11 P2PK secret.\n *\n * @remarks\n * Returns `0` if the proof is unlocked and spendable by anyone (locktime EXPIRED, no refund keys).\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns Number of Locktime signatories (n_sigs) required or `0` if unlocked.\n * @throws If secret is not P2PK.\n */\nexport function getP2PKNSigs(secretStr: string | Secret): number {\n\tconst secret = parseP2PKSecret(secretStr);\n\tconst lockState: LockState = getP2PKLockState(secret);\n\tconst refundKeys = getP2PKWitnessRefundkeys(secret);\n\t// Locking applies except when NO refund keys AND lock is expired\n\tif (!refundKeys.length && lockState === 'EXPIRED') {\n\t\treturn 0; // proof unlocked\n\t}\n\treturn getTagInt(secret, 'n_sigs') ?? 1;\n}\n\n/**\n * Returns the number of Refund signatures required for a NUT-11 P2PK secret.\n *\n * @remarks\n * Returns `0` if the refund lock is currently inactive.\n *\n * Proof may still be locked - use: getP2PKNSigs() to check!\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns Number of Refund signatories (n_sigs_refund) required, or `0` if lock is inactive.\n * @throws If secret is not P2PK.\n */\nexport function getP2PKNSigsRefund(secretStr: string | Secret): number {\n\tconst secret = parseP2PKSecret(secretStr);\n\tconst lockState: LockState = getP2PKLockState(secret);\n\tconst refundKeys = getP2PKWitnessRefundkeys(secret);\n\t// Refund lock applies if there are refund keys AND lock is expired\n\tif (refundKeys.length && lockState === 'EXPIRED') {\n\t\treturn getTagInt(secret, 'n_sigs_refund') ?? 1;\n\t}\n\treturn 0; // refund lock inactive\n}\n\n/**\n * Returns the sigflag from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns The sigflag or 'SIG_INPUTS' (default)\n * @throws If secret is not P2PK.\n */\nexport function getP2PKSigFlag(secretStr: string | Secret): SigFlag {\n\tconst secret = parseP2PKSecret(secretStr);\n\tconst flag = getTagScalar(secret, 'sigflag');\n\treturn flag === 'SIG_ALL' ? 'SIG_ALL' : 'SIG_INPUTS';\n}\n\n/**\n * Gets witness signatures as an array.\n *\n * @param witness From Proof.\n * @returns Array of witness signatures.\n */\nexport function getP2PKWitnessSignatures(witness: Proof['witness']): string[] {\n\treturn parseWitnessData(witness)?.signatures ?? [];\n}\n\n/**\n * Normalise Proof.witness into a WitnessData object.\n *\n * @param witness From Proof.\n * @returns WitnessData object or undefined.\n * @internal\n */\nfunction parseWitnessData(witness: Proof['witness']): WitnessData | undefined {\n\tif (!witness) return undefined;\n\tlet parsed: Partial<HTLCWitness & P2PKWitness>;\n\ttry {\n\t\tparsed =\n\t\t\ttypeof witness === 'string'\n\t\t\t\t? (JSON.parse(witness) as Partial<HTLCWitness & P2PKWitness>)\n\t\t\t\t: witness;\n\t} catch (e) {\n\t\tconsole.error('Failed to parse witness string:', e);\n\t\treturn undefined;\n\t}\n\tconst data: WitnessData = {\n\t\t// always normalise signatures to an array\n\t\tsignatures: parsed.signatures ?? [],\n\t};\n\n\t// Only set preimage if it is a non empty string\n\tif (typeof parsed.preimage === 'string' && parsed.preimage.length > 0) {\n\t\tdata.preimage = parsed.preimage;\n\t}\n\treturn data;\n}\n\n// ------------------------------\n// Signing and Verifying Proofs\n// ------------------------------\n\n/**\n * Signs proofs with provided private key(s) if required.\n *\n * @remarks\n * NB: Will only sign if the proof requires a signature from the key.\n * @param proofs - An array of proofs to sign.\n * @param privateKey - A single private key or array of private keys (hex string or Uint8Array).\n * @param logger - Optional logger (default: NULL_LOGGER)\n * @param message - Optional. The message to sign (for SIG_ALL)\n * @returns Signed proofs.\n * @throws On general errors.\n */\nexport function signP2PKProofs(\n\tproofs: Proof[],\n\tprivateKey: PrivKey | PrivKey[],\n\tlogger: Logger = NULL_LOGGER,\n\tmessage?: string,\n): Proof[] {\n\t// Convert to hex strings for maybeDeriveP2BKPrivateKeys\n\tconst toHex = (k: PrivKey): string => (typeof k === 'string' ? k : bytesToHex(k));\n\tconst privateKeyHex = Array.isArray(privateKey) ? privateKey.map(toHex) : toHex(privateKey);\n\treturn proofs.map((proof, index) => {\n\t\tconst privateKeys: string[] = maybeDeriveP2BKPrivateKeys(privateKeyHex, proof);\n\t\tlet signedProof = proof;\n\t\tfor (const priv of privateKeys) {\n\t\t\ttry {\n\t\t\t\tsignedProof = signP2PKProof(signedProof, priv, message);\n\t\t\t} catch (error: unknown) {\n\t\t\t\t// Log signature failures only - these are not fatal, just informational\n\t\t\t\t// as not all keys will be needed for some proofs (eg P2BK, NIP60 etc)\n\t\t\t\tconst message = error instanceof Error ? error.message : 'Unknown error';\n\t\t\t\tlogger.warn(`Proof #${index + 1}: ${message}`);\n\t\t\t}\n\t\t}\n\t\treturn signedProof;\n\t});\n}\n\n/**\n * Signs a single proof with the provided private key if required.\n *\n * @remarks\n * Will only sign if the proof requires a signature from the key.\n * @param proof - A proof to sign.\n * @param privateKey - A single private key (hex string or Uint8Array).\n * @param message - Optional. The message to sign (for SIG_ALL)\n * @returns Signed proofs.\n * @throws Error if signature is not required or proof is already signed.\n */\nexport function signP2PKProof(proof: Proof, privateKey: PrivKey, message?: string): Proof {\n\tconst secret: Secret = parseP2PKSecret(proof.secret);\n\tmessage = message ?? proof.secret; // default message is secret\n\n\t// Check if the private key is required to sign by checking its\n\t// X-only pubkey (no 02/03 prefix) against the expected witness pubkeys\n\t// NB: Nostr pubkeys prepend 02 by convention, ignoring actual Y-parity\n\tconst privKeyBytes = typeof privateKey === 'string' ? hexToBytes(privateKey) : privateKey;\n\tconst pubkey = bytesToHex(schnorr.getPublicKey(privKeyBytes)); // x-only\n\tconst witnesses = getP2PKExpectedWitnessPubkeys(secret);\n\tif (!witnesses.length || !witnesses.some((w) => w.includes(pubkey))) {\n\t\tthrow new Error(`Signature not required from [02|03]${pubkey}`);\n\t}\n\n\t// Check if the public key has already signed\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\tconst alreadySigned = signatures.some((sig) => {\n\t\treturn schnorrVerifyMessage(sig, message, pubkey);\n\t});\n\n\tif (alreadySigned) {\n\t\tthrow new Error(`Proof already signed by [02|03]${pubkey}`);\n\t}\n\n\t// Add new signature\n\tconst signature = schnorrSignMessage(message, privateKey);\n\tconst witness = parseWitnessData(proof.witness);\n\tconst newWitness: WitnessData = {\n\t\t...(witness && witness.preimage !== undefined ? { preimage: witness.preimage } : {}),\n\t\tsignatures: [...(witness?.signatures ?? []), signature],\n\t};\n\treturn { ...proof, witness: newWitness };\n}\n\n/**\n * Verifies a pubkey has signed a P2PK Proof.\n *\n * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).\n * @param proof - A Cashu proof.\n * @param message - Optional. The message that was signed (for SIG_ALL)\n * @returns True if one of the signatures is theirs, false otherwise.\n */\nexport function hasP2PKSignedProof(pubkey: string, proof: Proof, message?: string): boolean {\n\tif (!proof.witness) {\n\t\treturn false;\n\t}\n\t// Check if message is needed\n\tif (isP2PKSigAll([proof]) && !message) {\n\t\tthrow new Error('Cannot verify a SIG_ALL proof without the message to sign');\n\t}\n\tmessage = message ?? proof.secret; // default message is secret\n\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\t// See if any of the signatures belong to this pubkey. We need to do this\n\t// as Schnorr signatures are non-deterministic (see: signMessage)\n\treturn signatures.some((sig) => {\n\t\treturn schnorrVerifyMessage(sig, message, pubkey);\n\t});\n}\n\n/**\n * Verify P2PK spending conditions for a single input.\n *\n * Two spending paths are available:\n *\n * 1. Normal path: signatures from the main pubkeys (always valid)\n * 2. Refund path: signatures from refund pubkeys (only valid after locktime)\n *\n * In addition, if the lock has expired and no refund keys are present, the proof is considered\n * unlocked and spendable without witness signatures.\n *\n * @remarks\n * Returns a detailed P2PKVerificationResult showing the conditions. If you just want a boolean\n * result, use isP2PKSpendAuthorised().\n * @param proof - The Proof to check.\n * @param logger - Optional logger (default: NULL_LOGGER)\n * @param message - Optional. The message to sign (for SIG_ALL)\n * @returns A P2PKVerificationResult describing the spending outcome.\n * @throws If verification is impossible.\n */\nexport function verifyP2PKSpendingConditions(\n\tproof: Proof,\n\tlogger: Logger = NULL_LOGGER,\n\tmessage?: string,\n): P2PKVerificationResult {\n\t// Check if message is needed\n\tif (isP2PKSigAll([proof]) && !message) {\n\t\tlogger.error('Cannot verify a SIG_ALL proof without the message to sign');\n\t\tthrow new Error('Cannot verify a SIG_ALL proof without the message to sign');\n\t}\n\n\t// Init\n\tmessage = message ?? proof.secret; // default message is proof secret\n\tconst secret: Secret = parseP2PKSecret(proof.secret);\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\tconst lockState: LockState = getP2PKLockState(secret);\n\tconst mainKeys = getP2PKWitnessPubkeys(secret);\n\tconst nsigs = getP2PKNSigs(secret);\n\tconst mainSigners = getValidSigners(signatures, message, mainKeys);\n\tconst resultBase = {\n\t\tsuccess: true,\n\t\tpath: 'MAIN' as P2PKSpendingPath,\n\t\tlockState,\n\t\trequiredSigners: nsigs,\n\t\teligibleSigners: mainKeys.length,\n\t\treceivedSigners: mainSigners,\n\t};\n\tlet result: P2PKVerificationResult = resultBase;\n\n\t// Verify the normal pathway (main pubkeys)\n\tif (mainKeys.length && nsigs > 0 && mainSigners.length >= nsigs) {\n\t\tlogger.debug('Spending condition satisfied via main pubkeys', { result });\n\t\treturn result; // success, MAIN pathway\n\t}\n\n\t// Check locktime status, continue only if expired\n\tif (lockState !== 'EXPIRED') {\n\t\tresult = { ...resultBase, success: false, path: 'FAILED' };\n\t\tlogger.debug('P2PK lock enabled, but threshold not met by main pubkeys', { result });\n\t\treturn result; // failed, MAIN pathway\n\t}\n\n\t// Verify the refund pathway\n\tlogger.debug('P2PK lock expired. Checking refund path.', { lockState });\n\tconst refundKeys = getP2PKWitnessRefundkeys(secret);\n\tif (refundKeys.length) {\n\t\tconst nSigsRefund = getP2PKNSigsRefund(secret);\n\t\tconst refundSigners = getValidSigners(signatures, message, refundKeys);\n\t\tconst refundBase: P2PKVerificationResult = {\n\t\t\t...resultBase,\n\t\t\tpath: 'REFUND',\n\t\t\trequiredSigners: nSigsRefund,\n\t\t\teligibleSigners: refundKeys.length,\n\t\t\treceivedSigners: refundSigners,\n\t\t};\n\t\tif (nSigsRefund > 0 && refundSigners.length >= nSigsRefund) {\n\t\t\tresult = refundBase;\n\t\t\tlogger.debug('Spending condition satisfied via refund pubkeys', { result });\n\t\t\treturn result; // success, REFUND pathway\n\t\t}\n\t\t// Still here?\n\t\tresult = { ...refundBase, success: false, path: 'FAILED' };\n\t\tlogger.debug('Spending threshold not met by refund pubkeys', { result });\n\t\treturn result; // failed, REFUND pathway\n\t}\n\n\t// No spending conditions\n\tresult = { ...resultBase, path: 'UNLOCKED' };\n\tlogger.debug('No refund pubkeys, anyone can spend.', { result });\n\treturn result; // success, UNLOCKED\n}\n\n/**\n * Verify P2PK spending conditions for a single input.\n *\n * @param proof - The Proof to check.\n * @param logger - Optional logger (default: NULL_LOGGER)\n * @param message - Optional. The message to sign (for SIG_ALL)\n * @returns True if the witness threshold was reached, false otherwise.\n * @throws If verification is impossible.\n */\nexport function isP2PKSpendAuthorised(\n\tproof: Proof,\n\tlogger: Logger = NULL_LOGGER,\n\tmessage?: string,\n): boolean {\n\treturn verifyP2PKSpendingConditions(proof, logger, message).success;\n}\n\n// ------------------------------\n// P2BK - Pay To Blinded Key\n// ------------------------------\n\n/**\n * Derives blinded secret keys for a P2BK proof.\n *\n * @remarks\n * Calculates the deterministic blinding factor for each P2PK pubkey (data, pubkeys, refund) and\n * calling our parity-aware derivation.\n * @param privateKey Secret key (or array of secret keys)\n * @param proof The proof.\n * @returns Deduplicated list of derived secret keys (hex, 64 chars)\n * @experimental\n */\nexport function maybeDeriveP2BKPrivateKeys(privateKey: string | string[], proof: Proof): string[] {\n\tconst privs = Array.isArray(privateKey) ? privateKey : [privateKey];\n\tconst Ehex: string | undefined = proof?.p2pk_e;\n\tif (!Ehex) {\n\t\treturn Array.from(new Set(privs));\n\t}\n\t// Extract pubkeys and keyset ID from proof\n\tconst secret = parseP2PKSecret(proof.secret);\n\tconst pubs = [...getP2PKWitnessPubkeys(secret), ...getP2PKWitnessRefundkeys(secret)];\n\tconst kid = proof.id; // keyset id is hex\n\treturn deriveP2BKSecretKeys(Ehex, privs, pubs, kid);\n}\n\n// ------------------------------\n// SIG_ALL Handling\n// ------------------------------\n\n/**\n * Validates SIG_ALL inputs have matching secrets and tags.\n *\n * @param inputs Array of Proofs.\n * @throws If proofs are not valid for SIG_ALL.\n * @internal\n */\nexport function assertSigAllInputs(inputs: Proof[]): void {\n\tif (inputs.length === 0) throw new Error('No proofs');\n\t// Check first proof\n\tconst first = parseP2PKSecret(inputs[0].secret);\n\tif (getP2PKSigFlag(first) !== 'SIG_ALL') throw new Error('First proof is not SIG_ALL');\n\tconst data0 = first[1].data;\n\tconst tags0 = JSON.stringify(first[1].tags ?? []);\n\t// Compare remaining proofs\n\tfor (let i = 1; i < inputs.length; i++) {\n\t\tconst si = parseP2PKSecret(inputs[i].secret);\n\t\tif (si[0] !== first[0]) throw new Error(`Proof #${i + 1} is not ${first[0]}`);\n\t\tif (getP2PKSigFlag(si) !== 'SIG_ALL') throw new Error(`Proof #${i + 1} is not SIG_ALL`);\n\t\tif (si[1].data !== data0) throw new Error('SIG_ALL inputs must share identical Secret.data');\n\t\tif (JSON.stringify(si[1].tags ?? []) !== tags0)\n\t\t\tthrow new Error('SIG_ALL inputs must share identical Secret.tags');\n\t}\n}\n\n/**\n * Message aggregation for SIG_ALL.\n *\n * NOTE: Use `assertSigAllInputs()` to ensure valid message inputs.\n *\n * @remarks\n * Melt transactions MUST include the quoteId.\n * @param inputs Array of Proofs.\n * @param outputs Array of OutputDataLike objects (OutputData, Factory etc).\n * @param quoteId Optional. Quote id for Melt transactions.\n * @internal\n */\nexport function buildP2PKSigAllMessage(\n\tinputs: Proof[],\n\toutputs: OutputDataLike[],\n\tquoteId?: string,\n): string {\n\tconst parts: string[] = [];\n\t// Concat inputs: secret_0 || C_0 ...\n\tfor (const p of inputs) {\n\t\tparts.push(p.secret, p.C);\n\t}\n\t// Concat outputs: amount_0 ||  B_0 ...\n\tfor (const o of outputs) {\n\t\tparts.push(String(o.blindedMessage.amount), o.blindedMessage.B_);\n\t}\n\t// Add quoteId for melts\n\tif (quoteId) {\n\t\tparts.push(quoteId);\n\t}\n\treturn parts.join('');\n}\n\n/**\n * Check if proofs are SIG_ALL.\n *\n * @remarks\n * Returns true if ANY proof has SIG_ALL, false otherwise.\n * @param inputs Array of Proofs.\n * @internal\n */\nexport function isP2PKSigAll(inputs: Proof[]): boolean {\n\treturn inputs.some((p) => {\n\t\ttry {\n\t\t\treturn getP2PKSigFlag(p.secret) === 'SIG_ALL';\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t});\n}\n\n// ------------------------------\n// Deprecated\n// ------------------------------\n\n/**\n * Message aggregation for SIG_ALL (interim format).\n *\n * @remarks\n * Melt transactions MUST include the quoteId.\n * @deprecated - For compatibility with NutShell < v18.2.\n * @internal\n */\nexport function buildInterimP2PKSigAllMessage(\n\tinputs: Proof[],\n\toutputs: OutputDataLike[],\n\tquoteId?: string,\n): string {\n\tconst parts: string[] = [];\n\t// Concat inputs: secret_0 || C_0 ...\n\tfor (const p of inputs) {\n\t\tparts.push(p.secret, p.C);\n\t}\n\t// Concat outputs: amount_0 || id_0 || B_0 ...\n\tfor (const o of outputs) {\n\t\tparts.push(String(o.blindedMessage.amount), o.blindedMessage.id, o.blindedMessage.B_);\n\t}\n\t// Add quoteId for melts\n\tif (quoteId) {\n\t\tparts.push(quoteId);\n\t}\n\treturn parts.join('');\n}\n\n/**\n * Message aggregation for SIG_ALL (legacy format).\n *\n * @remarks\n * Melt transactions MUST include the quoteId.\n * @deprecated - For compatibility with NutShell < v18.0, CDK < v0.14.1.\n * @internal\n */\nexport function buildLegacyP2PKSigAllMessage(\n\tinputs: Proof[],\n\toutputs: OutputDataLike[],\n\tquoteId?: string,\n): string {\n\tconst parts: string[] = [];\n\t// Concat inputs: secret_0 ...\n\tfor (const p of inputs) {\n\t\tparts.push(p.secret);\n\t}\n\t// Concat outputs: B_0 ...\n\tfor (const o of outputs) {\n\t\tparts.push(o.blindedMessage.B_);\n\t}\n\t// Add quoteId for melts\n\tif (quoteId) {\n\t\tparts.push(quoteId);\n\t}\n\treturn parts.join('');\n}\n\n/**\n * @deprecated - Use SecretKind for NUT-10 kinds.\n */\nexport type WellKnownSecret = 'P2PK';\n\n/**\n * Signs a P2PK secret using Schnorr.\n *\n * @deprecated Use {@link schnorrSignMessage}\n */\nexport const signP2PKSecret = (secret: string, privateKey: PrivKey): string => {\n\treturn schnorrSignMessage(secret, privateKey);\n};\n\n/**\n * Verifies a Schnorr signature on a P2PK secret.\n *\n * @deprecated Use {@link schnorrVerifyMessage}\n */\nexport const verifyP2PKSecretSignature = (\n\tsignature: string,\n\tsecret: string,\n\tpubkey: string,\n): boolean => {\n\treturn schnorrVerifyMessage(signature, secret, pubkey);\n};\n\n/**\n * @deprecated - Typo: use {@link getP2PKExpectedWitnessPubkeys} instead.\n */\nexport function getP2PKExpectedKWitnessPubkeys(secretStr: string | Secret): string[] {\n\treturn getP2PKExpectedWitnessPubkeys(secretStr);\n}\n\n/**\n * @deprecated Use {@link isP2PKSpendAuthorised} or {@link verifyP2PKSpendingConditions} instead.\n */\nexport function verifyP2PKSig(proof: Proof): boolean {\n\treturn isP2PKSpendAuthorised(proof);\n}\n","import { type DLEQ, hash_e, hashToCurve, createRandomSecretKey } from './core';\nimport { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass.js';\nimport { numberToBytesBE } from '@noble/curves/utils.js';\nimport { secp256k1 } from '@noble/curves/secp256k1.js';\n\nfunction arraysEqual(arr1: Uint8Array, arr2: Uint8Array) {\n\tif (arr1.length !== arr2.length) return false;\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (arr1[i] !== arr2[i]) return false;\n\t}\n\treturn true;\n}\n\nexport const verifyDLEQProof = (\n\tdleq: DLEQ,\n\tB_: WeierstrassPoint<bigint>,\n\tC_: WeierstrassPoint<bigint>,\n\tA: WeierstrassPoint<bigint>,\n) => {\n\tconst s = secp256k1.Point.Fn.fromBytes(dleq.s);\n\tconst e = secp256k1.Point.Fn.fromBytes(dleq.e);\n\tconst sG = secp256k1.Point.BASE.multiply(s);\n\tconst eA = A.multiply(e);\n\tconst sB_ = B_.multiply(s);\n\tconst eC_ = C_.multiply(e);\n\tconst R_1 = sG.subtract(eA); // R1 = sG - eA\n\tconst R_2 = sB_.subtract(eC_); // R2 = sB' - eC'\n\tconst hash = hash_e([R_1, R_2, A, C_]); // e == hash(R1, R2, A, C')\n\treturn arraysEqual(hash, dleq.e);\n};\n\nexport const verifyDLEQProof_reblind = (\n\tsecret: Uint8Array, // secret\n\tdleq: DLEQ,\n\tC: WeierstrassPoint<bigint>, // unblinded e-cash signature point\n\tA: WeierstrassPoint<bigint>, // mint public key point\n) => {\n\tif (dleq.r === undefined) throw new Error('verifyDLEQProof_reblind: Undefined blinding factor');\n\tconst Y = hashToCurve(secret);\n\tconst C_ = C.add(A.multiply(dleq.r)); // Re-blind the e-cash signature\n\tconst bG = secp256k1.Point.BASE.multiply(dleq.r);\n\tconst B_ = Y.add(bG); // Re-blind the message\n\treturn verifyDLEQProof(dleq, B_, C_, A);\n};\n\n/**\n * !!! WARNING !!! Not recommended for production use, due to non-constant time operations See:\n * https://github.com/cashubtc/cashu-crypto-ts/pull/2 for more details See:\n * https://en.wikipedia.org/wiki/Timing_attack for information about timing attacks.\n */\nexport const createDLEQProof = (B_: WeierstrassPoint<bigint>, a: Uint8Array): DLEQ => {\n\tconst r = secp256k1.Point.Fn.fromBytes(createRandomSecretKey()); // r <- random (Uint8Array)\n\tconst R_1 = secp256k1.Point.BASE.multiply(r); // R1 = rG\n\tconst R_2 = B_.multiply(r); // R2 = rB_\n\tconst scalar_a = secp256k1.Point.Fn.fromBytes(a);\n\tconst C_ = B_.multiply(scalar_a); // C_ = aB_\n\tconst A = secp256k1.Point.BASE.multiply(scalar_a); // A = aG\n\tconst e = hash_e([R_1, R_2, A, C_]); // e = hash(R1, R2, A, C_)\n\tconst scalar_e = secp256k1.Point.Fn.fromBytes(e);\n\t// Use field operations for constant-time addition and multiplication\n\tconst s_scalar = secp256k1.Point.Fn.add(r, secp256k1.Point.Fn.mul(scalar_e, scalar_a));\n\tconst s = numberToBytesBE(s_scalar, 32); // s = (r + e * a) mod n\n\treturn { s, e };\n};\n","import { hmac } from '@noble/hashes/hmac.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { getKeysetIdInt } from './core';\nimport { HDKey } from '@scure/bip32';\nimport { Bytes, isBase64String } from '../utils';\n\nconst STANDARD_DERIVATION_PATH = `m/129372'/0'`;\n\nconst SECP256K1_N = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141');\n\nenum DerivationType {\n\tSECRET = 0,\n\tBLINDING_FACTOR = 1,\n}\n\nexport const deriveSecret = (seed: Uint8Array, keysetId: string, counter: number): Uint8Array => {\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keysetId);\n\tif (!isValidHex && isBase64String(keysetId)) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.SECRET);\n\t}\n\n\tif (isValidHex && keysetId.startsWith('00')) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.SECRET);\n\t} else if (isValidHex && keysetId.startsWith('01')) {\n\t\treturn derive(seed, keysetId, counter, DerivationType.SECRET);\n\t}\n\tthrow new Error(`Unrecognized keyset ID version ${keysetId.slice(0, 2)}`);\n};\n\nexport const deriveBlindingFactor = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n): Uint8Array => {\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keysetId);\n\tif (!isValidHex && isBase64String(keysetId)) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t}\n\n\tif (isValidHex && keysetId.startsWith('00')) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t} else if (isValidHex && keysetId.startsWith('01')) {\n\t\treturn derive(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t}\n\tthrow new Error(`Unrecognized keyset ID version ${keysetId.slice(0, 2)}`);\n};\n\nconst derive = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n\tsecretOrBlinding: DerivationType,\n): Uint8Array => {\n\tlet message = Bytes.concat(\n\t\tBytes.fromString('Cashu_KDF_HMAC_SHA256'),\n\t\tBytes.fromHex(keysetId),\n\t\tBytes.writeBigUint64BE(BigInt(counter)),\n\t);\n\n\tswitch (secretOrBlinding) {\n\t\tcase DerivationType.SECRET:\n\t\t\tmessage = Bytes.concat(message, Bytes.fromHex('00'));\n\t\t\tbreak;\n\t\tcase DerivationType.BLINDING_FACTOR:\n\t\t\tmessage = Bytes.concat(message, Bytes.fromHex('01'));\n\t}\n\n\tconst hmacDigest = hmac(sha256, seed, message);\n\n\tif (secretOrBlinding === DerivationType.BLINDING_FACTOR) {\n\t\tconst x = Bytes.toBigInt(hmacDigest);\n\t\t// Optimization: single subtraction instead of modulo\n\t\t// Probability of HMAC >= SECP256K1_N is ~2^-128\n\t\tif (x >= SECP256K1_N) {\n\t\t\treturn Bytes.fromBigInt(x - SECP256K1_N);\n\t\t}\n\t\tif (x === 0n) {\n\t\t\tthrow new Error('Derived invalid blinding scalar r == 0');\n\t\t}\n\t\treturn hmacDigest;\n\t}\n\n\treturn hmacDigest;\n};\n\nconst derive_deprecated = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n\tsecretOrBlinding: DerivationType,\n): Uint8Array => {\n\tconst hdkey = HDKey.fromMasterSeed(seed);\n\tconst keysetIdInt = getKeysetIdInt(keysetId);\n\tconst derivationPath = `${STANDARD_DERIVATION_PATH}/${keysetIdInt}'/${counter}'/${secretOrBlinding}`;\n\tconst derived = hdkey.derive(derivationPath);\n\tif (derived.privateKey === null) {\n\t\tthrow new Error('Could not derive private key');\n\t}\n\treturn derived.privateKey;\n};\n","import { bytesToHex, hexToBytes, randomBytes } from '@noble/curves/utils.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { type HTLCWitness, type Proof } from '../model/types';\nimport { type Logger, NULL_LOGGER } from '../logger';\nimport { type P2PKVerificationResult, verifyP2PKSpendingConditions } from './NUT11';\nimport {\n\tassertSecretKind,\n\tcreateSecret,\n\ttype Secret,\n\tgetDataField,\n\tparseSecret,\n\tgetSecretKind,\n} from './NUT10';\n\n// ------------------------------\n// NUT-14 Secrets\n// ------------------------------\n\n/**\n * Create an HTLC secret.\n *\n * @remarks\n * Use `createHTLCHash()` for hash creation.\n * @param hash - The HTLC hash to add to Secret.data.\n * @param tags - Optional. Additional P2PK tags.\n */\nexport function createHTLCsecret(hash: string, tags?: string[][]): string {\n\treturn createSecret('HTLC', hash, tags);\n}\n\n/**\n * Parse an HTLC Secret and validate NUT-10 shape.\n *\n * @param secret - The Proof secret.\n * @returns Secret object.\n * @throws If the JSON is invalid or NUT-10 secret is malformed.\n */\nexport function parseHTLCSecret(secret: string | Secret): Secret {\n\treturn assertSecretKind('HTLC', secret);\n}\n\n// ------------------------------\n// Creating and Verifying Hashes\n// ------------------------------\n\n/**\n * Create an HTLC hash/preimage pair.\n *\n * @param preimage - Optional. Preimage to use (Default: random preimage)\n * @returns Hash and preimage pair.\n * @throws If the preimage supplied is not a 64-char hex string.\n */\nexport function createHTLCHash(preimage?: string): { hash: string; preimage: string } {\n\tconst hasPreimage = preimage !== undefined;\n\tif (hasPreimage && !/^[0-9a-f]{64}$/i.test(preimage)) {\n\t\tthrow new Error('Preimage must be a 64 character hexadecimal string (32 bytes).');\n\t}\n\t// Create hash\n\tconst piBytes = hasPreimage ? hexToBytes(preimage) : randomBytes(32);\n\tconst hash = bytesToHex(sha256(piBytes));\n\treturn { hash, preimage: bytesToHex(piBytes) };\n}\n\n/**\n * Verify an HTLC hash/preimage pair.\n *\n * @param preimage - As a 64-character lowercase hexadecimal string.\n * @param hash - As a 64-character lowercase hexadecimal string.\n * @returns True if preimage calculates the same hash, False otherwise.\n */\nexport function verifyHTLCHash(preimage: string, hash: string): boolean {\n\tconst { hash: valid } = createHTLCHash(preimage);\n\treturn hash === valid;\n}\n\n/**\n * Verify HTLC spending conditions for a single input.\n *\n * Two spending paths are available:\n *\n * 1. Hashlock path: Preimage + signatures from the main pubkeys (always valid)\n * 2. Refund path: signatures from refund pubkeys (only valid after locktime)\n *\n * In addition, if the lock has expired and no refund keys are present, the proof is considered\n * unlocked and spendable without witness signatures.\n *\n * @remarks\n * Returns a detailed P2PKVerificationResult showing the conditions. If you just want a boolean\n * result, use isP2PKSpendAuthorised().\n * @param proof - The Proof to check.\n * @param logger - Optional logger (default: NULL_LOGGER)\n * @param message - Optional. The message to sign (for SIG_ALL)\n * @returns A P2PKVerificationResult describing the spending outcome.\n * @throws If verification is impossible.\n */\nexport function verifyHTLCSpendingConditions(\n\tproof: Proof,\n\tlogger: Logger = NULL_LOGGER,\n\tmessage?: string,\n): P2PKVerificationResult {\n\t// Init\n\tlet result: P2PKVerificationResult;\n\tmessage = message ?? proof.secret; // default message is proof secret\n\n\t// Check P2PK locking conditions are satisfied first\n\t// We are only interested in 'MAIN' pathway spends on HTLC proofs\n\tconst secret = parseSecret(proof.secret); // no assert\n\tconst p2pkResult = verifyP2PKSpendingConditions(proof, logger, message);\n\tif (p2pkResult.path != 'MAIN' || getSecretKind(secret) !== 'HTLC') {\n\t\treturn p2pkResult; // not an hashlock spend\n\t}\n\n\t// Ensure proof has a preimage\n\tconst preimage = getHTLCWitnessPreimage(proof.witness);\n\tif (!preimage) {\n\t\tresult = { ...p2pkResult, success: false, path: 'FAILED' };\n\t\tlogger.debug('Hashlock spend failed, no preimage found', { result });\n\t\treturn result;\n\t}\n\n\t// Check preimage and hash correspond if main pathway was used\n\tconst hash = getDataField(secret);\n\tif (verifyHTLCHash(preimage, hash)) {\n\t\tresult = p2pkResult;\n\t\tlogger.debug('Spending condition satisfied via hashlock (receiver) pathway', { result });\n\t\treturn result; // success, MAIN pathway\n\t}\n\n\t// Still here? Bad news...\n\tresult = { ...p2pkResult, success: false, path: 'FAILED' };\n\tlogger.debug('Hashlock spend failed, wrong preimage for hash', { result });\n\treturn result; // failed, wrong preimage\n}\n\n/**\n * Verify HTLC spending conditions for a single input.\n *\n * @param proof - The Proof to check.\n * @param logger - Optional logger (default: NULL_LOGGER)\n * @param message - Optional. The message to sign (for SIG_ALL)\n * @returns True if spending conditions are satisfied, false otherwise.\n * @throws If verification is impossible.\n */\nexport function isHTLCSpendAuthorised(\n\tproof: Proof,\n\tlogger: Logger = NULL_LOGGER,\n\tmessage?: string,\n): boolean {\n\treturn verifyHTLCSpendingConditions(proof, logger, message).success;\n}\n\n/**\n * Get preimage from a witness if present.\n *\n * @param witness From a Proof.\n * @returns Preimage if present.\n */\nexport function getHTLCWitnessPreimage(witness: Proof['witness']): string | undefined {\n\tif (!witness) return undefined;\n\tlet parsed: Partial<HTLCWitness>;\n\ttry {\n\t\tparsed = typeof witness === 'string' ? (JSON.parse(witness) as Partial<HTLCWitness>) : witness;\n\t} catch (e) {\n\t\tconsole.error('Failed to parse HTLC witness string:', e);\n\t\treturn undefined;\n\t}\n\t// Check preimage is a non-empty string\n\tconst preimage = parsed.preimage;\n\treturn typeof preimage === 'string' && preimage.length > 0 ? preimage : undefined;\n}\n","import { schnorr } from '@noble/curves/secp256k1.js';\nimport { type SerializedBlindedMessage } from '../model/types';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\n\nfunction constructMessage(quote: string, blindedMessages: SerializedBlindedMessage[]): Uint8Array {\n\tlet message = quote;\n\tfor (const blindedMessage of blindedMessages) {\n\t\tmessage += blindedMessage.B_;\n\t}\n\tconst msgbytes = new TextEncoder().encode(message);\n\treturn sha256(msgbytes);\n}\n\nexport function signMintQuote(\n\tprivkey: string,\n\tquote: string,\n\tblindedMessages: SerializedBlindedMessage[],\n): string {\n\tconst message = constructMessage(quote, blindedMessages);\n\tconst privkeyBytes = hexToBytes(privkey);\n\tconst signature = schnorr.sign(message, privkeyBytes);\n\treturn bytesToHex(signature);\n}\n\nexport function verifyMintQuoteSignature(\n\tpubkey: string,\n\tquote: string,\n\tblindedMessages: SerializedBlindedMessage[],\n\tsignature: string,\n): boolean {\n\tconst sigbytes = hexToBytes(signature);\n\tlet pubkeyBytes = hexToBytes(pubkey);\n\tif (pubkeyBytes.length !== 33) return false;\n\tpubkeyBytes = pubkeyBytes.slice(1);\n\tconst message = constructMessage(quote, blindedMessages);\n\treturn schnorr.verify(sigbytes, message, pubkeyBytes);\n}\n","import { type Proof } from '../../model/types/proof';\n\nexport type RawTransport = {\n\tt: PaymentRequestTransportType; // type\n\ta: string; // target\n\tg?: string[][]; // tags\n};\n\nexport type RawNUT10Option = {\n\tk: string; // kind\n\td: string; // data\n\tt: string[][]; // tags\n};\n\nexport type RawPaymentRequest = {\n\ti?: string; // id\n\ta?: number; // amount\n\tu?: string; // unit\n\ts?: boolean; // single use\n\tm?: string[]; // mints\n\td?: string; // description\n\tt?: RawTransport[]; // transports\n\tnut10?: RawNUT10Option;\n\tnut26?: boolean; // P2BK\n};\n\nexport type PaymentRequestTransport = {\n\ttype: PaymentRequestTransportType;\n\ttarget: string;\n\ttags?: string[][];\n};\n\nexport enum PaymentRequestTransportType {\n\tPOST = 'post',\n\tNOSTR = 'nostr',\n}\n\nexport type PaymentRequestPayload = {\n\tid?: string;\n\tmemo?: string;\n\tunit: string;\n\tmint: string;\n\tproofs: Proof[];\n};\n\n/**\n * Used to express a spending condition that proofs should be encumbered with.\n */\nexport type NUT10Option = {\n\t/**\n\t * The kind of spending condition.\n\t */\n\tkind: string;\n\t/**\n\t * Expresses the spending condition relative to the kind.\n\t */\n\tdata: string;\n\t/**\n\t * Tags associated with the spending condition for additional data.\n\t */\n\ttags: string[][];\n};\n","import { bech32 } from '@scure/base';\nimport type { PaymentRequestTransport } from '../wallet/types/payment-requests';\nimport { PaymentRequestTransportType } from '../wallet/types/payment-requests';\n\n/**\n * NUT-10 Spending Condition structure.\n */\nexport type Nut10SpendingCondition = {\n\tkind: string;\n\tdata: string;\n\ttags?: string[][];\n};\n\n/**\n * Decoded TLV Payment Request structure.\n */\nexport type DecodedTLVPaymentRequest = {\n\tid?: string;\n\tamount?: bigint;\n\tunit?: string;\n\tsingleUse?: boolean;\n\tmints?: string[];\n\tdescription?: string;\n\ttransports?: PaymentRequestTransport[];\n\tnut10?: Nut10SpendingCondition[];\n};\n\n/**\n * TLV Tag definitions for Payment Request (NUT-18 version B).\n *\n * | Tag  | Field       | Type      | Description                                      |\n * | ---- | ----------- | --------- | ------------------------------------------------ |\n * | 0x01 | id          | string    | Payment identifier                               |\n * | 0x02 | amount      | u64       | Amount in base units                             |\n * | 0x03 | unit        | u8/string | Currency unit (0x00 = 'sat')                     |\n * | 0x04 | single_use  | u8        | Single-use flag: 0=false, 1=true                 |\n * | 0x05 | mint        | string    | Mint URL (repeatable)                            |\n * | 0x06 | description | string    | Human-readable description                       |\n * | 0x07 | transport   | sub-TLV   | Transport configuration (repeatable)             |\n * | 0x08 | nut10       | sub-TLV   | NUT-10 spending conditions (not yet implemented) |\n */\nconst TAG_ID = 0x01;\nconst TAG_AMOUNT = 0x02;\nconst TAG_UNIT = 0x03;\nconst TAG_SINGLE_USE = 0x04;\nconst TAG_MINT = 0x05;\nconst TAG_DESCRIPTION = 0x06;\nconst TAG_TRANSPORT = 0x07;\nconst TAG_NUT10 = 0x08;\n\n/**\n * Transport Sub-TLV Tag definitions.\n *\n * | Sub-Tag | Field     | Type    | Description                                       |\n * | ------- | --------- | ------- | ------------------------------------------------- |\n * | 0x01    | kind      | u8      | Transport type: 0=nostr, 1=http_post              |\n * | 0x02    | target    | bytes   | Transport target (pubkey for nostr, URL for post) |\n * | 0x03    | tag_tuple | sub-TLV | Generic tag tuple (repeatable)                    |\n */\nconst TRANSPORT_TAG_KIND = 0x01;\nconst TRANSPORT_TAG_TARGET = 0x02;\nconst TRANSPORT_TAG_TAG_TUPLE = 0x03;\n\nconst TRANSPORT_KIND_NOSTR = 0;\nconst TRANSPORT_KIND_HTTP_POST = 1;\n\n/**\n * NUT-10 Sub-TLV Tag definitions.\n *\n * | Sub-Tag | Field     | Type        | Description                        |\n * | ------- | --------- | ----------- | ---------------------------------- |\n * | 0x01    | kind      | u8          | Secret kind (0=P2PK, 1=HTLC, etc.) |\n * | 0x02    | data      | bytes       | Kind-specific data (UTF-8 encoded) |\n * | 0x03    | tag_tuple | sub-sub-TLV | Tag tuple (repeatable)             |\n */\nconst NUT10_TAG_KIND = 0x01;\nconst NUT10_TAG_DATA = 0x02;\nconst NUT10_TAG_TAG_TUPLE = 0x03;\n\nconst NUT10_KIND_P2PK = 0;\nconst NUT10_KIND_HTLC = 1;\n\ntype TLVPart = {\n\ttag: number;\n\tlength: number;\n\tvalue: Uint8Array;\n};\n\n/**\n * Decodes a TLV-encoded Payment Request.\n *\n * @param data - The TLV-encoded data as Uint8Array.\n * @returns Decoded payment request object.\n */\nexport function decodeTLV(data: Uint8Array): DecodedTLVPaymentRequest {\n\tconst parts = decodeAllParts(data);\n\tconst result: DecodedTLVPaymentRequest = {};\n\n\tfor (const part of parts) {\n\t\tswitch (part.tag) {\n\t\t\tcase TAG_ID:\n\t\t\t\tresult.id = parseString(part.value);\n\t\t\t\tbreak;\n\t\t\tcase TAG_AMOUNT:\n\t\t\t\tresult.amount = parseU64(part.value);\n\t\t\t\tbreak;\n\t\t\tcase TAG_UNIT:\n\t\t\t\tif (part.value.length === 1 && part.value[0] === 0) {\n\t\t\t\t\tresult.unit = 'sat';\n\t\t\t\t} else {\n\t\t\t\t\tresult.unit = parseString(part.value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TAG_SINGLE_USE:\n\t\t\t\tresult.singleUse = parseU8(part.value) === 1;\n\t\t\t\tbreak;\n\t\t\tcase TAG_MINT:\n\t\t\t\tif (!result.mints) {\n\t\t\t\t\tresult.mints = [];\n\t\t\t\t}\n\t\t\t\tresult.mints.push(parseString(part.value));\n\t\t\t\tbreak;\n\t\t\tcase TAG_DESCRIPTION:\n\t\t\t\tresult.description = parseString(part.value);\n\t\t\t\tbreak;\n\t\t\tcase TAG_TRANSPORT:\n\t\t\t\tif (!result.transports) {\n\t\t\t\t\tresult.transports = [];\n\t\t\t\t}\n\t\t\t\tresult.transports.push(parseTransport(part.value));\n\t\t\t\tbreak;\n\t\t\tcase TAG_NUT10:\n\t\t\t\tif (!result.nut10) {\n\t\t\t\t\tresult.nut10 = [];\n\t\t\t\t}\n\t\t\t\tresult.nut10.push(parseNut10(part.value));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Ignore unknown tags for forward compatibility\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Decodes all TLV parts from the data.\n */\nfunction decodeAllParts(data: Uint8Array): TLVPart[] {\n\tconst parts: TLVPart[] = [];\n\tlet offset = 0;\n\n\twhile (offset < data.length) {\n\t\tconst part = decodeNextPart(data.subarray(offset));\n\t\tparts.push(part);\n\t\t// Tag (1 byte) + Length (2 bytes) + Value\n\t\toffset += 1 + 2 + part.length;\n\t}\n\n\treturn parts;\n}\n\n/**\n * Decodes the next TLV part from the data.\n *\n * Wire format:\n *\n * - Tag: 1 byte (uint8)\n * - Length: 2 bytes (uint16, big-endian)\n * - Value: `length` bytes.\n */\nfunction decodeNextPart(data: Uint8Array): TLVPart {\n\tif (data.length < 3) {\n\t\tthrow new Error('TLV data too short: need at least 3 bytes for tag and length');\n\t}\n\n\tconst dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\tconst tag = dataView.getUint8(0);\n\tconst length = dataView.getUint16(1, false); // big-endian\n\n\tif (data.length < 3 + length) {\n\t\tthrow new Error(`TLV data too short: expected ${3 + length} bytes, got ${data.length}`);\n\t}\n\n\tconst value = data.subarray(3, 3 + length);\n\treturn { tag, length, value };\n}\n\nfunction parseString(value: Uint8Array): string {\n\treturn new TextDecoder().decode(value);\n}\n\nfunction parseU64(value: Uint8Array): bigint {\n\tif (value.length !== 8) {\n\t\tthrow new Error(`Invalid u64: expected 8 bytes, got ${value.length}`);\n\t}\n\treturn new DataView(value.buffer, value.byteOffset, value.byteLength).getBigUint64(0, false);\n}\n\nfunction parseU8(value: Uint8Array): number {\n\tif (value.length !== 1) {\n\t\tthrow new Error(`Invalid u8: expected 1 byte, got ${value.length}`);\n\t}\n\treturn value[0];\n}\n\nfunction transportKindToType(kind: number): PaymentRequestTransportType {\n\tswitch (kind) {\n\t\tcase TRANSPORT_KIND_NOSTR:\n\t\t\treturn 'nostr' as PaymentRequestTransportType;\n\t\tcase TRANSPORT_KIND_HTTP_POST:\n\t\t\treturn 'post' as PaymentRequestTransportType;\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported transport kind: ${kind}`);\n\t}\n}\n\nfunction nut10KindToType(kind: number): string {\n\tswitch (kind) {\n\t\tcase NUT10_KIND_P2PK:\n\t\t\treturn 'P2PK';\n\t\tcase NUT10_KIND_HTLC:\n\t\t\treturn 'HTLC';\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported NUT-10 kind: ${kind}`);\n\t}\n}\n\nfunction parseTransport(value: Uint8Array): PaymentRequestTransport {\n\tconst parts = decodeAllParts(value);\n\n\tlet kind: number | undefined;\n\tlet targetBytes: Uint8Array | undefined;\n\tlet tags: string[][] | undefined;\n\n\tfor (const part of parts) {\n\t\tswitch (part.tag) {\n\t\t\tcase TRANSPORT_TAG_KIND:\n\t\t\t\tkind = parseU8(part.value);\n\t\t\t\tbreak;\n\t\t\tcase TRANSPORT_TAG_TARGET:\n\t\t\t\ttargetBytes = part.value;\n\t\t\t\tbreak;\n\t\t\tcase TRANSPORT_TAG_TAG_TUPLE:\n\t\t\t\tif (!tags) {\n\t\t\t\t\ttags = [];\n\t\t\t\t}\n\t\t\t\ttags.push(parseTagTuple(part.value));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (kind === undefined) {\n\t\tthrow new Error('Transport missing required kind field');\n\t}\n\tif (targetBytes === undefined) {\n\t\tthrow new Error('Transport missing required target field');\n\t}\n\n\t// Parse target based on kind\n\tlet target: string;\n\tif (kind === TRANSPORT_KIND_NOSTR) {\n\t\t// For nostr, encode as nprofile with pubkey and relay URLs from tag tuples (key \"r\")\n\t\tconst relayUrls =\n\t\t\ttags?.filter((tuple) => tuple[0] === 'r').flatMap((tuple) => tuple.slice(1)) ?? [];\n\t\ttarget = encodeNprofile(targetBytes, relayUrls);\n\t\t// Remove relay tags since they're now embedded in the nprofile\n\t\ttags = tags?.filter((tuple) => tuple[0] !== 'r');\n\t} else {\n\t\ttarget = parseString(targetBytes);\n\t}\n\n\t// Return undefined for tags if empty\n\tconst finalTags = tags && tags.length > 0 ? tags : undefined;\n\n\treturn {\n\t\ttype: transportKindToType(kind),\n\t\ttarget,\n\t\ttags: finalTags,\n\t};\n}\n\n/**\n * Parses a NUT-10 spending condition from its TLV value.\n *\n * @param value - The NUT-10 sub-TLV value bytes.\n * @returns Parsed NUT-10 spending condition.\n */\nfunction parseNut10(value: Uint8Array): Nut10SpendingCondition {\n\tconst parts = decodeAllParts(value);\n\n\tlet kindNum: number | undefined;\n\tlet data: string | undefined;\n\tlet tags: string[][] | undefined;\n\n\tfor (const part of parts) {\n\t\tswitch (part.tag) {\n\t\t\tcase NUT10_TAG_KIND:\n\t\t\t\tkindNum = parseU8(part.value);\n\t\t\t\tbreak;\n\t\t\tcase NUT10_TAG_DATA:\n\t\t\t\tdata = parseString(part.value);\n\t\t\t\tbreak;\n\t\t\tcase NUT10_TAG_TAG_TUPLE:\n\t\t\t\tif (!tags) {\n\t\t\t\t\ttags = [];\n\t\t\t\t}\n\t\t\t\ttags.push(parseTagTuple(part.value));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (kindNum === undefined) {\n\t\tthrow new Error('NUT-10 spending condition missing required kind field');\n\t}\n\tif (data === undefined) {\n\t\tthrow new Error('NUT-10 spending condition missing required data field');\n\t}\n\n\t// Return undefined for tags if empty\n\tconst finalTags = tags && tags.length > 0 ? tags : undefined;\n\n\treturn {\n\t\tkind: nut10KindToType(kindNum),\n\t\tdata,\n\t\ttags: finalTags,\n\t};\n}\n\n/**\n * Parses a tag tuple from its TLV value.\n *\n * Tag tuple encoding:\n *\n * 1. Key length (1 byte)\n * 2. Key string (UTF-8)\n * 3. For each value:\n *\n *    - Value length (1 byte)\n *    - Value string (UTF-8)\n *\n * @param value - The tag tuple value bytes.\n * @returns Array of strings representing the tuple [key, value1, value2, ...].\n */\nfunction parseTagTuple(value: Uint8Array): string[] {\n\tconst tuple: string[] = [];\n\tlet offset = 0;\n\n\twhile (offset < value.length) {\n\t\tconst length = value[offset];\n\t\toffset += 1;\n\n\t\tif (value.length - offset < length) {\n\t\t\tthrow new Error(\n\t\t\t\t`Tag tuple data too short: expected ${length} bytes, got ${value.length - offset}`,\n\t\t\t);\n\t\t}\n\n\t\tconst str = parseString(value.subarray(offset, offset + length));\n\t\ttuple.push(str);\n\t\toffset += length;\n\t}\n\n\treturn tuple;\n}\n\n/**\n * Encodes a Payment Request into TLV format.\n *\n * @param request - The payment request object to encode.\n * @returns TLV-encoded data as Uint8Array.\n */\nexport function encodeTLV(request: DecodedTLVPaymentRequest): Uint8Array {\n\tconst parts: Uint8Array[] = [];\n\n\t// Encode fields in sequential tag order\n\tif (request.id) {\n\t\tparts.push(encodeTLVPart(TAG_ID, encodeString(request.id)));\n\t}\n\n\tif (request.amount !== undefined) {\n\t\tparts.push(encodeTLVPart(TAG_AMOUNT, encodeU64(request.amount)));\n\t}\n\n\tif (request.unit) {\n\t\tif (request.unit === 'sat') {\n\t\t\tparts.push(encodeTLVPart(TAG_UNIT, new Uint8Array([0x00])));\n\t\t} else {\n\t\t\tparts.push(encodeTLVPart(TAG_UNIT, encodeString(request.unit)));\n\t\t}\n\t}\n\n\tif (request.singleUse !== undefined) {\n\t\tparts.push(encodeTLVPart(TAG_SINGLE_USE, encodeU8(request.singleUse ? 1 : 0)));\n\t}\n\n\t// Repeatable: mint\n\tif (request.mints && request.mints.length > 0) {\n\t\tfor (const mint of request.mints) {\n\t\t\tparts.push(encodeTLVPart(TAG_MINT, encodeString(mint)));\n\t\t}\n\t}\n\n\tif (request.description) {\n\t\tparts.push(encodeTLVPart(TAG_DESCRIPTION, encodeString(request.description)));\n\t}\n\n\t// Repeatable: transport\n\tif (request.transports && request.transports.length > 0) {\n\t\tfor (const transport of request.transports) {\n\t\t\tparts.push(encodeTLVPart(TAG_TRANSPORT, encodeTransport(transport)));\n\t\t}\n\t}\n\n\t// Repeatable: nut10\n\tif (request.nut10 && request.nut10.length > 0) {\n\t\tfor (const nut10 of request.nut10) {\n\t\t\tparts.push(encodeTLVPart(TAG_NUT10, encodeNut10(nut10)));\n\t\t}\n\t}\n\n\t// Concatenate all parts\n\tconst totalLength = parts.reduce((sum, part) => sum + part.length, 0);\n\tconst result = new Uint8Array(totalLength);\n\tlet offset = 0;\n\tfor (const part of parts) {\n\t\tresult.set(part, offset);\n\t\toffset += part.length;\n\t}\n\n\treturn result;\n}\n\n/**\n * Encodes a single TLV part.\n *\n * @param tag - The tag byte.\n * @param value - The value bytes.\n * @returns Encoded TLV part (tag + length + value).\n */\nfunction encodeTLVPart(tag: number, value: Uint8Array): Uint8Array {\n\tconst length = value.length;\n\tif (length > 0xffff) {\n\t\tthrow new Error(`TLV value too long: ${length} bytes (max 65535)`);\n\t}\n\n\tconst result = new Uint8Array(3 + length);\n\tresult[0] = tag;\n\t// Write length as big-endian uint16\n\tresult[1] = (length >> 8) & 0xff;\n\tresult[2] = length & 0xff;\n\tresult.set(value, 3);\n\n\treturn result;\n}\n\nfunction encodeString(str: string): Uint8Array {\n\treturn new TextEncoder().encode(str);\n}\n\nfunction encodeU64(value: bigint): Uint8Array {\n\tconst buffer = new ArrayBuffer(8);\n\tconst view = new DataView(buffer);\n\tview.setBigUint64(0, value, false); // big-endian\n\treturn new Uint8Array(buffer);\n}\n\nfunction encodeU8(value: number): Uint8Array {\n\treturn new Uint8Array([value]);\n}\n\nfunction transportTypeToKind(type: PaymentRequestTransportType): number {\n\tswitch (type) {\n\t\tcase PaymentRequestTransportType.NOSTR:\n\t\t\treturn TRANSPORT_KIND_NOSTR;\n\t\tcase PaymentRequestTransportType.POST:\n\t\t\treturn TRANSPORT_KIND_HTTP_POST;\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported transport type: ${type as string}`);\n\t}\n}\n\nfunction nut10TypeToKind(type: string): number {\n\tswitch (type) {\n\t\tcase 'P2PK':\n\t\t\treturn NUT10_KIND_P2PK;\n\t\tcase 'HTLC':\n\t\t\treturn NUT10_KIND_HTLC;\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported NUT-10 type: ${type}`);\n\t}\n}\n\n/**\n * Encodes a transport into its TLV sub-structure.\n *\n * @param transport - The transport to encode.\n * @returns Encoded transport sub-TLV.\n */\nfunction encodeTransport(transport: PaymentRequestTransport): Uint8Array {\n\tconst parts: Uint8Array[] = [];\n\tconst kind = transportTypeToKind(transport.type);\n\n\t// Encode kind\n\tparts.push(encodeTLVPart(TRANSPORT_TAG_KIND, encodeU8(kind)));\n\n\t// Handle target based on transport type\n\tlet targetBytes: Uint8Array;\n\tlet relayTags: string[][] = [];\n\n\tif (transport.type === PaymentRequestTransportType.NOSTR) {\n\t\t// Decode nprofile to extract pubkey and relays\n\t\tconst { pubkey, relays } = decodeNprofile(transport.target);\n\t\ttargetBytes = pubkey;\n\t\t// Create relay tags\n\t\trelayTags = relays.map((relay) => ['r', relay]);\n\t} else {\n\t\ttargetBytes = encodeString(transport.target);\n\t}\n\n\t// Encode target\n\tparts.push(encodeTLVPart(TRANSPORT_TAG_TARGET, targetBytes));\n\n\t// Merge relay tags with existing tags (for nostr) and encode\n\tconst allTags = [...relayTags, ...(transport.tags || [])];\n\tif (allTags.length > 0) {\n\t\tfor (const tag of allTags) {\n\t\t\tparts.push(encodeTLVPart(TRANSPORT_TAG_TAG_TUPLE, encodeTagTuple(tag)));\n\t\t}\n\t}\n\n\t// Concatenate all sub-parts\n\tconst totalLength = parts.reduce((sum, part) => sum + part.length, 0);\n\tconst result = new Uint8Array(totalLength);\n\tlet offset = 0;\n\tfor (const part of parts) {\n\t\tresult.set(part, offset);\n\t\toffset += part.length;\n\t}\n\n\treturn result;\n}\n\n/**\n * Encodes a NUT-10 spending condition into its TLV sub-structure.\n *\n * @param nut10 - The NUT-10 spending condition to encode.\n * @returns Encoded NUT-10 sub-TLV.\n */\nfunction encodeNut10(nut10: Nut10SpendingCondition): Uint8Array {\n\tconst parts: Uint8Array[] = [];\n\tconst kind = nut10TypeToKind(nut10.kind);\n\n\t// Encode kind\n\tparts.push(encodeTLVPart(NUT10_TAG_KIND, encodeU8(kind)));\n\n\t// Encode data\n\tparts.push(encodeTLVPart(NUT10_TAG_DATA, encodeString(nut10.data)));\n\n\t// Encode tags if present\n\tif (nut10.tags && nut10.tags.length > 0) {\n\t\tfor (const tag of nut10.tags) {\n\t\t\tparts.push(encodeTLVPart(NUT10_TAG_TAG_TUPLE, encodeTagTuple(tag)));\n\t\t}\n\t}\n\n\t// Concatenate all sub-parts\n\tconst totalLength = parts.reduce((sum, part) => sum + part.length, 0);\n\tconst result = new Uint8Array(totalLength);\n\tlet offset = 0;\n\tfor (const part of parts) {\n\t\tresult.set(part, offset);\n\t\toffset += part.length;\n\t}\n\n\treturn result;\n}\n\n/**\n * Encodes a tag tuple into its TLV value format.\n *\n * @param tuple - Array of strings [key, value1, value2, ...].\n * @returns Encoded tag tuple.\n */\nfunction encodeTagTuple(tuple: string[]): Uint8Array {\n\tconst encoder = new TextEncoder();\n\tconst parts: Uint8Array[] = [];\n\n\tfor (const str of tuple) {\n\t\tconst encoded = encoder.encode(str);\n\t\tif (encoded.length > 255) {\n\t\t\tthrow new Error(`Tag tuple string too long: ${str} (max 255 bytes)`);\n\t\t}\n\t\t// 1-byte length prefix + string bytes\n\t\tconst part = new Uint8Array(1 + encoded.length);\n\t\tpart[0] = encoded.length;\n\t\tpart.set(encoded, 1);\n\t\tparts.push(part);\n\t}\n\n\t// Concatenate all parts\n\tconst totalLength = parts.reduce((sum, part) => sum + part.length, 0);\n\tconst result = new Uint8Array(totalLength);\n\tlet offset = 0;\n\tfor (const part of parts) {\n\t\tresult.set(part, offset);\n\t\toffset += part.length;\n\t}\n\n\treturn result;\n}\n\n/**\n * Decodes an nprofile string to extract the pubkey and relay URLs.\n *\n * @param nprofile - Bech32m encoded nprofile string.\n * @returns Object containing pubkey (32 bytes) and array of relay URLs.\n */\nexport function decodeNprofile(nprofile: string): { pubkey: Uint8Array; relays: string[] } {\n\t// Decode bech32m\n\tconst decoded = bech32.decode(nprofile as `${string}1${string}`, 1024);\n\tif (decoded.prefix !== 'nprofile') {\n\t\tthrow new Error(`Invalid nprofile: expected prefix 'nprofile', got '${decoded.prefix}'`);\n\t}\n\n\tconst tlvData = bech32.fromWords(decoded.words);\n\tconst data = new Uint8Array(tlvData);\n\n\t// Parse TLV structure (1-byte T, 1-byte L format)\n\tlet pubkey: Uint8Array | undefined;\n\tconst relays: string[] = [];\n\tlet offset = 0;\n\n\twhile (offset < data.length) {\n\t\tif (offset + 2 > data.length) {\n\t\t\tthrow new Error('Nprofile TLV data too short');\n\t\t}\n\n\t\tconst tag = data[offset];\n\t\tconst length = data[offset + 1];\n\t\toffset += 2;\n\n\t\tif (offset + length > data.length) {\n\t\t\tthrow new Error(`Nprofile TLV value too short: expected ${length} bytes`);\n\t\t}\n\n\t\tconst value = data.subarray(offset, offset + length);\n\t\toffset += length;\n\n\t\tif (tag === 0x00) {\n\t\t\t// Pubkey\n\t\t\tif (value.length !== 32) {\n\t\t\t\tthrow new Error(`Invalid pubkey length: expected 32 bytes, got ${value.length}`);\n\t\t\t}\n\t\t\tpubkey = value;\n\t\t} else if (tag === 0x01) {\n\t\t\t// Relay URL\n\t\t\trelays.push(new TextDecoder().decode(value));\n\t\t}\n\t\t// Ignore unknown tags\n\t}\n\n\tif (!pubkey) {\n\t\tthrow new Error('Nprofile missing required pubkey');\n\t}\n\n\treturn { pubkey, relays };\n}\n\n/**\n * Encodes a 32-byte public key and a list of relay URLs into a bech32m encoded string.\n *\n * @param pubkey - 32-byte public key as Uint8Array.\n * @param relays - Array of relay URLs.\n * @returns Bech32m encoded string.\n */\nexport function encodeNprofile(pubkey: Uint8Array, relays: string[]): string {\n\tconst tlv = encodePubkeyRelaysTLV(pubkey, relays);\n\tconst words = bech32.toWords(tlv);\n\treturn bech32.encode('nprofile', words, 1024);\n}\n\n/**\n * Encodes a 32-byte public key and a list of relay URLs into a TLV structure.\n *\n * Wire format (1-byte T, 1-byte L):\n *\n * - T=0x00: 32-byte public key.\n * - T=0x01: relay URL (repeatable)\n *\n * @param pubkey - 32-byte public key as Uint8Array.\n * @param relays - Array of relay URLs.\n * @returns TLV-encoded Uint8Array.\n */\nfunction encodePubkeyRelaysTLV(pubkey: Uint8Array, relays: string[]): Uint8Array {\n\tif (pubkey.length !== 32) {\n\t\tthrow new Error(`Invalid pubkey: expected 32 bytes, got ${pubkey.length}`);\n\t}\n\n\tconst encoder = new TextEncoder();\n\tconst encodedRelays = relays.map((relay) => encoder.encode(relay));\n\n\t// Validate relay lengths fit in 1 byte\n\tfor (let i = 0; i < encodedRelays.length; i++) {\n\t\tif (encodedRelays[i].length > 255) {\n\t\t\tthrow new Error(`Relay URL too long: ${relays[i]} (max 255 bytes)`);\n\t\t}\n\t}\n\n\t// Calculate total size: pubkey (1 + 1 + 32) + relays (1 + 1 + len each)\n\tconst totalSize = 2 + 32 + encodedRelays.reduce((sum, r) => sum + 2 + r.length, 0);\n\tconst result = new Uint8Array(totalSize);\n\n\tlet offset = 0;\n\n\t// Write pubkey: T=0x00, L=32, V=<32 bytes>\n\tresult[offset++] = 0x00;\n\tresult[offset++] = 32;\n\tresult.set(pubkey, offset);\n\toffset += 32;\n\n\t// Write each relay: T=0x01, L=<len>, V=<UTF-8 string>\n\tfor (const relay of encodedRelays) {\n\t\tresult[offset++] = 0x01;\n\t\tresult[offset++] = relay.length;\n\t\tresult.set(relay, offset);\n\t\toffset += relay.length;\n\t}\n\n\treturn result;\n}\n","import { encodeBase64toUint8, decodeCBOR, encodeCBOR, Bytes } from '../utils';\nimport { decodeBech32mToBytes, encodeBech32m } from '../utils/bech32m';\nimport { decodeTLV, encodeTLV } from '../utils/tlv';\nimport type { DecodedTLVPaymentRequest, Nut10SpendingCondition } from '../utils/tlv';\nimport type {\n\tRawPaymentRequest,\n\tRawTransport,\n\tNUT10Option,\n\tPaymentRequestTransport,\n\tPaymentRequestTransportType,\n} from '../wallet/types';\n\nexport class PaymentRequest {\n\tconstructor(\n\t\tpublic transport?: PaymentRequestTransport[],\n\t\tpublic id?: string,\n\t\tpublic amount?: number,\n\t\tpublic unit?: string,\n\t\tpublic mints?: string[],\n\t\tpublic description?: string,\n\t\tpublic singleUse: boolean = false,\n\t\tpublic nut10?: NUT10Option,\n\t\tpublic nut26: boolean = false,\n\t) {}\n\n\ttoRawRequest() {\n\t\tconst rawRequest: RawPaymentRequest = {};\n\t\tif (this.transport) {\n\t\t\trawRequest.t = this.transport.map((t: PaymentRequestTransport) => ({\n\t\t\t\tt: t.type,\n\t\t\t\ta: t.target,\n\t\t\t\tg: t.tags,\n\t\t\t}));\n\t\t}\n\t\tif (this.id) {\n\t\t\trawRequest.i = this.id;\n\t\t}\n\t\tif (this.amount) {\n\t\t\trawRequest.a = this.amount;\n\t\t}\n\t\tif (this.unit) {\n\t\t\trawRequest.u = this.unit;\n\t\t}\n\t\tif (this.mints) {\n\t\t\trawRequest.m = this.mints;\n\t\t}\n\t\tif (this.description) {\n\t\t\trawRequest.d = this.description;\n\t\t}\n\t\tif (this.singleUse) {\n\t\t\trawRequest.s = this.singleUse;\n\t\t}\n\t\tif (this.nut10) {\n\t\t\trawRequest.nut10 = {\n\t\t\t\tk: this.nut10.kind,\n\t\t\t\td: this.nut10.data,\n\t\t\t\tt: this.nut10.tags,\n\t\t\t};\n\t\t}\n\t\tif (this.nut26) {\n\t\t\trawRequest.nut26 = this.nut26;\n\t\t}\n\t\treturn rawRequest;\n\t}\n\n\ttoEncodedRequest(): string {\n\t\tconst rawRequest: RawPaymentRequest = this.toRawRequest();\n\t\tconst data = encodeCBOR(rawRequest);\n\t\tconst encodedData = Bytes.toBase64(data);\n\t\treturn 'creq' + 'A' + encodedData;\n\t}\n\n\t/**\n\t * Encodes the payment request to creqA format (CBOR).\n\t *\n\t * @returns A base64 encoded payment request string with 'creqA' prefix.\n\t */\n\ttoEncodedCreqA(): string {\n\t\treturn this.toEncodedRequest();\n\t}\n\n\t/**\n\t * Encodes the payment request to creqB format (TLV + bech32m).\n\t *\n\t * @returns A bech32m encoded payment request string with 'CREQB' prefix.\n\t * @experimental\n\t */\n\ttoEncodedCreqB(): string {\n\t\tconst tlvRequest: DecodedTLVPaymentRequest = {\n\t\t\tid: this.id,\n\t\t\tamount: this.amount !== undefined ? BigInt(this.amount) : undefined,\n\t\t\tunit: this.unit,\n\t\t\tsingleUse: this.singleUse,\n\t\t\tmints: this.mints,\n\t\t\tdescription: this.description,\n\t\t\ttransports: this.transport,\n\t\t\tnut10: this.nut10\n\t\t\t\t? [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkind: this.nut10.kind,\n\t\t\t\t\t\t\tdata: this.nut10.data,\n\t\t\t\t\t\t\ttags: this.nut10.tags,\n\t\t\t\t\t\t} as Nut10SpendingCondition,\n\t\t\t\t\t]\n\t\t\t\t: undefined,\n\t\t};\n\n\t\tconst tlvBytes = encodeTLV(tlvRequest);\n\t\treturn encodeBech32m('creqb', tlvBytes).toUpperCase();\n\t}\n\n\tgetTransport(type: PaymentRequestTransportType) {\n\t\treturn this.transport?.find((t: PaymentRequestTransport) => t.type === type);\n\t}\n\n\t/**\n\t * Creates a PaymentRequest from a raw payment request. Supports both creqA and creqB versions.\n\t *\n\t * @param rawPaymentRequest - The raw payment request string to create a PaymentRequest from.\n\t * @returns A PaymentRequest object.\n\t * @throws An error if the raw payment request is not supported.\n\t */\n\tstatic fromRawRequest(rawPaymentRequest: RawPaymentRequest): PaymentRequest {\n\t\tconst transports = rawPaymentRequest.t\n\t\t\t? rawPaymentRequest.t.map((t: RawTransport) => ({\n\t\t\t\t\ttype: t.t,\n\t\t\t\t\ttarget: t.a,\n\t\t\t\t\ttags: t.g,\n\t\t\t\t}))\n\t\t\t: undefined;\n\t\tconst nut10 = rawPaymentRequest.nut10\n\t\t\t? {\n\t\t\t\t\tkind: rawPaymentRequest.nut10.k,\n\t\t\t\t\tdata: rawPaymentRequest.nut10.d,\n\t\t\t\t\ttags: rawPaymentRequest.nut10.t,\n\t\t\t\t}\n\t\t\t: undefined;\n\t\treturn new PaymentRequest(\n\t\t\ttransports,\n\t\t\trawPaymentRequest.i,\n\t\t\trawPaymentRequest.a,\n\t\t\trawPaymentRequest.u,\n\t\t\trawPaymentRequest.m,\n\t\t\trawPaymentRequest.d,\n\t\t\trawPaymentRequest.s,\n\t\t\tnut10,\n\t\t\trawPaymentRequest.nut26,\n\t\t);\n\t}\n\n\tstatic fromEncodedRequest(encodedRequest: string): PaymentRequest {\n\t\tconst lowerRequest = encodedRequest.toLowerCase();\n\n\t\t// Version B: bech32m + TLV encoding (creqb...)\n\t\tif (lowerRequest.startsWith('creqb')) {\n\t\t\tconst data = decodeBech32mToBytes(lowerRequest);\n\t\t\tconst decoded = decodeTLV(data);\n\t\t\treturn new PaymentRequest(\n\t\t\t\tdecoded.transports,\n\t\t\t\tdecoded.id,\n\t\t\t\tdecoded.amount !== undefined ? Number(decoded.amount) : undefined,\n\t\t\t\tdecoded.unit,\n\t\t\t\tdecoded.mints,\n\t\t\t\tdecoded.description,\n\t\t\t\tdecoded.singleUse ?? false,\n\t\t\t\tundefined,\n\t\t\t\tfalse,\n\t\t\t);\n\t\t}\n\n\t\t// Version A: CBOR encoding (creqA...)\n\t\tif (!encodedRequest.startsWith('creq')) {\n\t\t\tthrow new Error('unsupported pr: invalid prefix');\n\t\t}\n\t\tconst version = encodedRequest[4];\n\t\tif (version !== 'A') {\n\t\t\tthrow new Error('unsupported pr version');\n\t\t}\n\t\tconst encodedData = encodedRequest.slice(5);\n\t\tconst data = encodeBase64toUint8(encodedData);\n\t\tconst decoded = decodeCBOR(data) as RawPaymentRequest;\n\t\treturn this.fromRawRequest(decoded);\n\t}\n}\n","import { type DLEQ, pointFromHex, verifyDLEQProof_reblind } from '../crypto';\nimport { bytesToHex, hexToBytes } from '@noble/curves/utils.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport {\n\tencodeBase64ToJson,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeUint8toBase64Url,\n\tisBase64String,\n} from './base64';\nimport { decodeCBOR, encodeCBOR } from './cbor';\nimport { PaymentRequest } from '../model/PaymentRequest';\nimport type {\n\tTokenMetadata,\n\tDeprecatedToken,\n\tKeys,\n\tMintKeys,\n\tProof,\n\tSerializedDLEQ,\n\tToken,\n\tTokenV4Template,\n\tV4DLEQTemplate,\n\tV4InnerToken,\n\tV4ProofTemplate,\n\tHasKeysetKeys,\n\tHasKeysetId,\n} from '../model/types';\nimport { Bytes } from './Bytes';\n\n/**\n * Splits the amount into denominations of the provided keyset.\n *\n * @remarks\n * Partial splits will be filled up to value using minimum splits required. Sorting is only applied\n * if a fill was made - exact custom splits are always returned in the same order.\n * @param value Amount to split.\n * @param keyset Keys to look up split amounts.\n * @param split? Optional custom split amounts.\n * @param order? Optional order for split amounts (if fill was required)\n * @returns Array of split amounts.\n * @throws Error if split sum is greater than value or mint does not have keys for requested split.\n */\nexport function splitAmount(\n\tvalue: number,\n\tkeyset: Keys,\n\tsplit?: number[],\n\torder?: 'desc' | 'asc',\n): number[] {\n\tif (split) {\n\t\tconst totalSplitAmount = sumArray(split);\n\n\t\t// Special case: explicit \"zero-total\" outputs (restore or NUT-08 blanks)\n\t\tif (value === 0 && totalSplitAmount === 0) {\n\t\t\treturn split;\n\t\t}\n\n\t\t// Normal positive-value paths: ignore zeros for validation and totals\n\t\tconst positive = split.filter((amt) => amt > 0);\n\t\tconst totalPositive = sumArray(positive);\n\t\tif (totalPositive > value) {\n\t\t\tthrow new Error(`Split is greater than total amount: ${totalPositive} > ${value}`);\n\t\t}\n\t\tif (positive.some((amt) => !hasCorrespondingKey(amt, keyset))) {\n\t\t\tthrow new Error('Provided amount preferences do not match the amounts of the mint keyset.');\n\t\t}\n\n\t\t// if caller supplied an exact custom split, preserve their order\n\t\tif (totalPositive === value) {\n\t\t\treturn positive;\n\t\t}\n\n\t\t// Work only with validated positive amounts from here on\n\t\tsplit = positive;\n\t\tvalue -= totalPositive;\n\t} else {\n\t\tsplit = [];\n\t}\n\n\t// Denomination fill for the remaining value\n\tconst sortedKeyAmounts = getKeysetAmounts(keyset, 'desc');\n\tif (!sortedKeyAmounts || sortedKeyAmounts.length === 0) {\n\t\tthrow new Error('Cannot split amount, keyset is inactive or contains no keys');\n\t}\n\tfor (const amt of sortedKeyAmounts) {\n\t\tif (amt <= 0) continue;\n\t\t// Calculate how many of amt fit into remaining value\n\t\tconst requireCount = Math.floor(value / amt);\n\t\t// Add them to the split and reduce the target value by added amounts\n\t\tsplit.push(...Array<number>(requireCount).fill(amt));\n\t\tvalue -= amt * requireCount;\n\t\t// Break early once target is satisfied\n\t\tif (value === 0) break;\n\t}\n\tif (value !== 0) {\n\t\tthrow new Error(`Unable to split remaining amount: ${value}`);\n\t}\n\n\t// Only sort when we performed a fill and it was requested\n\t// Exact custom splits were returned unsorted earlier\n\tif (order) {\n\t\treturn split.sort((a, b) => (order === 'desc' ? b - a : a - b));\n\t}\n\treturn split;\n}\n\n/**\n * Creates a list of amounts to keep based on the proofs we have and the proofs we want to reach.\n *\n * @param proofsWeHave Complete set of proofs stored (from current mint)\n * @param amountToKeep Amount to keep.\n * @param keys Keys of current keyset.\n * @param targetCount The target number of proofs to reach.\n * @returns An array of amounts to keep.\n */\nexport function getKeepAmounts(\n\tproofsWeHave: Proof[],\n\tamountToKeep: number,\n\tkeys: Keys,\n\ttargetCount: number,\n): number[] {\n\t// determines amounts we need to reach the targetCount for each amount based on the amounts of the proofs we have\n\t// it tries to select amounts so that the proofs we have and the proofs we want reach the targetCount\n\tconst amountsWeWant: number[] = [];\n\tconst amountsWeHave = proofsWeHave.map((p: Proof) => p.amount);\n\tconst sortedKeyAmounts = getKeysetAmounts(keys, 'asc');\n\tsortedKeyAmounts.forEach((amt) => {\n\t\tconst countWeHave = amountsWeHave.filter((a) => a === amt).length;\n\t\tconst countWeWant = Math.max(targetCount - countWeHave, 0);\n\t\tfor (let i = 0; i < countWeWant; ++i) {\n\t\t\tif (amountsWeWant.reduce((a, b) => a + b, 0) + amt > amountToKeep) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tamountsWeWant.push(amt);\n\t\t}\n\t});\n\t// use splitAmount to fill the rest between the sum of amountsWeHave and amountToKeep\n\tconst amountDiff = amountToKeep - amountsWeWant.reduce((a, b) => a + b, 0);\n\tif (amountDiff) {\n\t\tconst remainingAmounts = splitAmount(amountDiff, keys);\n\t\tremainingAmounts.forEach((amt: number) => {\n\t\t\tamountsWeWant.push(amt);\n\t\t});\n\t}\n\treturn amountsWeWant.sort((a, b) => a - b);\n}\n/**\n * Returns the amounts in the keyset sorted by the order specified.\n *\n * @param keyset To search in.\n * @param order Order to sort the amounts in.\n * @returns The amounts in the keyset sorted by the order specified.\n */\nexport function getKeysetAmounts(keyset: Keys, order: 'asc' | 'desc' = 'desc'): number[] {\n\tif (order == 'desc') {\n\t\treturn Object.keys(keyset)\n\t\t\t.map((k: string) => parseInt(k))\n\t\t\t.sort((a: number, b: number) => b - a);\n\t}\n\treturn Object.keys(keyset)\n\t\t.map((k: string) => parseInt(k))\n\t\t.sort((a: number, b: number) => a - b);\n}\n\n/**\n * Checks if the provided amount is in the keyset.\n *\n * @param amount Amount to check.\n * @param keyset To search in.\n * @returns True if the amount is in the keyset, false otherwise.\n */\nexport function hasCorrespondingKey(amount: number, keyset: Keys): boolean {\n\treturn amount in keyset;\n}\n\n/**\n * Converts a bytes array to a number.\n *\n * @deprecated We now use Bytes.toBigInt internally for better performance. This function is kept\n *   public for backward compatibility.\n * @param bytes To convert to number.\n * @returns Number as bigint.\n */\nexport function bytesToNumber(bytes: Uint8Array): bigint {\n\treturn Bytes.toBigInt(bytes);\n}\n\n/**\n * Converts a hex string to a number.\n *\n * @param hex To convert to number.\n * @returns Number.\n */\nexport function hexToNumber(hex: string): bigint {\n\treturn BigInt(`0x${hex}`);\n}\n\n/**\n * Converts a number to a hex string of 64 characters.\n *\n * @param number (bigint) to conver to hex.\n * @returns Hex string start-padded to 64 characters.\n */\nexport function numberToHexPadded64(number: bigint): string {\n\treturn number.toString(16).padStart(64, '0');\n}\n\nexport function isValidHex(str: string) {\n\treturn /^[a-f0-9]*$/i.test(str);\n}\n\n/**\n * Checks wether a proof or a list of proofs contains a non-hex id.\n *\n * @param p Proof or list of proofs.\n * @returns Boolean.\n */\nexport function hasNonHexId(p: Proof | Proof[]) {\n\tif (Array.isArray(p)) {\n\t\treturn p.some((proof) => !isValidHex(proof.id));\n\t}\n\treturn !isValidHex(p.id);\n}\n\n//used for json serialization\nexport function bigIntStringify<T>(_key: unknown, value: T) {\n\treturn typeof value === 'bigint' ? value.toString() : value;\n}\n\n/**\n * Helper function to encode a v3 cashu token.\n *\n * @param token To encode.\n * @returns Encoded token.\n */\nexport function getEncodedTokenV3(token: Token, removeDleq?: boolean): string {\n\tif (!hasNonHexId(token.proofs)) {\n\t\ttoken.proofs = convertToShortKeysetId(token.proofs);\n\t}\n\tif (removeDleq) {\n\t\ttoken.proofs = stripDleq(token.proofs);\n\t}\n\tconst v3TokenObj: DeprecatedToken = { token: [{ mint: token.mint, proofs: token.proofs }] };\n\tif (token.unit) {\n\t\tv3TokenObj.unit = token.unit;\n\t}\n\tif (token.memo) {\n\t\tv3TokenObj.memo = token.memo;\n\t}\n\tconst prefix = 'cashu';\n\tconst version = 'A';\n\treturn prefix + version + encodeJsonToBase64(v3TokenObj);\n}\n\n/*\n * Convert a keyset ID into short form\n */\nfunction convertToShortKeysetId(proofs: Proof[]) {\n\treturn proofs.map((p) => {\n\t\tconst newP = { ...p };\n\t\tnewP.id = newP.id.slice(0, 16);\n\t\treturn newP;\n\t});\n}\n\n/**\n * Helper function to encode a cashu token (defaults to v4 if keyset id allows it)\n *\n * @param token\n * @param [opts]\n */\nexport function getEncodedToken(\n\ttoken: Token,\n\topts?: { version?: 3 | 4; removeDleq?: boolean },\n): string {\n\t// Find out if it's a base64 keyset\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex || opts?.version === 3) {\n\t\tif (opts?.version === 4) {\n\t\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t\t}\n\t\treturn getEncodedTokenV3(token, opts?.removeDleq);\n\t}\n\treturn getEncodedTokenV4(token, opts?.removeDleq);\n}\n\nexport function getEncodedTokenV4(token: Token, removeDleq?: boolean): string {\n\tif (removeDleq) {\n\t\ttoken.proofs = stripDleq(token.proofs);\n\t}\n\t// Make sure each DLEQ has its blinding factor\n\ttoken.proofs.forEach((p) => {\n\t\tif (p.dleq && p.dleq.r == undefined) {\n\t\t\tthrow new Error('Missing blinding factor in included DLEQ proof');\n\t\t}\n\t});\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex) {\n\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t}\n\t// Map keyset IDs to short IDs\n\ttoken.proofs = convertToShortKeysetId(token.proofs);\n\n\tconst tokenTemplate = templateFromToken(token);\n\n\tconst encodedData = encodeCBOR(tokenTemplate);\n\tconst prefix = 'cashu';\n\tconst version = 'B';\n\tconst base64Data = encodeUint8toBase64Url(encodedData);\n\treturn prefix + version + base64Data;\n}\n\nfunction templateFromToken(token: Token): TokenV4Template {\n\tconst idMap: { [id: string]: Proof[] } = {};\n\tconst mint = token.mint;\n\tfor (let i = 0; i < token.proofs.length; i++) {\n\t\tconst proof = token.proofs[i];\n\t\tif (idMap[proof.id]) {\n\t\t\tidMap[proof.id].push(proof);\n\t\t} else {\n\t\t\tidMap[proof.id] = [proof];\n\t\t}\n\t}\n\tconst tokenTemplate: TokenV4Template = {\n\t\tm: mint,\n\t\tu: token.unit || 'sat',\n\t\tt: Object.keys(idMap).map(\n\t\t\t(id: string): V4InnerToken => ({\n\t\t\t\ti: hexToBytes(id),\n\t\t\t\tp: idMap[id].map(\n\t\t\t\t\t(p: Proof): V4ProofTemplate => ({\n\t\t\t\t\t\ta: p.amount,\n\t\t\t\t\t\ts: p.secret,\n\t\t\t\t\t\tc: hexToBytes(p.C),\n\t\t\t\t\t\t...(p.dleq && {\n\t\t\t\t\t\t\td: {\n\t\t\t\t\t\t\t\te: hexToBytes(p.dleq.e),\n\t\t\t\t\t\t\t\ts: hexToBytes(p.dleq.s),\n\t\t\t\t\t\t\t\tr: hexToBytes(p.dleq.r ?? '00'),\n\t\t\t\t\t\t\t} as V4DLEQTemplate,\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t...(p.p2pk_e && {\n\t\t\t\t\t\t\tpe: hexToBytes(p.p2pk_e),\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t...(p.witness && {\n\t\t\t\t\t\t\tw: JSON.stringify(p.witness),\n\t\t\t\t\t\t}),\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t}),\n\t\t),\n\t} as TokenV4Template;\n\tif (token.memo) {\n\t\ttokenTemplate.d = token.memo;\n\t}\n\treturn tokenTemplate;\n}\n\n/**\n * Asserts amount is a valid, safe integer.\n *\n * @param amount Value to check.\n * @param allowZero If false, requires amount > 0 (default: false).\n */\n/**\n * @internal\n */\nexport function validateAmount(amount: unknown, allowZero = false): asserts amount is number {\n\tif (typeof amount !== 'number' || !Number.isFinite(amount) || !Number.isInteger(amount)) {\n\t\tthrow new Error(`Invalid amount: ${String(amount)}`);\n\t}\n\tif (!Number.isSafeInteger(amount)) {\n\t\tthrow new Error(`Amount must be a safe integer: ${amount}`);\n\t}\n\tif (allowZero ? amount < 0 : amount <= 0) {\n\t\tthrow new Error(`Amount must be ${allowZero ? 'non-negative' : 'positive'}: ${amount}`);\n\t}\n}\n\nfunction tokenFromTemplate(template: TokenV4Template): Token {\n\tconst proofs: Proof[] = [];\n\ttemplate.t.forEach((t) =>\n\t\tt.p.forEach((p) => {\n\t\t\tvalidateAmount(p.a, true);\n\t\t\tproofs.push({\n\t\t\t\tsecret: p.s,\n\t\t\t\tC: bytesToHex(p.c),\n\t\t\t\tamount: p.a,\n\t\t\t\tid: bytesToHex(t.i),\n\t\t\t\t...(p.d && {\n\t\t\t\t\tdleq: {\n\t\t\t\t\t\tr: bytesToHex(p.d.r),\n\t\t\t\t\t\ts: bytesToHex(p.d.s),\n\t\t\t\t\t\te: bytesToHex(p.d.e),\n\t\t\t\t\t} as SerializedDLEQ,\n\t\t\t\t}),\n\t\t\t\t...(p.pe && {\n\t\t\t\t\tp2pk_e: bytesToHex(p.pe),\n\t\t\t\t}),\n\t\t\t\t...(p.w && {\n\t\t\t\t\twitness: p.w,\n\t\t\t\t}),\n\t\t\t});\n\t\t}),\n\t);\n\tconst decodedToken: Token = { mint: template.m, proofs, unit: template.u || 'sat' };\n\tif (template.d) {\n\t\tdecodedToken.memo = template.d;\n\t}\n\treturn decodedToken;\n}\n\n/**\n * Helper function to decode cashu tokens into object.\n *\n * @param token An encoded cashu token (cashuB...)\n * @param keysets Optional. Array of full keyset IDs, eg: from KeyChain.getAllKeysetIds()\n * @returns Cashu token object.\n */\nexport function getDecodedToken(tokenString: string, keysetIds?: readonly string[]): Token;\n/**\n * @deprecated Pass keyset ids as `string[]` instead, eg: using KeyChain.getAllKeysetIds()\n */\nexport function getDecodedToken(tokenString: string, keysetIds?: readonly HasKeysetId[]): Token;\nexport function getDecodedToken(\n\ttokenString: string,\n\tkeysetOrIds?: ReadonlyArray<string | HasKeysetId>,\n): Token {\n\t// normalize to array of strings\n\tconst keysetIds = (keysetOrIds ?? []).map((ks) => (typeof ks === 'string' ? ks : ks.id));\n\t// remove prefixes\n\tconst tokenStr = removePrefix(tokenString);\n\tconst token: Token = handleTokens(tokenStr);\n\ttoken.proofs = mapShortKeysetIds(token.proofs, keysetIds);\n\treturn token;\n}\n\n/**\n * Returns the metadata of a cashu token.\n *\n * @param token An encoded cashu token (cashuB...)\n * @returns Token metadata.\n */\nexport function getTokenMetadata(token: string): TokenMetadata {\n\ttoken = removePrefix(token);\n\tconst tokenObj = handleTokens(token);\n\treturn {\n\t\tunit: tokenObj.unit || 'sat',\n\t\tmint: tokenObj.mint,\n\t\tamount: sumProofs(tokenObj.proofs),\n\t\t...(tokenObj.memo && { memo: tokenObj.memo }),\n\t\tincompleteProofs: tokenObj.proofs.map((p) => ({\n\t\t\tsecret: p.secret,\n\t\t\tC: p.C,\n\t\t\tamount: p.amount,\n\t\t\t...(p.dleq && {\n\t\t\t\tdleq: p.dleq,\n\t\t\t}),\n\t\t\t...(p.witness && {\n\t\t\t\twitness: p.witness,\n\t\t\t}),\n\t\t})),\n\t};\n}\n\n/**\n * Helper function to decode different versions of cashu tokens into an object.\n *\n * @param token An encoded cashu token (cashuB...)\n * @returns Cashu Token object.\n */\nexport function handleTokens(token: string): Token {\n\tconst version = token.slice(0, 1);\n\tconst encodedToken = token.slice(1);\n\tif (version === 'A') {\n\t\tconst parsedV3Token = encodeBase64ToJson<DeprecatedToken>(encodedToken);\n\t\tif (parsedV3Token.token.length > 1) {\n\t\t\tthrow new Error('Multi entry token are not supported');\n\t\t}\n\t\tconst entry = parsedV3Token.token[0];\n\t\tfor (const p of entry.proofs) {\n\t\t\tvalidateAmount(p.amount, true);\n\t\t}\n\t\tconst tokenObj: Token = {\n\t\t\tmint: entry.mint,\n\t\t\tproofs: entry.proofs,\n\t\t\tunit: parsedV3Token.unit || 'sat',\n\t\t};\n\t\tif (parsedV3Token.memo) {\n\t\t\ttokenObj.memo = parsedV3Token.memo;\n\t\t}\n\t\treturn tokenObj;\n\t} else if (version === 'B') {\n\t\tconst uInt8Token = encodeBase64toUint8(encodedToken);\n\t\tconst tokenData = decodeCBOR(uInt8Token) as TokenV4Template;\n\t\treturn tokenFromTemplate(tokenData);\n\t}\n\tthrow new Error('Token version is not supported');\n}\n\nexport type DeriveKeysetIdOptions = {\n\texpiry?: number;\n\tinput_fee_ppk?: number;\n\tunit?: string;\n\tversionByte?: number;\n\tisDeprecatedBase64?: boolean;\n};\n\n/**\n * Returns the keyset id of a set of keys.\n *\n * @param keys Keys object to derive keyset id from.\n * @param options.expiry (optional) expiry of the keyset.\n * @param options.input_fee_ppk (optional) Input fee for keyset (in ppk)\n * @param options.unit (optional) the unit of the keyset. Default: sat.\n * @param options.versionByte (optional) version of the keyset ID. Default: 1.\n * @param options.isDeprecatedBase64 (optional) version of the keyset ID. Default: false.\n * @returns Keyset id of the keys.\n * @throws If keyset versionByte is not valid.\n */\nexport function deriveKeysetId(keys: Keys, options?: DeriveKeysetIdOptions): string;\n/**\n * @deprecated Use the new options signature, which also adds keysets v2 support:\n *\n *       deriveKeysetId(keys, { unit, expiry, versionByte, input_fee_ppk });\n */\nexport function deriveKeysetId(\n\tkeys: Keys,\n\tunit?: string,\n\texpiry?: number,\n\tversionByte?: number,\n\tisDeprecatedBase64?: boolean,\n): string;\nexport function deriveKeysetId(\n\tkeys: Keys,\n\targ2?: string | DeriveKeysetIdOptions,\n\texpiry?: number,\n\tversionByte?: number,\n\tisDeprecatedBase64?: boolean,\n\tinput_fee_ppk?: number,\n): string {\n\tlet unit: string = 'sat';\n\tif (arg2 && typeof arg2 === 'object') {\n\t\t// New signature\n\t\tunit = arg2.unit ?? 'sat'; // default: sat\n\t\texpiry = arg2.expiry;\n\t\tversionByte = arg2.versionByte ?? 1; // default: 1\n\t\tinput_fee_ppk = arg2.input_fee_ppk;\n\t\tisDeprecatedBase64 = arg2.isDeprecatedBase64 ?? false; // default: false\n\t} else {\n\t\t// Deprecated signature\n\t\tunit = arg2 ?? 'sat'; // default: sat\n\t\tversionByte = versionByte ?? 0; // default: 0\n\t\tisDeprecatedBase64 = isDeprecatedBase64 ?? false; // default: false\n\t}\n\n\tif (isDeprecatedBase64) {\n\t\tconst pubkeysConcat = Object.entries(keys)\n\t\t\t.sort(([amountA], [amountB]) => Number(amountA) - Number(amountB))\n\t\t\t.map(([, pubKey]) => pubKey)\n\t\t\t.reduce((prev: string, curr: string) => prev + curr, '');\n\t\tconst hash = sha256(Bytes.fromString(pubkeysConcat));\n\t\tconst b64 = Bytes.toBase64(hash);\n\t\treturn b64.slice(0, 12);\n\t}\n\n\tswitch (versionByte) {\n\t\tcase 0: {\n\t\t\tconst pubkeysConcat = Object.entries(keys)\n\t\t\t\t.sort(([amountA], [amountB]) => Number(amountA) - Number(amountB))\n\t\t\t\t.map(([, pubKey]) => hexToBytes(pubKey))\n\t\t\t\t.reduce(\n\t\t\t\t\t(prev: Uint8Array, curr: Uint8Array) => mergeUInt8Arrays(prev, curr),\n\t\t\t\t\tnew Uint8Array(),\n\t\t\t\t);\n\t\t\tconst hash = sha256(pubkeysConcat);\n\t\t\tconst hashHex = Bytes.toHex(hash).slice(0, 14);\n\t\t\treturn '00' + hashHex;\n\t\t}\n\t\tcase 1: {\n\t\t\tif (!unit) {\n\t\t\t\tthrow new Error('Cannot compute keyset ID version 01: unit is required.');\n\t\t\t}\n\t\t\tconst sortedEntries = Object.entries(keys).sort(\n\t\t\t\t([amountA], [amountB]) => Number(amountA) - Number(amountB),\n\t\t\t);\n\t\t\tlet preimage = sortedEntries.map(([amount, pubkey]) => `${amount}:${pubkey}`).join(',');\n\t\t\tpreimage += `|unit:${unit}`;\n\t\t\tif (input_fee_ppk) {\n\t\t\t\tpreimage += `|input_fee_ppk:${input_fee_ppk}`;\n\t\t\t}\n\t\t\tif (expiry) {\n\t\t\t\tpreimage += `|final_expiry:${expiry}`;\n\t\t\t}\n\t\t\tconst hash = sha256(Bytes.fromString(preimage));\n\t\t\tconst hashHex = Bytes.toHex(hash);\n\t\t\treturn '01' + hashHex;\n\t\t}\n\t\tdefault:\n\t\t\tthrow new Error(`Unrecognized keyset ID version: ${versionByte}`);\n\t}\n}\n\nexport function mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n\t// sum of individual array lengths\n\tconst mergedArray = new Uint8Array(a1.length + a2.length);\n\tmergedArray.set(a1);\n\tmergedArray.set(a2, a1.length);\n\treturn mergedArray;\n}\n\nexport function sortProofsById(proofs: Proof[]) {\n\treturn proofs.sort((a: Proof, b: Proof) => a.id.localeCompare(b.id));\n}\n\nexport function isObj(v: unknown): v is object {\n\treturn typeof v === 'object';\n}\n\nexport function checkResponse(data: { error?: string; detail?: string }) {\n\tif (!isObj(data)) return;\n\tif ('error' in data && data.error) {\n\t\tthrow new Error(data.error);\n\t}\n\tif ('detail' in data && data.detail) {\n\t\tthrow new Error(data.detail);\n\t}\n}\n\nexport function joinUrls(...parts: string[]): string {\n\treturn parts.map((part: string) => part.replace(/(^\\/+|\\/+$)/g, '')).join('/');\n}\n\nexport function sanitizeUrl(url: string): string {\n\treturn url.replace(/\\/$/, '');\n}\n\nexport function sumProofs(proofs: Proof[]) {\n\treturn proofs.reduce((acc: number, proof: Proof) => acc + proof.amount, 0);\n}\n\nexport function decodePaymentRequest(paymentRequest: string) {\n\treturn PaymentRequest.fromEncodedRequest(paymentRequest);\n}\n\nexport class MessageNode {\n\tprivate _value: string;\n\tprivate _next: MessageNode | null;\n\n\tpublic get value(): string {\n\t\treturn this._value;\n\t}\n\tpublic set value(message: string) {\n\t\tthis._value = message;\n\t}\n\tpublic get next(): MessageNode | null {\n\t\treturn this._next;\n\t}\n\tpublic set next(node: MessageNode | null) {\n\t\tthis._next = node;\n\t}\n\n\tconstructor(message: string) {\n\t\tthis._value = message;\n\t\tthis._next = null;\n\t}\n}\n\nexport class MessageQueue {\n\tprivate _first: MessageNode | null;\n\tprivate _last: MessageNode | null;\n\n\tpublic get first(): MessageNode | null {\n\t\treturn this._first;\n\t}\n\tpublic set first(messageNode: MessageNode | null) {\n\t\tthis._first = messageNode;\n\t}\n\tpublic get last(): MessageNode | null {\n\t\treturn this._last;\n\t}\n\tpublic set last(messageNode: MessageNode | null) {\n\t\tthis._last = messageNode;\n\t}\n\tprivate _size: number;\n\tpublic get size(): number {\n\t\treturn this._size;\n\t}\n\tpublic set size(v: number) {\n\t\tthis._size = v;\n\t}\n\n\tconstructor() {\n\t\tthis._first = null;\n\t\tthis._last = null;\n\t\tthis._size = 0;\n\t}\n\tenqueue(message: string): boolean {\n\t\tconst newNode = new MessageNode(message);\n\t\tif (this._size === 0 || !this._last) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\t\t} else {\n\t\t\tthis._last.next = newNode;\n\t\t\tthis._last = newNode;\n\t\t}\n\t\tthis._size++;\n\t\treturn true;\n\t}\n\tdequeue(): string | null {\n\t\tif (this._size === 0 || !this._first) return null;\n\n\t\tconst prev = this._first;\n\t\tthis._first = prev.next;\n\t\tprev.next = null;\n\n\t\tthis._size--;\n\t\treturn prev.value;\n\t}\n}\n/**\n * Removes all traces of DLEQs from a list of proofs.\n *\n * @param proofs The list of proofs that dleq should be stripped from.\n */\nexport function stripDleq(proofs: Proof[]): Array<Omit<Proof, 'dleq'>> {\n\treturn proofs.map((p) => {\n\t\tconst newP = { ...p };\n\t\tdelete newP['dleq'];\n\t\treturn newP;\n\t});\n}\n\n/**\n * @deprecated Use Keyset.verifyKeysetId(keys), or init a Keyset and call keyset.verify().\n */\nexport function verifyKeysetId(keys: MintKeys): boolean {\n\t// Note: we are NOT redirecting to Keyset.verifyKeysetId() here as that would\n\t// couple the utils class to Keyset, and risks circular dependencies.\n\tconst isBase64 = isBase64String(keys.id);\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keys.id);\n\tconst versionByte = isValidHex ? hexToBytes(keys.id)[0] : 0;\n\treturn (\n\t\tderiveKeysetId(keys.keys, {\n\t\t\texpiry: keys.final_expiry,\n\t\t\tinput_fee_ppk: keys.input_fee_ppk,\n\t\t\tunit: keys.unit,\n\t\t\tversionByte,\n\t\t\tisDeprecatedBase64: isBase64 && !isValidHex,\n\t\t}) === keys.id\n\t);\n}\n\n/**\n * Maps the short keyset IDs stored in the token to actual keyset IDs that were fetched from the\n * Mint.\n *\n * @param proofs Array of Proofs.\n * @param keysets Optional. Array of full keyset IDs, eg: from KeyChain.getAllKeysetIds()\n * @returns Array of Proofs with full keyset IDs.\n */\nfunction mapShortKeysetIds(proofs: Proof[], keysetIds?: readonly string[]): Proof[];\n/**\n * @deprecated Pass keyset ids as `string[]` instead.\n */\nfunction mapShortKeysetIds(proofs: Proof[], keysetIds?: readonly HasKeysetId[]): Proof[];\nfunction mapShortKeysetIds(\n\tproofs: Proof[],\n\tkeysetOrIds?: ReadonlyArray<string | HasKeysetId>,\n): Proof[] {\n\t// normalize to array of keyset ids\n\tconst keysetIds = (keysetOrIds ?? []).map((ks) => (typeof ks === 'string' ? ks : ks.id));\n\tconst newProofs: Proof[] = [];\n\tfor (const proof of proofs) {\n\t\tlet idBytes: Uint8Array;\n\t\ttry {\n\t\t\tidBytes = hexToBytes(proof.id);\n\t\t} catch {\n\t\t\t// Base64 keysets don't need conversion\n\t\t\tnewProofs.push(proof);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (idBytes[0] === 0x00) {\n\t\t\tnewProofs.push(proof);\n\t\t} else if (idBytes[0] === 0x01) {\n\t\t\tif (!keysetIds) {\n\t\t\t\tthrow new Error('A short keyset ID v2 was encountered, but got no keysets to map it to.');\n\t\t\t}\n\t\t\t// Look for a match: prefix(keyset ID) == short ID\n\t\t\tconst matches = keysetIds.filter((keyset) => proof.id === keyset.slice(0, proof.id.length));\n\t\t\tif (matches.length > 1) {\n\t\t\t\tthrow new Error(`Short keyset ID ${proof.id} is ambiguous.`);\n\t\t\t}\n\t\t\tif (matches.length === 0) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Couldn't map short keyset ID ${proof.id} to any known keysets of the current Mint`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tproof.id = matches[0];\n\t\t\tnewProofs.push(proof);\n\t\t} else {\n\t\t\tthrow new Error(`Unknown keyset ID version: ${idBytes[0]}`);\n\t\t}\n\t}\n\n\treturn newProofs;\n}\n\n/**\n * Checks that the proof has a valid DLEQ proof according to keyset `keys`\n *\n * @param proof The proof subject to verification.\n * @param keyset Object containing keyset keys (eg: Keyset, MintKeys, KeysetCache)\n * @returns True if verification succeeded, false otherwise.\n * @throws Throws if the proof amount does not match any key in the provided keyset.\n */\nexport function hasValidDleq(proof: Proof, keyset: HasKeysetKeys): boolean {\n\tif (proof.dleq == undefined) {\n\t\treturn false;\n\t}\n\tconst dleq = {\n\t\te: hexToBytes(proof.dleq.e),\n\t\ts: hexToBytes(proof.dleq.s),\n\t\tr: hexToNumber(proof.dleq.r ?? '00'),\n\t} as DLEQ;\n\tif (!hasCorrespondingKey(proof.amount, keyset.keys)) {\n\t\tthrow new Error(`Undefined key for amount ${proof.amount} in keyset ${keyset.id}`);\n\t}\n\tconst key = keyset.keys[proof.amount];\n\treturn verifyDLEQProof_reblind(\n\t\tnew TextEncoder().encode(proof.secret),\n\t\tdleq,\n\t\tpointFromHex(proof.C),\n\t\tpointFromHex(key),\n\t);\n}\n\nfunction concatByteArrays(...arrays: Uint8Array[]): Uint8Array {\n\tconst totalLength = arrays.reduce((a, c) => a + c.length, 0);\n\tconst byteArray = new Uint8Array(totalLength);\n\tlet pointer = 0;\n\tfor (let i = 0; i < arrays.length; i++) {\n\t\tbyteArray.set(arrays[i], pointer);\n\t\tpointer = pointer + arrays[i].length;\n\t}\n\treturn byteArray;\n}\n\nexport function getEncodedTokenBinary(token: Token): Uint8Array {\n\tconst utf8Encoder = new TextEncoder();\n\tconst template = templateFromToken(token);\n\tconst binaryTemplate = encodeCBOR(template);\n\tconst prefix = utf8Encoder.encode('craw');\n\tconst version = utf8Encoder.encode('B');\n\treturn concatByteArrays(prefix, version, binaryTemplate);\n}\n\nexport function getDecodedTokenBinary(bytes: Uint8Array): Token {\n\tconst utfDecoder = new TextDecoder();\n\tconst prefix = utfDecoder.decode(bytes.slice(0, 4));\n\tconst version = utfDecoder.decode(new Uint8Array([bytes[4]]));\n\tif (prefix !== 'craw' || version !== 'B') {\n\t\tthrow new Error('not a valid binary token');\n\t}\n\tconst binaryToken = bytes.slice(5);\n\tconst decoded = decodeCBOR(binaryToken) as TokenV4Template;\n\treturn tokenFromTemplate(decoded);\n}\n\nfunction sumArray(arr: number[]) {\n\treturn arr.reduce((a, c) => a + c, 0);\n}\n\n/**\n * Utility function for deep equality comparison of objects.\n */\nexport function deepEqual<T>(a: T, b: T): boolean {\n\tif (a === b) return true;\n\tif (a == null || b == null) return false;\n\tif (typeof a !== 'object' || typeof b !== 'object') return false;\n\n\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\tif (a.length !== b.length) return false;\n\t\treturn a.every((item, index) => deepEqual(item, b[index]));\n\t}\n\n\tif (Array.isArray(a) || Array.isArray(b)) return false;\n\n\tconst keysA = Object.keys(a) as Array<keyof T>;\n\tconst keysB = Object.keys(b) as Array<keyof T>;\n\tif (keysA.length !== keysB.length) return false;\n\n\treturn keysA.every((key) => keysB.includes(key) && deepEqual(a[key], b[key]));\n}\n\nfunction removePrefix(token: string): string {\n\tconst uriPrefixes = ['web+cashu://', 'cashu://', 'cashu:', 'cashu'];\n\turiPrefixes.forEach((prefix: string) => {\n\t\tif (!token.startsWith(prefix)) {\n\t\t\treturn;\n\t\t}\n\t\ttoken = token.slice(prefix.length);\n\t});\n\treturn token;\n}\n\n/**\n * Detects whether a BOLT-11 Lightning invoice encodes a non-zero amount in the Human-Readable Part\n * (HRP).\n */\nexport function invoiceHasAmountInHRP(invoice: string): boolean {\n\treturn /^ln[a-z]{2,}[1-9][0-9]*(?:[mun]|0p)?1/i.test(invoice);\n}\n","import { MessageQueue } from '../utils';\nimport { type JsonRpcMessage, type JsonRpcReqParams, type RpcSubId } from '../model/types';\nimport { getWebSocketImpl } from './ws';\nimport { type Logger, NULL_LOGGER } from '../logger';\n\n// Internal interface for RPC listeners\ninterface RpcListener {\n\tcallback: () => void;\n\terrorCallback: (e: Error) => void;\n}\n\ntype OnOpenSuccess = () => void;\ntype OnOpenError = (err: Error) => void;\n\nexport class ConnectionManager {\n\tprivate static instance: ConnectionManager;\n\tprivate connectionMap: Map<string, WSConnection> = new Map();\n\n\tstatic getInstance() {\n\t\tif (!ConnectionManager.instance) {\n\t\t\tConnectionManager.instance = new ConnectionManager();\n\t\t}\n\t\treturn ConnectionManager.instance;\n\t}\n\n\tgetConnection(url: string, logger?: Logger): WSConnection {\n\t\tconst existing = this.connectionMap.get(url);\n\t\tif (existing) {\n\t\t\tif (logger) existing.setLogger(logger);\n\t\t\treturn existing;\n\t\t}\n\t\tconst newConn = new WSConnection(url, logger);\n\t\tthis.connectionMap.set(url, newConn);\n\t\treturn newConn;\n\t}\n}\n\nexport class WSConnection {\n\tpublic readonly url: URL;\n\tprivate readonly _WS: typeof WebSocket;\n\tprivate ws: WebSocket | undefined;\n\tprivate connectionPromise: Promise<void> | undefined;\n\tprivate subListeners: { [subId: string]: Array<(payload: unknown) => void> } = {};\n\tprivate rpcListeners: { [rpcSubId: string]: RpcListener } = {};\n\tprivate messageQueue: MessageQueue;\n\tprivate handlingInterval?: ReturnType<typeof setInterval>;\n\tprivate rpcId = 0;\n\tprivate _logger: Logger;\n\tprivate onCloseCallbacks: Array<(e: CloseEvent) => void> = [];\n\n\tconstructor(url: string, logger?: Logger) {\n\t\tthis._WS = getWebSocketImpl();\n\t\tthis.url = new URL(url);\n\t\tthis.messageQueue = new MessageQueue();\n\t\tthis._logger = logger ?? NULL_LOGGER;\n\t}\n\n\tsetLogger(logger: Logger) {\n\t\tthis._logger = logger;\n\t}\n\n\tconnect(timeoutMs = 10_000): Promise<void> {\n\t\tif (this.connectionPromise) return this.connectionPromise;\n\n\t\tthis.connectionPromise = new Promise((resolve: OnOpenSuccess, reject: OnOpenError) => {\n\t\t\tlet opened = false;\n\t\t\tlet settled = false;\n\t\t\tlet timer: ReturnType<typeof setTimeout> | null = null;\n\n\t\t\tconst settle = (fn: () => void) => {\n\t\t\t\tif (settled) return;\n\t\t\t\tsettled = true;\n\t\t\t\tif (timer) clearTimeout(timer);\n\t\t\t\tfn();\n\t\t\t};\n\n\t\t\tconst cleanupSocket = () => {\n\t\t\t\tif (!this.ws) return;\n\t\t\t\ttry {\n\t\t\t\t\tthis.ws.onopen = null;\n\t\t\t\t\tthis.ws.onerror = null;\n\t\t\t\t\tthis.ws.onmessage = null;\n\t\t\t\t\tthis.ws.onclose = null;\n\t\t\t\t} catch {\n\t\t\t\t\t// silence\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tthis.ws.close();\n\t\t\t\t} catch {\n\t\t\t\t\t// silence\n\t\t\t\t}\n\t\t\t\tthis.ws = undefined;\n\t\t\t\tthis.stopMessageHandling();\n\t\t\t};\n\n\t\t\tconst fail = (e: unknown) => {\n\t\t\t\tthis.connectionPromise = undefined;\n\t\t\t\tcleanupSocket();\n\t\t\t\tconst err = e instanceof Error ? e : new Error(String(e));\n\t\t\t\tthis.failPendingRpc(err);\n\t\t\t\tsettle(() => reject(err));\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tthis.ws = new this._WS(this.url.toString());\n\t\t\t} catch (e) {\n\t\t\t\tfail(e);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttimer = setTimeout(() => {\n\t\t\t\tfail(new Error(`WebSocket connect timeout after ${timeoutMs}ms`));\n\t\t\t}, timeoutMs);\n\n\t\t\tthis.ws.onopen = () => {\n\t\t\t\topened = true;\n\t\t\t\tsettle(resolve);\n\t\t\t};\n\n\t\t\tthis.ws.onerror = (ev) => {\n\t\t\t\tif (!opened) {\n\t\t\t\t\tfail(new Error('Failed to open WebSocket'));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._logger.error('WebSocket error after open', { ev });\n\t\t\t\t// do not call fail(), onclose will follow in most implementations\n\t\t\t};\n\n\t\t\tthis.ws.onmessage = (e: MessageEvent) => {\n\t\t\t\tthis.messageQueue.enqueue(e.data as string);\n\t\t\t\tif (!this.handlingInterval) {\n\t\t\t\t\tthis.handlingInterval = setInterval(this.handleNextMessage.bind(this), 0);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.ws.onclose = (e: CloseEvent) => {\n\t\t\t\tthis.connectionPromise = undefined;\n\n\t\t\t\tif (!opened) {\n\t\t\t\t\tconst reason = e?.reason ? `, ${e.reason}` : '';\n\t\t\t\t\tfail(new Error(`WebSocket closed before open (code ${e?.code ?? 0}${reason})`));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.stopMessageHandling();\n\n\t\t\t\t// If the socket closed unexpectedly, fail any in flight RPC acks.\n\t\t\t\t// Otherwise just clear them to avoid leaks, but don't spam errors.\n\t\t\t\tconst reason = e?.reason ? `, ${e.reason}` : '';\n\t\t\t\tconst code = e?.code ?? 0;\n\t\t\t\tconst wasClean = typeof e.wasClean === 'boolean' ? e.wasClean : true;\n\n\t\t\t\tconst abnormal = !wasClean || (code !== 1000 && code !== 1001);\n\t\t\t\tif (abnormal) {\n\t\t\t\t\tthis.failPendingRpc(new Error(`WebSocket closed (code ${code}${reason})`));\n\t\t\t\t} else {\n\t\t\t\t\tthis.rpcListeners = {};\n\t\t\t\t}\n\n\t\t\t\tthis.onCloseCallbacks.forEach((cb) => cb(e));\n\t\t\t};\n\t\t});\n\n\t\treturn this.connectionPromise;\n\t}\n\n\tsendRequest(method: 'subscribe', params: JsonRpcReqParams): void;\n\tsendRequest(method: 'unsubscribe', params: { subId: string }): void;\n\tsendRequest(method: 'subscribe' | 'unsubscribe', params: Partial<JsonRpcReqParams>): void {\n\t\tif (this.ws?.readyState !== this._WS.OPEN) {\n\t\t\tif (method === 'unsubscribe') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._logger.error('Attempted sendRequest, but socket was not open');\n\t\t\tthrow new Error('Socket not open');\n\t\t}\n\n\t\tconst id = this.rpcId;\n\t\tthis.rpcId++;\n\t\tthis.sendRpcMessage(method, params, id);\n\t}\n\n\t/**\n\t * @deprecated Use cancelSubscription for JSONRPC compliance.\n\t */\n\tcloseSubscription(subId: string) {\n\t\tthis.ws?.send(JSON.stringify(['CLOSE', subId]));\n\t}\n\n\taddSubListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void) {\n\t\t(this.subListeners[subId] = this.subListeners[subId] || []).push(\n\t\t\tcallback as (payload: unknown) => void,\n\t\t);\n\t}\n\n\tprivate stopMessageHandling() {\n\t\tif (this.handlingInterval) {\n\t\t\tclearInterval(this.handlingInterval);\n\t\t\tthis.handlingInterval = undefined;\n\t\t}\n\t\t// Drain any queued messages so we don't process stale frames after teardown.\n\t\twhile (this.messageQueue.size > 0) {\n\t\t\tthis.messageQueue.dequeue();\n\t\t}\n\t}\n\n\tprivate failPendingRpc(err: Error) {\n\t\tconst listeners = this.rpcListeners;\n\t\tthis.rpcListeners = {};\n\t\tfor (const key of Object.keys(listeners)) {\n\t\t\ttry {\n\t\t\t\tlisteners[key].errorCallback(err);\n\t\t\t} catch {\n\t\t\t\t// ignore user error callbacks throwing\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate sendRpcMessage(\n\t\tmethod: 'subscribe' | 'unsubscribe',\n\t\tparams: Partial<JsonRpcReqParams>,\n\t\tid: number,\n\t): void {\n\t\tif (this.ws?.readyState !== this._WS.OPEN) {\n\t\t\tthrow new Error('Socket not open');\n\t\t}\n\n\t\tconst message = JSON.stringify({ jsonrpc: '2.0', method, params, id });\n\n\t\ttry {\n\t\t\tthis.ws.send(message);\n\t\t} catch (e) {\n\t\t\tthis._logger.error('WebSocket send failed', { e });\n\t\t\t// allow retry\n\t\t\tthis.connectionPromise = undefined;\n\n\t\t\t// Ensure the failed socket is closed and queues are flushed.\n\t\t\ttry {\n\t\t\t\tthis.ws.close();\n\t\t\t} catch {\n\t\t\t\t// silence\n\t\t\t}\n\t\t\tthis.ws = undefined;\n\t\t\tthis.stopMessageHandling();\n\n\t\t\tconst err = e instanceof Error ? e : new Error(String(e));\n\t\t\tthis.failPendingRpc(err);\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tprivate addRpcListener(\n\t\tcallback: () => void,\n\t\terrorCallback: (e: Error) => void,\n\t\tid: Exclude<RpcSubId, null>,\n\t) {\n\t\tthis.rpcListeners[id] = { callback, errorCallback };\n\t}\n\n\tprivate removeRpcListener(id: Exclude<RpcSubId, null>) {\n\t\tdelete this.rpcListeners[id];\n\t}\n\n\tprivate removeListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void) {\n\t\tif (!this.subListeners[subId]) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.subListeners[subId].length === 1) {\n\t\t\tdelete this.subListeners[subId];\n\t\t\treturn;\n\t\t}\n\t\tthis.subListeners[subId] = this.subListeners[subId].filter(\n\t\t\t(fn) => fn !== (callback as (payload: unknown) => void),\n\t\t);\n\t}\n\n\tasync ensureConnection(timeoutMs?: number) {\n\t\tif (this.ws?.readyState !== this._WS.OPEN) {\n\t\t\tawait this.connect(timeoutMs);\n\t\t}\n\t}\n\n\tprivate handleNextMessage() {\n\t\tif (this.messageQueue.size === 0) {\n\t\t\tif (this.handlingInterval) {\n\t\t\t\tclearInterval(this.handlingInterval);\n\t\t\t\tthis.handlingInterval = undefined;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tconst message = this.messageQueue.dequeue() as string;\n\n\t\ttry {\n\t\t\tconst parsed = JSON.parse(message) as JsonRpcMessage;\n\n\t\t\tif ('result' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].callback();\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('error' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].errorCallback(new Error(parsed.error.message));\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('method' in parsed) {\n\t\t\t\tif ('id' in parsed) {\n\t\t\t\t\t// Do nothing as mints should not send requests\n\t\t\t\t} else {\n\t\t\t\t\tconst subId = parsed.params?.subId;\n\t\t\t\t\tif (!subId) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.subListeners[subId]?.length > 0) {\n\t\t\t\t\t\tconst notification = parsed;\n\t\t\t\t\t\tthis.subListeners[subId].forEach((cb) => {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tcb(notification.params?.payload);\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tthis._logger.error('Subscription handler threw', { e });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis._logger.error('Error doing handleNextMessage', { e });\n\t\t}\n\t}\n\n\tcreateSubscription<TPayload = unknown>(\n\t\tparams: Omit<JsonRpcReqParams, 'subId'>,\n\t\tcallback: (payload: TPayload) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): string {\n\t\tif (this.ws?.readyState !== this._WS.OPEN) {\n\t\t\tthis._logger.error('Attempted createSubscription, but socket was not open');\n\t\t\tthrow new Error('Socket is not open');\n\t\t}\n\n\t\tconst subId = (Math.random() + 1).toString(36).substring(7);\n\t\tconst rpcId = this.rpcId; // this is the id sendRequest will use next\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis.addSubListener(subId, callback);\n\t\t\t},\n\t\t\terrorCallback,\n\t\t\trpcId as Exclude<RpcSubId, null>,\n\t\t);\n\n\t\ttry {\n\t\t\tthis.sendRequest('subscribe', { ...params, subId });\n\t\t} catch (e) {\n\t\t\tthis.removeRpcListener(rpcId as Exclude<RpcSubId, null>);\n\t\t\tthrow e;\n\t\t}\n\n\t\treturn subId;\n\t}\n\n\t/**\n\t * Cancels a subscription, sending an unsubscribe request and handling responses.\n\t *\n\t * @param subId The subscription ID to cancel.\n\t * @param callback The original payload callback to remove.\n\t * @param errorCallback Optional callback for unsubscribe errors (defaults to logging).\n\t */\n\tcancelSubscription<TPayload = unknown>(\n\t\tsubId: string,\n\t\tcallback: (payload: TPayload) => void,\n\t\terrorCallback?: (e: Error) => void,\n\t) {\n\t\tthis.removeListener(subId, callback);\n\n\t\tif (this.ws?.readyState !== this._WS.OPEN) {\n\t\t\tthis._logger.info('Socket not open, removed listener locally {subId}', { subId });\n\t\t\treturn;\n\t\t}\n\n\t\tconst id = this.rpcId;\n\t\tthis.rpcId++;\n\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis._logger.info('Unsubscribed {subId}', { subId });\n\t\t\t},\n\t\t\terrorCallback || ((e: Error) => this._logger.error('Unsubscribe failed', { e })),\n\t\t\tid as Exclude<RpcSubId, null>,\n\t\t);\n\n\t\ttry {\n\t\t\tthis.sendRpcMessage('unsubscribe', { subId }, id);\n\t\t} catch (e) {\n\t\t\tthis.removeRpcListener(id as Exclude<RpcSubId, null>);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\tget activeSubscriptions() {\n\t\treturn Object.keys(this.subListeners);\n\t}\n\n\tclose() {\n\t\tif (this.ws) {\n\t\t\ttry {\n\t\t\t\tthis.ws.close();\n\t\t\t} catch {\n\t\t\t\t// silence\n\t\t\t}\n\t\t\tthis.ws = undefined;\n\t\t}\n\t\tthis.connectionPromise = undefined;\n\t\tthis.stopMessageHandling();\n\t}\n\n\tonClose(callback: (e: CloseEvent) => void) {\n\t\tthis.onCloseCallbacks.push(callback);\n\t}\n}\n","import { type SerializedBlindedMessage, type SerializedBlindedSignature } from './blinded';\n\nexport const MintQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPAID: 'PAID',\n\tISSUED: 'ISSUED',\n} as const;\nexport type MintQuoteState = (typeof MintQuoteState)[keyof typeof MintQuoteState];\n\n/**\n * Base mint quote request - all mint quote requests have these fields (NUT-04) and may have\n * optional fields (NUT-20)\n */\nexport type MintQuoteBaseRequest = {\n\t/**\n\t * Unit to be minted.\n\t */\n\tunit: string;\n\t/**\n\t * Optional. Public key to lock the quote to (NUT-20).\n\t */\n\tpubkey?: string;\n};\n\n/**\n * Base mint quote response - all mint quotes have these fields (NUT-04) and may have optional\n * fields (NUT-20)\n */\nexport type MintQuoteBaseResponse = {\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * Payment request.\n\t */\n\trequest: string;\n\t/**\n\t * Unit of the melt quote.\n\t */\n\tunit: string;\n\t/**\n\t * Optional. Public key the quote is locked to (NUT-20)\n\t */\n\tpubkey?: string;\n};\n\n/**\n * Payload that needs to be sent to the mint when requesting a mint.\n */\nexport type MintRequest = {\n\t/**\n\t * Quote ID received from the mint.\n\t */\n\tquote: string;\n\t/**\n\t * Outputs (blinded messages) to be signed by the mint.\n\t */\n\toutputs: SerializedBlindedMessage[];\n\t/**\n\t * Optional. Signature for the Public key the quote is locked to (NUT-20)\n\t */\n\tsignature?: string;\n};\n\n/**\n * Response from the mint after requesting a mint.\n */\nexport type MintResponse = {\n\tsignatures: SerializedBlindedSignature[];\n};\n","import { type SerializedBlindedMessage, type SerializedBlindedSignature } from './blinded';\nimport { type Proof } from './proof';\n\nexport const MeltQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPENDING: 'PENDING',\n\tPAID: 'PAID',\n} as const;\nexport type MeltQuoteState = (typeof MeltQuoteState)[keyof typeof MeltQuoteState];\n\n/**\n * Base melt quote request - all melt quote requests have these fields (NUT-05)\n */\nexport type MeltQuoteBaseRequest = {\n\t/**\n\t * Unit to be melted.\n\t */\n\tunit: string;\n\t/**\n\t * Request to be melted to.\n\t */\n\trequest: string;\n};\n\n/**\n * Base melt quote response - all melt quotes have these fields (NUT-05)\n */\nexport type MeltQuoteBaseResponse = {\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * Amount to be melted.\n\t */\n\tamount: number;\n\t/**\n\t * Unit of the melt quote.\n\t */\n\tunit: string;\n\t/**\n\t * State of the melt quote.\n\t */\n\tstate: MeltQuoteState;\n\t/**\n\t * Timestamp of when the quote expires.\n\t */\n\texpiry: number;\n\t/**\n\t * Optional change from overpaid fees. If blanks were provided in `outputs`, the mint may return\n\t * signatures here.\n\t */\n\tchange?: SerializedBlindedSignature[];\n};\n\n/**\n * Generic Melt request payload.\n *\n * NUT-05 core fields plus optional blanks for overpayment change.\n */\nexport type MeltRequest = {\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * Proofs to melt.\n\t */\n\tinputs: Proof[];\n\t/**\n\t * Optional blanks for fee change. If present, the mint may return signatures in `change`.\n\t */\n\toutputs?: SerializedBlindedMessage[];\n} & Record<string, unknown>;\n","/**\n * Entries of CheckStateResponse with state of the proof.\n */\nexport type ProofState = {\n\tY: string;\n\tstate: CheckStateEnum;\n\twitness: string | null;\n};\n\n/**\n * Enum for the state of a proof.\n */\nexport const CheckStateEnum = {\n\tUNSPENT: 'UNSPENT',\n\tPENDING: 'PENDING',\n\tSPENT: 'SPENT',\n} as const;\nexport type CheckStateEnum = (typeof CheckStateEnum)[keyof typeof CheckStateEnum];\n\n/**\n * Response when checking proofs if they are spendable. Should not rely on this for receiving, since\n * it can be easily cheated.\n */\nexport type CheckStateResponse = {\n\tstates: ProofState[];\n};\n","import { MeltQuoteState, type MeltQuoteBaseResponse } from '../model/types';\nimport type { Logger } from '../logger';\n\nexport type MeltQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMeltQuoteResponseDeprecated<TQuote extends MeltQuoteBaseResponse>(\n\tresponse: TQuote & MeltQuoteResponsePaidDeprecated,\n\tlogger: Logger,\n): TQuote {\n\t// if the response has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tlogger.warn(\n\t\t\t\"Field 'state' not found in Melt quote response. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)\",\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MeltQuoteState.PAID : MeltQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import { type MintQuoteBolt11Response, MintQuoteState } from '../model/types';\nimport type { Logger } from '../logger';\n\nexport type MintQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMintQuoteResponseDeprecated(\n\tresponse: MintQuoteBolt11Response & MintQuoteResponsePaidDeprecated,\n\tlogger: Logger,\n): MintQuoteBolt11Response {\n\t// if the response has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tlogger.warn(\n\t\t\t\"Field 'state' not found in Mint quote response. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)\",\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MintQuoteState.PAID : MintQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import type { Logger } from '../logger';\nimport { type GetInfoResponse, type MintContactInfo } from '../model/types';\n\nexport function handleMintInfoContactFieldDeprecated(data: GetInfoResponse, logger: Logger) {\n\t// Monkey patch old contact field [\"email\", \"me@mail.com\"] Array<[string, string]>; to new contact field [{method: \"email\", info: \"me@mail.com\"}] Array<MintContactInfo>\n\t// This is to maintain backwards compatibility with older versions of the mint\n\tif (Array.isArray(data?.contact) && data?.contact.length > 0) {\n\t\tdata.contact = data.contact.map((contact: MintContactInfo) => {\n\t\t\tif (\n\t\t\t\tArray.isArray(contact) &&\n\t\t\t\tcontact.length === 2 &&\n\t\t\t\ttypeof contact[0] === 'string' &&\n\t\t\t\ttypeof contact[1] === 'string'\n\t\t\t) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117`,\n\t\t\t\t);\n\t\t\t\treturn { method: contact[0], info: contact[1] } as MintContactInfo;\n\t\t\t}\n\t\t\treturn contact;\n\t\t});\n\t}\n\treturn data;\n}\n","import {\n\ttype GetInfoResponse,\n\ttype MPPMethod,\n\ttype SwapMethod,\n\ttype WebSocketSupport,\n} from './types';\n\ntype Method = 'GET' | 'POST';\ntype Endpoint = { method: Method; path: string };\n\ntype ProtectedIndex = {\n\tcache: Record<string, boolean>; // \"METHOD /v1/foo\"\n\texact: Array<{ method: Method; path: string }>;\n\tprefix: Array<{ method: Method; path: string }>;\n};\n\nexport class MintInfo {\n\t// Full mint info response\n\tprivate readonly _mintInfo: GetInfoResponse;\n\t// NUT-22, Blind-auth protected endpoints\n\tprivate readonly _protected22?: ProtectedIndex;\n\t// NUT-21, Clear-auth protected endpoints\n\tprivate readonly _protected21?: ProtectedIndex;\n\n\tconstructor(info: GetInfoResponse) {\n\t\tthis._mintInfo = info;\n\n\t\tconst pe22 = this.toEndpoints(info?.nuts?.[22]?.protected_endpoints);\n\t\tthis._protected22 = this.buildIndex(pe22);\n\n\t\tconst pe21 = this.toEndpoints(info?.nuts?.[21]?.protected_endpoints);\n\t\tthis._protected21 = this.buildIndex(pe21);\n\t}\n\n\tisSupported(num: 4 | 5): { disabled: boolean; params: SwapMethod[] };\n\tisSupported(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20): { supported: boolean };\n\tisSupported(num: 17): { supported: boolean; params?: WebSocketSupport[] };\n\tisSupported(num: 15): { supported: boolean; params?: MPPMethod[] };\n\tisSupported(num: number) {\n\t\tswitch (num) {\n\t\t\tcase 4:\n\t\t\tcase 5: {\n\t\t\t\treturn this.checkMintMelt(num);\n\t\t\t}\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\tcase 9:\n\t\t\tcase 10:\n\t\t\tcase 11:\n\t\t\tcase 12:\n\t\t\tcase 14:\n\t\t\tcase 20: {\n\t\t\t\treturn this.checkGenericNut(num);\n\t\t\t}\n\t\t\tcase 17: {\n\t\t\t\treturn this.checkNut17();\n\t\t\t}\n\t\t\tcase 15: {\n\t\t\t\treturn this.checkNut15();\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error('nut is not supported by cashu-ts');\n\t\t\t}\n\t\t}\n\t}\n\n\trequiresBlindAuthToken(method: 'GET' | 'POST', path: string): boolean {\n\t\treturn this.matchesProtected(this._protected22, method, path);\n\t}\n\n\trequiresClearAuthToken(method: 'GET' | 'POST', path: string): boolean {\n\t\treturn this.matchesProtected(this._protected21, method, path);\n\t}\n\n\tprivate matchesProtected(idx: ProtectedIndex | undefined, method: Method, path: string): boolean {\n\t\tif (!idx) return false;\n\n\t\tconst cacheKey = `${method} ${path}`;\n\t\tconst cached = idx.cache[cacheKey];\n\t\tif (typeof cached === 'boolean') return cached;\n\n\t\tconst exactHit = idx.exact.some((e) => e.method === method && e.path === path);\n\t\tconst prefixHit = exactHit\n\t\t\t? false\n\t\t\t: idx.prefix.some((e) => e.method === method && path.startsWith(e.path));\n\n\t\tconst res = exactHit || prefixHit;\n\t\tidx.cache[cacheKey] = res;\n\t\treturn res;\n\t}\n\n\tprivate checkGenericNut(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20) {\n\t\treturn this._mintInfo.nuts[num]?.supported ? { supported: true } : { supported: false };\n\t}\n\n\tprivate checkMintMelt(num: 4 | 5) {\n\t\tconst mintMeltInfo = this._mintInfo.nuts[num];\n\t\tif (mintMeltInfo && mintMeltInfo.methods.length > 0 && !mintMeltInfo.disabled) {\n\t\t\treturn { disabled: false, params: mintMeltInfo.methods };\n\t\t}\n\t\treturn { disabled: true, params: mintMeltInfo?.methods ?? [] };\n\t}\n\n\tprivate checkNut17() {\n\t\tif (this._mintInfo.nuts[17] && this._mintInfo.nuts[17].supported.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[17].supported };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\n\tprivate checkNut15() {\n\t\tif (this._mintInfo.nuts[15] && this._mintInfo.nuts[15].methods.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[15].methods };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\n\t// ---------- private helpers ----------\n\n\tprivate toEndpoints(maybe: unknown): Endpoint[] {\n\t\tif (!Array.isArray(maybe)) return [];\n\t\tconst out: Endpoint[] = [];\n\t\tfor (const e of maybe) {\n\t\t\tif (e && typeof e === 'object') {\n\t\t\t\tconst rec = e as Record<string, unknown>;\n\t\t\t\tconst mm = rec.method;\n\t\t\t\tconst pp = rec.path;\n\t\t\t\tif (typeof mm === 'string' && typeof pp === 'string') {\n\t\t\t\t\tconst method = mm.toUpperCase();\n\t\t\t\t\tif (method === 'GET' || method === 'POST') {\n\t\t\t\t\t\tout.push({ method, path: pp });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\n\tprivate buildIndex(endpoints?: Endpoint[]): ProtectedIndex | undefined {\n\t\tif (!endpoints || endpoints.length === 0) return undefined;\n\n\t\tconst exact: ProtectedIndex['exact'] = [];\n\t\tconst prefix: ProtectedIndex['prefix'] = [];\n\n\t\tfor (const e of endpoints) {\n\t\t\tlet p = e.path;\n\t\t\tif (p.startsWith('^')) p = p.slice(1);\n\t\t\tif (p.endsWith('$')) p = p.slice(0, -1);\n\t\t\tif (p.endsWith('.*')) {\n\t\t\t\tprefix.push({ method: e.method, path: p.slice(0, -2) });\n\t\t\t} else {\n\t\t\t\texact.push({ method: e.method, path: p });\n\t\t\t}\n\t\t}\n\n\t\tconst cache: Record<string, boolean> = {};\n\t\treturn { cache, exact, prefix };\n\t}\n\n\t// ---------- getters ----------\n\n\tget cache(): GetInfoResponse {\n\t\treturn this._mintInfo;\n\t}\n\tget contact() {\n\t\treturn this._mintInfo.contact;\n\t}\n\tget description() {\n\t\treturn this._mintInfo.description;\n\t}\n\tget description_long() {\n\t\treturn this._mintInfo.description_long;\n\t}\n\tget name() {\n\t\treturn this._mintInfo.name;\n\t}\n\tget pubkey() {\n\t\treturn this._mintInfo.pubkey;\n\t}\n\tget nuts() {\n\t\treturn this._mintInfo.nuts;\n\t}\n\tget version() {\n\t\treturn this._mintInfo.version;\n\t}\n\tget motd() {\n\t\treturn this._mintInfo.motd;\n\t}\n\n\t/**\n\t * @deprecated Use supportsNut04Description(method, unit)\n\t */\n\tget supportsBolt12Description(): boolean {\n\t\treturn this.supportsNut04Description('bolt12');\n\t}\n\n\t/**\n\t * Checks if the mint supports creating invoices/offers with a description for the specified\n\t * payment method.\n\t *\n\t * @param method - The payment method to check ('bolt11' or 'bolt12')\n\t * @returns True if the mint supports description for the method, false otherwise.\n\t */\n\tsupportsNut04Description(method: 'bolt11' | 'bolt12', unit?: string): boolean {\n\t\treturn this._mintInfo.nuts[4]?.methods.some(\n\t\t\t(met) =>\n\t\t\t\tmet.method === method &&\n\t\t\t\t(unit ? met.unit === unit : true) &&\n\t\t\t\t(met.options?.description === true || met.description === true),\n\t\t);\n\t}\n\n\tsupportsAmountless(method: string = 'bolt11', unit: string = 'sat'): boolean {\n\t\tconst meltMethods = this._mintInfo?.nuts?.[5]?.methods ?? [];\n\n\t\tif (!Array.isArray(meltMethods)) return false;\n\n\t\treturn meltMethods.some(\n\t\t\t(met) => met.method === method && met.unit === unit && met.options?.amountless === true,\n\t\t);\n\t}\n}\n","import { randomBytes } from '@noble/curves/utils.js';\nimport { type Logger, NULL_LOGGER, safeCallback } from '../logger';\nimport { Bytes, encodeUint8toBase64Url } from '../utils';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { type GetInfoResponse } from '../model/types';\n\nexport type OIDCConfig = {\n\tissuer: string;\n\tauthorization_endpoint?: string;\n\ttoken_endpoint: string;\n\tdevice_authorization_endpoint?: string;\n};\n\nexport type TokenResponse = {\n\taccess_token?: string;\n\ttoken_type?: string;\n\texpires_in?: number;\n\trefresh_token?: string;\n\tid_token?: string;\n\tscope?: string;\n\terror?: string;\n\terror_description?: string;\n};\n\nexport type DeviceStartResponse = {\n\tdevice_code: string;\n\tuser_code: string;\n\tverification_uri: string;\n\tverification_uri_complete?: string;\n\tinterval?: number;\n\texpires_in?: number;\n};\n\nexport type OIDCAuthOptions = {\n\tclientId?: string;\n\tscope?: string;\n\tlogger?: Logger;\n\tonTokens?: (t: TokenResponse) => void | Promise<void>;\n};\n\nexport class OIDCAuth {\n\tprivate readonly discoveryUrl: string;\n\tprivate readonly logger: Logger;\n\n\tprivate clientId: string;\n\tprivate scope: string;\n\tprivate config?: OIDCConfig;\n\tprivate onTokens?: (t: TokenResponse) => void | Promise<void>;\n\n\t// External listeners, notified after onTokens fires\n\tprivate tokenListeners: Array<(t: TokenResponse) => void | Promise<void>> = [];\n\n\tstatic fromMintInfo(info: { nuts: GetInfoResponse['nuts'] }, opts?: OIDCAuthOptions): OIDCAuth {\n\t\tconst n21 = info?.nuts?.['21'];\n\t\tif (!n21?.openid_discovery) {\n\t\t\tthrow new Error('OIDCAuth: mint does not advertise NUT-21 openid_discovery');\n\t\t}\n\t\tconst clientId = opts?.clientId ?? n21.client_id ?? 'cashu-client';\n\t\treturn new OIDCAuth(n21.openid_discovery, { ...opts, clientId });\n\t}\n\n\tconstructor(discoveryUrl: string, opts?: OIDCAuthOptions) {\n\t\tthis.discoveryUrl = discoveryUrl;\n\t\tthis.logger = opts?.logger ?? NULL_LOGGER;\n\t\tthis.clientId = opts?.clientId ?? 'cashu-client';\n\t\tthis.scope = opts?.scope ?? 'openid';\n\t\tthis.onTokens = opts?.onTokens;\n\t}\n\n\tsetClient(id: string): void {\n\t\tthis.clientId = id;\n\t}\n\n\tsetScope(scope?: string): void {\n\t\tthis.scope = scope ?? 'openid';\n\t}\n\n\t/**\n\t * Subscribe to token updates. Listeners are called after the primary onTokens callback.\n\t */\n\taddTokenListener(fn: (t: TokenResponse) => void | Promise<void>): void {\n\t\tthis.tokenListeners.push(fn);\n\t}\n\n\t// ---- Discovery ----\n\n\tasync loadConfig(): Promise<OIDCConfig> {\n\t\tif (this.config) return this.config;\n\t\tconst res = await fetch(this.discoveryUrl, {\n\t\t\tmethod: 'GET',\n\t\t\theaders: { Accept: 'application/json' },\n\t\t});\n\t\tconst text = await res.text();\n\t\tlet json: unknown;\n\t\ttry {\n\t\t\tjson = text ? JSON.parse(text) : undefined;\n\t\t} catch (err) {\n\t\t\tthis.logger.warn('OIDCAuth: bad discovery JSON', { err });\n\t\t}\n\t\tif (!res.ok || !json) {\n\t\t\tthrow new Error('OIDCAuth: invalid discovery document');\n\t\t}\n\t\tconst cfg = json as OIDCConfig;\n\t\tif (typeof cfg.token_endpoint !== 'string' || cfg.token_endpoint.length === 0) {\n\t\t\tthrow new Error('OIDCAuth: invalid discovery document, missing token_endpoint');\n\t\t}\n\t\tthis.config = cfg;\n\t\treturn cfg;\n\t}\n\n\t// --- Authorization Code with PKCE ---\n\n\t/**\n\t * Generate a PKCE verifier and S256 challenge.\n\t *\n\t * - Verifier: base64url of random bytes, length >= 43, RFC 7636 compliant.\n\t * - Challenge: base64url(sha256(verifier))\n\t */\n\tgeneratePKCE(): { verifier: string; challenge: string } {\n\t\t// 48 bytes->base64url is typically 64 chars without padding, comfortably >= 43\n\t\tconst rnd = randomBytes(48);\n\t\tconst verifier = encodeUint8toBase64Url(rnd);\n\n\t\t// RFC 7636, challenge = BASE64URL-ENCODE( SHA256( ASCII(verifier) ) )\n\t\tconst vBytes = Bytes.fromString(verifier);\n\t\tconst chBytes = sha256(vBytes);\n\t\tconst challenge = encodeUint8toBase64Url(chBytes);\n\n\t\treturn { verifier, challenge };\n\t}\n\n\t/**\n\t * Build an Authorization Code + PKCE URL.\n\t */\n\tasync buildAuthCodeUrl(input: {\n\t\tredirectUri: string;\n\t\tcodeChallenge: string;\n\t\tcodeChallengeMethod?: 'S256' | 'plain'; // default S256\n\t\tstate?: string; // optional state to pass back to redirectUrl\n\t\tscope?: string; // default this.scope\n\t}): Promise<string> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst scope = input.scope ?? this.scope;\n\t\tconst params = new URLSearchParams({\n\t\t\tresponse_type: 'code',\n\t\t\tclient_id: this.clientId,\n\t\t\tredirect_uri: input.redirectUri,\n\t\t\tscope,\n\t\t\tcode_challenge_method: input.codeChallengeMethod ?? 'S256',\n\t\t\tcode_challenge: input.codeChallenge,\n\t\t});\n\t\tif (input.state) params.set('state', input.state);\n\n\t\tif (!cfg.authorization_endpoint) {\n\t\t\tthrow new Error('OIDCAuth: discovery lacks authorization_endpoint');\n\t\t}\n\t\treturn `${cfg.authorization_endpoint}?${params.toString()}`;\n\t}\n\n\t/**\n\t * Exchange an auth code for tokens, using the PKCE verifier.\n\t */\n\tasync exchangeAuthCode(input: { code: string; redirectUri: string; codeVerifier: string }) {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst form = this.toForm({\n\t\t\tgrant_type: 'authorization_code',\n\t\t\tcode: input.code,\n\t\t\tredirect_uri: input.redirectUri,\n\t\t\tclient_id: this.clientId,\n\t\t\tcode_verifier: input.codeVerifier,\n\t\t});\n\t\tconst tok = await this.postFormStrict<TokenResponse>(cfg.token_endpoint, form);\n\t\tthis.handleTokens(tok);\n\t\treturn tok;\n\t}\n\n\t// ---- Device Code (recommended for CLIs) ----\n\n\tasync deviceStart(): Promise<DeviceStartResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst ep = cfg.device_authorization_endpoint;\n\t\tif (!ep) throw new Error('OIDCAuth: provider lacks device_authorization_endpoint');\n\n\t\tconst form = this.toForm({ client_id: this.clientId, scope: this.scope });\n\t\treturn this.postFormStrict<DeviceStartResponse>(ep, form);\n\t}\n\n\tasync devicePoll(device_code: string, intervalSec = 5): Promise<TokenResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\t// Clamp to a sensible minimum to avoid hot loops\n\t\tlet delay = Math.max(1, intervalSec);\n\t\twhile (true) {\n\t\t\tawait this.sleep(delay * 1000);\n\t\t\tconst form = this.toForm({\n\t\t\t\tgrant_type: 'urn:ietf:params:oauth:grant-type:device_code',\n\t\t\t\tdevice_code,\n\t\t\t\tclient_id: this.clientId,\n\t\t\t});\n\t\t\tconst res = await this.postFormLoose<TokenResponse>(cfg.token_endpoint, form);\n\t\t\tif (res.access_token) {\n\t\t\t\tthis.handleTokens(res);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\tconst err = (res.error ?? '').toString();\n\t\t\tif (err === 'authorization_pending') continue;\n\t\t\tif (err === 'slow_down') {\n\t\t\t\tdelay = Math.max(delay + 5, delay * 2);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst msg = res.error_description || err || 'device authorization failed';\n\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t}\n\t}\n\n\t/**\n\t * One call convenience for Device Code flow.\n\t *\n\t * @remarks\n\t * Polling interval will be the MAX of intervalSec and Mint interval.\n\t * @param intervalSec Desired polling interval in seconds.\n\t * @returns The start fields and helpers to poll or cancel.\n\t */\n\tasync startDeviceAuth(intervalSec: number = 5): Promise<\n\t\tDeviceStartResponse & {\n\t\t\tpoll: () => Promise<TokenResponse>;\n\t\t\tcancel: () => void;\n\t\t}\n\t> {\n\t\tconst start = await this.deviceStart();\n\t\tconst interval = Math.max(start.interval ?? 1, intervalSec);\n\t\tlet aborted = false;\n\n\t\tconst poll = async (): Promise<TokenResponse> => {\n\t\t\tconst cfg = await this.loadConfig();\n\t\t\tlet delay = Math.max(1, interval);\n\t\t\twhile (true) {\n\t\t\t\tif (aborted) throw new Error('OIDCAuth: device polling cancelled');\n\t\t\t\tawait this.sleep(delay * 1000);\n\t\t\t\tconst form = this.toForm({\n\t\t\t\t\tgrant_type: 'urn:ietf:params:oauth:grant-type:device_code',\n\t\t\t\t\tdevice_code: start.device_code,\n\t\t\t\t\tclient_id: this.clientId,\n\t\t\t\t});\n\t\t\t\tconst res = await this.postFormLoose<TokenResponse>(cfg.token_endpoint, form);\n\t\t\t\tif (res.access_token) {\n\t\t\t\t\tthis.handleTokens(res);\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tconst err = (res.error ?? '').toString();\n\t\t\t\tif (err === 'authorization_pending') continue;\n\t\t\t\tif (err === 'slow_down') {\n\t\t\t\t\tdelay = Math.max(delay + 5, delay * 2);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst msg = res.error_description || err || 'device authorization failed';\n\t\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t\t}\n\t\t};\n\n\t\tconst cancel = (): void => {\n\t\t\taborted = true;\n\t\t};\n\n\t\treturn { ...start, poll, cancel };\n\t}\n\n\t// ---- Refresh ----\n\n\tasync refresh(refresh_token: string): Promise<TokenResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst form = this.toForm({\n\t\t\tgrant_type: 'refresh_token',\n\t\t\trefresh_token,\n\t\t\tclient_id: this.clientId,\n\t\t});\n\t\tconst tok = await this.postFormStrict<TokenResponse>(cfg.token_endpoint, form);\n\t\tthis.handleTokens(tok);\n\t\treturn tok;\n\t}\n\n\t// ---- ROPC (discouraged, but some mints allow it) ----\n\n\tasync passwordGrant(username: string, password: string): Promise<TokenResponse> {\n\t\tconst cfg = await this.loadConfig();\n\t\tconst form = this.toForm({\n\t\t\tgrant_type: 'password',\n\t\t\tclient_id: this.clientId,\n\t\t\tusername,\n\t\t\tpassword,\n\t\t\tscope: this.scope,\n\t\t});\n\t\tconst tok = await this.postFormStrict<TokenResponse>(cfg.token_endpoint, form);\n\t\tthis.handleTokens(tok);\n\t\treturn tok;\n\t}\n\n\t// ---- internals ----\n\n\t/**\n\t * Fire and forget token fan out. Any listener errors are logged inside safeCallback. Nothing\n\t * thrown here will come from listeners.\n\t */\n\tprivate handleTokens(t: TokenResponse): void {\n\t\tif (!t.access_token) {\n\t\t\tconst msg = t.error_description || t.error || 'token response missing access_token';\n\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t}\n\t\t// Schedule on microtask queue so we never block the caller and we avoid sync throws leaking.\n\t\tqueueMicrotask(() =>\n\t\t\tsafeCallback(this.onTokens, t, this.logger, { where: 'OIDCAuth.handleTokens' }),\n\t\t);\n\n\t\tfor (const listener of this.tokenListeners) {\n\t\t\tqueueMicrotask(() =>\n\t\t\t\tsafeCallback(listener, t, this.logger, {\n\t\t\t\t\twhere: 'OIDCAuth.handleTokens.listener',\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate toForm(params: Record<string, string>): string {\n\t\tconst enc = (v: string) => encodeURIComponent(v).replace(/%20/g, '+');\n\t\treturn Object.entries(params)\n\t\t\t.map(([k, v]) => `${enc(k)}=${enc(v)}`)\n\t\t\t.join('&');\n\t}\n\n\t// Strict, throws on non 2xx\n\tprivate async postFormStrict<TSuccess extends object>(\n\t\tendpoint: string,\n\t\tformBody: string,\n\t): Promise<TSuccess> {\n\t\ttry {\n\t\t\tthis.logger.debug('OIDCAuth Request', { formBody });\n\t\t\tconst res = await fetch(endpoint, {\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/x-www-form-urlencoded',\n\t\t\t\t\tAccept: 'application/json',\n\t\t\t\t},\n\t\t\t\tbody: formBody,\n\t\t\t});\n\t\t\tconst text = await res.text();\n\t\t\tlet json: unknown;\n\t\t\ttry {\n\t\t\t\tjson = text ? JSON.parse(text) : undefined;\n\t\t\t} catch (err) {\n\t\t\t\tthis.logger.warn('OIDCAuth: bad JSON (strict)', { err });\n\t\t\t}\n\t\t\tif (!res.ok) {\n\t\t\t\tconst err = (json ?? {}) as TokenResponse;\n\t\t\t\tconst msg = err.error_description || err.error || `HTTP ${res.status}`;\n\t\t\t\tthrow new Error(`OIDCAuth: ${msg}`);\n\t\t\t}\n\t\t\tthis.logger.debug('OIDCAuth Response', { json });\n\t\t\treturn (json ?? {}) as TSuccess;\n\t\t} catch (err) {\n\t\t\tthis.logger.error('OIDCAuth: postFormStrict failed', { err });\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t// Loose, returns JSON payload even on non 2xx\n\tprivate async postFormLoose<T extends object>(\n\t\tendpoint: string,\n\t\tformBody: string,\n\t): Promise<T | TokenResponse> {\n\t\ttry {\n\t\t\tthis.logger.debug('OIDCAuth Request', { formBody });\n\t\t\tconst res = await fetch(endpoint, {\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/x-www-form-urlencoded',\n\t\t\t\t\tAccept: 'application/json',\n\t\t\t\t},\n\t\t\t\tbody: formBody,\n\t\t\t});\n\t\t\tconst text = await res.text();\n\t\t\tlet json: unknown;\n\t\t\ttry {\n\t\t\t\tjson = text ? JSON.parse(text) : undefined;\n\t\t\t} catch (err) {\n\t\t\t\tthis.logger.warn('OIDCAuth: bad JSON (loose)', { err });\n\t\t\t}\n\t\t\tthis.logger.debug('OIDCAuth Response', { json });\n\t\t\treturn (json ?? {}) as T | TokenResponse;\n\t\t} catch (err) {\n\t\t\tthis.logger.error('OIDCAuth: postFormLoose network error', { err });\n\t\t\treturn { error: 'network_error', error_description: String(err) };\n\t\t}\n\t}\n\n\tprivate sleep(ms: number): Promise<void> {\n\t\treturn new Promise<void>((resolve) => setTimeout(resolve, ms));\n\t}\n}\n","/**\n * Cashu Mint Class.\n *\n * @remarks\n * You should ordinarily not need to instantiate a Mint, as it will be auto-instantiated by the\n * Wallet class when you pass in the mint url.\n */\nimport type {\n\tPostRestoreResponse,\n\tSwapResponse,\n\tCheckStatePayload,\n\tPostRestorePayload,\n} from './types';\nimport type { GetKeysResponse, GetKeysetsResponse } from '../model/types/keyset';\nimport request, {\n\tConnectionManager,\n\ttype WSConnection,\n\tsetRequestLogger,\n\ttype RequestFn,\n\ttype RequestOptions,\n} from '../transport';\nimport { isObj, joinUrls, sanitizeUrl } from '../utils';\nimport {\n\ttype MeltQuoteResponsePaidDeprecated,\n\thandleMeltQuoteResponseDeprecated,\n} from '../legacy/nut-05';\nimport {\n\ttype MintQuoteResponsePaidDeprecated,\n\thandleMintQuoteResponseDeprecated,\n} from '../legacy/nut-04';\nimport { handleMintInfoContactFieldDeprecated } from '../legacy/nut-06';\nimport { MintInfo } from '../model/MintInfo';\nimport { type Logger, NULL_LOGGER, failIf } from '../logger';\nimport type { AuthProvider } from '../auth/AuthProvider';\nimport { OIDCAuth, type OIDCAuthOptions } from '../auth/OIDCAuth';\nimport {\n\ttype MintQuoteBolt11Response,\n\ttype MintQuoteBolt12Response,\n\ttype MeltQuoteBaseResponse,\n\ttype MeltQuoteBolt11Response,\n\ttype MeltQuoteBolt12Response,\n\tMeltQuoteState,\n\ttype MintResponse,\n\ttype GetInfoResponse,\n\ttype MeltRequest,\n\ttype CheckStateResponse,\n\ttype MeltQuoteBolt11Request,\n\ttype MeltQuoteBolt12Request,\n\ttype MintRequest,\n\ttype MintQuoteBolt11Request,\n\ttype MintQuoteBolt12Request,\n\ttype SwapRequest,\n} from '../model/types';\n\n/**\n * Class represents Cashu Mint API.\n *\n * @remarks\n * This class contains lower-level functions that are implemented by Wallet.\n */\nclass Mint {\n\tprivate ws?: WSConnection;\n\tprivate _mintUrl: string;\n\tprivate _request: RequestFn;\n\tprivate _logger: Logger;\n\tprivate _mintInfo?: MintInfo;\n\tprivate _authProvider?: AuthProvider;\n\n\t/**\n\t * @param mintUrl Requires mint URL to create this object.\n\t * @param customRequest Optional, for custom network communication with the mint.\n\t * @param authTokenGetter Optional. Function to obtain a NUT-22 BlindedAuthToken (e.g. from a\n\t *   database or localstorage)\n\t */\n\tconstructor(\n\t\tmintUrl: string,\n\t\toptions?: {\n\t\t\tcustomRequest?: RequestFn;\n\t\t\tauthProvider?: AuthProvider;\n\t\t\tlogger?: Logger;\n\t\t},\n\t) {\n\t\tthis._mintUrl = sanitizeUrl(mintUrl);\n\t\tthis._request = options?.customRequest ?? request;\n\t\tthis._authProvider = options?.authProvider;\n\t\tthis._logger = options?.logger ?? NULL_LOGGER;\n\t\tsetRequestLogger(this._logger);\n\t}\n\n\tget mintUrl() {\n\t\treturn this._mintUrl;\n\t}\n\n\t/**\n\t * Create an OIDC client using this mintâ€™s NUT-21 metadata.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const oidc = await mint.oidcAuth({ onTokens: (t) => authMgr.setCAT(t.access_token!) });\n\t * const start = await oidc.deviceStart();\n\t * // show start.user_code / start.verification_uri to the user\n\t * const token = await oidc.devicePoll(start.device_code, start.interval ?? 5);\n\t * // token.access_token is your CAT\n\t * ```\n\t */\n\tasync oidcAuth(opts?: OIDCAuthOptions): Promise<OIDCAuth> {\n\t\tconst n21 = (await this.getLazyMintInfo()).nuts['21'];\n\t\tif (!n21?.openid_discovery) {\n\t\t\tthrow new Error('Mint: no NUT-21 openid_discovery');\n\t\t}\n\t\treturn new OIDCAuth(n21.openid_discovery, {\n\t\t\t...opts,\n\t\t\tclientId: opts?.clientId ?? n21.client_id ?? 'cashu-client',\n\t\t});\n\t}\n\n\t/**\n\t * Fetches mint's info at the /info endpoint.\n\t *\n\t * @param customRequest Optional override for the request function.\n\t * @returns The mint's information response.\n\t */\n\tasync getInfo(customRequest?: RequestFn): Promise<GetInfoResponse> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\tconst response = await requestInstance<GetInfoResponse>({\n\t\t\tendpoint: joinUrls(this._mintUrl, '/v1/info'),\n\t\t});\n\t\tconst data = handleMintInfoContactFieldDeprecated(response, this._logger);\n\t\treturn data;\n\t}\n\n\t/**\n\t * Lazily fetches and caches the mint's info if not already loaded.\n\t *\n\t * @returns The parsed MintInfo object.\n\t */\n\tasync getLazyMintInfo(): Promise<MintInfo> {\n\t\tif (this._mintInfo) {\n\t\t\treturn this._mintInfo;\n\t\t}\n\t\tconst data = await this.getInfo();\n\t\tthis._mintInfo = new MintInfo(data);\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Performs a swap operation with ecash inputs and outputs.\n\t *\n\t * @param swapPayload Payload containing inputs and outputs.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Signed outputs.\n\t */\n\tasync swap(swapPayload: SwapRequest, customRequest?: RequestFn): Promise<SwapResponse> {\n\t\tconst data = await this.requestWithAuth<SwapResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/swap',\n\t\t\t{ requestBody: swapPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'swap' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new mint quote from the mint.\n\t *\n\t * @param mintQuotePayload Payload for creating a new mint quote.\n\t * @param customRequest Optional override for the request function.\n\t * @returns A new mint quote containing a payment request for the specified amount and unit.\n\t */\n\tasync createMintQuoteBolt11(\n\t\tmintQuotePayload: MintQuoteBolt11Request,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MintQuoteBolt11Response> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tMintQuoteBolt11Response & MintQuoteResponsePaidDeprecated\n\t\t>('POST', '/v1/mint/quote/bolt11', { requestBody: mintQuotePayload }, customRequest);\n\t\tconst data = handleMintQuoteResponseDeprecated(response, this._logger);\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new BOLT12 mint quote from the mint using Lightning Network offers.\n\t *\n\t * @param mintQuotePayload Payload containing amount, unit, optional description, and required\n\t *   pubkey.\n\t * @param customRequest Optional override for the request function.\n\t * @returns A mint quote containing a BOLT12 offer.\n\t */\n\tasync createMintQuoteBolt12(\n\t\tmintQuotePayload: MintQuoteBolt12Request,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MintQuoteBolt12Response> {\n\t\tconst response = await this.requestWithAuth<MintQuoteBolt12Response>(\n\t\t\t'POST',\n\t\t\t'/v1/mint/quote/bolt12',\n\t\t\t{ requestBody: mintQuotePayload },\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The status of the mint quote, including payment details and state.\n\t */\n\tasync checkMintQuoteBolt11(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MintQuoteBolt11Response> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tMintQuoteBolt11Response & MintQuoteResponsePaidDeprecated\n\t\t>('GET', `/v1/mint/quote/bolt11/${quote}`, {}, customRequest);\n\n\t\tconst data = handleMintQuoteResponseDeprecated(response, this._logger);\n\t\treturn data;\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 mint quote from the mint.\n\t *\n\t * @param quote Quote ID to check.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Updated quote with current payment and issuance amounts.\n\t */\n\tasync checkMintQuoteBolt12(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MintQuoteBolt12Response> {\n\t\tconst response = await this.requestWithAuth<MintQuoteBolt12Response>(\n\t\t\t'GET',\n\t\t\t`/v1/mint/quote/bolt12/${quote}`,\n\t\t\t{},\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Mints new tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Serialized blinded signatures.\n\t */\n\tasync mintBolt11(mintPayload: MintRequest, customRequest?: RequestFn): Promise<MintResponse> {\n\t\tconst data = await this.requestWithAuth<MintResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/mint/bolt11',\n\t\t\t{ requestBody: mintPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'mintBolt11' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Mints new tokens using a BOLT12 quote by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the quote ID and outputs to get blind signatures on.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Serialized blinded signatures for the requested outputs.\n\t */\n\tasync mintBolt12(mintPayload: MintRequest, customRequest?: RequestFn): Promise<MintResponse> {\n\t\tconst data = await this.requestWithAuth<MintResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/mint/bolt12',\n\t\t\t{ requestBody: mintPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'mintBolt12' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new melt quote from the mint.\n\t *\n\t * @param meltQuotePayload Payload for creating a new melt quote.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The melt quote response.\n\t */\n\tasync createMeltQuoteBolt11(\n\t\tmeltQuotePayload: MeltQuoteBolt11Request,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MeltQuoteBolt11Response> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tMeltQuoteBolt11Response & MeltQuoteResponsePaidDeprecated\n\t\t>('POST', '/v1/melt/quote/bolt11', { requestBody: meltQuotePayload }, customRequest);\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, this._logger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string'\n\t\t) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'createMeltQuoteBolt11' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new BOLT12 melt quote from the mint for paying a Lightning Network offer. For\n\t * amount-less offers, specify the amount in options.amountless.amount_msat.\n\t *\n\t * @param meltQuotePayload Payload containing the BOLT12 offer to pay and unit.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Melt quote with amount, fee reserve, and payment state.\n\t */\n\tasync createMeltQuoteBolt12(\n\t\tmeltQuotePayload: MeltQuoteBolt12Request,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MeltQuoteBolt12Response> {\n\t\tconst response = await this.requestWithAuth<MeltQuoteBolt12Response>(\n\t\t\t'POST',\n\t\t\t'/v1/melt/quote/bolt12',\n\t\t\t{ requestBody: meltQuotePayload },\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Gets an existing melt quote.\n\t *\n\t * @param quote Quote ID.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The melt quote response.\n\t */\n\tasync checkMeltQuoteBolt11(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MeltQuoteBolt11Response> {\n\t\tconst response = await this.requestWithAuth<\n\t\t\tMeltQuoteBolt11Response & MeltQuoteResponsePaidDeprecated\n\t\t>('GET', `/v1/melt/quote/bolt11/${quote}`, {}, customRequest);\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, this._logger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string' ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'checkMeltQuoteBolt11' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 melt quote from the mint. Returns current payment state (UNPAID,\n\t * PENDING, or PAID) and payment preimage if paid.\n\t *\n\t * @param quote Quote ID to check.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Updated quote with current payment state and preimage if available.\n\t */\n\tasync checkMeltQuoteBolt12(\n\t\tquote: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<MeltQuoteBolt12Response> {\n\t\tconst response = await this.requestWithAuth<MeltQuoteBolt12Response>(\n\t\t\t'GET',\n\t\t\t`/v1/melt/quote/bolt12/${quote}`,\n\t\t\t{},\n\t\t\tcustomRequest,\n\t\t);\n\t\treturn response;\n\t}\n\n\t/**\n\t * Generic method to melt tokens using any payment method endpoint.\n\t *\n\t * @remarks\n\t * This method enables support for custom payment methods without modifying the Mint class. It\n\t * constructs the endpoint as `/v1/melt/{method}` and POSTs the payload. The response must contain\n\t * the common fields: quote, amount, fee_reserve, state, expiry.\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await mint.melt('bolt11', { quote: 'q1', inputs: [...], outputs: [...] });\n\t * const response = await mint.melt('custom-payment', { quote: 'c1', inputs: [...], outputs: [...] });\n\t * ```\n\t *\n\t * @param method The payment method (e.g., 'bolt11', 'bolt12', or custom method name).\n\t * @param meltPayload The melt payload containing inputs and optional outputs.\n\t * @param options.customRequest Optional override for the request function.\n\t * @param options.preferAsync Optional override to set 'respond-async' header.\n\t * @returns A response object with at least the required melt quote fields.\n\t */\n\tasync melt<TRes extends Record<string, unknown> = Record<string, unknown>>(\n\t\tmethod: string,\n\t\tmeltPayload: MeltRequest,\n\t\toptions?: {\n\t\t\tcustomRequest?: RequestFn;\n\t\t\tpreferAsync?: boolean;\n\t\t},\n\t): Promise<MeltQuoteBaseResponse & TRes> {\n\t\t// Set headers as needed\n\t\tconst headers: Record<string, string> = {\n\t\t\t...(options?.preferAsync ? { Prefer: 'respond-async' } : {}),\n\t\t};\n\t\t// Validate method string and make request\n\t\tfailIf(!this.isValidMethodString(method), `Invalid melt method: ${method}`, this._logger);\n\t\tconst data = await this.requestWithAuth<MeltQuoteBaseResponse & TRes>(\n\t\t\t'POST',\n\t\t\t`/v1/melt/${method}`,\n\t\t\t{ requestBody: meltPayload, headers },\n\t\t\toptions?.customRequest,\n\t\t);\n\n\t\t// Runtime shape check for basic MeltQuoteBaseResponse\n\t\t// TODO: - Tests need updating before we can do full shape check!\n\t\tif (\n\t\t\t!isObj(data) //||\n\t\t\t// typeof data.quote !== 'string' ||\n\t\t\t// typeof data.amount !== 'number' ||\n\t\t\t// typeof data.unit !== 'string' ||\n\t\t\t// typeof data.expiry !== 'number' ||\n\t\t\t// !Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'melt' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests the mint to pay for a Bolt11 payment request by providing ecash as inputs to be spent.\n\t * The inputs contain the amount and the fee_reserves for a Lightning payment. The payload can\n\t * also contain blank outputs in order to receive back overpaid Lightning fees.\n\t *\n\t * @param meltPayload The melt payload containing inputs and optional outputs.\n\t * @param options.customRequest Optional override for the request function.\n\t * @param options.preferAsync Optional override to set 'respond-async' header.\n\t * @returns The melt response.\n\t */\n\tasync meltBolt11(\n\t\tmeltPayload: MeltRequest,\n\t\toptions?: {\n\t\t\tcustomRequest?: RequestFn;\n\t\t\tpreferAsync?: boolean;\n\t\t},\n\t): Promise<MeltQuoteBolt11Response> {\n\t\tconst response = await this.melt<MeltQuoteBolt11Response>('bolt11', meltPayload, options);\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, this._logger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'meltBolt11' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests the mint to pay a BOLT12 offer by providing ecash inputs to be spent. The inputs must\n\t * cover the amount plus fee reserves. Optional outputs can be included to receive change for\n\t * overpaid Lightning fees.\n\t *\n\t * @param meltPayload Payload containing quote ID, inputs, and optional outputs for change.\n\t * @param options.customRequest Optional override for the request function.\n\t * @param options.preferAsync Optional override to set 'respond-async' header.\n\t * @returns Payment result with state and optional change signatures.\n\t */\n\tasync meltBolt12(\n\t\tmeltPayload: MeltRequest,\n\t\toptions?: {\n\t\t\tcustomRequest?: RequestFn;\n\t\t\tpreferAsync?: boolean;\n\t\t},\n\t): Promise<MeltQuoteBolt12Response> {\n\t\treturn this.melt<MeltQuoteBolt12Response>('bolt12', meltPayload, options);\n\t}\n\n\t/**\n\t * Checks if specific proofs have already been redeemed.\n\t *\n\t * @param checkPayload The payload containing proofs to check.\n\t * @param customRequest Optional override for the request function.\n\t * @returns Redeemed and unredeemed ordered list of booleans.\n\t */\n\tasync check(\n\t\tcheckPayload: CheckStatePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<CheckStateResponse> {\n\t\tconst data = await this.requestWithAuth<CheckStateResponse>(\n\t\t\t'POST',\n\t\t\t'/v1/checkstate',\n\t\t\t{ requestBody: checkPayload },\n\t\t\tcustomRequest,\n\t\t);\n\n\t\tif (!isObj(data) || !Array.isArray(data?.states)) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'check' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Get the mint's public keys.\n\t *\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @param mintUrl Optional alternative mint URL to use for this request.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The mint's public keys.\n\t */\n\tasync getKeys(\n\t\tkeysetId?: string,\n\t\tmintUrl?: string,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<GetKeysResponse> {\n\t\tconst targetUrl = mintUrl || this._mintUrl;\n\t\t// backwards compatibility for base64 encoded keyset ids\n\t\tif (keysetId) {\n\t\t\t// make the keysetId url safe\n\t\t\tkeysetId = keysetId.replace(/\\//g, '_').replace(/\\+/g, '-');\n\t\t}\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\tconst data = await requestInstance<GetKeysResponse>({\n\t\t\tendpoint: keysetId\n\t\t\t\t? joinUrls(targetUrl, '/v1/keys', keysetId)\n\t\t\t\t: joinUrls(targetUrl, '/v1/keys'),\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data.keysets)) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'getKeys' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Get the mint's keysets in no specific order.\n\t *\n\t * @param customRequest Optional override for the request function.\n\t * @returns All the mint's past and current keysets.\n\t */\n\tasync getKeySets(customRequest?: RequestFn): Promise<GetKeysetsResponse> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\treturn requestInstance<GetKeysetsResponse>({\n\t\t\tendpoint: joinUrls(this._mintUrl, '/v1/keysets'),\n\t\t});\n\t}\n\n\t/**\n\t * Restores proofs from the provided blinded messages.\n\t *\n\t * @param restorePayload The payload containing outputs to restore.\n\t * @param customRequest Optional override for the request function.\n\t * @returns The restore response with outputs and signatures.\n\t */\n\tasync restore(\n\t\trestorePayload: PostRestorePayload,\n\t\tcustomRequest?: RequestFn,\n\t): Promise<PostRestoreResponse> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\tconst data = await requestInstance<PostRestoreResponse>({\n\t\t\tendpoint: joinUrls(this._mintUrl, '/v1/restore'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: restorePayload,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.outputs) || !Array.isArray(data?.signatures)) {\n\t\t\tthis._logger.error('Invalid response from mint...', { data, op: 'restore' });\n\t\t\tthrow new Error('Invalid response from mint');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Tries to establish a websocket connection with the websocket mint url according to NUT-17.\n\t */\n\tasync connectWebSocket() {\n\t\ttry {\n\t\t\tconst mintUrl = new URL(this._mintUrl);\n\t\t\tconst wsSegment = 'v1/ws';\n\n\t\t\tif (mintUrl.pathname.endsWith('/')) mintUrl.pathname += wsSegment;\n\t\t\telse mintUrl.pathname += '/' + wsSegment;\n\n\t\t\t// preserve query params if any, and avoid manual string building\n\t\t\tmintUrl.protocol = mintUrl.protocol === 'https:' ? 'wss:' : 'ws:';\n\t\t\tconst wsUrl = mintUrl.toString();\n\n\t\t\tif (!this.ws) {\n\t\t\t\tthis.ws = ConnectionManager.getInstance().getConnection(wsUrl, this._logger);\n\t\t\t}\n\n\t\t\tawait this.ws.ensureConnection();\n\t\t} catch (e) {\n\t\t\tthis._logger.error('Failed to connect to WebSocket...', { e });\n\t\t\ttry {\n\t\t\t\tthis.ws?.close();\n\t\t\t} catch {\n\t\t\t\t// silence\n\t\t\t}\n\t\t\tthis.ws = undefined;\n\t\t\tthrow new Error('Failed to connect to WebSocket...');\n\t\t}\n\t}\n\n\t/**\n\t * Closes a websocket connection.\n\t */\n\tdisconnectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tthis.ws.close();\n\t\t}\n\t}\n\n\tget webSocketConnection() {\n\t\treturn this.ws;\n\t}\n\n\t/**\n\t * Returns the Clear Authentication Token (CAT) to use in the 'Clear-auth' header, or undefined if\n\t * not required for the given path and method.\n\t *\n\t * @param method The method to call on the path.\n\t * @param path The API path to check for blind auth requirement.\n\t * @returns The blind auth token if required, otherwise undefined.\n\t */\n\tprivate async handleClearAuth(method: 'GET' | 'POST', path: string): Promise<string | undefined> {\n\t\tif (!this._authProvider) return undefined;\n\t\tconst info = await this.getLazyMintInfo();\n\t\tif (!info.requiresClearAuthToken(method, path)) return undefined;\n\t\tthis._logger.error('Clear Authentication Token...', { cat: this._authProvider.getCAT() });\n\t\treturn this._authProvider.getCAT();\n\t}\n\n\t/**\n\t * Returns a serialized Blind Authentication Token (BAT) to use in the 'Blind-auth' header, or\n\t * undefined if not required for the given path and method.\n\t *\n\t * @param method The method to call on the path.\n\t * @param path The API path to check for blind auth requirement.\n\t * @returns The blind auth token if required, otherwise undefined.\n\t */\n\tprivate async handleBlindAuth(method: 'GET' | 'POST', path: string): Promise<string | undefined> {\n\t\tif (!this._authProvider) return undefined;\n\t\tconst info = await this.getLazyMintInfo();\n\t\tif (!info.requiresBlindAuthToken(method, path)) return undefined;\n\t\tconst bat = await this._authProvider.getBlindAuthToken({ method, path });\n\t\tthis._logger.error('Blind Authentication Token...', { bat });\n\t\treturn bat;\n\t}\n\n\tprivate async requestWithAuth<T>(\n\t\tmethod: 'GET' | 'POST',\n\t\tpath: string,\n\t\tinit: Omit<RequestOptions, 'endpoint' | 'method' | 'headers' | 'requestBody'> & {\n\t\t\trequestBody?: Record<string, unknown>;\n\t\t\theaders?: Record<string, string>;\n\t\t} = {},\n\t\tcustomRequest?: RequestFn,\n\t): Promise<T> {\n\t\tconst requestInstance = customRequest ?? this._request;\n\t\t// Get BAT/CAT token if this endpoint is protected\n\t\tconst bat = await this.handleBlindAuth(method, path);\n\t\tconst cat = await this.handleClearAuth(method, path);\n\t\tconst headers: Record<string, string> = {\n\t\t\t...(init.headers ?? {}),\n\t\t\t...(bat ? { 'Blind-auth': bat } : {}),\n\t\t\t...(cat ? { 'Clear-auth': cat } : {}),\n\t\t};\n\t\treturn requestInstance<T>({\n\t\t\t...init,\n\t\t\tendpoint: joinUrls(this._mintUrl, path),\n\t\t\tmethod,\n\t\t\theaders,\n\t\t});\n\t}\n\n\tprivate isValidMethodString(method: unknown): boolean {\n\t\t// Is a string at least one character long, containing only 0-9, a-z, _ or -\n\t\tif (typeof method === 'string' && /^[a-z0-9_-]+$/.test(method)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nexport { Mint };\n","import { isValidHex, deriveKeysetId, isBase64String } from '../utils';\nimport { type MintKeyset, type MintKeys } from '../model/types';\nimport { hexToBytes } from '@noble/curves/utils.js';\n\nexport class Keyset {\n\tprivate _id: string;\n\tprivate _unit: string;\n\tprivate _active: boolean;\n\tprivate _keys: Record<number, string> = {};\n\tprivate _input_fee_ppk?: number;\n\tprivate _final_expiry?: number;\n\n\tconstructor(\n\t\tid: string,\n\t\tunit: string,\n\t\tactive: boolean,\n\t\tinput_fee_ppk?: number,\n\t\tfinal_expiry?: number,\n\t) {\n\t\tthis._id = id;\n\t\tthis._unit = unit;\n\t\tthis._active = active;\n\t\tthis._input_fee_ppk = input_fee_ppk;\n\t\tthis._final_expiry = final_expiry;\n\t}\n\n\tget id(): string {\n\t\treturn this._id;\n\t}\n\n\tget unit(): string {\n\t\treturn this._unit;\n\t}\n\n\tget isActive(): boolean {\n\t\treturn this._active;\n\t}\n\n\tget fee(): number {\n\t\treturn this._input_fee_ppk ?? 0;\n\t}\n\n\tget expiry(): number | undefined {\n\t\treturn this._final_expiry;\n\t}\n\n\tget hasKeys(): boolean {\n\t\treturn Object.keys(this._keys).length > 0;\n\t}\n\n\tget hasHexId(): boolean {\n\t\treturn isValidHex(this._id);\n\t}\n\n\tget keys(): Record<number, string> {\n\t\treturn this._keys;\n\t}\n\n\tset keys(keys: Record<number, string>) {\n\t\tthis._keys = keys;\n\t}\n\n\t/**\n\t * @deprecated Use `isActive` instead.\n\t */\n\tget active(): boolean {\n\t\treturn this.isActive;\n\t}\n\n\t/**\n\t * @deprecated Use `fee` instead.\n\t */\n\tget input_fee_ppk(): number {\n\t\treturn this.fee;\n\t}\n\n\t/**\n\t * @deprecated Use `expiry` instead.\n\t */\n\tget final_expiry(): number | undefined {\n\t\treturn this.expiry;\n\t}\n\n\t/**\n\t * To Mint API MintKeyset format.\n\t *\n\t * @returns MintKeyset object.\n\t */\n\ttoMintKeyset(): MintKeyset {\n\t\treturn {\n\t\t\tid: this._id,\n\t\t\tunit: this._unit,\n\t\t\tactive: this._active,\n\t\t\tinput_fee_ppk: this._input_fee_ppk,\n\t\t\tfinal_expiry: this._final_expiry,\n\t\t};\n\t}\n\n\t/**\n\t * To Mint API MintKeys format.\n\t *\n\t * @returns MintKeys object.\n\t */\n\ttoMintKeys(): MintKeys | null {\n\t\tif (!this.hasKeys) {\n\t\t\treturn null;\n\t\t}\n\t\treturn {\n\t\t\tid: this._id,\n\t\t\tunit: this._unit,\n\t\t\tactive: this._active,\n\t\t\tinput_fee_ppk: this._input_fee_ppk,\n\t\t\tfinal_expiry: this._final_expiry,\n\t\t\tkeys: this._keys,\n\t\t};\n\t}\n\n\t/**\n\t * Verifies that the keyset's ID matches the derived ID from its keys, unit, and expiry.\n\t *\n\t * @returns True if verification succeeds, false otherwise (e.g: no keys or mismatch).\n\t */\n\tverify(): boolean {\n\t\tif (!this.hasKeys) {\n\t\t\treturn false;\n\t\t}\n\t\treturn Keyset.verifyKeysetId(this.toMintKeys()!);\n\t}\n\n\t/**\n\t * Verifies that a MintKeys DTO has a correct id for its keys/unit/expiry.\n\t *\n\t * @returns True if verification succeeds, false otherwise (e.g: no keys or mismatch).\n\t */\n\tstatic verifyKeysetId(keys: MintKeys): boolean {\n\t\tif (!keys.keys || Object.keys(keys.keys).length === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tconst isDeprecatedBase64 = isBase64String(keys.id) && !isValidHex(keys.id);\n\t\tconst versionByte = isValidHex(keys.id) ? hexToBytes(keys.id)[0] : 0;\n\t\tconst derivedId = deriveKeysetId(keys.keys, {\n\t\t\tinput_fee_ppk: keys.input_fee_ppk,\n\t\t\texpiry: keys.final_expiry,\n\t\t\tunit: keys.unit,\n\t\t\tversionByte,\n\t\t\tisDeprecatedBase64,\n\t\t});\n\t\treturn derivedId === keys.id;\n\t}\n\n\t/**\n\t * Create a Keyset from Mint API DTOs.\n\t *\n\t * @param meta The MintKeyset metadata from GetKeysetsResponse.\n\t * @param keys The MintKeys from GetKeysResponse.\n\t * @returns Keyset instance.\n\t */\n\tstatic fromMintApi(meta: MintKeyset, keys?: MintKeys): Keyset {\n\t\tconst ks = new Keyset(meta.id, meta.unit, meta.active, meta.input_fee_ppk, meta.final_expiry);\n\n\t\t// Sanity checks\n\t\tif (keys) {\n\t\t\tif (keys.id !== meta.id) {\n\t\t\t\tthrow new Error(`Mismatched keyset ids: meta=${meta.id}, keys=${keys.id}`);\n\t\t\t}\n\t\t\tif (keys.unit !== meta.unit) {\n\t\t\t\tthrow new Error(`Mismatched keyset units: meta=${meta.unit}, keys=${keys.unit}`);\n\t\t\t}\n\t\t\tif (\n\t\t\t\tkeys.final_expiry !== undefined &&\n\t\t\t\tmeta.final_expiry !== undefined &&\n\t\t\t\tkeys.final_expiry !== meta.final_expiry\n\t\t\t) {\n\t\t\t\tthrow new Error(`Mismatched keyset expiry for id=${meta.id}`);\n\t\t\t}\n\t\t\t// All good\n\t\t\tks.keys = keys.keys;\n\t\t}\n\t\treturn ks;\n\t}\n}\n","import { Keyset } from './Keyset';\nimport { Mint } from '../mint';\nimport type {\n\tMintKeyset,\n\tMintKeys,\n\tGetKeysetsResponse,\n\tGetKeysResponse,\n\tKeyChainCache,\n\tKeysetCache,\n} from '../model/types/keyset';\nimport { isValidHex } from '../utils';\n\n/**\n * Manages the unit-specific keysets for a Mint.\n *\n * @remarks\n * Will ONLY load keysets in the KeyChain unit.\n */\nexport class KeyChain {\n\tprivate mint: Mint;\n\tprivate unit: string;\n\tprivate keysets: { [id: string]: Keyset } = {};\n\n\tconstructor(\n\t\tmint: string | Mint,\n\t\tunit: string,\n\t\tcachedKeysets?: MintKeyset[],\n\t\tcachedKeys?: MintKeys[] | MintKeys,\n\t) {\n\t\tthis.mint = typeof mint === 'string' ? new Mint(mint) : mint;\n\t\tthis.unit = unit;\n\n\t\t// Legacy preload path using Mint API DTOs\n\t\tif (cachedKeysets && cachedKeys) {\n\t\t\tconst arrayOfKeys = Array.isArray(cachedKeys) ? cachedKeys : [cachedKeys];\n\t\t\tthis.buildKeychain(cachedKeysets, arrayOfKeys);\n\n\t\t\t// Smoke test, fail fast on bad cache\n\t\t\tthis.getCheapestKeyset();\n\t\t}\n\t}\n\n\t// ---------------------------------------------------------------------\n\t// Static helpers\n\t// ---------------------------------------------------------------------\n\n\t/**\n\t * Construct a KeyChain from previously cached data.\n\t *\n\t * @remarks\n\t * Does not hit the network. The cache should have been produced by `keyChain.cache`.\n\t */\n\tstatic fromCache(mint: string | Mint, cache: KeyChainCache): KeyChain {\n\t\tconst chain = new KeyChain(mint, cache.unit);\n\t\tchain.loadFromCache(cache);\n\t\treturn chain;\n\t}\n\n\t/**\n\t * Convert Mint API DTOs into a consolidated KeyChainCache.\n\t *\n\t * @remarks\n\t * This is symmetrical to {@link KeyChain.cacheToMintDTO}. It is used by the `cache` getter and any\n\t * code that wants to move from raw Mint DTOs to the new cache shape.\n\t */\n\tstatic mintToCacheDTO(\n\t\tunit: string,\n\t\tmintUrl: string,\n\t\tallKeysets: MintKeyset[],\n\t\tallKeys: MintKeys[],\n\t): KeyChainCache {\n\t\tconst keysById = new Map<string, MintKeys>(allKeys.map((k) => [k.id, k]));\n\t\tconst cacheKeysets: KeysetCache[] = allKeysets.map((meta) => {\n\t\t\tconst maybeKeys = keysById.get(meta.id);\n\t\t\tconst kc: KeysetCache = { ...meta };\n\t\t\tif (maybeKeys) {\n\t\t\t\tkc.keys = maybeKeys.keys;\n\t\t\t}\n\t\t\treturn kc;\n\t\t});\n\t\treturn {\n\t\t\tkeysets: cacheKeysets,\n\t\t\tunit,\n\t\t\tmintUrl,\n\t\t};\n\t}\n\n\t/**\n\t * Convert a KeyChainCache back into Mint API DTOs.\n\t *\n\t * @remarks\n\t * This is the inverse of {@link KeyChain.mintToCacheDTO} and is used by `loadFromCache` and the\n\t * deprecated `getCache()` wrapper.\n\t */\n\tstatic cacheToMintDTO(cache: KeyChainCache): {\n\t\tkeysets: MintKeyset[];\n\t\tkeys: MintKeys[];\n\t} {\n\t\tconst keysets: MintKeyset[] = cache.keysets.map((k) => ({\n\t\t\tid: k.id,\n\t\t\tunit: k.unit,\n\t\t\tactive: k.active,\n\t\t\tinput_fee_ppk: k.input_fee_ppk,\n\t\t\tfinal_expiry: k.final_expiry,\n\t\t}));\n\n\t\tconst keys: MintKeys[] = cache.keysets\n\t\t\t.filter((k): k is KeysetCache & { keys: NonNullable<KeysetCache['keys']> } => !!k.keys)\n\t\t\t.map((k) => ({\n\t\t\t\tid: k.id,\n\t\t\t\tunit: k.unit,\n\t\t\t\tactive: k.active,\n\t\t\t\tinput_fee_ppk: k.input_fee_ppk,\n\t\t\t\tfinal_expiry: k.final_expiry,\n\t\t\t\tkeys: k.keys,\n\t\t\t}));\n\n\t\treturn { keysets, keys };\n\t}\n\n\t// ---------------------------------------------------------------------\n\t// Mint loading\n\t// ---------------------------------------------------------------------\n\n\t/**\n\t * Asynchronously load keysets and keys from the mint.\n\t *\n\t * @remarks\n\t * Intended for callers that want the freshest data from the mint and can use an asynchronous\n\t * path.\n\t * @param forceRefresh If true, re-fetches data even if already loaded.\n\t */\n\tasync init(forceRefresh?: boolean): Promise<void> {\n\t\t// Skip if already loaded, unless force\n\t\tif (Object.keys(this.keysets).length > 0 && !forceRefresh) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fetch keys and keysets in parallel\n\t\tconst [allKeysetsResponse, allKeysResponse]: [GetKeysetsResponse, GetKeysResponse] =\n\t\t\tawait Promise.all([this.mint.getKeySets(), this.mint.getKeys()]);\n\n\t\tthis.buildKeychain(allKeysetsResponse.keysets, allKeysResponse.keysets);\n\n\t\t// Smoke test (will throw if init was unsuccessful)\n\t\tthis.getCheapestKeyset();\n\t}\n\n\t/**\n\t * Synchronously load keysets and keys from cached data.\n\t *\n\t * @remarks\n\t * Does not hit the network. Intended for callers that already have a KeyChainCache and want a\n\t * synchronous path.\n\t */\n\tloadFromCache(cache: KeyChainCache): void {\n\t\tif (cache.unit !== this.unit) {\n\t\t\tthrow new Error(\n\t\t\t\t`KeyChain unit mismatch in cache, expected '${this.unit}', got '${cache.unit}' from ${cache.mintUrl}`,\n\t\t\t);\n\t\t}\n\n\t\tconst { keysets, keys } = KeyChain.cacheToMintDTO(cache);\n\t\tthis.buildKeychain(keysets, keys);\n\n\t\t// Smoke test\n\t\tthis.getCheapestKeyset();\n\t}\n\n\t/**\n\t * Builds keychain from Mint Keyset and Keys data.\n\t *\n\t * @param allKeysets Keyset data from mint.getKeySets() API.\n\t * @param allKeys Keys data from mint.getKeys() API.\n\t */\n\tprivate buildKeychain(allKeysets: MintKeyset[], allKeys: MintKeys[]): void {\n\t\t// Clear existing keysets to avoid stale data\n\t\tthis.keysets = {};\n\n\t\t// Filter Keysets / Keys by unit\n\t\tconst unitKeysets = allKeysets.filter((k) => k.unit === this.unit);\n\t\tif (!unitKeysets.length) {\n\t\t\tthrow new Error(`No Keysets found for unit: ${this.unit}`);\n\t\t}\n\t\tconst keysMap = new Map<string, MintKeys>(\n\t\t\tallKeys.filter((k) => k.unit === this.unit).map((k) => [k.id, k]),\n\t\t);\n\n\t\t// Build keysets\n\t\tfor (const meta of unitKeysets) {\n\t\t\tlet keyset: Keyset;\n\n\t\t\t// Only active hex keysets should have keys\n\t\t\tif (meta.active && isValidHex(meta.id)) {\n\t\t\t\tconst mk = keysMap.get(meta.id);\n\t\t\t\tkeyset = Keyset.fromMintApi(meta, mk);\n\t\t\t} else {\n\t\t\t\tkeyset = Keyset.fromMintApi(meta);\n\t\t\t}\n\n\t\t\t// Validate active keysets with keys\n\t\t\tif (keyset.hasKeys && !keyset.verify()) {\n\t\t\t\tthrow new Error(`Keyset verification failed for ID ${keyset.id}`);\n\t\t\t}\n\n\t\t\t// Add to keychain\n\t\t\tthis.keysets[keyset.id] = keyset;\n\t\t}\n\t}\n\n\t// ---------------------------------------------------------------------\n\t// Queries\n\t// ---------------------------------------------------------------------\n\n\t/**\n\t * Get a keyset by ID or the cheapest keyset if no ID is provided.\n\t *\n\t * @param id Optional keyset ID.\n\t * @returns Keyset with keys.\n\t * @throws If keyset not found or uninitialized.\n\t */\n\tgetKeyset(id?: string): Keyset {\n\t\tconst keyset = id ? this.keysets[id] : this.getCheapestKeyset();\n\t\tif (!keyset) {\n\t\t\tthrow new Error(`Keyset '${id}' not found`);\n\t\t}\n\t\treturn keyset;\n\t}\n\n\t/**\n\t * Get the cheapest active keyset.\n\t *\n\t * @remarks\n\t * Selects active keyset with lowest fee and hex ID.\n\t * @returns Active Keyset.\n\t * @throws If none found or uninitialized.\n\t */\n\tgetCheapestKeyset(): Keyset {\n\t\tif (Object.keys(this.keysets).length === 0) {\n\t\t\tthrow new Error('KeyChain not initialized');\n\t\t}\n\t\tconst activeKeysets = Object.values(this.keysets).filter(\n\t\t\t(k) => k.isActive && k.hasHexId && k.hasKeys,\n\t\t);\n\t\tif (activeKeysets.length === 0) {\n\t\t\tthrow new Error('No active keyset found');\n\t\t}\n\t\treturn activeKeysets.sort((a, b) => a.fee - b.fee)[0];\n\t}\n\n\t/**\n\t * Get list of all keysets for the unit.\n\t *\n\t * @returns Array of Keysets.\n\t * @throws If uninitialized.\n\t */\n\tgetKeysets(): Keyset[] {\n\t\tif (Object.keys(this.keysets).length === 0) {\n\t\t\tthrow new Error('KeyChain not initialized');\n\t\t}\n\t\treturn Object.values(this.keysets);\n\t}\n\n\t/**\n\t * Returns all the keys in this KeyChain.\n\t *\n\t * @remarks\n\t * This mirrors the old `wallet.getAllKeys()` behaviour and is the preferred replacement in v3.\n\t * @returns Array of MintKeys objects.\n\t * @throws If uninitialized.\n\t */\n\tgetAllKeys(): MintKeys[] {\n\t\treturn this.getKeysets()\n\t\t\t.map((k) => k.toMintKeys())\n\t\t\t.filter((mk): mk is MintKeys => mk !== null);\n\t}\n\n\t/**\n\t * Returns all the keyset IDs in this KeyChain.\n\t *\n\t * @returns Array of keyset IDs.\n\t * @throws If uninitialized.\n\t */\n\tgetAllKeysetIds(): string[] {\n\t\treturn this.getKeysets().map((k) => k.id);\n\t}\n\n\t// ---------------------------------------------------------------------\n\t// Caching\n\t// ---------------------------------------------------------------------\n\n\t/**\n\t * Preferred consolidated cache representation.\n\t *\n\t * @remarks\n\t * Built from the live Keyset instances via their Mint DTO exporters. This is the canonical cache\n\t * API going forward.\n\t */\n\tget cache(): KeyChainCache {\n\t\tconst allKeysets: Keyset[] = this.getKeysets();\n\t\tconst metaList: MintKeyset[] = allKeysets.map((k) => k.toMintKeyset());\n\t\tconst keysList: MintKeys[] = allKeysets\n\t\t\t.map((k) => k.toMintKeys())\n\t\t\t.filter((mk): mk is MintKeys => mk !== null);\n\t\treturn KeyChain.mintToCacheDTO(this.unit, this.mint.mintUrl, metaList, keysList);\n\t}\n\n\t/**\n\t * Legacy Mint API cache format.\n\t *\n\t * @remarks\n\t * Useful for instantiating new wallets / keychains without repeatedly calling the mint API.\n\t * @deprecated Use the `cache` getter which returns a consolidated KeyChainCache.\n\t */\n\tgetCache(): {\n\t\tkeysets: MintKeyset[];\n\t\tkeys: MintKeys[];\n\t\tunit: string;\n\t\tmintUrl: string;\n\t} {\n\t\tconst cache = this.cache;\n\t\tconst { keysets, keys } = KeyChain.cacheToMintDTO(cache);\n\t\treturn {\n\t\t\tkeysets,\n\t\t\tkeys,\n\t\t\tunit: cache.unit,\n\t\t\tmintUrl: cache.mintUrl,\n\t\t};\n\t}\n}\n","import { type SerializedBlindedMessage } from './types/index';\nimport { type WeierstrassPoint } from '@noble/curves/abstract/weierstrass.js';\n\nclass BlindedMessage {\n\tamount: number;\n\tB_: WeierstrassPoint<bigint>;\n\tid: string;\n\tconstructor(amount: number, B_: WeierstrassPoint<bigint>, id: string) {\n\t\tthis.amount = amount;\n\t\tthis.B_ = B_;\n\t\tthis.id = id;\n\t}\n\tgetSerializedBlindedMessage(): SerializedBlindedMessage {\n\t\treturn { amount: this.amount, B_: this.B_.toHex(true), id: this.id };\n\t}\n}\nexport { BlindedMessage };\n","import {\n\ttype HasKeysetKeys,\n\ttype Proof,\n\ttype SerializedBlindedMessage,\n\ttype SerializedBlindedSignature,\n\ttype SerializedDLEQ,\n} from './types';\nimport { type P2PKOptions } from '../wallet';\nimport {\n\tblindMessage,\n\tconstructProofFromPromise,\n\tderiveP2BKBlindedPubkeys,\n\tderiveBlindingFactor,\n\tderiveSecret,\n\tpointFromHex,\n\tserializeProof,\n\ttype DLEQ,\n} from '../crypto';\nimport { BlindedMessage } from './BlindedMessage';\nimport { bytesToHex, hexToBytes, randomBytes } from '@noble/hashes/utils.js';\nimport { Bytes, numberToHexPadded64, splitAmount } from '../utils';\n\n// TODO(v4): Consider removing the generic and fixing `keyset` to `HasKeysetKeys`.\n// For now the generic preserves the relationship between factory input type and `toProof` keyset type,\n// and keeps narrower implementations assignable under `strictFunctionTypes`.\n\n/**\n * Note: OutputData helpers only require keyset `id` and `keys`. If you want richer keyset typing at\n * the call site, use `OutputDataLike<YourType>`.\n *\n * @remarks\n * WARNING: In v4 we may simplify this further by fixing the keyset type to `HasKeysetKeys` and\n * removing the generic.\n */\nexport interface OutputDataLike<TKeyset extends HasKeysetKeys = HasKeysetKeys> {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\ttoProof: (signature: SerializedBlindedSignature, keyset: TKeyset) => Proof;\n}\n\n/**\n * Note: OutputData helpers only require keyset `id` and `keys`. If you want richer keyset typing at\n * the call site, use `OutputDataLike<YourType>`.\n *\n * @remarks\n * WARNING: In v4 we may simplify this further by fixing the keyset type to `HasKeysetKeys` and\n * removing the generic.\n */\nexport type OutputDataFactory<TKeyset extends HasKeysetKeys = HasKeysetKeys> = (\n\tamount: number,\n\tkeys: TKeyset,\n) => OutputDataLike<TKeyset>;\n\n/**\n * Core P2PK tags that must not be settable in additional tags.\n *\n * @internal\n */\nexport const RESERVED_P2PK_TAGS = new Set([\n\t'locktime',\n\t'pubkeys',\n\t'n_sigs',\n\t'refund',\n\t'n_sigs_refund',\n]);\n\n/**\n * Asserts P2PK Tag key is valid.\n *\n * @param key Tag Key.\n * @throws If not a string, or is a reserved string.\n */\nexport function assertValidTagKey(key: string) {\n\tif (!key || typeof key !== 'string') throw new Error('tag key must be a non empty string');\n\tif (RESERVED_P2PK_TAGS.has(key)) {\n\t\tthrow new Error(`additionalTags must not use reserved key \"${key}\"`);\n\t}\n}\n\n/**\n * Maximum secret length.\n *\n * @remarks\n * Based on the Nutshell default mint_max_secret_length.\n * @internal\n */\nexport const MAX_SECRET_LENGTH = 1024;\n\nexport function isOutputDataFactory(\n\tvalue: OutputData[] | OutputDataFactory,\n): value is OutputDataFactory {\n\treturn typeof value === 'function';\n}\n\n// Holds the map of Pubkey blinding factors for a given OutputData\n// This avoids changing the shape of the OutputDataLike interface\nconst EPHEMERAL_E = new WeakMap<OutputData, string>(); // one-shot\nfunction setEphemeralE(target: OutputData, Ehex?: string) {\n\tif (Ehex) EPHEMERAL_E.set(target, Ehex);\n}\nfunction takeEphemeralE(target: OutputData): string | undefined {\n\tconst e = EPHEMERAL_E.get(target);\n\tif (!e) return;\n\tEPHEMERAL_E.delete(target); // one-shot to avoid leakage\n\treturn e;\n}\n\nexport class OutputData implements OutputDataLike<HasKeysetKeys> {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\tconstructor(\n\t\tblindedMessage: SerializedBlindedMessage,\n\t\tblindingFactor: bigint,\n\t\tsecret: Uint8Array,\n\t) {\n\t\tthis.secret = secret;\n\t\tthis.blindingFactor = blindingFactor;\n\t\tthis.blindedMessage = blindedMessage;\n\t}\n\n\ttoProof(sig: SerializedBlindedSignature, keyset: HasKeysetKeys) {\n\t\tlet dleq: DLEQ | undefined;\n\t\tif (sig.dleq) {\n\t\t\tdleq = {\n\t\t\t\ts: hexToBytes(sig.dleq.s),\n\t\t\t\te: hexToBytes(sig.dleq.e),\n\t\t\t\tr: this.blindingFactor,\n\t\t\t};\n\t\t}\n\t\tconst blindSignature = {\n\t\t\tid: sig.id,\n\t\t\tamount: sig.amount,\n\t\t\tC_: pointFromHex(sig.C_),\n\t\t\tdleq: dleq,\n\t\t};\n\t\tconst A = pointFromHex(keyset.keys[sig.amount]);\n\t\tconst proof = constructProofFromPromise(blindSignature, this.blindingFactor, this.secret, A);\n\t\tconst serializedProof = {\n\t\t\t...serializeProof(proof),\n\t\t\t...(dleq && {\n\t\t\t\tdleq: {\n\t\t\t\t\ts: bytesToHex(dleq.s),\n\t\t\t\t\te: bytesToHex(dleq.e),\n\t\t\t\t\tr: numberToHexPadded64(dleq.r ?? BigInt(0)),\n\t\t\t\t} as SerializedDLEQ,\n\t\t\t}),\n\t\t} as Proof;\n\n\t\t// Add P2BK (Pay to Blinded Key) blinding factors if needed\n\t\tconst Ehex = takeEphemeralE(this);\n\t\tif (Ehex) serializedProof.p2pk_e = Ehex;\n\n\t\treturn serializedProof;\n\t}\n\n\tstatic createP2PKData<T extends HasKeysetKeys>(\n\t\tp2pk: P2PKOptions,\n\t\tamount: number,\n\t\tkeyset: T,\n\t\tcustomSplit?: number[],\n\t) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleP2PKData(p2pk, a, keyset.id));\n\t}\n\n\tstatic createSingleP2PKData(p2pk: P2PKOptions, amount: number, keysetId: string) {\n\t\t// normalise keys and clamp required signature counts to available keys\n\t\tconst lockKeys: string[] = Array.isArray(p2pk.pubkey) ? p2pk.pubkey : [p2pk.pubkey];\n\t\tconst refundKeys: string[] = p2pk.refundKeys ?? [];\n\t\tconst reqLock = Math.max(1, Math.min(p2pk.requiredSignatures ?? 1, lockKeys.length));\n\t\tconst reqRefund = Math.max(\n\t\t\t1,\n\t\t\tMath.min(p2pk.requiredRefundSignatures ?? 1, refundKeys.length || 1),\n\t\t);\n\t\t// Sanity check - we always need at least one locking key\n\t\tif (lockKeys.length === 0) {\n\t\t\tthrow new Error('P2PK requires at least one pubkey');\n\t\t}\n\n\t\t// Init vars\n\t\tconst isHTLC = typeof p2pk.hashlock === 'string' && p2pk.hashlock.length > 0;\n\t\tlet data = isHTLC ? (p2pk.hashlock as string) : lockKeys[0];\n\t\tlet pubkeys = isHTLC ? lockKeys : lockKeys.slice(1);\n\t\tlet refund = refundKeys;\n\n\t\t// Optional key blinding (P2BK)\n\t\tlet Ehex: string | undefined;\n\t\tif (p2pk.blindKeys) {\n\t\t\tconst ordered = [...lockKeys, ...refundKeys];\n\t\t\tconst { blinded, Ehex: _E } = deriveP2BKBlindedPubkeys(ordered, keysetId);\n\t\t\tif (isHTLC) {\n\t\t\t\t// hashlock is in data, all locking keys into pubkeys\n\t\t\t\tpubkeys = blinded.slice(0, lockKeys.length);\n\t\t\t} else {\n\t\t\t\t// first locking key in data, rest into pubkeys\n\t\t\t\tdata = blinded[0];\n\t\t\t\tpubkeys = blinded.slice(1, lockKeys.length);\n\t\t\t}\n\t\t\trefund = blinded.slice(lockKeys.length);\n\t\t\tEhex = _E;\n\t\t}\n\n\t\t// build P2PK Tags (NUT-11)\n\t\tconst tags: string[][] = [];\n\n\t\tconst ts = p2pk.locktime ?? NaN;\n\t\tif (Number.isSafeInteger(ts) && ts >= 0) {\n\t\t\ttags.push(['locktime', String(ts)]);\n\t\t}\n\n\t\tif (pubkeys.length > 0) {\n\t\t\ttags.push(['pubkeys', ...pubkeys]);\n\t\t\tif (reqLock > 1) {\n\t\t\t\ttags.push(['n_sigs', String(reqLock)]);\n\t\t\t}\n\t\t}\n\n\t\tif (refund.length > 0) {\n\t\t\ttags.push(['refund', ...refund]);\n\t\t\tif (reqRefund > 1) {\n\t\t\t\ttags.push(['n_sigs_refund', String(reqRefund)]);\n\t\t\t}\n\t\t}\n\n\t\tif (p2pk.sigFlag == 'SIG_ALL') {\n\t\t\ttags.push(['sigflag', 'SIG_ALL']);\n\t\t}\n\n\t\t// Append additional tags if any\n\t\tif (p2pk.additionalTags?.length) {\n\t\t\tconst normalized = p2pk.additionalTags.map(([k, ...vals]) => {\n\t\t\t\tassertValidTagKey(k); // Validate key\n\t\t\t\treturn [k, ...vals.map(String)]; // all to strings\n\t\t\t});\n\t\t\ttags.push(...normalized);\n\t\t}\n\n\t\t// Construct secret\n\t\tconst kind = isHTLC ? 'HTLC' : 'P2PK';\n\t\tconst newSecret: [string, { nonce: string; data: string; tags: string[][] }] = [\n\t\t\tkind,\n\t\t\t{\n\t\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\t\tdata,\n\t\t\t\ttags,\n\t\t\t},\n\t\t];\n\n\t\t// blind the message\n\t\tconst parsed = JSON.stringify(newSecret);\n\n\t\t// Check secret length, counting Unicode code points\n\t\t// Same semantics as Nutshell python: len(str)\n\t\tconst charCount = [...parsed].length;\n\t\tif (charCount > MAX_SECRET_LENGTH) {\n\t\t\tthrow new Error(`Secret too long (${charCount} characters), maximum is ${MAX_SECRET_LENGTH}`);\n\t\t}\n\t\t// blind the message\n\t\tconst secretBytes = new TextEncoder().encode(parsed);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\n\t\t// create OutputData\n\t\tconst od = new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\n\t\t// stash Ehex - we add it to Proof later @see: toProof()\n\t\tif (p2pk.blindKeys && Ehex) setEphemeralE(od, Ehex);\n\n\t\treturn od;\n\t}\n\n\tstatic createRandomData<T extends HasKeysetKeys>(\n\t\tamount: number,\n\t\tkeyset: T,\n\t\tcustomSplit?: number[],\n\t) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleRandomData(a, keyset.id));\n\t}\n\n\tstatic createSingleRandomData(amount: number, keysetId: string) {\n\t\tconst randomHex = bytesToHex(randomBytes(32));\n\t\tconst secretBytes = new TextEncoder().encode(randomHex);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\t}\n\n\tstatic createDeterministicData<T extends HasKeysetKeys>(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeyset: T,\n\t\tcustomSplit?: number[],\n\t): OutputData[] {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a, i) =>\n\t\t\tthis.createSingleDeterministicData(a, seed, counter + i, keyset.id),\n\t\t);\n\t}\n\n\t/**\n\t * @throws May throw if blinding factor is out of range. Caller should catch, increment counter,\n\t *   and retry per BIP32-style derivation.\n\t */\n\tstatic createSingleDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeysetId: string,\n\t) {\n\t\tconst secretBytes = deriveSecret(seed, keysetId, counter);\n\t\tconst secretBytesAsHex = bytesToHex(secretBytes);\n\t\tconst utf8SecretBytes = new TextEncoder().encode(secretBytesAsHex);\n\t\t// Note: Bytes.toBigInt is used here so invalid values bubble up as throws\n\t\t// for BIP32-style retry logic (caller increments counter and retries).\n\t\tconst deterministicR = Bytes.toBigInt(deriveBlindingFactor(seed, keysetId, counter));\n\t\tconst { r, B_ } = blindMessage(utf8SecretBytes, deterministicR);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tutf8SecretBytes,\n\t\t);\n\t}\n\n\t/**\n\t * Calculates the sum of amounts in an array of OutputDataLike objects.\n\t *\n\t * @param outputs Array of OutputDataLike objects.\n\t * @returns The total sum of amounts.\n\t */\n\tstatic sumOutputAmounts(outputs: OutputDataLike[]): number {\n\t\treturn outputs.reduce((sum, output) => sum + output.blindedMessage.amount, 0);\n\t}\n}\n","import { assertValidTagKey, OutputData } from '../model/OutputData';\nimport { type P2PKOptions, type P2PKTag } from './types/config';\nimport { type SigFlag } from '../crypto';\n\n// Accept 33 byte compressed (02|03...), or 32 byte x-only,\n// normalised to lowercase 33 byte with 02 prefix for x only\nfunction normalisePubkey(pk: string): string {\n\tconst hex = pk.toLowerCase();\n\tif (hex.length === 66 && (hex.startsWith('02') || hex.startsWith('03'))) return hex;\n\tif (hex.length === 64) return `02${hex}`;\n\tthrow new Error(\n\t\t`Invalid pubkey, expected 33 byte compressed or 32 byte x only, got length ${hex.length}`,\n\t);\n}\n\nfunction toUnixSeconds(input: Date | number): number {\n\tif (input instanceof Date) return Math.floor(input.getTime() / 1000);\n\treturn input < 1e12 ? Math.floor(input) : Math.floor(input / 1000); // > 1e12 = ms\n}\n\nexport class P2PKBuilder {\n\t// A Set enforces uniqueness and preserves insertion order, which means\n\t// the first added lock key also becomes primary (data) pubkey\n\tprivate lockSet = new Set<string>();\n\tprivate refundSet = new Set<string>();\n\tprivate locktime?: number;\n\tprivate nSigs?: number;\n\tprivate nSigsRefund?: number;\n\tprivate extraTags: P2PKTag[] = [];\n\tprivate _blindKeys?: boolean;\n\tprivate sigFlag?: SigFlag;\n\tprivate hashlock?: string;\n\n\taddLockPubkey(pk: string | string[]) {\n\t\tconst arr = Array.isArray(pk) ? pk : [pk];\n\t\tfor (const k of arr) this.lockSet.add(normalisePubkey(k));\n\t\treturn this;\n\t}\n\n\taddRefundPubkey(pk: string | string[]) {\n\t\tconst arr = Array.isArray(pk) ? pk : [pk];\n\t\tfor (const k of arr) this.refundSet.add(normalisePubkey(k));\n\t\treturn this;\n\t}\n\n\tlockUntil(when: Date | number) {\n\t\tthis.locktime = toUnixSeconds(when);\n\t\treturn this;\n\t}\n\n\trequireLockSignatures(n: number) {\n\t\tthis.nSigs = Math.max(1, Math.trunc(n));\n\t\treturn this;\n\t}\n\n\trequireRefundSignatures(n: number) {\n\t\tthis.nSigsRefund = Math.max(1, Math.trunc(n));\n\t\treturn this;\n\t}\n\n\taddTag(key: string, values?: string[] | string) {\n\t\tassertValidTagKey(key); //  Validate key\n\t\tconst vals = values === undefined ? [] : Array.isArray(values) ? values : [values];\n\t\tthis.extraTags.push([key, ...vals.map(String)]); // all to strings\n\t\treturn this;\n\t}\n\n\taddTags(tags: P2PKTag[]) {\n\t\tfor (const [k, ...vals] of tags) this.addTag(k, vals);\n\t\treturn this;\n\t}\n\t/**\n\t * @experimental\n\t */\n\tblindKeys() {\n\t\tthis._blindKeys = true;\n\t\treturn this;\n\t}\n\n\tsigAll() {\n\t\tthis.sigFlag = 'SIG_ALL';\n\t\treturn this;\n\t}\n\n\t/**\n\t * Converts a `P2PK` output into a NUT-14 `HTLC` kind output.\n\t */\n\taddHashlock(hashlock: string) {\n\t\tthis.hashlock = hashlock;\n\t\treturn this;\n\t}\n\n\ttoOptions(): P2PKOptions {\n\t\tconst locks = Array.from(this.lockSet);\n\t\tconst refunds = Array.from(this.refundSet);\n\n\t\tif (locks.length === 0) throw new Error('At least one lock pubkey is required');\n\t\tif (refunds.length > 0 && this.locktime === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t'Refund pubkeys require a locktime, add lockUntil(...) or remove refund keys',\n\t\t\t);\n\t\t}\n\n\t\tconst total = locks.length + refunds.length;\n\t\tif (total > 10)\n\t\t\tthrow new Error(`Too many pubkeys, ${total} provided, maximum allowed is 10 in total`);\n\n\t\t// Clamp required signatures to available keys\n\t\tconst reqLock = this.nSigs ? Math.min(Math.max(1, this.nSigs), locks.length) : undefined;\n\t\tconst reqRefund = this.nSigsRefund\n\t\t\t? Math.min(Math.max(1, this.nSigsRefund), Math.max(1, refunds.length))\n\t\t\t: undefined;\n\n\t\tconst pubkey: string | string[] = locks.length === 1 ? locks[0] : locks;\n\n\t\tconst p2pk: P2PKOptions = {\n\t\t\tpubkey,\n\t\t\t...(this.locktime !== undefined ? { locktime: this.locktime } : {}),\n\t\t\t...(refunds.length ? { refundKeys: refunds } : {}),\n\t\t\t...(reqLock && reqLock > 1 ? { requiredSignatures: reqLock } : {}),\n\t\t\t...(reqRefund && reqRefund > 1 ? { requiredRefundSignatures: reqRefund } : {}),\n\t\t\t...(this.extraTags.length ? { additionalTags: this.extraTags.slice() } : {}),\n\t\t\t...(this._blindKeys ? { blindKeys: true } : {}),\n\t\t\t...(this.sigFlag == 'SIG_ALL' ? { sigFlag: 'SIG_ALL' } : {}),\n\t\t\t...(this.hashlock ? { hashlock: this.hashlock } : {}),\n\t\t};\n\n\t\t// Ensure the secret is valid (not too long etc)\n\t\tconst smokeTest = OutputData.createSingleP2PKData(p2pk, 1, 'deedbeef');\n\t\tvoid smokeTest; // intentionally unused\n\n\t\treturn p2pk;\n\t}\n\n\tstatic fromOptions(opts: P2PKOptions): P2PKBuilder {\n\t\tconst b = new P2PKBuilder();\n\t\tconst locks = Array.isArray(opts.pubkey) ? opts.pubkey : [opts.pubkey];\n\t\tb.addLockPubkey(locks);\n\t\tif (opts.locktime !== undefined) b.lockUntil(opts.locktime);\n\t\tif (opts.refundKeys?.length) b.addRefundPubkey(opts.refundKeys);\n\t\tif (opts.requiredSignatures !== undefined) b.requireLockSignatures(opts.requiredSignatures);\n\t\tif (opts.requiredRefundSignatures !== undefined)\n\t\t\tb.requireRefundSignatures(opts.requiredRefundSignatures);\n\t\tif (opts.additionalTags?.length) b.addTags(opts.additionalTags);\n\t\tif (opts.blindKeys) b.blindKeys();\n\t\tif (opts.sigFlag == 'SIG_ALL') b.sigAll();\n\t\tif (opts.hashlock) b.addHashlock(opts.hashlock);\n\t\treturn b;\n\t}\n}\n","// Minimal types to avoid importing the whole wallet, keeps this module independent\nimport type { Proof } from '../model/types/proof';\nimport { fail, failIf, failIfNullish, type Logger, NULL_LOGGER, measureTime } from '../logger';\nimport { type SendResponse } from './types';\nimport { type KeyChain } from './KeyChain';\n\nexport type SelectProofs = (\n\tproofs: Proof[],\n\tamountToSend: number,\n\tkeyChain: KeyChain,\n\tincludeFees?: boolean,\n\texactMatch?: boolean,\n\tlogger?: Logger,\n) => SendResponse;\n\nexport const selectProofsRGLI: SelectProofs = (\n\tproofs: Proof[],\n\tamountToSend: number,\n\tkeyChain: KeyChain,\n\tincludeFees: boolean = false,\n\texactMatch: boolean = false,\n\t_logger: Logger = NULL_LOGGER,\n): SendResponse => {\n\t// Init vars\n\tconst MAX_TRIALS = 60; // 40-80 is optimal (per RGLI paper)\n\tconst MAX_OVRPCT = 0; // Acceptable close match overage (percent)\n\tconst MAX_OVRAMT = 0; // Acceptable close match overage (absolute)\n\tconst MAX_TIMEMS = 1000; // Halt new trials if over time (in ms)\n\tconst MAX_P2SWAP = 5000; // Max number of Phase 2 improvement swaps\n\tconst timer = measureTime(); // start the clock\n\tlet bestSubset: ProofWithFee[] | null = null;\n\tlet bestDelta = Infinity;\n\tlet bestAmount = 0;\n\tlet bestFeePPK = 0;\n\n\t/**\n\t * Helper Functions.\n\t */\n\tinterface ProofWithFee {\n\t\tproof: Proof;\n\t\texFee: number;\n\t\tppkfee: number;\n\t}\n\t// Looks up fee for a proof\n\tconst feeForProof = (proof: Proof): number => {\n\t\ttry {\n\t\t\treturn keyChain.getKeyset(proof.id).fee;\n\t\t} catch (e) {\n\t\t\tfail(`Could not get fee. No keyset found for keyset id: ${proof.id}`, _logger, {\n\t\t\t\terror: e,\n\t\t\t\tkeychain: keyChain.getKeysets(),\n\t\t\t});\n\t\t}\n\t};\n\t// Calculate net amount after fees\n\tconst sumExFees = (amount: number, feePPK: number): number => {\n\t\treturn amount - (includeFees ? Math.ceil(feePPK / 1000) : 0);\n\t};\n\t// Shuffle array for randomization\n\tconst shuffleArray = <T>(array: T[]): T[] => {\n\t\tconst shuffled = [...array];\n\t\tfor (let i = shuffled.length - 1; i > 0; i--) {\n\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n\t\t}\n\t\treturn shuffled;\n\t};\n\t// Performs a binary search on a sorted (ascending) array of ProofWithFee objects by exFee.\n\t// If lessOrEqual=true, returns the rightmost index where exFee <= value\n\t// If lessOrEqual=false, returns the leftmost index where exFee >= value\n\tconst binarySearchIndex = (\n\t\tarr: ProofWithFee[],\n\t\tvalue: number,\n\t\tlessOrEqual: boolean,\n\t): number | null => {\n\t\tlet left = 0,\n\t\t\tright = arr.length - 1,\n\t\t\tresult: number | null = null;\n\t\twhile (left <= right) {\n\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\tconst midValue = arr[mid].exFee;\n\t\t\tif (lessOrEqual ? midValue <= value : midValue >= value) {\n\t\t\t\tresult = mid;\n\t\t\t\tif (lessOrEqual) left = mid + 1;\n\t\t\t\telse right = mid - 1;\n\t\t\t} else {\n\t\t\t\tif (lessOrEqual) right = mid - 1;\n\t\t\t\telse left = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn lessOrEqual ? result : left < arr.length ? left : null;\n\t};\n\t// Insert into array of ProofWithFee objects sorted by exFee\n\tconst insertSorted = (arr: ProofWithFee[], obj: ProofWithFee): void => {\n\t\tconst value = obj.exFee;\n\t\tlet left = 0,\n\t\t\tright = arr.length;\n\t\twhile (left < right) {\n\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\tif (arr[mid].exFee < value) left = mid + 1;\n\t\t\telse right = mid;\n\t\t}\n\t\tarr.splice(left, 0, obj);\n\t};\n\t// \"Delta\" is the excess over amountToSend including fees\n\t// plus a tiebreaker to favour lower PPK keysets\n\t// NB: Solutions under amountToSend are invalid (delta: Infinity)\n\tconst calculateDelta = (amount: number, feePPK: number): number => {\n\t\tconst netSum = sumExFees(amount, feePPK);\n\t\tif (netSum < amountToSend) return Infinity; // no good\n\t\treturn amount + feePPK / 1000 - amountToSend;\n\t};\n\n\t/**\n\t * Pre-processing.\n\t */\n\tlet totalAmount = 0;\n\tlet totalFeePPK = 0;\n\tconst proofWithFees = proofs.map((p) => {\n\t\tconst ppkfee = feeForProof(p);\n\t\tconst exFee = includeFees ? p.amount - ppkfee / 1000 : p.amount;\n\t\tconst obj = { proof: p, exFee, ppkfee };\n\t\t// Sum all economical proofs (filtered below)\n\t\tif (!includeFees || exFee > 0) {\n\t\t\ttotalAmount += p.amount;\n\t\t\ttotalFeePPK += ppkfee;\n\t\t}\n\t\treturn obj;\n\t});\n\n\t// Filter uneconomical proofs (totals computed above)\n\tlet spendableProofs = includeFees ? proofWithFees.filter((obj) => obj.exFee > 0) : proofWithFees;\n\n\t// Sort by exFee ascending\n\tspendableProofs.sort((a, b) => a.exFee - b.exFee);\n\n\t// Remove proofs too large to be useful and adjust totals\n\t// Exact Match: Keep proofs where exFee <= amountToSend\n\t// Close Match: Keep proofs where exFee <= nextBiggerExFee\n\tif (spendableProofs.length > 0) {\n\t\tlet endIndex;\n\t\tif (exactMatch) {\n\t\t\tconst rightIndex = binarySearchIndex(spendableProofs, amountToSend, true);\n\t\t\tendIndex = rightIndex !== null ? rightIndex + 1 : 0;\n\t\t} else {\n\t\t\tconst biggerIndex = binarySearchIndex(spendableProofs, amountToSend, false);\n\t\t\tif (biggerIndex !== null) {\n\t\t\t\tconst nextBiggerExFee = spendableProofs[biggerIndex].exFee;\n\t\t\t\tconst rightIndex = binarySearchIndex(spendableProofs, nextBiggerExFee, true);\n\t\t\t\tfailIfNullish(rightIndex, 'Unexpected null rightIndex in binary search', _logger);\n\t\t\t\tendIndex = rightIndex + 1;\n\t\t\t} else {\n\t\t\t\t// Keep all proofs if all exFee < amountToSend\n\t\t\t\tendIndex = spendableProofs.length;\n\t\t\t}\n\t\t}\n\t\t// Adjust totals for removed proofs\n\t\tfor (let i = endIndex; i < spendableProofs.length; i++) {\n\t\t\ttotalAmount -= spendableProofs[i].proof.amount;\n\t\t\ttotalFeePPK -= spendableProofs[i].ppkfee;\n\t\t}\n\t\tspendableProofs = spendableProofs.slice(0, endIndex);\n\t}\n\n\t// Validate using precomputed totals\n\tconst totalNetSum = sumExFees(totalAmount, totalFeePPK);\n\tif (amountToSend <= 0 || amountToSend > totalNetSum) {\n\t\treturn { keep: proofs, send: [] };\n\t}\n\n\t// Max acceptable amount for non-exact matches\n\tconst maxOverAmount = Math.min(\n\t\tMath.ceil(amountToSend * (1 + MAX_OVRPCT / 100)),\n\t\tamountToSend + MAX_OVRAMT,\n\t\ttotalNetSum,\n\t);\n\n\t/**\n\t * RGLI algorithm: Runs multiple trials (up to MAX_TRIALS) Each trial starts with randomized\n\t * greedy subset (S) and then tries to improve that subset to get a valid solution. NOTE: Fees are\n\t * dynamic, based on number of proofs (PPK), so we perform all calculations based on net amounts.\n\t */\n\tfor (let trial = 0; trial < MAX_TRIALS; trial++) {\n\t\t// PHASE 1: Randomized Greedy Selection\n\t\t// Add proofs up to amountToSend (after adjusting for fees)\n\t\t// for exact match or the first amount over target otherwise\n\t\tconst S: ProofWithFee[] = [];\n\t\tlet amount = 0;\n\t\tlet feePPK = 0;\n\t\tfor (const obj of shuffleArray(spendableProofs)) {\n\t\t\tconst newAmount = amount + obj.proof.amount;\n\t\t\tconst newFeePPK = feePPK + obj.ppkfee;\n\t\t\tconst netSum = sumExFees(newAmount, newFeePPK);\n\t\t\tif (exactMatch && netSum > amountToSend) break;\n\t\t\tS.push(obj);\n\t\t\tamount = newAmount;\n\t\t\tfeePPK = newFeePPK;\n\t\t\tif (netSum >= amountToSend) break;\n\t\t}\n\n\t\t// PHASE 2: Local Improvement\n\t\t// Examine all the amounts found in the first phase, and find the\n\t\t// amount not in the current solution (others), which would get us\n\t\t// closest to the amountToSend.\n\n\t\t// Calculate the \"others\" array (note: spendableProofs is sorted ASC)\n\t\t// Using set.has() for filtering gives faster lookups: O(n+m)\n\t\t// Using array.includes() would be way slower: O(n*m)\n\t\tconst SSet = new Set(S);\n\t\tconst others = spendableProofs.filter((obj) => !SSet.has(obj));\n\t\t// Generate a random order for accessing the trial subset ('S')\n\t\tconst indices = shuffleArray(Array.from({ length: S.length }, (_, i) => i)).slice(\n\t\t\t0,\n\t\t\tMAX_P2SWAP,\n\t\t);\n\t\tfor (const i of indices) {\n\t\t\t// Exact or acceptable close match solution found?\n\t\t\tconst netSum = sumExFees(amount, feePPK);\n\t\t\tif (\n\t\t\t\tnetSum === amountToSend ||\n\t\t\t\t(!exactMatch && netSum >= amountToSend && netSum <= maxOverAmount)\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Get details for proof being replaced (objP), and temporarily\n\t\t\t// calculate the subset amount/fee with that proof removed.\n\t\t\tconst objP = S[i];\n\t\t\tconst tempAmount = amount - objP.proof.amount;\n\t\t\tconst tempFeePPK = feePPK - objP.ppkfee;\n\t\t\tconst tempNetSum = sumExFees(tempAmount, tempFeePPK);\n\t\t\tconst target = amountToSend - tempNetSum;\n\n\t\t\t// Find a better replacement proof (objQ) and swap it in\n\t\t\t// Exact match can only replace larger to close on the target\n\t\t\t// Close match can replace larger or smaller as needed, but will\n\t\t\t// not replace larger unless it closes on the target\n\t\t\tconst qIndex = binarySearchIndex(others, target, exactMatch);\n\t\t\tif (qIndex !== null) {\n\t\t\t\tconst objQ = others[qIndex];\n\t\t\t\tif (!exactMatch || objQ.exFee > objP.exFee) {\n\t\t\t\t\tif (target >= 0 || objQ.exFee <= objP.exFee) {\n\t\t\t\t\t\tS[i] = objQ;\n\t\t\t\t\t\tamount = tempAmount + objQ.proof.amount;\n\t\t\t\t\t\tfeePPK = tempFeePPK + objQ.ppkfee;\n\t\t\t\t\t\tothers.splice(qIndex, 1);\n\t\t\t\t\t\tinsertSorted(others, objP);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Update best solution\n\t\tconst delta = calculateDelta(amount, feePPK);\n\t\tif (delta < bestDelta) {\n\t\t\t_logger.debug(\n\t\t\t\t`selectProofsToSend: best solution found in trial #${trial} - amount: ${amount}, delta: ${delta}`,\n\t\t\t);\n\t\t\tbestSubset = [...S].sort((a, b) => b.exFee - a.exFee); // copy & sort\n\t\t\tbestDelta = delta;\n\t\t\tbestAmount = amount;\n\t\t\tbestFeePPK = feePPK;\n\n\t\t\t// \"PHASE 3\": Final check to make sure we haven't overpaid fees\n\t\t\t// and see if we can improve the solution. This is an adaptation\n\t\t\t// to the original RGLI, which helps us identify close match and\n\t\t\t// optimal fee solutions more consistently\n\t\t\tconst tempS = [...bestSubset]; // copy\n\t\t\twhile (tempS.length > 1 && bestDelta > 0) {\n\t\t\t\tconst objP = tempS.pop() as ProofWithFee;\n\t\t\t\tconst tempAmount = amount - objP.proof.amount;\n\t\t\t\tconst tempFeePPK = feePPK - objP.ppkfee;\n\t\t\t\tconst tempDelta = calculateDelta(tempAmount, tempFeePPK);\n\t\t\t\tif (tempDelta == Infinity) break;\n\t\t\t\tif (tempDelta < bestDelta) {\n\t\t\t\t\tbestSubset = [...tempS];\n\t\t\t\t\tbestDelta = tempDelta;\n\t\t\t\t\tbestAmount = tempAmount;\n\t\t\t\t\tbestFeePPK = tempFeePPK;\n\t\t\t\t\tamount = tempAmount;\n\t\t\t\t\tfeePPK = tempFeePPK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Check if solution is acceptable\n\t\tif (bestSubset && bestDelta < Infinity) {\n\t\t\tconst bestSum = sumExFees(bestAmount, bestFeePPK);\n\t\t\tif (\n\t\t\t\tbestSum === amountToSend ||\n\t\t\t\t(!exactMatch && bestSum >= amountToSend && bestSum <= maxOverAmount)\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Time limit reached?\n\t\tif (timer.elapsed() > MAX_TIMEMS) {\n\t\t\tfailIf(\n\t\t\t\texactMatch,\n\t\t\t\t'Proof selection took too long. Try again with a smaller proof set.',\n\t\t\t\t_logger,\n\t\t\t);\n\t\t\t_logger.warn('Proof selection took too long. Returning best selection so far.');\n\t\t\tbreak;\n\t\t}\n\t}\n\t// Return Result\n\tif (bestSubset && bestDelta < Infinity) {\n\t\tconst bestProofs = bestSubset.map((obj) => obj.proof);\n\t\tconst bestSubsetSet = new Set(bestProofs);\n\t\tconst keep = proofs.filter((p) => !bestSubsetSet.has(p));\n\t\t_logger.info(`Proof selection took ${timer.elapsed()}ms`);\n\t\treturn { keep, send: bestProofs };\n\t}\n\treturn { keep: proofs, send: [] };\n};\n","/**\n * Usable counters in range is [start, start+count-1]\n *\n * @example // Start: 5, count: 3 => 5,6,7.\n */\nexport interface CounterRange {\n\tstart: number;\n\tcount: number;\n}\n\n// CounterSource.ts\nexport interface CounterSource {\n\t/**\n\t * Reserve n counters for a keyset.\n\t *\n\t * N may be 0. In that case the call MUST NOT mutate state and MUST return { start: currentNext,\n\t * count: 0 }, effectively a read only peek of the cursor.\n\t */\n\treserve(keysetId: string, n: number): Promise<CounterRange>;\n\t/**\n\t * Monotonic bump, ensure the next counter is at least minNext.\n\t */\n\tadvanceToAtLeast(keysetId: string, minNext: number): Promise<void>;\n\t/**\n\t * Optional introspection.\n\t */\n\tsnapshot?(): Promise<Record<string, number>>;\n\t/**\n\t * Optional hard set, useful for tests or migrations.\n\t */\n\tsetNext?(keysetId: string, next: number): Promise<void>;\n}\n\n/**\n * Counter summary for an operation.\n *\n * - `keysetId` - of the transaction.\n * - `start` - beginning of reservation.\n * - `count` - number of reservations.\n * - `next` - counter available after reservation.\n *\n * @example // Start: 5, Count: 3 => 5,6,7. Next: 8.\n */\nexport type OperationCounters = {\n\tkeysetId: string;\n\tstart: number;\n\tcount: number;\n\tnext: number;\n};\n\n/**\n * In memory implementation with per keyset locks for atomic counters.\n */\nexport class EphemeralCounterSource implements CounterSource {\n\tprivate next = new Map<string, number>();\n\tprivate locks = new Map<string, Promise<void>>();\n\n\tconstructor(initial?: Record<string, number>) {\n\t\tif (initial) {\n\t\t\tfor (const [k, v] of Object.entries(initial)) this.next.set(k, v);\n\t\t}\n\t}\n\n\tprivate async withLock<T>(k: string, fn: () => T | Promise<T>): Promise<T> {\n\t\tconst prev = this.locks.get(k) ?? Promise.resolve();\n\t\tlet release!: () => void;\n\t\tconst p = new Promise<void>((resolve) => (release = resolve));\n\t\tconst chain = prev.then(() => p);\n\t\tthis.locks.set(k, chain);\n\t\ttry {\n\t\t\tawait prev;\n\t\t\treturn await fn();\n\t\t} finally {\n\t\t\trelease();\n\t\t\tif (this.locks.get(k) === chain) {\n\t\t\t\tthis.locks.delete(k);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync reserve(keysetId: string, n: number): Promise<CounterRange> {\n\t\tif (n < 0) throw new Error('reserve called with negative count');\n\t\treturn this.withLock(keysetId, () => {\n\t\t\tconst cur = this.next.get(keysetId) ?? 0;\n\t\t\tif (n === 0) return { start: cur, count: 0 }; // report current, do not move\n\t\t\tthis.next.set(keysetId, cur + n);\n\t\t\treturn { start: cur, count: n };\n\t\t});\n\t}\n\n\tasync advanceToAtLeast(keysetId: string, minNext: number): Promise<void> {\n\t\tawait this.withLock(keysetId, () => {\n\t\t\tconst cur = this.next.get(keysetId) ?? 0;\n\t\t\tif (minNext > cur) this.next.set(keysetId, minNext);\n\t\t});\n\t}\n\n\tasync setNext(keysetId: string, next: number): Promise<void> {\n\t\tawait this.withLock(keysetId, () => {\n\t\t\tif (next < 0) throw new Error('setNext: negative next not allowed');\n\t\t\tthis.next.set(keysetId, next);\n\t\t});\n\t}\n\n\tsnapshot(): Promise<Record<string, number>> {\n\t\treturn Promise.resolve(Object.fromEntries(this.next.entries()));\n\t}\n}\n","import {\n\ttype MeltQuoteBolt11Response,\n\ttype MeltQuoteBolt12Response,\n\ttype MeltQuoteBaseResponse,\n\ttype MintQuoteBolt12Response,\n\ttype MintQuoteBolt11Response,\n} from '../model/types';\nimport { type OutputDataLike, type OutputDataFactory } from '../model/OutputData';\nimport type { Proof } from '../model/types/proof';\nimport type { Token } from '../model/types/token';\nimport {\n\ttype OutputType,\n\ttype OutputConfig,\n\ttype SendConfig,\n\ttype ReceiveConfig,\n\ttype MintProofsConfig,\n\ttype P2PKOptions,\n\ttype OnCountersReserved,\n\ttype MeltProofsConfig,\n\ttype MeltProofsResponse,\n\ttype MeltPreview,\n} from './types';\nimport type { Wallet } from './Wallet';\n\nexport type MintMethod = 'bolt11' | 'bolt12';\n\nexport type MintQuoteFor<M extends MintMethod> = M extends 'bolt11'\n\t? string | MintQuoteBolt11Response\n\t: MintQuoteBolt12Response;\n\n/**\n * Fluent operations builder for a Wallet instance.\n *\n * @remarks\n * Provides chainable builders for sending, receiving, and minting. Each builder is single use. If\n * you do not customise an output side, the walletâ€™s policy defaults apply.\n */\nexport class WalletOps {\n\tconstructor(private wallet: Wallet) {}\n\tsend(amount: number, proofs: Proof[]) {\n\t\treturn new SendBuilder(this.wallet, amount, proofs);\n\t}\n\treceive(token: Token | string) {\n\t\treturn new ReceiveBuilder(this.wallet, token);\n\t}\n\tmintBolt11(amount: number, quote: MintQuoteFor<'bolt11'>) {\n\t\treturn new MintBuilder<'bolt11'>(this.wallet, 'bolt11', amount, quote);\n\t}\n\tmintBolt12(amount: number, quote: MintQuoteFor<'bolt12'>) {\n\t\treturn new MintBuilder<'bolt12'>(this.wallet, 'bolt12', amount, quote);\n\t}\n\tmeltBolt11(quote: MeltQuoteBolt11Response, proofs: Proof[]) {\n\t\treturn new MeltBuilder<MeltQuoteBolt11Response>(this.wallet, 'bolt11', quote, proofs);\n\t}\n\tmeltBolt12(quote: MeltQuoteBolt12Response, proofs: Proof[]) {\n\t\treturn new MeltBuilder<MeltQuoteBolt12Response>(this.wallet, 'bolt12', quote, proofs);\n\t}\n}\n\n/**\n * Builder for composing a send or swap.\n *\n * @remarks\n * If you only customise the send side, keep is omitted so the wallet may still attempt an offline\n * exact match selection where possible.\n * @example\n *\n *     const { keep, send } = await wallet.ops\n *     \t.send(5, proofs)\n *     \t.asDeterministic() // counter 0 means auto reserve via CounterSource\n *     \t.keepAsRandom()\n *     \t.includeFees(true) // sender pays receiverâ€™s future spend fee\n *     \t.run();\n */\nexport class SendBuilder {\n\tprivate sendOT?: OutputType;\n\tprivate keepOT?: OutputType;\n\tprivate config: SendConfig = {};\n\tprivate offlineExact?: { requireDleq: boolean };\n\tprivate offlineClose?: { requireDleq: boolean };\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate amount: number,\n\t\tprivate proofs: Proof[],\n\t) {}\n\n\t/**\n\t * Use random blinding for the sent outputs.\n\t *\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.sendOT = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use deterministic outputs for the sent proofs.\n\t *\n\t * @param counter Starting counter. Zero means auto reserve using the walletâ€™s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.sendOT = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use P2PK locked outputs for the sent proofs.\n\t *\n\t * @param options NUT 11 options like pubkey and locktime.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.sendOT = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a factory to generate OutputData for the sent proofs.\n\t *\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.sendOT = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Provide pre created OutputData for the sent proofs.\n\t *\n\t * @param data Fully formed OutputData. Their amounts must sum to the send amount, otherwise the\n\t *   wallet will throw.\n\t */\n\tasCustom(data: OutputDataLike[]) {\n\t\tthis.sendOT = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use random blinding for change outputs.\n\t *\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsRandom(denoms?: number[]) {\n\t\tthis.keepOT = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use deterministic outputs for change.\n\t *\n\t * @param counter Starting counter. Zero means auto reserve using the walletâ€™s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.keepOT = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use P2PK locked change (NUT 11).\n\t *\n\t * @param options Locking options applied to the kept proofs.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.keepOT = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a factory to generate OutputData for change.\n\t *\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tkeepAsFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.keepOT = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Provide pre created OutputData for change.\n\t *\n\t * @param data Fully formed OutputData for the keep (change) amount.\n\t */\n\tkeepAsCustom(data: OutputDataLike[]) {\n\t\tthis.keepOT = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Make the sender cover the receiverâ€™s future spend fee.\n\t *\n\t * @param on When true, include fees in the sent amount. Default true if called.\n\t */\n\tincludeFees(on = true) {\n\t\tthis.config.includeFees = on;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a specific keyset for the operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Private key(s) used to sign P2PK locked proofs.\n\t *\n\t * @param k Single key or array of multisig keys.\n\t */\n\tprivkey(k: string | string[]) {\n\t\tthis.config.privkey = k;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Provide existing proofs to help optimise denomination selection.\n\t *\n\t * @remarks\n\t * Has no effect if denominations (custom split) was specified.\n\t * @param p Proofs currently held by the wallet, used to hit denomination targets.\n\t */\n\tproofsWeHave(p: Proof[]) {\n\t\tthis.config.proofsWeHave = p;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Force a pure offline, exact match selection. No mint calls are made. If an exact match cannot\n\t * be found, this throws.\n\t *\n\t * @param requireDleq Only consider proofs with a DLEQ when true.\n\t */\n\tofflineExactOnly(requireDleq = false) {\n\t\tthis.offlineExact = { requireDleq };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Force a pure offline selection that allows a close match, overspend permitted per wallet RGLI.\n\t * No mint calls are made. Returns the best offline subset found, or throws if funds are\n\t * insufficient.\n\t *\n\t * @param requireDleq Only consider proofs with a DLEQ when true.\n\t */\n\tofflineCloseMatch(requireDleq = false) {\n\t\tthis.offlineClose = { requireDleq };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Prepare the swap to send.\n\t *\n\t * @remarks\n\t * Call `wallet.completeSwap(SwapPreview)` to complete the send.\n\t * @returns A SwapPreview containing inputs, outputs, amount, fee and unselectedProofs.\n\t */\n\tasync prepare() {\n\t\t// Construct an OutputConfig using default send if no customizations\n\t\tconst outputConfig: OutputConfig = {\n\t\t\tsend: this.sendOT ?? this.wallet.defaultOutputType(),\n\t\t\t...(this.keepOT ? { keep: this.keepOT } : {}),\n\t\t};\n\t\treturn this.wallet.prepareSwapToSend(this.amount, this.proofs, this.config, outputConfig);\n\t}\n\n\t/**\n\t * Execute the send.\n\t *\n\t * @returns The split result with kept and sent proofs.\n\t */\n\tasync run() {\n\t\t// If an offline mode is requested, forbid custom OutputTypes,\n\t\t// because offline uses existing proofs and cannot honour new outputs.\n\t\tif ((this.offlineExact || this.offlineClose) && (this.sendOT || this.keepOT)) {\n\t\t\tthrow new Error(\n\t\t\t\t'Offline selection cannot be combined with custom output types. Remove send/keep output configuration, or use an online swap.',\n\t\t\t);\n\t\t}\n\n\t\t// Strict offline, exact match only\n\t\tif (this.offlineExact) {\n\t\t\t// Sign if needed\n\t\t\tif (this.config.privkey) {\n\t\t\t\tthis.proofs = this.wallet.signP2PKProofs(this.proofs, this.config.privkey);\n\t\t\t}\n\t\t\treturn this.wallet.sendOffline(this.amount, this.proofs, {\n\t\t\t\tincludeFees: this.config.includeFees,\n\t\t\t\texactMatch: true,\n\t\t\t\trequireDleq: this.offlineExact.requireDleq,\n\t\t\t});\n\t\t}\n\n\t\t// Offline close match, may overshoot\n\t\tif (this.offlineClose) {\n\t\t\t// Sign if needed\n\t\t\tif (this.config.privkey) {\n\t\t\t\tthis.proofs = this.wallet.signP2PKProofs(this.proofs, this.config.privkey);\n\t\t\t}\n\t\t\treturn this.wallet.sendOffline(this.amount, this.proofs, {\n\t\t\t\tincludeFees: this.config.includeFees,\n\t\t\t\texactMatch: false,\n\t\t\t\trequireDleq: this.offlineClose.requireDleq,\n\t\t\t});\n\t\t}\n\n\t\t// Construct an OutputConfig using default send if no customizations\n\t\tconst outputConfig: OutputConfig = {\n\t\t\tsend: this.sendOT ?? this.wallet.defaultOutputType(),\n\t\t\t...(this.keepOT ? { keep: this.keepOT } : {}),\n\t\t};\n\t\treturn this.wallet.send(this.amount, this.proofs, this.config, outputConfig);\n\t}\n}\n\n/**\n * Builder for receiving a token.\n *\n * @remarks\n * If you do not call a type method, the walletâ€™s policy default is used.\n * @example\n *\n *     const proofs = await wallet.ops\n *     \t.receive(token)\n *     \t.asDeterministic() // counter 0 auto reserves\n *     \t.requireDleq(true)\n *     \t.run();\n */\nexport class ReceiveBuilder {\n\tprivate outputType?: OutputType;\n\tprivate config: ReceiveConfig = {};\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate token: Token | string,\n\t) {}\n\n\t/**\n\t * Use random blinding for the received outputs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.outputType = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use deterministic outputs for the received proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param counter Starting counter. Zero means auto reserve using the walletâ€™s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.outputType = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use P2PK locked outputs for the received proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param options NUT 11 options like pubkey and locktime.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.outputType = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a factory to generate OutputData for received proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.outputType = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Provide pre created OutputData for received proofs.\n\t *\n\t * @param data Fully formed OutputData for the final amount.\n\t */\n\tasCustom(data: OutputDataLike[]) {\n\t\tthis.outputType = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a specific keyset for the operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Require all incoming proofs to have a valid DLEQ for the selected keyset.\n\t *\n\t * @param on When true, proofs without DLEQ are rejected.\n\t */\n\trequireDleq(on = true) {\n\t\tthis.config.requireDleq = on;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Private key(s) used to sign P2PK locked incoming proofs.\n\t *\n\t * @param k Single key or array of multisig keys.\n\t */\n\tprivkey(k: string | string[]) {\n\t\tthis.config.privkey = k;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Provide existing proofs to help optimise denomination selection.\n\t *\n\t * @remarks\n\t * Has no effect if denominations (custom split) was specified.\n\t * @param p Proofs currently held by the wallet, used to hit denomination targets.\n\t */\n\tproofsWeHave(p: Proof[]) {\n\t\tthis.config.proofsWeHave = p;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Prepare the swap to receive.\n\t *\n\t * @remarks\n\t * Call `wallet.completeSwap(SwapPreview)` to complete the receive.\n\t * @returns A SwapPreview containing inputs, outputs, amount, and fee.\n\t */\n\tasync prepare() {\n\t\treturn this.wallet.prepareSwapToReceive(this.token, this.config, this.outputType);\n\t}\n\n\t/**\n\t * Execute the receive.\n\t *\n\t * @returns The new proofs.\n\t */\n\tasync run() {\n\t\treturn this.wallet.receive(this.token, this.config, this.outputType);\n\t}\n}\n\n/**\n * Builder for minting proofs from a quote.\n *\n * @remarks\n * Bolt12 requires privkey by default, bolt11 only for locked quotes. The compiler will throw an\n * error if bolt12 and privkey() is omitted: MintBuilder<\"bolt12\", false>' is not assignable...\n * @example\n *\n *     const proofs = await wallet.ops\n *     \t.mint(100, quote)\n *     \t.asDeterministic() // counter 0 auto reserves\n *     \t.onCountersReserved((info) => console.log(info))\n *     \t.privkey('sk')\n *     \t.run();\n */\nexport class MintBuilder<\n\tM extends MintMethod,\n\tHasPrivKey extends boolean = M extends 'bolt12' ? false : true,\n> {\n\tprivate outputType?: OutputType;\n\tprivate config: MintProofsConfig = {};\n\n\t// phantom field to satisfy linter (erased at emit)\n\tprivate readonly _hasPrivkey!: HasPrivKey;\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate method: M,\n\t\tprivate amount: number,\n\t\tprivate quote: MintQuoteFor<M>,\n\t) {\n\t\tvoid this._hasPrivkey; // intentionally unused (phantom field)\n\t}\n\n\t/**\n\t * Use random blinding for the minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.outputType = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use deterministic outputs for the minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param counter Starting counter. Zero means auto reserve using the walletâ€™s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.outputType = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use P2PK locked outputs for the minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param options NUT 11 options like pubkey and locktime.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.outputType = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a factory to generate OutputData for minted proofs.\n\t *\n\t * @remarks\n\t * If denoms specified, proofsWeHave() will have no effect.\n\t * @param factory OutputDataFactory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.outputType = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Provide pre created OutputData for minted proofs.\n\t *\n\t * @param data Fully formed OutputData for the final amount.\n\t */\n\tasCustom(data: OutputDataLike[]) {\n\t\tthis.outputType = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a specific keyset for the operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Private key to sign locked mint quotes.\n\t *\n\t * @param k Private key for locked quotes.\n\t */\n\tprivkey(k: string): MintBuilder<M, true> {\n\t\t// For bolt11 - privkey is sent in the config\n\t\t// For bolt12 - privkey is sent positionally in run()\n\t\tthis.config.privkey = k;\n\t\treturn this as MintBuilder<M, true>;\n\t}\n\n\t/**\n\t * Provide existing proofs to help optimise denomination selection.\n\t *\n\t * @remarks\n\t * Has no effect if denominations (custom split) was specified.\n\t * @param p Proofs currently held by the wallet, used to hit denomination targets.\n\t */\n\tproofsWeHave(p: Proof[]) {\n\t\tthis.config.proofsWeHave = p;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Execute minting against the quote.\n\t *\n\t * @remarks\n\t * This method can only be called for bolt12 quotes when .privkey() is set.\n\t * @returns The newly minted proofs.\n\t */\n\tasync run(this: MintBuilder<M, true>) {\n\t\t// BOLT 11\n\t\tif (this.method === 'bolt11') {\n\t\t\tconst quote = this.quote as string | MintQuoteBolt11Response;\n\t\t\t// For object quotes, enforce privkey when the quote is locked\n\t\t\tif (typeof quote !== 'string' && quote.pubkey && !this.config.privkey) {\n\t\t\t\tthrow new Error('privkey is required for locked BOLT11 mint quotes');\n\t\t\t}\n\t\t\treturn this.wallet.mintProofsBolt11(this.amount, quote, this.config, this.outputType);\n\t\t}\n\n\t\t// BOLT 12\n\t\tconst bolt12 = this.quote as MintQuoteBolt12Response;\n\t\tif (!this.config.privkey) {\n\t\t\tthrow new Error('privkey is required for BOLT12 mint quotes');\n\t\t}\n\t\treturn this.wallet.mintProofsBolt12(\n\t\t\tthis.amount,\n\t\t\tbolt12,\n\t\t\tthis.config.privkey,\n\t\t\tthis.config,\n\t\t\tthis.outputType,\n\t\t);\n\t}\n}\n\n/**\n * Builder for melting proofs to pay a Lightning invoice or BOLT12 offer.\n *\n * @remarks\n * Uses the generic prepareMelt / completeMelt flow under the hood, so it works for any NUT-05 style\n * melt quote, not just BOLT11 / BOLT12.\n * @example\n *\n * ```typescript\n * // Basic BOLT11 melt\n * await wallet.ops.meltBolt11(quote, proofs).run();\n *\n * // BOLT12 melt with deterministic change and NUT-08 blanks callback\n * await wallet.ops\n * \t.meltBolt12(quote12, proofs)\n * \t.asDeterministic() // counter 0 auto reserves\n * \t.onCountersReserved((info) => console.log('Reserved', info))\n * \t.run();\n * ```\n */\nexport class MeltBuilder<TQuote extends MeltQuoteBaseResponse = MeltQuoteBolt11Response> {\n\tprivate outputType?: OutputType;\n\tprivate config: MeltProofsConfig = {};\n\n\tconstructor(\n\t\tprivate wallet: Wallet,\n\t\tprivate method: string,\n\t\tprivate quote: TQuote,\n\t\tprivate proofs: Proof[],\n\t) {}\n\n\t/**\n\t * Use random blinding for change outputs.\n\t *\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasRandom(denoms?: number[]) {\n\t\tthis.outputType = { type: 'random', denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use deterministic outputs for change.\n\t *\n\t * @param counter Starting counter. Zero means auto reserve using the walletâ€™s CounterSource.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasDeterministic(counter = 0, denoms?: number[]) {\n\t\tthis.outputType = { type: 'deterministic', counter, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use P2PK-locked change (NUT-11).\n\t *\n\t * @param options NUT-11 locking options (e.g., pubkey, locktime).\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasP2PK(options: P2PKOptions, denoms?: number[]) {\n\t\tthis.outputType = { type: 'p2pk', options, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a factory to generate OutputData for change.\n\t *\n\t * @param factory Factory used to produce blinded messages.\n\t * @param denoms Optional custom split. Can be partial if you only need SOME specific amounts.\n\t */\n\tasFactory(factory: OutputDataFactory, denoms?: number[]) {\n\t\tthis.outputType = { type: 'factory', factory, denominations: denoms };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Provide pre-created OutputData for change.\n\t *\n\t * @param data Fully formed OutputData for the change amount.\n\t */\n\tasCustom(data: OutputDataLike[]) {\n\t\tthis.outputType = { type: 'custom', data };\n\t\treturn this;\n\t}\n\n\t/**\n\t * Use a specific keyset for the melt operation.\n\t *\n\t * @param id Keyset id to use for mint keys and fee lookup.\n\t */\n\tkeyset(id: string) {\n\t\tthis.config.keysetId = id;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Private key(s) used to sign P2PK locked proofs.\n\t *\n\t * @param k Single key or array of multisig keys.\n\t */\n\tprivkey(k: string | string[]) {\n\t\tthis.config.privkey = k;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Receive a callback once counters are atomically reserved for deterministic outputs.\n\t *\n\t * @param cb Called with OperationCounters when counters are reserved.\n\t */\n\tonCountersReserved(cb: OnCountersReserved) {\n\t\tthis.config.onCountersReserved = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Receive a callback when NUT-08 blanks (0-sat change outputs) are created for async melts.\n\t *\n\t * @remarks\n\t * You can persist these blanks and later call `wallet.completeMelt(blanks)` to finalize and\n\t * recover change once the invoice/offer is paid.\n\t * @deprecated Use prepare() instead of run() and store the MeltPreview instead.\n\t * @param cb Callback invoked with the created blanks payload.\n\t */\n\tonChangeOutputsCreated(cb: NonNullable<MeltProofsConfig['onChangeOutputsCreated']>) {\n\t\tthis.config.onChangeOutputsCreated = cb;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Prepare the melt.\n\t *\n\t * @remarks\n\t * Call `wallet.completeMelt(MeltPreview)` to complete the melt.\n\t * @returns A MeltPreview containing inputs, outputs, amount, and fee.\n\t */\n\tasync prepare(): Promise<MeltPreview<TQuote>> {\n\t\treturn await this.wallet.prepareMelt<TQuote>(\n\t\t\tthis.method,\n\t\t\tthis.quote,\n\t\t\tthis.proofs,\n\t\t\tthis.config,\n\t\t\tthis.outputType,\n\t\t);\n\t}\n\n\t/**\n\t * Execute the melt against the quote.\n\t *\n\t * @returns The melt result: `{ quote, change }`.\n\t */\n\tasync run(): Promise<MeltProofsResponse<TQuote>> {\n\t\t// Step 1, preview and allocate NUT-08 blanks\n\t\tconst preview = await this.wallet.prepareMelt<TQuote>(\n\t\t\tthis.method,\n\t\t\tthis.quote,\n\t\t\tthis.proofs,\n\t\t\tthis.config,\n\t\t\tthis.outputType,\n\t\t);\n\n\t\t// Step 2, sign if needed and complete the melt\n\t\treturn this.wallet.completeMelt(preview, this.config.privkey);\n\t}\n}\n","import type { Wallet } from './Wallet';\nimport type {\n\tProof,\n\tProofState,\n\tMeltQuoteBaseResponse,\n\tMeltQuoteBolt11Response,\n\tMintQuoteBolt11Response,\n} from '../model/types';\nimport { MintQuoteState, MeltQuoteState } from '../model/types';\nimport type { MeltBlanks } from './types';\nimport { hashToCurve } from '../crypto';\nimport { type OperationCounters } from './CounterSource';\nimport { safeCallback } from '../logger';\n\nexport type SubscriptionCanceller = () => void;\n\nexport type CancellerLike = SubscriptionCanceller | Promise<SubscriptionCanceller>;\n\nexport type SubscribeOpts = { signal?: AbortSignal };\n\ntype ErrorWithCause = Error & { cause?: unknown };\n\nfunction safeStringify(obj: unknown): string {\n\tconst seen = new WeakSet<object>();\n\ttry {\n\t\treturn JSON.stringify(obj, (_k: string, v: unknown) => {\n\t\t\tif (typeof v === 'object' && v !== null) {\n\t\t\t\tif (seen.has(v)) return '[Circular]';\n\t\t\t\tseen.add(v);\n\t\t\t}\n\t\t\treturn v; // returning `unknown` is fine\n\t\t});\n\t} catch {\n\t\treturn Object.prototype.toString.call(obj);\n\t}\n}\n\nfunction normalizeError(err: unknown): Error {\n\tif (err instanceof Error) return err;\n\tconst message = typeof err === 'string' ? err : safeStringify(err);\n\tconst e: ErrorWithCause = new Error(message);\n\te.cause = err;\n\treturn e;\n}\n\nfunction makeAbortError(): Error {\n\tconst e = new Error('Aborted');\n\tObject.defineProperty(e, 'name', { value: 'AbortError' });\n\treturn e;\n}\n\nfunction cancelSafely(c: CancellerLike | null | undefined): void {\n\tif (!c) return;\n\tvoid Promise.resolve(c)\n\t\t.then((fn) => {\n\t\t\ttry {\n\t\t\t\tfn();\n\t\t\t} catch {\n\t\t\t\t/* ignore canceller errors */\n\t\t\t}\n\t\t\treturn;\n\t\t})\n\t\t.catch(() => {\n\t\t\t/* ignore awaiting-canceller errors */\n\t\t});\n}\n\nexport class WalletEvents {\n\tconstructor(private wallet: Wallet) {}\n\n\t// Callbacks registered for Counters Reserved events\n\tprivate countersReservedHandlers = new Set<(payload: OperationCounters) => void>();\n\n\t// Callbacks registered for Melt blanks created events\n\tprivate meltBlanksHandlers = new Set<(payload: MeltBlanks<MeltQuoteBaseResponse>) => void>();\n\n\t// Binds an abort signal to each subscription canceller\n\tprivate withAbort(\n\t\tsignal: AbortSignal | undefined,\n\t\tcancel: SubscriptionCanceller,\n\t): SubscriptionCanceller {\n\t\tif (!signal) return cancel;\n\t\tif (signal.aborted) {\n\t\t\tcancel();\n\t\t\treturn () => {\n\t\t\t\t/* noop */\n\t\t\t};\n\t\t}\n\t\tconst onAbort = () => cancel();\n\t\tsignal.addEventListener('abort', onAbort, { once: true });\n\t\treturn () => {\n\t\t\tsignal.removeEventListener('abort', onAbort);\n\t\t\tcancel();\n\t\t};\n\t}\n\n\t// Subscribe to a quote-paid event and resolve when it fires.\n\t// Supports AbortSignal and timeout, and always cleans up.\n\tprivate waitUntilPaid<T>(\n\t\tsubscribeFn: (\n\t\t\tid: string,\n\t\t\tcb: (p: T) => void, // called when the entity becomes PAID\n\t\t\terr: (e: Error) => void, // called if the subscription itself errors\n\t\t\topts?: { signal?: AbortSignal },\n\t\t) => Promise<SubscriptionCanceller>,\n\t\tid: string, // identifier of the mint/melt/etc. to watch\n\t\topts?: SubscribeOpts & { timeoutMs?: number },\n\t\ttimeoutMsg = 'Timeout waiting for paid',\n\t): Promise<T> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet cancelP: Promise<SubscriptionCanceller> | null = null; // handle to unsub later\n\t\t\tlet to: ReturnType<typeof setTimeout> | null = null; // optional timeout timer\n\t\t\tlet done = false;\n\n\t\t\t// Common cleanup: cancels subscription, clears timer, detaches abort listener.\n\t\t\t// If an error is provided, rejects the promise with it.\n\t\t\tconst cleanup = (err?: unknown) => {\n\t\t\t\tif (done) return;\n\t\t\t\tdone = true;\n\t\t\t\tcancelSafely(cancelP);\n\t\t\t\tif (to) {\n\t\t\t\t\tclearTimeout(to);\n\t\t\t\t\tto = null;\n\t\t\t\t}\n\t\t\t\tif (opts?.signal) opts.signal.removeEventListener('abort', onAbort);\n\t\t\t\tif (err) reject(normalizeError(err));\n\t\t\t};\n\n\t\t\t// Abort handler produces a standardized AbortError and rejects.\n\t\t\tconst onAbort = () => cleanup(makeAbortError());\n\n\t\t\t// Hook up AbortSignal if provided.\n\t\t\tif (opts?.signal) {\n\t\t\t\tif (opts.signal.aborted) return onAbort(); // already aborted\n\t\t\t\topts.signal.addEventListener('abort', onAbort, { once: true });\n\t\t\t}\n\n\t\t\t// Start a timeout if requested.\n\t\t\tif (opts?.timeoutMs && opts.timeoutMs > 0) {\n\t\t\t\tto = setTimeout(() => cleanup(new Error(timeoutMsg)), opts.timeoutMs);\n\t\t\t}\n\n\t\t\t// Subscribe to the actual event. Canceller returned is saved to cancelP.\n\t\t\tcancelP = subscribeFn(\n\t\t\t\tid,\n\t\t\t\t(p) => {\n\t\t\t\t\tcleanup(); // clean up resources\n\t\t\t\t\tresolve(p); // resolve promise with payload\n\t\t\t\t},\n\t\t\t\t(e) => cleanup(e), // reject if subscription itself errors\n\t\t\t\t{ signal: opts?.signal }, // delegate abort to subscription as well\n\t\t\t);\n\n\t\t\t// catch errors starting the subscription\n\t\t\tvoid cancelP.catch((e) => cleanup(e));\n\t\t});\n\t}\n\n\t/**\n\t * Register a callback that fires whenever deterministic counters are reserved.\n\t *\n\t * Timing: the callback is invoked synchronously _after_ a successful reservation and _before_ the\n\t * enclosing wallet method returns. The wallet does **not** await your callback, it is\n\t * fire-and-forget.\n\t *\n\t * Responsibility for async work is on the consumer. If your handler calls an async function (e.g.\n\t * persisting `start + count` to storage), make sure to handle errors inside it to avoid unhandled\n\t * rejections.\n\t *\n\t * Typical use: persist `start + count` for the `keysetId` so counters survive restarts.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * wallet.on.countersReserved(({ keysetId, start, count, next }) => {\n\t * \tsaveNextToDb(keysetId, start + count); // handle async errors inside saveNextToDb\n\t * });\n\t * ```\n\t *\n\t * @param cb Handler called with { keysetId, start, count }.\n\t * @returns A function that unsubscribes the handler.\n\t */\n\tpublic countersReserved(\n\t\tcb: (payload: OperationCounters) => void,\n\t\topts?: SubscribeOpts,\n\t): SubscriptionCanceller {\n\t\tthis.countersReservedHandlers.add(cb);\n\t\tconst cancel = () => this.countersReservedHandlers.delete(cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\t/**\n\t * @internal\n\t */\n\tpublic _emitCountersReserved(payload: OperationCounters) {\n\t\tfor (const h of this.countersReservedHandlers) {\n\t\t\tsafeCallback(h, payload, this.wallet.logger, { event: 'countersReserved' });\n\t\t}\n\t}\n\n\t/**\n\t * Register a callback fired whenever NUT-08 blanks are created during a melt.\n\t *\n\t * Called synchronously right after blanks are prepared (before the melt request), and the wallet\n\t * does not await your handler.\n\t *\n\t * Typical use: persist `payload` so you can later call `wallet.completeMelt(payload)`.\n\t *\n\t * @deprecated Use wallet.prepareMelt() and store the MeltPreview instead.\n\t */\n\tpublic meltBlanksCreated(\n\t\tcb: (payload: MeltBlanks<MeltQuoteBaseResponse>) => void,\n\t\topts?: SubscribeOpts,\n\t): SubscriptionCanceller {\n\t\tthis.meltBlanksHandlers.add(cb);\n\t\tconst cancel = () => this.meltBlanksHandlers.delete(cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic _emitMeltBlanksCreated(payload: MeltBlanks<MeltQuoteBaseResponse>) {\n\t\tfor (const h of this.meltBlanksHandlers) {\n\t\t\tsafeCallback(h, payload, this.wallet.logger, { event: 'meltBlanksCreated' });\n\t\t}\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a mint quote's state changes.\n\t *\n\t * @param quoteIds List of mint quote IDs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a mint quote state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync mintQuoteUpdates(\n\t\tids: string[],\n\t\tcb: (p: MintQuoteBolt11Response) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.wallet.mint.connectWebSocket();\n\t\tconst ws = this.wallet.mint.webSocketConnection;\n\t\tif (!ws) throw new Error('Failed to establish WebSocket connection.');\n\n\t\tconst uniq = Array.from(new Set(ids));\n\t\tconst subId = ws.createSubscription({ kind: 'bolt11_mint_quote', filters: uniq }, cb, err);\n\t\tconst cancel = () => ws.cancelSubscription(subId, cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single mint quote gets paid.\n\t *\n\t * @param quoteId Mint quote id that should be subscribed to.\n\t * @param callback Callback function that will be called when this mint quote gets paid.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync mintQuotePaid(\n\t\tid: string,\n\t\tcb: (p: MintQuoteBolt11Response) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.mintQuoteUpdates(\n\t\t\t[id],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MintQuoteState.PAID) cb(p);\n\t\t\t},\n\t\t\terr,\n\t\t\topts,\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a melt quoteâ€™s state changes.\n\t *\n\t * @param quoteId Melt quote id that should be subscribed to.\n\t * @param callback Callback function that will be called when this melt quote gets paid.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync meltQuoteUpdates(\n\t\tids: string[],\n\t\tcb: (p: MeltQuoteBolt11Response) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.wallet.mint.connectWebSocket();\n\t\tconst ws = this.wallet.mint.webSocketConnection;\n\t\tif (!ws) throw new Error('Failed to establish WebSocket connection.');\n\n\t\tconst uniq = Array.from(new Set(ids));\n\t\tconst subId = ws.createSubscription({ kind: 'bolt11_melt_quote', filters: uniq }, cb, err);\n\t\tconst cancel = () => ws.cancelSubscription(subId, cb);\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single melt quote gets paid.\n\t *\n\t * @param quoteIds List of melt quote IDs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a melt quote state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync meltQuotePaid(\n\t\tid: string,\n\t\tcb: (p: MeltQuoteBolt11Response) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.meltQuoteUpdates(\n\t\t\t[id],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MeltQuoteState.PAID) cb(p);\n\t\t\t},\n\t\t\terr,\n\t\t\topts,\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a subscribed proof state changes.\n\t *\n\t * @param proofs List of proofs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a proof's state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync proofStateUpdates(\n\t\tproofs: Proof[],\n\t\tcb: (payload: ProofState & { proof: Proof }) => void,\n\t\terr: (e: Error) => void,\n\t\topts?: SubscribeOpts,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.wallet.mint.connectWebSocket();\n\t\tconst ws = this.wallet.mint.webSocketConnection;\n\t\tif (!ws) throw new Error('Failed to establish WebSocket connection.');\n\n\t\tconst enc = new TextEncoder();\n\t\tconst proofMap: Record<string, Proof> = {};\n\t\tfor (const p of proofs) {\n\t\t\tconst y = hashToCurve(enc.encode(p.secret)).toHex(true);\n\t\t\tproofMap[y] = p;\n\t\t}\n\t\tconst ys = Object.keys(proofMap);\n\n\t\tconst handler = (payload: ProofState) => {\n\t\t\tcb({ ...payload, proof: proofMap[payload.Y] });\n\t\t};\n\t\tconst subId = ws.createSubscription({ kind: 'proof_state', filters: ys }, handler, err);\n\t\tconst cancel = () => ws.cancelSubscription(subId, handler);\n\n\t\treturn this.withAbort(opts?.signal, cancel);\n\t}\n\n\t/**\n\t * Resolve once a mint quote transitions to PAID, with automatic unsubscription, optional abort\n\t * signal, and optional timeout.\n\t *\n\t * The underlying subscription is always cancelled after resolution or rejection, including on\n\t * timeout or abort.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const ac = new AbortController();\n\t * // Cancel if the user navigates away\n\t * window.addEventListener('beforeunload', () => ac.abort(), { once: true });\n\t *\n\t * try {\n\t * \tconst paid = await wallet.on.onceMintPaid(quoteId, {\n\t * \t\tsignal: ac.signal,\n\t * \t\ttimeoutMs: 60_000,\n\t * \t});\n\t * \tconsole.log('Mint paid, amount', paid.amount);\n\t * } catch (e) {\n\t * \tif ((e as Error).name === 'AbortError') {\n\t * \t\tconsole.log('User aborted');\n\t * \t} else {\n\t * \t\tconsole.error('Mint not paid', e);\n\t * \t}\n\t * }\n\t * ```\n\t *\n\t * @param id Mint quote id to watch.\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal to cancel the wait early.\n\t * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.\n\t * @returns A promise that resolves with the latest `MintQuoteBolt11Response` once PAID.\n\t */\n\tonceMintPaid(\n\t\tid: string,\n\t\topts?: { signal?: AbortSignal; timeoutMs?: number },\n\t): Promise<MintQuoteBolt11Response> {\n\t\treturn this.waitUntilPaid<MintQuoteBolt11Response>(\n\t\t\tthis.mintQuotePaid.bind(this),\n\t\t\tid,\n\t\t\topts,\n\t\t\t'Timeout waiting for mint paid',\n\t\t);\n\t}\n\n\t/**\n\t * Resolve when ANY of several mint quotes is PAID, cancelling the rest.\n\t *\n\t * Subscribes to all distinct ids, resolves with `{ id, quote }` for the first PAID, and cancels\n\t * all remaining subscriptions.\n\t *\n\t * Errors from individual subscriptions are ignored by default so a single noisy stream does not\n\t * abort the whole race. Set `failOnError: true` to reject on the first error instead. If all\n\t * subscriptions error and none paid, the promise rejects with the last seen error.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Race multiple quotes obtained from splitting a large top up\n\t * const { id, quote } = await wallet.on.onceAnyMintPaid(batchQuoteIds, {\n\t * \ttimeoutMs: 120_000,\n\t * });\n\t * console.log('First top up paid', id, quote.preimage?.length);\n\t * ```\n\t *\n\t * @param ids Array of mint quote ids (duplicates are ignored).\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal to cancel the wait early.\n\t * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.\n\t * @param opts.failOnError When true, reject on first error. Default false.\n\t * @returns A promise resolving to the id that won and its `MintQuoteBolt11Response`.\n\t */\n\tonceAnyMintPaid(\n\t\tids: string[],\n\t\topts?: { signal?: AbortSignal; timeoutMs?: number; failOnError?: boolean },\n\t): Promise<{ id: string; quote: MintQuoteBolt11Response }> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst unique = Array.from(new Set(ids));\n\t\t\tconst cancels: Map<string, CancellerLike> = new Map();\n\t\t\tlet to: ReturnType<typeof setTimeout> | null = null;\n\t\t\tlet lastError: unknown = null;\n\t\t\tlet fullyRegistered = false;\n\t\t\tlet done = false;\n\n\t\t\tconst cleanup = (err?: unknown) => {\n\t\t\t\tif (done) return;\n\t\t\t\tdone = true;\n\t\t\t\tfor (const c of cancels.values()) {\n\t\t\t\t\tcancelSafely(c);\n\t\t\t\t}\n\t\t\t\tcancels.clear();\n\t\t\t\tif (to) {\n\t\t\t\t\tclearTimeout(to);\n\t\t\t\t\tto = null;\n\t\t\t\t}\n\t\t\t\tif (opts?.signal) opts.signal.removeEventListener('abort', onAbort);\n\t\t\t\tif (err) reject(normalizeError(err));\n\t\t\t};\n\n\t\t\tconst onAbort = () => cleanup(makeAbortError());\n\n\t\t\tif (opts?.signal) {\n\t\t\t\tif (opts.signal.aborted) return onAbort();\n\t\t\t\topts.signal.addEventListener('abort', onAbort, { once: true });\n\t\t\t}\n\n\t\t\tif (opts?.timeoutMs && opts.timeoutMs > 0) {\n\t\t\t\tto = setTimeout(\n\t\t\t\t\t() => cleanup(new Error('Timeout waiting for any mint paid')),\n\t\t\t\t\topts.timeoutMs,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (unique.length === 0) return cleanup(new Error('No quote ids provided'));\n\n\t\t\tfor (const quoteId of unique) {\n\t\t\t\tconst c = this.mintQuotePaid(\n\t\t\t\t\tquoteId,\n\t\t\t\t\t(p) => {\n\t\t\t\t\t\tcleanup();\n\t\t\t\t\t\tresolve({ id: quoteId, quote: p });\n\t\t\t\t\t},\n\t\t\t\t\t(e) => {\n\t\t\t\t\t\t// Catch errors after setup\n\t\t\t\t\t\tif (opts?.failOnError) {\n\t\t\t\t\t\t\tcleanup(e);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastError = e;\n\n\t\t\t\t\t\tconst thisCanceller = cancels.get(quoteId);\n\t\t\t\t\t\tif (thisCanceller) {\n\t\t\t\t\t\t\tcancelSafely(thisCanceller);\n\t\t\t\t\t\t\tcancels.delete(quoteId);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (fullyRegistered && cancels.size === 0) {\n\t\t\t\t\t\t\tcleanup(lastError ?? new Error('No subscriptions remaining'));\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tcancels.set(quoteId, c);\n\n\t\t\t\t// Catch errors setting up\n\t\t\t\tvoid c.catch((e) => {\n\t\t\t\t\tif (opts?.failOnError) {\n\t\t\t\t\t\tcleanup(e);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlastError = e;\n\n\t\t\t\t\tconst thisCanceller = cancels.get(quoteId);\n\t\t\t\t\tif (thisCanceller) {\n\t\t\t\t\t\tcancelSafely(thisCanceller);\n\t\t\t\t\t\tcancels.delete(quoteId);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (fullyRegistered && cancels.size === 0) {\n\t\t\t\t\t\tcleanup(lastError ?? new Error('No subscriptions remaining'));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfullyRegistered = true;\n\t\t});\n\t}\n\n\t/**\n\t * Resolve once a melt quote transitions to PAID, with automatic unsubscription, optional abort\n\t * signal, and optional timeout.\n\t *\n\t * Mirrors onceMintPaid, but for melts.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * try {\n\t * \tconst paid = await wallet.on.onceMeltPaid(meltId, { timeoutMs: 45_000 });\n\t * \tconsole.log('Invoice paid by mint, paid msat', paid.paid ?? 0);\n\t * } catch (e) {\n\t * \tconsole.error('Payment did not complete in time', e);\n\t * }\n\t * ```\n\t *\n\t * @param id Melt quote id to watch.\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal to cancel the wait early.\n\t * @param opts.timeoutMs Milliseconds to wait before rejecting with a timeout error.\n\t * @returns A promise that resolves with the `MeltQuoteBolt11Response` once PAID.\n\t */\n\tonceMeltPaid(\n\t\tid: string,\n\t\topts?: { signal?: AbortSignal; timeoutMs?: number },\n\t): Promise<MeltQuoteBolt11Response> {\n\t\treturn this.waitUntilPaid<MeltQuoteBolt11Response>(\n\t\t\tthis.meltQuotePaid.bind(this),\n\t\t\tid,\n\t\t\topts,\n\t\t\t'Timeout waiting for melt paid',\n\t\t);\n\t}\n\n\t/**\n\t * Async iterable that yields proof state updates for the provided proofs.\n\t *\n\t * Adds a bounded buffer option:\n\t *\n\t * - If `maxBuffer` is set and the queue is full when a new payload arrives, either drop the oldest\n\t *   queued payload (`drop: 'oldest'`, default) or the incoming payload (`drop: 'newest'`). In\n\t *   both cases `onDrop` is invoked with the dropped payload.\n\t *\n\t * The stream ends and cleans up on abort or on the wallet error callback. Errors from the wallet\n\t * are treated as a graceful end for this iterator.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const ac = new AbortController();\n\t * try {\n\t * \tfor await (const update of wallet.on.proofStatesStream(myProofs)) {\n\t * \t\tif (update.state === CheckStateEnum.SPENT) {\n\t * \t\t\tconsole.warn('Spent proof', update.proof.id);\n\t * \t\t}\n\t * \t}\n\t * } catch (e) {\n\t * \tif ((e as Error).name !== 'AbortError') {\n\t * \t\tconsole.error('Stream error', e);\n\t * \t}\n\t * }\n\t * ```\n\t *\n\t * @param proofs The proofs to subscribe to. Only `secret` is required.\n\t * @param opts Optional controls.\n\t * @param opts.signal AbortSignal that stops the stream when aborted.\n\t * @param opts.maxBuffer Maximum number of queued items before applying the drop strategy.\n\t * @param opts.drop Overflow strategy when `maxBuffer` is reached, 'oldest' | 'newest'. Default\n\t *   'oldest'.\n\t * @param opts.onDrop Callback invoked with the payload that was dropped.\n\t * @returns An async iterable of update payloads.\n\t */\n\tproofStatesStream<T = unknown>(\n\t\tproofs: Proof[],\n\t\topts?: {\n\t\t\tsignal?: AbortSignal;\n\t\t\tmaxBuffer?: number;\n\t\t\tdrop?: 'oldest' | 'newest';\n\t\t\tonDrop?: (payload: T) => void;\n\t\t},\n\t): AsyncIterable<T> {\n\t\treturn async function* (this: WalletEvents) {\n\t\t\tconst queue: T[] = [];\n\t\t\tlet done = false;\n\t\t\tlet notify: (() => void) | null = null;\n\n\t\t\tconst max = opts?.maxBuffer && opts.maxBuffer > 0 ? opts.maxBuffer : Infinity;\n\t\t\tconst dropMode: 'oldest' | 'newest' = opts?.drop ?? 'oldest';\n\n\t\t\tconst wake = () => {\n\t\t\t\tconst n = notify;\n\t\t\t\tnotify = null;\n\t\t\t\tif (n) n();\n\t\t\t};\n\n\t\t\tconst push = (payload: T) => {\n\t\t\t\tif (queue.length >= max) {\n\t\t\t\t\tif (dropMode === 'oldest') {\n\t\t\t\t\t\tconst dropped = queue.shift();\n\t\t\t\t\t\tif (dropped !== undefined) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\topts?.onDrop?.(dropped);\n\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\t/* noop */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqueue.push(payload);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\topts?.onDrop?.(payload);\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t/* noop */\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn; // drop newest\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push(payload);\n\t\t\t\t}\n\t\t\t\twake();\n\t\t\t};\n\n\t\t\tconst cancelP: Promise<SubscriptionCanceller> = this.proofStateUpdates(\n\t\t\t\tproofs,\n\t\t\t\t(payload: ProofState & { proof: Proof }) => {\n\t\t\t\t\t// Accept wallet payload type and expose as generic T to consumer\n\t\t\t\t\tpush(payload as unknown as T);\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tdone = true;\n\t\t\t\t\twake();\n\t\t\t\t},\n\t\t\t\t{ signal: opts?.signal },\n\t\t\t);\n\n\t\t\tconst onAbort = () => {\n\t\t\t\tdone = true;\n\t\t\t\twake();\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tif (opts?.signal) {\n\t\t\t\t\tif (opts.signal.aborted) onAbort();\n\t\t\t\t\telse opts.signal.addEventListener('abort', onAbort, { once: true });\n\t\t\t\t}\n\t\t\t\twhile (!done || queue.length) {\n\t\t\t\t\twhile (queue.length) yield queue.shift()!;\n\t\t\t\t\tif (done) break;\n\t\t\t\t\tawait new Promise<void>((resolve) => (notify = resolve));\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tcancelSafely(cancelP);\n\t\t\t\tif (opts?.signal) opts.signal.removeEventListener('abort', onAbort);\n\t\t\t}\n\t\t}.call(this);\n\t}\n\n\t/**\n\t * Create a composite canceller that can collect many subscriptions and dispose them all in one\n\t * call.\n\t *\n\t * Accepts both a `SubscriptionCanceller` and a `Promise<SubscriptionCanceller>`. When the\n\t * composite canceller is called, all collected cancellations are invoked. Errors from individual\n\t * cancellers are caught and ignored.\n\t *\n\t * The returned function also has an `.add()` method to register more cancellers, and a\n\t * `.cancelled` boolean property for debugging.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const cancelAll = wallet.on.group();\n\t * cancelAll.add(wallet.on.mintQuotes(ids, onUpdate, onErr));\n\t * cancelAll.add(asyncSubscribeElsewhere());\n\t *\n\t * // later\n\t * cancelAll(); // disposes everything\n\t * ```\n\t *\n\t * @returns Composite canceller function with `.add()` and `.cancelled` members.\n\t */\n\tgroup(): SubscriptionCanceller & {\n\t\tadd: (c: CancellerLike) => CancellerLike;\n\t\tcancelled: boolean;\n\t} {\n\t\tconst cancels: CancellerLike[] = [];\n\t\tlet cancelled = false;\n\n\t\tconst cancelAll = (() => {\n\t\t\tif (cancelled) return;\n\t\t\tcancelled = true;\n\t\t\twhile (cancels.length) cancelSafely(cancels.pop());\n\t\t}) as SubscriptionCanceller & {\n\t\t\tadd: (c: CancellerLike) => CancellerLike;\n\t\t\tcancelled: boolean;\n\t\t};\n\n\t\tcancelAll.add = (c: CancellerLike) => {\n\t\t\tif (cancelled) {\n\t\t\t\t// already cancelled, immediately dispose newly added subscription\n\t\t\t\tcancelSafely(c);\n\t\t\t\treturn c;\n\t\t\t}\n\t\t\tcancels.push(c);\n\t\t\treturn c;\n\t\t};\n\n\t\tObject.defineProperty(cancelAll, 'cancelled', {\n\t\t\tget: () => cancelled,\n\t\t\tenumerable: true,\n\t\t});\n\n\t\treturn cancelAll;\n\t}\n}\n","import type { CounterSource } from './CounterSource';\n\n/**\n * Developer friendly view of the wallet's deterministic output counters.\n */\nexport class WalletCounters {\n\tconstructor(private readonly src: CounterSource) {}\n\t/**\n\t * Returns the \"next\" counter for a specified keyset.\n\t */\n\tasync peekNext(keysetId: string): Promise<number> {\n\t\tconst r = await this.src.reserve(keysetId, 0);\n\t\treturn r.start;\n\t}\n\n\t/**\n\t * Bumps the counter if it is behind `minNext` (no-op if ahead).\n\t */\n\tasync advanceToAtLeast(keysetId: string, minNext: number): Promise<void> {\n\t\t// Mandatory on CounterSource\n\t\tawait this.src.advanceToAtLeast(keysetId, minNext);\n\t}\n\n\t/**\n\t * Hard-sets the cursor (useful for tests or migrations).\n\t *\n\t * @throws If the CounterSource does not support setNext()\n\t */\n\tasync setNext(keysetId: string, next: number): Promise<void> {\n\t\t// Optional capability\n\t\tif (typeof this.src.setNext === 'function') {\n\t\t\tawait this.src.setNext(keysetId, next);\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error('CounterSource does not support setNext()');\n\t}\n\t/**\n\t * Returns the current \"next\" per keyset (what will be reserved next).\n\t *\n\t * @throws If the CounterSource does not support snapshot()\n\t */\n\tasync snapshot(): Promise<Record<string, number>> {\n\t\t// Optional capability\n\t\tif (typeof this.src.snapshot === 'function') {\n\t\t\treturn await this.src.snapshot();\n\t\t}\n\t\tthrow new Error('CounterSource does not support snapshot()');\n\t}\n}\n","/**\n * Cashu Wallet Class.\n *\n * @remarks\n * This is the instantiation point for the Cashu-TS library.\n */\n\nimport {\n\ttype MeltPreview,\n\ttype OutputType,\n\ttype OutputConfig,\n\ttype SendConfig,\n\ttype SendOfflineConfig,\n\ttype ReceiveConfig,\n\ttype MintProofsConfig,\n\ttype MeltProofsConfig,\n\ttype SwapTransaction,\n\ttype MeltProofsResponse,\n\ttype SendResponse,\n\ttype RestoreConfig,\n\ttype SecretsPolicy,\n\ttype SwapPreview,\n\ttype MeltBlanks,\n} from './types';\nimport {\n\ttype CounterSource,\n\tEphemeralCounterSource,\n\ttype OperationCounters,\n\ttype CounterRange,\n} from './CounterSource';\n\nimport {\n\tsignMintQuote,\n\tsignP2PKProofs as cryptoSignP2PKProofs,\n\thashToCurve,\n\tisP2PKSigAll,\n\tbuildP2PKSigAllMessage,\n\tassertSigAllInputs,\n\tbuildLegacyP2PKSigAllMessage,\n\tbuildInterimP2PKSigAllMessage,\n} from '../crypto';\nimport { Mint } from '../mint';\nimport { MintInfo } from '../model/MintInfo';\nimport { KeyChain } from './KeyChain';\nimport { type Keyset } from './Keyset';\nimport { WalletOps } from './WalletOps';\nimport { WalletEvents } from './WalletEvents';\nimport { WalletCounters } from './WalletCounters';\nimport { selectProofsRGLI, type SelectProofs } from './SelectProofs';\nimport { type Logger, NULL_LOGGER, fail, failIf, failIfNullish, safeCallback } from '../logger';\n\n// shared primitives and options\nimport type { Proof } from '../model/types/proof';\nimport type { Token } from '../model/types/token';\nimport type { SerializedBlindedSignature } from '../model/types/blinded';\nimport { CheckStateEnum, type ProofState } from '../model/types/NUT07';\nimport type { KeyChainCache, MintKeys, MintKeyset } from '../model/types/keyset';\nimport type {\n\tGetInfoResponse,\n\tMeltRequest,\n\tMeltQuoteBaseResponse,\n\tMeltQuoteBolt11Request,\n\tMeltQuoteBolt11Response,\n\tMeltQuoteBolt12Response,\n\tMintRequest,\n\tMintQuoteBolt11Response,\n\tMintQuoteBolt12Response,\n\tMintQuoteBolt11Request,\n\tMintQuoteBolt12Request,\n\tSwapRequest,\n} from '../model/types';\n\n// model helpers\nimport { OutputData, type OutputDataLike } from '../model/OutputData';\n\nimport {\n\tvalidateAmount,\n\tgetDecodedToken,\n\tgetKeepAmounts,\n\thasValidDleq,\n\tsplitAmount,\n\tsumProofs,\n\tsanitizeUrl,\n\tinvoiceHasAmountInHRP,\n} from '../utils';\nimport { type AuthProvider } from '../auth/AuthProvider';\n\nconst PENDING_KEYSET_ID = '__PENDING__';\n\n/**\n * Class that represents a Cashu wallet.\n *\n * @remarks\n * This class should act as the entry point for this library. Can be instantiated with a mint\n * instance or mint url.\n * @example\n *\n * ```typescript\n * import { Wallet } from '@cashu/cashu-ts';\n * const wallet = new Wallet('http://localhost:3338', { unit: 'sat' });\n * await wallet.loadMint(); // Initialize mint info, keysets, and keys\n * // Wallet is now ready to use, eg:\n * const proofs = [...]; // your array of unspent proofs\n * const { keep, send } = await wallet.send(32, proofs);\n * ```\n */\nclass Wallet {\n\t/**\n\t * Mint instance - allows direct calls to the mint.\n\t */\n\tpublic readonly mint: Mint;\n\t/**\n\t * Entry point for the builder.\n\t *\n\t * @example\n\t *\n\t *     const { keep, send } = await wallet.ops\n\t *     \t.send(5, proofs)\n\t *     \t.asDeterministic() // counter: 0 = auto\n\t *     \t.keepAsRandom()\n\t *     \t.includeFees(true)\n\t *     \t.run();\n\t *\n\t *     const proofs = await wallet.ops\n\t *     \t.receive(token)\n\t *     \t.asDeterministic()\n\t *     \t.keyset(wallet.keysetId)\n\t *     \t.run();\n\t */\n\tpublic readonly ops: WalletOps;\n\t/**\n\t * Convenience wrapper for events.\n\t */\n\tpublic readonly on: WalletEvents;\n\t/**\n\t * Developer-friendly counters API.\n\t */\n\tpublic readonly counters: WalletCounters;\n\tprivate _keyChain: KeyChain;\n\tprivate _seed: Uint8Array | undefined = undefined;\n\tprivate _unit = 'sat';\n\tprivate _mintInfo: MintInfo | undefined = undefined;\n\tprivate _denominationTarget = 3;\n\tprivate _secretsPolicy: SecretsPolicy = 'auto';\n\tprivate _counterSource: CounterSource;\n\tprivate _boundKeysetId: string = PENDING_KEYSET_ID;\n\tprivate _selectProofs: SelectProofs;\n\tprivate _logger: Logger;\n\n\t/**\n\t * Create a wallet for a given mint and unit. Call `loadMint` before use.\n\t *\n\t * Binding, if `options.keysetId` is omitted, the wallet binds to the cheapest active keyset for\n\t * this unit during `loadMint`. The keychain only loads keysets for this unit.\n\t *\n\t * Caching, to preload, provide both `keysets` and `keys`, otherwise the cache is ignored.\n\t *\n\t * Deterministic secrets, pass `bip39seed` and optionally `secretsPolicy`. Deterministic outputs\n\t * reserve counters from `counterSource`, or an ephemeral in memory source if not supplied.\n\t * `initialCounter` applies only with a supplied `keysetId` and the ephemeral source.\n\t *\n\t * Splitting, `denominationTarget` guides proof splits, default is 3. Override coin selection with\n\t * `selectProofs` if needed. Logging defaults to a null logger.\n\t *\n\t * @remarks\n\t * The options.keys, options.keysets, options.mintInfo options are deprecated. Use\n\t * wallet.loadMintFromCache() after init to load cached mint data.\n\t * @param mint Mint instance or URL.\n\t * @param options Optional settings.\n\t * @param options.unit Wallet unit, default 'sat'.\n\t * @param options.keysetId Bind to this keyset id, else bind on `loadMint`.\n\t * @param options.bip39seed BIP39 seed for deterministic secrets.\n\t * @param options.secretsPolicy Secrets policy, default 'auto'.\n\t * @param options.counterSource Counter source for deterministic outputs. If provided, this takes\n\t *   precedence over counterInit. Use when you need persistence across processes or devices.\n\t * @param options.counterInit Seed values for the built-in EphemeralCounterSource. Ignored if\n\t *   counterSource is also provided.\n\t * @param options.keys DEPRECATED: Use `wallet.loadMintFromCache` after init.\n\t * @param options.keysets DEPRECATED: Use `wallet.loadMintFromCache` after init.\n\t * @param options.mintInfo DEPRECATED: Use `wallet.loadMintFromCache` after init.\n\t * @param options.denominationTarget Target proofs per denomination, default 3.\n\t * @param options.selectProofs Custom proof selection function.\n\t * @param options.logger Logger instance, default null logger.\n\t */\n\tconstructor(\n\t\tmint: Mint | string,\n\t\toptions?: {\n\t\t\tunit?: string;\n\t\t\tauthProvider?: AuthProvider;\n\t\t\tkeysetId?: string; // if omitted, wallet binds to cheapest in loadMint\n\t\t\tbip39seed?: Uint8Array;\n\t\t\tsecretsPolicy?: SecretsPolicy; // optional, auto\n\t\t\tcounterSource?: CounterSource; // optional, otherwise ephemeral\n\t\t\tcounterInit?: Record<string, number>; // optional, starting \"next\" per keyset\n\t\t\t/**\n\t\t\t * @deprecated Use `wallet.loadMintFromCache` after init.\n\t\t\t */\n\t\t\tkeys?: MintKeys[] | MintKeys;\n\t\t\t/**\n\t\t\t * @deprecated Use `wallet.loadMintFromCache` after init.\n\t\t\t */\n\t\t\tkeysets?: MintKeyset[];\n\t\t\t/**\n\t\t\t * @deprecated Use `wallet.loadMintFromCache` after init.\n\t\t\t */\n\t\t\tmintInfo?: GetInfoResponse;\n\t\t\tdenominationTarget?: number;\n\t\t\tselectProofs?: SelectProofs; // optional override\n\t\t\tlogger?: Logger;\n\t\t},\n\t) {\n\t\tthis.ops = new WalletOps(this);\n\t\tthis.on = new WalletEvents(this);\n\t\tthis._logger = options?.logger ?? NULL_LOGGER; // init early (seed can throw)\n\t\tthis._selectProofs = options?.selectProofs ?? selectProofsRGLI; // vital\n\t\tthis.mint =\n\t\t\ttypeof mint === 'string'\n\t\t\t\t? new Mint(mint, { authProvider: options?.authProvider, logger: this._logger })\n\t\t\t\t: mint;\n\t\tthis._unit = options?.unit ?? this._unit;\n\t\tthis._boundKeysetId = options?.keysetId ?? this._boundKeysetId;\n\t\tif (options?.bip39seed) {\n\t\t\tthis.failIf(\n\t\t\t\t!(options.bip39seed instanceof Uint8Array),\n\t\t\t\t'bip39seed must be a valid Uint8Array',\n\t\t\t\t{\n\t\t\t\t\tbip39seed: options.bip39seed,\n\t\t\t\t},\n\t\t\t);\n\t\t\tthis._seed = options.bip39seed;\n\t\t}\n\t\tthis._secretsPolicy = options?.secretsPolicy ?? this._secretsPolicy;\n\t\tif (options?.counterSource) {\n\t\t\tthis._counterSource = options.counterSource;\n\t\t} else {\n\t\t\tthis._counterSource = new EphemeralCounterSource(options?.counterInit);\n\t\t}\n\t\tthis.counters = new WalletCounters(this._counterSource);\n\t\tthis._keyChain = new KeyChain(this.mint, this._unit);\n\t\tthis._denominationTarget = options?.denominationTarget ?? this._denominationTarget;\n\n\t\t// TODO: Deprecated cache init - to be removed with deprecated constructor options\n\t\tif (options?.keysets && options?.keys && options?.mintInfo) {\n\t\t\tconst allKeys = Array.isArray(options.keys) ? options.keys : [options.keys];\n\t\t\t// Convert Mint DTOs to KeyChainCache\n\t\t\tconst cache: KeyChainCache = KeyChain.mintToCacheDTO(\n\t\t\t\tthis._unit,\n\t\t\t\tthis.mint.mintUrl,\n\t\t\t\toptions.keysets,\n\t\t\t\tallKeys,\n\t\t\t);\n\t\t\tthis.loadMintFromCache(options.mintInfo, cache);\n\t\t}\n\t}\n\n\t// Convenience wrappers for \"log and throw\"\n\tprivate fail(message: string, context?: Record<string, unknown>): never {\n\t\treturn fail(message, this._logger, context);\n\t}\n\tprivate failIf(\n\t\tcondition: boolean,\n\t\tmessage: string,\n\t\tcontext?: Record<string, unknown>,\n\t): asserts condition is false {\n\t\treturn failIf(condition, message, this._logger, context);\n\t}\n\tprivate failIfNullish<T>(\n\t\tvalue: T,\n\t\tmessage: string,\n\t\tcontext?: Record<string, unknown>,\n\t): asserts value is Exclude<T, null | undefined> {\n\t\treturn failIfNullish(value, message, this._logger, context);\n\t}\n\tprivate safeCallback<T>(\n\t\tcb: ((p: T) => void) | undefined,\n\t\tpayload: T,\n\t\tcontext?: Record<string, unknown>,\n\t): void {\n\t\tsafeCallback(cb, payload, this._logger, context);\n\t}\n\n\t/**\n\t * Asserts amount is a positive, safe integer.\n\t *\n\t * @param amount To check.\n\t * @param op Caller method name (or other identifier) for debug.\n\t * @throws If not.\n\t */\n\tprivate assertAmount(amount: unknown, op: string): asserts amount is number {\n\t\ttry {\n\t\t\tvalidateAmount(amount, false);\n\t\t} catch (e) {\n\t\t\tthis.fail((e as Error).message, { op, amount });\n\t\t}\n\t}\n\n\t/**\n\t * Load mint information, keysets, and keys.\n\t *\n\t * @remarks\n\t * Must be called before using other methods, unless loading mint from cache. See:\n\t * `loadMintFromCache`.\n\t * @param forceRefresh If true, re-fetches data even if cached.\n\t * @throws If fetching mint info, keysets, or keys fails.\n\t */\n\tasync loadMint(forceRefresh?: boolean): Promise<void> {\n\t\tconst promises = [];\n\n\t\t// Load mint info\n\t\tif (!this._mintInfo || forceRefresh) {\n\t\t\tpromises.push(\n\t\t\t\tthis.mint.getInfo().then((info) => {\n\t\t\t\t\tthis._mintInfo = new MintInfo(info);\n\t\t\t\t\treturn null;\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\t// Load KeyChain\n\t\tpromises.push(this._keyChain.init(forceRefresh).then(() => null));\n\n\t\tawait Promise.all(promises);\n\t\tthis.finishInit();\n\t}\n\n\t/**\n\t * Load mint information, keysets, and keys from cached data.\n\t *\n\t * @remarks\n\t * Use this when you already have cached mint info and keychain cache and want to avoid network\n\t * calls.\n\t *\n\t * The `cache` argument should usually come from `wallet.keyChain.cache`.\n\t */\n\tloadMintFromCache(mintInfo: GetInfoResponse, cache: KeyChainCache): void {\n\t\tthis._mintInfo = new MintInfo(mintInfo);\n\t\tthis._keyChain.loadFromCache(cache);\n\t\tthis.finishInit();\n\t}\n\n\t/**\n\t * Finishes wiring up the wallet instance and checks we are \"Go for launch\".\n\t */\n\tprivate finishInit(): void {\n\t\t// Go Keychain?\n\t\tconst cheapestId = this._keyChain.getCheapestKeyset().id;\n\t\tthis._logger.debug('KeyChain', { keychain: this._keyChain.cache });\n\n\t\t// Bind the cheapest keyset if needed\n\t\tif (this._boundKeysetId === PENDING_KEYSET_ID) {\n\t\t\tthis._boundKeysetId = cheapestId;\n\t\t} else {\n\t\t\tconst k = this._keyChain.getKeyset(this._boundKeysetId);\n\t\t\tthis.failIf(!k.hasKeys, 'Wallet keyset has no keys', { keyset: k.id });\n\t\t}\n\n\t\t// Go Mintinfo?\n\t\tthis.getMintInfo();\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Getters\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Get the wallet's KeyChain.\n\t *\n\t * @returns The Keychain.\n\t */\n\tget keyChain(): KeyChain {\n\t\treturn this._keyChain;\n\t}\n\n\t/**\n\t * Get the wallet's unit.\n\t *\n\t * @returns The unit (e.g., 'sat').\n\t */\n\tget unit(): string {\n\t\treturn this._unit;\n\t}\n\n\t/**\n\t * Get information about the mint.\n\t *\n\t * @remarks\n\t * Returns cached mint info. Call `loadMint` first to initialize the wallet.\n\t * @returns Mint info.\n\t * @throws If mint info is not initialized.\n\t */\n\tgetMintInfo(): MintInfo {\n\t\tthis.failIfNullish(\n\t\t\tthis._mintInfo,\n\t\t\t'Mint info not initialized; call loadMint or loadMintFromCache first',\n\t\t);\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * The keyset ID bound to this wallet instance.\n\t */\n\tget keysetId(): string {\n\t\tthis.failIf(\n\t\t\tthis._boundKeysetId === PENDING_KEYSET_ID,\n\t\t\t'Wallet not initialised, call loadMint or loadMintFromCache first',\n\t\t);\n\t\treturn this._boundKeysetId;\n\t}\n\n\t/**\n\t * Gets the requested keyset or the keyset bound to the wallet.\n\t *\n\t * @remarks\n\t * This method enforces wallet policies. If `id` is omitted, it returns the keyset bound to this\n\t * wallet, including validation that:\n\t *\n\t * - The keyset exists in the keychain,\n\t * - The unit matches the wallet's unit,\n\t * - Keys are loaded for that keyset.\n\t *\n\t * Contrast with `keyChain.getKeyset(id?)`, which, when called without an id, returns the cheapest\n\t * active keyset for the unit, ignoring the wallet binding.\n\t * @param id Optional keyset id to resolve. If omitted, the wallet's bound keyset is used.\n\t * @returns The resolved `Keyset`.\n\t * @throws If the keyset is not found, has no keys, or its unit differs from the wallet.\n\t */\n\tpublic getKeyset(id?: string): Keyset {\n\t\tconst keyset = this._keyChain.getKeyset(id ?? this.keysetId);\n\t\tthis.failIf(keyset.unit !== this._unit, 'Keyset unit does not match wallet unit', {\n\t\t\tkeyset: keyset.id,\n\t\t\tunit: keyset.unit,\n\t\t\twalletUnit: this._unit,\n\t\t});\n\t\tthis.failIf(!keyset.hasKeys, 'Keyset has no keys loaded', { keyset: keyset.id });\n\t\treturn keyset;\n\t}\n\n\tpublic get logger(): Logger {\n\t\treturn this._logger;\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Counters\n\t// -----------------------------------------------------------------\n\n\tprivate async reserveFor(keysetId: string, totalOutputs: number): Promise<CounterRange> {\n\t\tif (totalOutputs <= 0) return { start: 0, count: 0 };\n\t\treturn this._counterSource.reserve(keysetId, totalOutputs);\n\t}\n\n\tprivate countersNeeded(ot: OutputType): number {\n\t\tif (ot.type !== 'deterministic' || ot.counter !== 0) return 0;\n\t\treturn (ot.denominations ?? []).length;\n\t}\n\n\tprivate async addCountersToOutputTypes(\n\t\tkeysetId: string,\n\t\t...outputTypes: OutputType[]\n\t): Promise<{ outputTypes: OutputType[]; used?: OperationCounters }> {\n\t\t// Get all outputTypes with a manual counter and denominations set.\n\t\tconst manual = outputTypes.filter(\n\t\t\t(ot): ot is Extract<OutputType, { type: 'deterministic' }> =>\n\t\t\t\tot.type === 'deterministic' && ot.counter > 0 && (ot.denominations?.length ?? 0) > 0,\n\t\t);\n\n\t\t// Reject if manual ranges overlap\n\t\tif (manual.length > 1) {\n\t\t\tconst ranges = manual\n\t\t\t\t.map((ot) => ({\n\t\t\t\t\tstart: ot.counter,\n\t\t\t\t\tend: ot.counter + ot.denominations!.length, // exclusive\n\t\t\t\t}))\n\t\t\t\t.sort((a, b) => a.start - b.start);\n\t\t\tfor (let i = 1; i < ranges.length; i++) {\n\t\t\t\tthis.failIf(ranges[i].start < ranges[i - 1].end, 'Manual counter ranges overlap', {\n\t\t\t\t\tkeysetId,\n\t\t\t\t\tprev: ranges[i - 1],\n\t\t\t\t\tcur: ranges[i],\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// If any deterministic OutputType has a manual counter (> 0), advance\n\t\t// the counter source so future \"auto\" allocations do not reuse counters.\n\t\tif (manual.length > 0) {\n\t\t\t// Get the max counter manually allocated\n\t\t\tconst maxManualEnd = Math.max(...manual.map((ot) => ot.counter + ot.denominations!.length));\n\n\t\t\t// Bump cursor to at least the end of the manually allocated range\n\t\t\tawait this._counterSource.advanceToAtLeast(keysetId, maxManualEnd);\n\t\t\tthis._logger.debug('Counter source advanced to respect manual deterministic counters', {\n\t\t\t\tkeysetId,\n\t\t\t\tmaxManualEnd,\n\t\t\t});\n\t\t}\n\n\t\t// Reserve counters for deterministic outputTypes with auto counter (counter===0))\n\t\tconst total = outputTypes.reduce((n, ot) => n + this.countersNeeded(ot), 0);\n\t\tif (total === 0) return { outputTypes };\n\n\t\tconst range = await this.reserveFor(keysetId, total);\n\t\tlet cursor = range.start;\n\n\t\tconst patched = outputTypes.map((ot): OutputType => {\n\t\t\tif (ot.type === 'deterministic' && ot.counter === 0) {\n\t\t\t\tconst need = ot.denominations?.length ?? 0;\n\t\t\t\tif (need > 0) {\n\t\t\t\t\tconst patched: typeof ot = { ...ot, counter: cursor };\n\t\t\t\t\tcursor += need;\n\t\t\t\t\treturn patched;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ot;\n\t\t});\n\n\t\t// Fire event after successful reservation (wallet does not await handlers)\n\t\tconst used = {\n\t\t\tkeysetId,\n\t\t\tstart: range.start,\n\t\t\tcount: range.count,\n\t\t\tnext: range.start + range.count,\n\t\t} as OperationCounters;\n\t\tthis.on._emitCountersReserved(used);\n\t\treturn { outputTypes: patched, used };\n\t}\n\n\t/**\n\t * Bind this wallet to a specific keyset id.\n\t *\n\t * @remarks\n\t * This changes the default keyset used by all operations that do not explicitly pass a keysetId.\n\t * The method validates that the keyset exists in the keychain, matches the wallet unit, and has\n\t * keys loaded.\n\t *\n\t * Typical uses:\n\t *\n\t * 1. After loadMint, to pin the wallet to a particular active keyset.\n\t * 2. After a refresh, to rebind deliberately rather than falling back to cheapest.\n\t *\n\t * @param id The keyset identifier to bind to.\n\t * @throws If keyset not found, if it has no keys loaded, or if its unit is not the wallet unit.\n\t */\n\tpublic bindKeyset(id: string): void {\n\t\tconst ks = this._keyChain.getKeyset(id);\n\t\tthis.failIf(ks.unit !== this._unit, 'Keyset unit does not match wallet unit', {\n\t\t\tkeyset: ks.id,\n\t\t\tunit: ks.unit,\n\t\t\twalletUnit: this._unit,\n\t\t});\n\t\tthis.failIf(!ks.hasKeys, 'Keyset has no keys loaded', { keyset: ks.id });\n\t\tthis._boundKeysetId = ks.id;\n\t\tthis._logger.debug('Wallet bound to keyset', {\n\t\t\tkeysetId: ks.id,\n\t\t\tunit: ks.unit,\n\t\t\tfeePPK: ks.fee,\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new Wallet bound to a different keyset, sharing the same CounterSource.\n\t *\n\t * Use this to operate on multiple keysets concurrently without mutating your original wallet.\n\t * Counters remain monotonic across instances because the same CounterSource is reused.\n\t *\n\t * Do NOT pass a fresh CounterSource for the same seed unless you know exactly why. Reusing\n\t * counters can recreate secrets that a mint will reject.\n\t *\n\t * @param id The keyset identifier to bind to.\n\t * @throws If keyset not found, if it has no keys loaded, or if its unit is not the wallet unit.\n\t */\n\tpublic withKeyset(id: string, opts?: { counterSource?: CounterSource }): Wallet {\n\t\tconst newWallet = new Wallet(this.mint, {\n\t\t\tkeysetId: id,\n\t\t\tbip39seed: this._seed,\n\t\t\tsecretsPolicy: this._secretsPolicy,\n\t\t\tlogger: this._logger,\n\t\t\tcounterSource: opts?.counterSource ?? this._counterSource,\n\t\t});\n\t\t// Load mint info from our caches\n\t\tnewWallet.loadMintFromCache(this.getMintInfo().cache, this._keyChain.cache);\n\t\treturn newWallet;\n\t}\n\n\t/**\n\t * Returns the default OutputType for this wallet, based on its configured secrets policy\n\t * (options?.secretsPolicy) and seed state.\n\t *\n\t * - If the secrets policy is 'random', returns { type: 'random' }.\n\t * - If the policy is 'deterministic', requires a seed and returns { type: 'deterministic', counter:\n\t *   0 }. Counter 0 is a flag meaning \"auto-increment from current state\".\n\t * - If no explicit policy is set, falls back to:\n\t *\n\t *   - Deterministic if a seed is present.\n\t *   - Random if no seed is present.\n\t *\n\t * @returns An OutputType object describing the default output strategy.\n\t * @throws Error if the policy is 'deterministic' but no seed has been set.\n\t */\n\tpublic defaultOutputType(): OutputType {\n\t\tif (this._secretsPolicy === 'random') return { type: 'random' };\n\t\tif (this._secretsPolicy === 'deterministic') {\n\t\t\tthis.failIfNullish(this._seed, 'Deterministic policy requires a seed');\n\t\t\treturn { type: 'deterministic', counter: 0 }; // 0 = auto flag\n\t\t}\n\t\treturn this._seed ? { type: 'deterministic', counter: 0 } : { type: 'random' };\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Output Creation\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Configures output denominations with fee adjustments and optimization.\n\t *\n\t * @remarks\n\t * If 'custom' outputType, data outputs MUST sum to the amount. Other outputTypes may supply\n\t * denominations. If no denominations are passed in, they will be calculated based on proofsWeHave\n\t * or the default split. If partial denominations are passed in, the balance will be added using\n\t * default split. Additional denominations to cover fees will then be added if required.\n\t * @param amount The total amount for outputs.\n\t * @param keyset The mint keyset.\n\t * @param outputType The output configuration.\n\t * @param includeFees Whether to include swap fees in the output amount.\n\t * @param proofsWeHave Optional proofs for optimizing denomination splitting.\n\t * @returns OutputType with required denominations.\n\t */\n\tprivate configureOutputs(\n\t\tamount: number,\n\t\tkeyset: Keyset,\n\t\toutputType: OutputType,\n\t\tincludeFees: boolean = false,\n\t\tproofsWeHave: Proof[] = [],\n\t): OutputType {\n\t\tlet newAmount = amount;\n\n\t\t// Custom outputs don't have automatic optimizations or fee inclusion)\n\t\tif (outputType.type === 'custom') {\n\t\t\tthis.failIf(includeFees, 'The custom OutputType does not support automatic fee inclusion');\n\n\t\t\t// Validate sum early, as no denominations to fill\n\t\t\tconst customTotal = OutputData.sumOutputAmounts(outputType.data);\n\t\t\tthis.failIf(\n\t\t\t\tcustomTotal !== amount,\n\t\t\t\t`Custom output data total (${customTotal}) does not match amount (${amount})`,\n\t\t\t);\n\t\t\treturn outputType;\n\t\t}\n\n\t\t// Start with any denominations provided.\n\t\t// Note: These MAY be partial (\"give me a [16,8], anything for the rest\")\n\t\t// We will complete the denomination set before we are done.\n\t\tlet denominations = outputType.denominations ?? [];\n\n\t\t// If no denominations, but proofsWeHave was provided - optimize\n\t\t// to get around _denominationTarget proofs of each denomination.\n\t\tif (denominations.length === 0 && proofsWeHave.length > 0) {\n\t\t\tdenominations = getKeepAmounts(\n\t\t\t\tproofsWeHave,\n\t\t\t\tnewAmount,\n\t\t\t\tkeyset.keys,\n\t\t\t\tthis._denominationTarget,\n\t\t\t);\n\t\t}\n\n\t\t// Fill in any missing denominations with default split.\n\t\t// NOTE: If we have to fill, the result will be in ASC order.\n\t\t// Original order is only maintained for exact denomination sets.\n\t\tdenominations = splitAmount(newAmount, keyset.keys, denominations);\n\n\t\t// If includeFees, we create additional output amounts to cover the\n\t\t// fee the receiver will pay when they spend the proofs (ie sender pays fees)\n\t\tif (includeFees) {\n\t\t\tlet receiveFee = this.getFeesForKeyset(denominations.length, keyset.id);\n\t\t\tlet receiveFeeAmounts = splitAmount(receiveFee, keyset.keys);\n\t\t\twhile (\n\t\t\t\tthis.getFeesForKeyset(denominations.length + receiveFeeAmounts.length, keyset.id) >\n\t\t\t\treceiveFee\n\t\t\t) {\n\t\t\t\treceiveFee++;\n\t\t\t\treceiveFeeAmounts = splitAmount(receiveFee, keyset.keys);\n\t\t\t}\n\t\t\tnewAmount += receiveFee;\n\t\t\tdenominations = [...denominations, ...receiveFeeAmounts];\n\t\t}\n\t\treturn { ...outputType, denominations };\n\t}\n\n\t/**\n\t * Sum total implied by a prepared OutputType. Note: Empty denomination is valid (e.g: zero\n\t * change).\n\t */\n\tprivate preparedTotal(ot: OutputType): number {\n\t\tif (ot.type === 'custom') return OutputData.sumOutputAmounts(ot.data);\n\t\tconst denoms = ot.denominations ?? [];\n\t\treturn denoms.reduce((a, b) => a + b, 0);\n\t}\n\n\t/**\n\t * Generates blinded messages based on the specified output type.\n\t *\n\t * @param amount The total amount for outputs.\n\t * @param keyset The mint keys.\n\t * @param outputType The output configuration.\n\t * @returns Prepared output data.\n\t */\n\tprivate createOutputData(\n\t\tamount: number,\n\t\tkeyset: Keyset,\n\t\toutputType: OutputType,\n\t): OutputDataLike[] {\n\t\t// we can accept zero (for blanks) or positive values\n\t\tthis.failIf(amount < 0, 'Amount was negative', { amount });\n\t\tif (\n\t\t\t// 'custom' OutputType has no denominations. Every other OutputType does.\n\t\t\t// so let's sanity check those were filled properly (eg: configureOutputs)\n\t\t\t'custom' != outputType.type &&\n\t\t\toutputType.denominations &&\n\t\t\toutputType.denominations.length > 0\n\t\t) {\n\t\t\tconst splitSum = outputType.denominations.reduce((sum, a) => sum + a, 0);\n\t\t\tthis.failIf(splitSum !== amount, 'Denominations do not sum to the expected amount', {\n\t\t\t\tsplitSum,\n\t\t\t\texpected: amount,\n\t\t\t});\n\t\t}\n\t\tlet outputData: OutputDataLike[];\n\t\tswitch (outputType.type) {\n\t\t\tcase 'random':\n\t\t\t\toutputData = OutputData.createRandomData(amount, keyset, outputType.denominations);\n\t\t\t\tbreak;\n\t\t\tcase 'deterministic':\n\t\t\t\tthis.failIfNullish(\n\t\t\t\t\tthis._seed,\n\t\t\t\t\t'Deterministic outputs require a seed configured in the wallet',\n\t\t\t\t);\n\t\t\t\toutputData = OutputData.createDeterministicData(\n\t\t\t\t\tamount,\n\t\t\t\t\tthis._seed,\n\t\t\t\t\toutputType.counter,\n\t\t\t\t\tkeyset,\n\t\t\t\t\toutputType.denominations,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'p2pk':\n\t\t\t\toutputData = OutputData.createP2PKData(\n\t\t\t\t\toutputType.options,\n\t\t\t\t\tamount,\n\t\t\t\t\tkeyset,\n\t\t\t\t\toutputType.denominations,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'factory': {\n\t\t\t\tconst factorySplit = splitAmount(amount, keyset.keys, outputType.denominations);\n\t\t\t\toutputData = factorySplit.map((a) => outputType.factory(a, keyset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'custom': {\n\t\t\t\toutputData = outputType.data;\n\t\t\t\tconst customTotal = OutputData.sumOutputAmounts(outputData);\n\t\t\t\tthis.failIf(\n\t\t\t\t\tcustomTotal !== amount,\n\t\t\t\t\t`Custom output data total (${customTotal}) does not match amount (${amount})`,\n\t\t\t\t);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthis.fail('Invalid OutputType');\n\t\t\t}\n\t\t}\n\t\treturn outputData;\n\t}\n\n\t/**\n\t * Creates a swap transaction with sorted outputs for privacy. This prevents a mint working out\n\t * which proofs will be sent or kept.\n\t *\n\t * @param inputs Prepared input proofs.\n\t * @param keepOutputs Outputs to keep (change or receiver's proofs).\n\t * @param sendOutputs Outputs to send (optional, default empty for receive/mint).\n\t * @returns Swap transaction with payload and metadata for processing signatures.\n\t */\n\tprivate createSwapTransaction(\n\t\tinputs: Proof[],\n\t\tkeepOutputs: OutputDataLike[],\n\t\tsendOutputs: OutputDataLike[] = [],\n\t): SwapTransaction {\n\t\t// Prepare inputs for mint\n\t\tinputs = this._prepareInputsForMint(inputs);\n\n\t\t// Sort ASC by amount for privacy, but keep indices to return order afterwards\n\t\t// But ONLY if the transaction is NOT SIG_ALL (as order is fixed for signing)\n\t\tconst mergedBlindingData = [...keepOutputs, ...sendOutputs];\n\t\tconst indices = mergedBlindingData.map((_, i) => i);\n\t\tif (!isP2PKSigAll(inputs)) {\n\t\t\tindices.sort(\n\t\t\t\t(a, b) =>\n\t\t\t\t\tmergedBlindingData[a].blindedMessage.amount - mergedBlindingData[b].blindedMessage.amount,\n\t\t\t);\n\t\t}\n\t\tconst keepVector: boolean[] = [\n\t\t\t...Array.from({ length: keepOutputs.length }, () => true),\n\t\t\t...Array.from({ length: sendOutputs.length }, () => false),\n\t\t];\n\t\tconst sortedOutputData: OutputDataLike[] = indices.map((i) => mergedBlindingData[i]);\n\t\tconst sortedKeepVector: boolean[] = indices.map((i) => keepVector[i]);\n\t\tconst outputs = sortedOutputData.map((d) => d.blindedMessage);\n\t\tthis._logger.debug('createSwapTransaction:', {\n\t\t\tindices,\n\t\t\tsortedKeepVector,\n\t\t\t// outputs, // <-- removed for security\n\t\t});\n\t\tconst payload: SwapRequest = {\n\t\t\tinputs,\n\t\t\toutputs,\n\t\t};\n\t\treturn {\n\t\t\tpayload,\n\t\t\toutputData: sortedOutputData,\n\t\t\tkeepVector: sortedKeepVector,\n\t\t\tsortedIndices: indices,\n\t\t};\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Send and Receive\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Receive a token (swaps with mint for new proofs)\n\t *\n\t * @example\n\t *\n\t * ```typescript\n\t * const result = await wallet.receive(\n\t * \ttoken,\n\t * \t{ includeFees: true },\n\t * \t{ type: 'deterministic', counter: 0 },\n\t * );\n\t * ```\n\t *\n\t * @param token Token string or decoded token.\n\t * @param config Optional receive config.\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Newly minted proofs.\n\t */\n\tasync receive(\n\t\ttoken: Token | string,\n\t\tconfig?: ReceiveConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\t// Prepare and complete the send\n\t\tconst txn = await this.prepareSwapToReceive(token, config, outputType);\n\t\tconst { keep } = await this.completeSwap(txn, config?.privkey);\n\t\treturn keep;\n\t}\n\n\t/**\n\t * Prepare A Receive Transaction.\n\t *\n\t * @remarks\n\t * Allows you to preview fees for a receive, get concrete outputs for P2PK SIG_ALL transactions,\n\t * and do any pre-swap tasks (such as marking proofs in-flight etc)\n\t * @example\n\t *\n\t * ```typescript\n\t * // Prepare transaction\n\t * const txn = await wallet.prepareSwapToReceive(token, { requireDleq: true });\n\t * const fees = txn.fees;\n\t *\n\t * // Complete transaction\n\t * const { keep } = await wallet.completeSwap(txn);\n\t * ```\n\t *\n\t * @param token Token string or decoded token.\n\t * @param config Optional receive config.\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns SwapPreview with metadata for swap transaction.\n\t */\n\tasync prepareSwapToReceive(\n\t\ttoken: Token | string,\n\t\tconfig?: ReceiveConfig,\n\t\toutputType?: OutputType,\n\t): Promise<SwapPreview> {\n\t\tconst { keysetId, requireDleq, proofsWeHave, onCountersReserved } = config || {};\n\t\toutputType = outputType ?? this.defaultOutputType(); // Fallback to policy\n\n\t\t// Decode and validate token\n\t\tconst decodedToken = typeof token === 'string' ? this.decodeToken(token) : token;\n\t\tconst tokenMintUrl = sanitizeUrl(decodedToken.mint);\n\t\tthis.failIf(tokenMintUrl !== this.mint.mintUrl, 'Token belongs to a different mint', {\n\t\t\ttoken: tokenMintUrl,\n\t\t\twallet: this.mint.mintUrl,\n\t\t});\n\t\tthis.failIf(decodedToken.unit !== this._unit, 'Token is not in wallet unit', {\n\t\t\ttoken: decodedToken.unit,\n\t\t\twallet: this._unit,\n\t\t});\n\n\t\t// Extract token proofs\n\t\tlet proofs: Proof[] = [];\n\t\t({ proofs } = decodedToken);\n\t\tconst totalAmount = sumProofs(proofs);\n\t\tthis.failIf(totalAmount === 0, 'Token contains no proofs', { proofs });\n\t\tthis.assertAmount(totalAmount, 'prepareSwapToReceive');\n\n\t\t// Check DLEQs if needed\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tif (requireDleq) {\n\t\t\tfor (const p of proofs) {\n\t\t\t\tconst ks = this._keyChain.getKeyset(p.id);\n\t\t\t\tif (!hasValidDleq(p, ks)) {\n\t\t\t\t\tthis.fail('Token contains proofs with invalid or missing DLEQ');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Shape receive output type and denominations\n\t\tconst swapFee = this.getFeesForProofs(proofs);\n\t\tconst amount = totalAmount - swapFee;\n\t\tlet receiveOT = this.configureOutputs(\n\t\t\tamount,\n\t\t\tkeyset,\n\t\t\toutputType,\n\t\t\tfalse, // includeFees is not applicable for receive\n\t\t\tproofsWeHave,\n\t\t);\n\n\t\t// Assign counter atomically if OutputType is deterministic\n\t\t// and the counter is zero (auto-assign)\n\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, receiveOT);\n\t\t[receiveOT] = autoCounters.outputTypes;\n\t\tif (autoCounters.used) {\n\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'receive' });\n\t\t}\n\t\tthis._logger.debug('receive counter', { counter: autoCounters.used, receiveOT });\n\n\t\t// Create outputs and execute swap\n\t\tconst outputs = this.createOutputData(this.preparedTotal(receiveOT), keyset, receiveOT);\n\n\t\t// Return SwapPreview\n\t\treturn {\n\t\t\tamount,\n\t\t\tfees: swapFee,\n\t\t\tkeysetId: keyset.id,\n\t\t\tinputs: proofs,\n\t\t\tkeepOutputs: outputs,\n\t\t} as SwapPreview;\n\t}\n\n\t/**\n\t * Sends proofs of a given amount from provided proofs.\n\t *\n\t * @remarks\n\t * If proofs are P2PK-locked to your public key, call signP2PKProofs first to sign them. The\n\t * default config uses exact match selection, and does not includeFees or requireDleq. Because the\n\t * send is offline, the user will unlock the signed proofs when they receive them online.\n\t * @param amount Amount to send.\n\t * @param proofs Array of proofs (must sum >= amount; pre-sign if P2PK-locked).\n\t * @param config Optional parameters for the send.\n\t * @returns SendResponse with keep/send proofs.\n\t * @throws Throws if the send cannot be completed offline.\n\t */\n\tsendOffline(amount: number, proofs: Proof[], config?: SendOfflineConfig): SendResponse {\n\t\tthis.assertAmount(amount, 'sendOffline');\n\t\tconst { requireDleq = false, includeFees = false, exactMatch = true } = config || {};\n\t\tif (requireDleq) {\n\t\t\t// Only use proofs that have a DLEQ\n\t\t\tproofs = proofs.filter((p: Proof) => p.dleq != undefined);\n\t\t}\n\t\tthis.failIf(sumProofs(proofs) < amount, 'Not enough funds available to send');\n\n\t\tconst { keep, send } = this.selectProofsToSend(proofs, amount, includeFees, exactMatch);\n\t\t// Ensure witnesses are serialized, strip DLEQ if not required\n\t\tconst sendPrepared = this._prepareInputsForMint(send, requireDleq);\n\t\treturn { keep, send: sendPrepared };\n\t}\n\n\t/**\n\t * Send proofs with online swap if necessary.\n\t *\n\t * @example\n\t *\n\t * ```typescript\n\t * // Simple send\n\t * const result = await wallet.send(5, proofs);\n\t *\n\t * // With a SendConfig\n\t * const result = await wallet.send(5, proofs, { includeFees: true });\n\t *\n\t * // With Custom output configuration\n\t * const customConfig: OutputConfig = {\n\t * \tsend: { type: 'p2pk', options: { pubkey: '...' } },\n\t * \tkeep: { type: 'deterministic', counter: 0 },\n\t * };\n\t * const customResult = await wallet.send(5, proofs, { includeFees: true }, customConfig);\n\t * ```\n\t *\n\t * @param amount Amount to send (receiver gets this net amount).\n\t * @param proofs Array of proofs to split.\n\t * @param config Optional parameters for the swap.\n\t * @returns SendResponse with keep/send proofs.\n\t * @throws Throws if the send cannot be completed offline or if funds are insufficient.\n\t */\n\tasync send(\n\t\tamount: number,\n\t\tproofs: Proof[],\n\t\tconfig?: SendConfig,\n\t\toutputConfig?: OutputConfig,\n\t): Promise<SendResponse> {\n\t\tthis.assertAmount(amount, 'send');\n\t\tconst { keysetId, includeFees = false } = config || {};\n\t\t// Fallback to policy defaults if no outputConfig\n\t\toutputConfig = outputConfig ?? {\n\t\t\tsend: this.defaultOutputType(),\n\t\t\tkeep: this.defaultOutputType(),\n\t\t};\n\n\t\t// First, let's see if we can avoid a swap (and fees)\n\t\t// by trying an exact match offline selection, including fees if\n\t\t// we are giving the receiver the amount + their fee to receive\n\t\t// In Wallet.ts, near send()\n\n\t\ttry {\n\t\t\t// Offline exact-match only allowed for plain-random defaults; deterministic implies swap.\n\t\t\tconst wantsDeterministicByPolicy = this.defaultOutputType().type === 'deterministic';\n\t\t\tconst isPlainRandom = (ot?: OutputType) =>\n\t\t\t\t!ot || (ot.type === 'random' && (!ot.denominations || ot.denominations.length === 0));\n\n\t\t\tif (\n\t\t\t\tkeysetId ||\n\t\t\t\twantsDeterministicByPolicy ||\n\t\t\t\t!isPlainRandom(outputConfig.send) ||\n\t\t\t\t(outputConfig.keep && !isPlainRandom(outputConfig.keep))\n\t\t\t) {\n\t\t\t\t// Explain why we must fall back to swap\n\t\t\t\tconst reasons: string[] = [];\n\t\t\t\tif (keysetId) reasons.push('keysetId override');\n\t\t\t\tif (wantsDeterministicByPolicy) reasons.push('wallet default is deterministic');\n\t\t\t\tif (!isPlainRandom(outputConfig.send)) reasons.push('non-default send output type');\n\t\t\t\tif (outputConfig.keep && !isPlainRandom(outputConfig.keep))\n\t\t\t\t\treasons.push('non-default keep output type');\n\n\t\t\t\tthrow new Error(`Options require a swap: ${reasons.join(', ')}`);\n\t\t\t}\n\n\t\t\t// Proceed with offline exact-match attempt\n\t\t\tconst { keep, send } = this.sendOffline(amount, proofs, {\n\t\t\t\tincludeFees,\n\t\t\t\texactMatch: true,\n\t\t\t\trequireDleq: false, // safety\n\t\t\t});\n\t\t\tconst expectedFee = includeFees ? this.getFeesForProofs(send) : 0;\n\n\t\t\tif (sumProofs(send) === amount + expectedFee) {\n\t\t\t\tthis._logger.info('Successful exactMatch offline selection!');\n\t\t\t\treturn { keep, send };\n\t\t\t}\n\t\t} catch (e: unknown) {\n\t\t\tconst message = e instanceof Error ? e.message : 'Unknown error';\n\t\t\tthis._logger.debug('ExactMatch offline selection failed.', { e: message });\n\t\t}\n\n\t\t// Prepare and complete the send\n\t\tconst txn = await this.prepareSwapToSend(amount, proofs, config, outputConfig);\n\t\treturn await this.completeSwap(txn, config?.privkey);\n\t}\n\n\t/**\n\t * Prepare A Send Transaction.\n\t *\n\t * @remarks\n\t * Allows you to preview fees for a send, get concrete outputs for P2PK SIG_ALL transactions, and\n\t * do any pre-swap tasks (such as marking proofs in-flight etc)\n\t * @example\n\t *\n\t * ```typescript\n\t * // Prepare transaction\n\t * const txn = await wallet.prepareSwapToSend(5, proofs, { includeFees: true });\n\t * const fees = txn.fees;\n\t *\n\t * // Complete transaction\n\t * const { keep, send } = await wallet.completeSwap(txn);\n\t * ```\n\t *\n\t * @param amount Amount to send (receiver gets this net amount).\n\t * @param proofs Array of proofs to split.\n\t * @param config Optional parameters for the swap.\n\t * @returns SwapPreview with metadata for swap transaction.\n\t * @throws Throws if the send cannot be completed offline or if funds are insufficient.\n\t */\n\tasync prepareSwapToSend(\n\t\tamount: number,\n\t\tproofs: Proof[],\n\t\tconfig?: SendConfig,\n\t\toutputConfig?: OutputConfig,\n\t): Promise<SwapPreview> {\n\t\tconst { keysetId, includeFees = false, onCountersReserved } = config || {};\n\n\t\t// Fallback to policy defaults if no outputConfig\n\t\toutputConfig = outputConfig ?? {\n\t\t\tsend: this.defaultOutputType(),\n\t\t\tkeep: this.defaultOutputType(),\n\t\t};\n\n\t\t// Fetch keys\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\n\t\t// Shape SEND output type and denominations\n\t\tlet sendOT = this.configureOutputs(\n\t\t\tamount,\n\t\t\tkeyset,\n\t\t\toutputConfig.send ?? this.defaultOutputType(),\n\t\t\tincludeFees,\n\t\t);\n\t\tconst sendAmount = this.preparedTotal(sendOT);\n\n\t\t// Select the subset of proofs needed to cover the swap (sendTarget + swap fee)\n\t\tconst { keep: unselectedProofs, send: selectedProofs } = this.selectProofsToSend(\n\t\t\tproofs,\n\t\t\tsendAmount,\n\t\t\ttrue, // Include fees to cover swap fee\n\t\t);\n\t\t// this._logger.debug('PROOFS SELECTED', {\n\t\t// \tunselectedProofs: unselectedProofs.map(p=>p.amount),\n\t\t// \tselectedProofs: selectedProofs.map(p=>p.amount),\n\t\t// });\n\t\tif (selectedProofs.length === 0) {\n\t\t\tthrow new Error('Not enough funds available to send');\n\t\t}\n\n\t\t// Calculate our expected change from the swap (and sanity check!)\n\t\tconst selectedSum = sumProofs(selectedProofs);\n\t\tconst swapFee = this.getFeesForProofs(selectedProofs);\n\t\tconst changeAmount = selectedSum - swapFee - sendAmount;\n\t\tthis.failIf(changeAmount < 0, 'Not enough funds available for swap', {\n\t\t\tselectedSum,\n\t\t\tswapFee,\n\t\t\tsendAmount,\n\t\t\tchangeAmount,\n\t\t});\n\n\t\t// Shape KEEP (change) output type and denominations\n\t\t// No includeFees, as we are the receiver of the change\n\t\tlet keepOT = this.configureOutputs(\n\t\t\tchangeAmount,\n\t\t\tkeyset,\n\t\t\toutputConfig.keep ?? this.defaultOutputType(),\n\t\t\tfalse,\n\t\t\tconfig?.proofsWeHave,\n\t\t);\n\t\tconst keepAmount = this.preparedTotal(keepOT);\n\n\t\t// Assign counters atomically if either/both OutputTypes are deterministic\n\t\t// and the counter is zero (auto-assign)\n\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, sendOT, keepOT);\n\t\t[sendOT, keepOT] = autoCounters.outputTypes;\n\t\tif (autoCounters.used) {\n\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'send' });\n\t\t}\n\t\tthis._logger.debug('send counters', { counter: autoCounters.used, sendOT, keepOT });\n\n\t\t// Create the output data\n\t\tconst sendOutputs = this.createOutputData(sendAmount, keyset, sendOT);\n\t\tconst keepOutputs = this.createOutputData(keepAmount, keyset, keepOT);\n\n\t\t// Return SwapPreview\n\t\treturn {\n\t\t\tamount,\n\t\t\tfees: swapFee,\n\t\t\tkeysetId: keyset.id,\n\t\t\tinputs: selectedProofs,\n\t\t\tsendOutputs,\n\t\t\tkeepOutputs,\n\t\t\tunselectedProofs,\n\t\t} as SwapPreview;\n\t}\n\n\t/**\n\t * Complete a prepared swap transaction.\n\t *\n\t * @example\n\t *\n\t * ```typescript\n\t * // Prepare transaction\n\t * const txn = await wallet.prepareSwapToSend(5, proofs, { includeFees: true });\n\t *\n\t * // Complete transaction\n\t * const result = await wallet.completeSwap(txn);\n\t * ```\n\t *\n\t * @param swapPreview With metadata for swap transaction.\n\t * @param privkey The private key(s) for signing.\n\t * @returns SendResponse with keep/send proofs.\n\t */\n\tasync completeSwap(swapPreview: SwapPreview, privkey?: string | string[]): Promise<SendResponse> {\n\t\tconst keepOutputs: OutputDataLike[] = swapPreview?.keepOutputs ? swapPreview.keepOutputs : [];\n\t\tconst sendOutputs: OutputDataLike[] = swapPreview.sendOutputs ? swapPreview.sendOutputs : [];\n\t\tconst unselectedProofs: Proof[] = swapPreview.unselectedProofs\n\t\t\t? swapPreview.unselectedProofs\n\t\t\t: [];\n\n\t\t// Sign proofs if needed\n\t\tif (privkey) {\n\t\t\tswapPreview.inputs = this.signP2PKProofs(swapPreview.inputs, privkey, [\n\t\t\t\t...keepOutputs,\n\t\t\t\t...sendOutputs,\n\t\t\t]);\n\t\t}\n\n\t\t// Create swap transaction\n\t\tconst swapTransaction = this.createSwapTransaction(\n\t\t\tswapPreview.inputs,\n\t\t\tkeepOutputs,\n\t\t\tsendOutputs,\n\t\t);\n\n\t\t// Execute swap\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\t\tthis.failIf(\n\t\t\tsignatures.length < swapTransaction.outputData.length,\n\t\t\t`Mint returned ${signatures.length} signatures, expected ${swapTransaction.outputData.length}`,\n\t\t);\n\n\t\t// Construct proofs\n\t\tconst keyset = this.getKeyset(swapPreview.keysetId);\n\t\tconst swapProofs = swapTransaction.outputData.map((d, i) => d.toProof(signatures[i], keyset));\n\t\tconst reorderedProofs = Array(swapProofs.length);\n\t\tconst reorderedKeepVector = Array(swapTransaction.keepVector.length);\n\t\tswapTransaction.sortedIndices.forEach((s, i) => {\n\t\t\treorderedKeepVector[s] = swapTransaction.keepVector[i];\n\t\t\treorderedProofs[s] = swapProofs[i];\n\t\t});\n\t\tconst keepProofs: Proof[] = [];\n\t\tconst sendProofs: Proof[] = [];\n\t\treorderedProofs.forEach((p: Proof, i) => {\n\t\t\tif (reorderedKeepVector[i]) {\n\t\t\t\tkeepProofs.push(p);\n\t\t\t} else {\n\t\t\t\tsendProofs.push(p);\n\t\t\t}\n\t\t});\n\t\tthis._logger.debug('SEND COMPLETED', {\n\t\t\tunselectedProofs: unselectedProofs.map((p) => p.amount),\n\t\t\tkeepProofs: keepProofs.map((p) => p.amount),\n\t\t\tsendProofs: sendProofs.map((p) => p.amount),\n\t\t});\n\t\treturn {\n\t\t\tkeep: [...keepProofs, ...unselectedProofs],\n\t\t\tsend: sendProofs,\n\t\t};\n\t}\n\n\t/**\n\t * @deprecated - Use send()\n\t */\n\tpublic readonly swap = this.send.bind(this);\n\n\t// -----------------------------------------------------------------\n\t// Section: Transaction Helpers\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Selects proofs to send based on amount and fee inclusion.\n\t *\n\t * @remarks\n\t * Uses an adapted Randomized Greedy with Local Improvement (RGLI) algorithm, which has a time\n\t * complexity O(n log n) and space complexity O(n).\n\t * @param proofs Array of Proof objects available to select from.\n\t * @param amountToSend The target amount to send.\n\t * @param includeFees Optional boolean to include fees; Default: false.\n\t * @param exactMatch Optional boolean to require exact match; Default: false.\n\t * @returns SendResponse containing proofs to keep and proofs to send.\n\t * @throws Throws an error if an exact match cannot be found within MAX_TIMEMS.\n\t * @see https://crypto.ethz.ch/publications/files/Przyda02.pdf\n\t */\n\tselectProofsToSend(\n\t\tproofs: Proof[],\n\t\tamountToSend: number,\n\t\tincludeFees = false,\n\t\texactMatch = false,\n\t): SendResponse {\n\t\tthis.assertAmount(amountToSend, 'selectProofsToSend');\n\t\tconst { keep, send } = this._selectProofs(\n\t\t\tproofs,\n\t\t\tamountToSend,\n\t\t\tthis._keyChain,\n\t\t\tincludeFees,\n\t\t\texactMatch,\n\t\t);\n\t\treturn { keep, send };\n\t}\n\n\t/**\n\t * Prepares proofs for sending by signing P2PK-locked proofs.\n\t *\n\t * @remarks\n\t * Call this method before operations like send if the proofs are P2PK-locked and need unlocking.\n\t * This is a public wrapper for signing.\n\t * @param proofs The proofs to sign.\n\t * @param privkey The private key(s) for signing.\n\t * @param outputData Optional. For signing of SIG_ALL transactions.\n\t * @param quoteId Optional. For signing SIG_ALL melt transactions.\n\t * @returns Signed proofs.\n\t */\n\tsignP2PKProofs(\n\t\tproofs: Proof[],\n\t\tprivkey: string | string[],\n\t\toutputData?: OutputDataLike[],\n\t\tquoteId?: string,\n\t): Proof[] {\n\t\t// Normal case, sign everything as usual\n\t\tif (!isP2PKSigAll(proofs)) {\n\t\t\treturn cryptoSignP2PKProofs(proofs, privkey, this._logger);\n\t\t}\n\n\t\t// Ensure SIG_ALL conditions are met\n\t\tthis.failIfNullish(outputData, 'OutputData is required for SIG_ALL proof signing.');\n\t\tassertSigAllInputs(proofs);\n\n\t\t// SIG_ALL is in flux currently, so let's generate all known message formats\n\t\t// and sign the first proof only against each message...\n\t\tconst [first, ...rest] = proofs;\n\t\tlet signedFirst = first;\n\t\tconst messages = [\n\t\t\tbuildLegacyP2PKSigAllMessage(proofs, outputData, quoteId),\n\t\t\tbuildInterimP2PKSigAllMessage(proofs, outputData, quoteId),\n\t\t\tbuildP2PKSigAllMessage(proofs, outputData, quoteId),\n\t\t];\n\t\tfor (const msg of messages) {\n\t\t\tsignedFirst = cryptoSignP2PKProofs([signedFirst], privkey, this._logger, msg)[0];\n\t\t}\n\n\t\t// Return the proofs in same order as before\n\t\treturn [signedFirst, ...rest];\n\t}\n\n\t/**\n\t * Calculates the fees based on inputs (proofs)\n\t *\n\t * @param proofs Input proofs to calculate fees for.\n\t * @returns Fee amount.\n\t * @throws Throws an error if the proofs keyset is unknown.\n\t */\n\tgetFeesForProofs(proofs: Proof[]): number {\n\t\tconst sumPPK = proofs.reduce((a, c) => a + this.getProofFeePPK(c), 0);\n\t\treturn Math.ceil(sumPPK / 1000);\n\t}\n\n\t/**\n\t * Returns the current fee PPK for a proof according to the cached keyset.\n\t *\n\t * @param proof {Proof} A single proof.\n\t * @returns FeePPK {number} The feePPK for the selected proof.\n\t * @throws Throws an error if the proofs keyset is unknown.\n\t */\n\tprivate getProofFeePPK(proof: Proof): number {\n\t\ttry {\n\t\t\t// We need the proof's keyset so use keyChain here\n\t\t\t// We must NOT fallback to wallet's keyset\n\t\t\treturn this._keyChain.getKeyset(proof.id).fee;\n\t\t} catch (e) {\n\t\t\tthis.fail(`Could not get fee. No keyset found for keyset id: ${proof.id}`, {\n\t\t\t\te,\n\t\t\t\tkeychain: this._keyChain.getKeysets(),\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the fees based on inputs for a given keyset.\n\t *\n\t * @param nInputs Number of inputs.\n\t * @param keysetId KeysetId used to lookup `input_fee_ppk`\n\t * @returns Fee amount.\n\t */\n\tgetFeesForKeyset(nInputs: number, keysetId: string): number {\n\t\ttry {\n\t\t\t// We must NOT fallback to wallet's keyset\n\t\t\tconst feePPK = this._keyChain.getKeyset(keysetId).fee;\n\t\t\treturn Math.floor(Math.max((nInputs * feePPK + 999) / 1000, 0));\n\t\t} catch (e) {\n\t\t\tthis.fail(`No keyset found with ID ${keysetId}`, { e });\n\t\t}\n\t}\n\n\t/**\n\t * Prepares inputs for a mint operation.\n\t *\n\t * @remarks\n\t * Internal method; strips DLEQ (NUT-12) and p2pk_e (NUT-26) for privacy and serializes witnesses.\n\t * Returns an array of new proof objects - does not mutate the originals.\n\t * @param proofs The proofs to prepare.\n\t * @param keepDleq Optional boolean to keep DLEQ (default: false, strips for privacy).\n\t * @returns Prepared proofs for mint payload.\n\t */\n\tprivate _prepareInputsForMint(proofs: Proof[], keepDleq: boolean = false): Proof[] {\n\t\treturn proofs.map((p) => {\n\t\t\tconst witness =\n\t\t\t\tp.witness && typeof p.witness !== 'string' ? JSON.stringify(p.witness) : p.witness;\n\t\t\tconst { dleq, p2pk_e, ...rest } = p; // isolate dleq and p2pk_e\n\t\t\tvoid p2pk_e; // intentionally unused (linter)\n\t\t\t// New proof object\n\t\t\treturn keepDleq && dleq ? { ...rest, dleq, witness } : { ...rest, witness };\n\t\t});\n\t}\n\n\t/**\n\t * Decodes a string token.\n\t *\n\t * @remarks\n\t * Rehydrates a token from the space-saving CBOR format, including mapping short keyset ids to\n\t * their full representation.\n\t * @param token The token in string format (cashuB...)\n\t * @returns Token object.\n\t */\n\tpublic decodeToken(token: string): Token {\n\t\tconst keysetIds = this._keyChain.getAllKeysetIds();\n\t\treturn getDecodedToken(token, keysetIds);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Restore\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Restores batches of deterministic proofs until no more signatures are returned from the mint.\n\t *\n\t * @param [gapLimit=300] The amount of empty counters that should be returned before restoring\n\t *   ends (defaults to 300). Default is `300`\n\t * @param [batchSize=100] The amount of proofs that should be restored at a time (defaults to\n\t *   100). Default is `100`\n\t * @param [counter=0] The counter that should be used as a starting point (defaults to 0). Default\n\t *   is `0`\n\t * @param [keysetId] Which keysetId to use for the restoration. If none is passed the instance's\n\t *   default one will be used.\n\t */\n\tasync batchRestore(\n\t\tgapLimit = 300,\n\t\tbatchSize = 100,\n\t\tcounter = 0,\n\t\tkeysetId?: string,\n\t): Promise<{ proofs: Proof[]; lastCounterWithSignature?: number }> {\n\t\tconst requiredEmptyBatches = Math.ceil(gapLimit / batchSize);\n\t\tconst restoredProofs: Proof[] = [];\n\n\t\tlet lastCounterWithSignature: undefined | number;\n\t\tlet emptyBatchesFound = 0;\n\n\t\twhile (emptyBatchesFound < requiredEmptyBatches) {\n\t\t\tconst restoreRes = await this.restore(counter, batchSize, { keysetId });\n\t\t\tif (restoreRes.proofs.length > 0) {\n\t\t\t\temptyBatchesFound = 0;\n\t\t\t\trestoredProofs.push(...restoreRes.proofs);\n\t\t\t\tlastCounterWithSignature = restoreRes.lastCounterWithSignature;\n\t\t\t} else {\n\t\t\t\temptyBatchesFound++;\n\t\t\t}\n\t\t\tcounter += batchSize;\n\t\t}\n\t\treturn { proofs: restoredProofs, lastCounterWithSignature };\n\t}\n\n\t/**\n\t * Regenerates.\n\t *\n\t * @param start Set starting point for count (first cycle for each keyset should usually be 0)\n\t * @param count Set number of blinded messages that should be generated.\n\t * @param options.keysetId Set a custom keysetId to restore from. @see `keyChain)`\n\t */\n\tasync restore(\n\t\tstart: number,\n\t\tcount: number,\n\t\tconfig?: RestoreConfig,\n\t): Promise<{ proofs: Proof[]; lastCounterWithSignature?: number }> {\n\t\tconst { keysetId } = config || {};\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tthis.failIfNullish(this._seed, 'Cashu Wallet must be initialized with a seed to use restore');\n\n\t\t// create deterministic blank outputs for unknown restore amounts\n\t\t// Note: zero amount + zero denomination passes splitAmount validation\n\t\tconst zeros = Array(count).fill(0);\n\t\tconst outputData = OutputData.createDeterministicData(0, this._seed, start, keyset, zeros);\n\n\t\tconst { outputs, signatures } = await this.mint.restore({\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t});\n\n\t\tconst signatureMap: { [sig: string]: SerializedBlindedSignature } = {};\n\t\toutputs.forEach((o, i) => (signatureMap[o.B_] = signatures[i]));\n\n\t\tconst restoredProofs: Proof[] = [];\n\t\tlet lastCounterWithSignature: number | undefined;\n\n\t\tfor (let i = 0; i < outputData.length; i++) {\n\t\t\tconst matchingSig = signatureMap[outputData[i].blindedMessage.B_];\n\t\t\tif (matchingSig) {\n\t\t\t\tlastCounterWithSignature = start + i;\n\t\t\t\toutputData[i].blindedMessage.amount = matchingSig.amount;\n\t\t\t\trestoredProofs.push(outputData[i].toProof(matchingSig, keyset));\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tproofs: restoredProofs,\n\t\t\tlastCounterWithSignature,\n\t\t};\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Create Mint Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use createMintQuoteBolt11()\n\t */\n\tasync createMintQuote(amount: number, description?: string): Promise<MintQuoteBolt11Response> {\n\t\treturn this.createMintQuoteBolt11(amount, description);\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint. Response returns a Lightning payment request for the\n\t * requested given amount and unit.\n\t *\n\t * @param amount Amount requesting for mint.\n\t * @param description Optional description for the mint quote.\n\t * @param pubkey Optional public key to lock the quote to.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuoteBolt11(\n\t\tamount: number,\n\t\tdescription?: string,\n\t): Promise<MintQuoteBolt11Response> {\n\t\tthis.assertAmount(amount, 'createMintQuoteBolt11');\n\t\t// Check if mint supports description for bolt11\n\t\tif (description) {\n\t\t\tconst mintInfo = this.getMintInfo();\n\t\t\tif (!mintInfo.supportsNut04Description('bolt11', this._unit)) {\n\t\t\t\tthis.fail('Mint does not support description for bolt11');\n\t\t\t}\n\t\t}\n\n\t\tconst mintQuotePayload: MintQuoteBolt11Request = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t};\n\t\tconst res = await this.mint.createMintQuoteBolt11(mintQuotePayload);\n\t\treturn { ...res, amount: res.amount || amount, unit: res.unit || this._unit };\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint that is locked to a public key.\n\t *\n\t * @param amount Amount requesting for mint.\n\t * @param pubkey Public key to lock the quote to.\n\t * @param description Optional description for the mint quote.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit. The quote will be locked to the specified `pubkey`.\n\t */\n\tasync createLockedMintQuote(\n\t\tamount: number,\n\t\tpubkey: string,\n\t\tdescription?: string,\n\t): Promise<MintQuoteBolt11Response> {\n\t\tthis.assertAmount(amount, 'createLockedMintQuote');\n\t\tconst { supported } = this.getMintInfo().isSupported(20);\n\t\tthis.failIf(!supported, 'Mint does not support NUT-20');\n\t\tconst mintQuotePayload: MintQuoteBolt11Request = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t\tpubkey: pubkey,\n\t\t};\n\t\tconst res = await this.mint.createMintQuoteBolt11(mintQuotePayload);\n\t\tthis.failIf(typeof res.pubkey !== 'string', 'Mint returned unlocked mint quote');\n\t\tconst resPubkey = res.pubkey!;\n\t\treturn {\n\t\t\t...res,\n\t\t\tpubkey: resPubkey,\n\t\t\tamount: res.amount || amount,\n\t\t\tunit: res.unit || this._unit,\n\t\t};\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint. Response returns a Lightning BOLT12 offer for the\n\t * requested given amount and unit.\n\t *\n\t * @param pubkey Public key to lock the quote to.\n\t * @param options.amount BOLT12 offer amount requesting for mint. If not specified, the offer will\n\t *   be amountless.\n\t * @param options.description Description for the mint quote.\n\t * @returns The mint will return a mint quote with a BOLT12 offer for minting tokens of the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuoteBolt12(\n\t\tpubkey: string,\n\t\toptions?: {\n\t\t\tamount?: number;\n\t\t\tdescription?: string;\n\t\t},\n\t): Promise<MintQuoteBolt12Response> {\n\t\t// Check if mint supports description for bolt12\n\t\tconst mintInfo = this.getMintInfo();\n\t\tif (options?.description && !mintInfo.supportsNut04Description('bolt12', this._unit)) {\n\t\t\tthis.fail('Mint does not support description for bolt12');\n\t\t}\n\n\t\tconst mintQuotePayload: MintQuoteBolt12Request = {\n\t\t\tpubkey: pubkey,\n\t\t\tunit: this._unit,\n\t\t\tamount: options?.amount,\n\t\t\tdescription: options?.description,\n\t\t};\n\n\t\treturn this.mint.createMintQuoteBolt12(mintQuotePayload);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Check Mint Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use checkMintQuoteBolt11()\n\t */\n\tasync checkMintQuote(quote: string | MintQuoteBolt11Response): Promise<MintQuoteBolt11Response> {\n\t\treturn this.checkMintQuoteBolt11(quote);\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The mint will create and return a Lightning invoice for the specified amount.\n\t */\n\tasync checkMintQuoteBolt11(\n\t\tquote: string | MintQuoteBolt11Response,\n\t): Promise<MintQuoteBolt11Response> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst baseRes = await this.mint.checkMintQuoteBolt11(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn baseRes;\n\t\t}\n\t\treturn { ...baseRes, amount: baseRes.amount || quote.amount, unit: baseRes.unit || quote.unit };\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The latest mint quote for the given quote ID.\n\t */\n\tasync checkMintQuoteBolt12(quote: string): Promise<MintQuoteBolt12Response> {\n\t\treturn this.mint.checkMintQuoteBolt12(quote);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Mint Proofs\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use mintProofsBolt11()\n\t */\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: string | MintQuoteBolt11Response,\n\t\tconfig?: MintProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt11', amount, quote, config, outputType);\n\t}\n\n\t/**\n\t * Mint proofs for a bolt11 quote.\n\t *\n\t * @param amount Amount to mint.\n\t * @param quote Mint quote ID or object (bolt11).\n\t * @param config Optional parameters (e.g. privkey for locked quotes).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Minted proofs.\n\t */\n\tasync mintProofsBolt11(\n\t\tamount: number,\n\t\tquote: string | MintQuoteBolt11Response,\n\t\tconfig?: MintProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt11', amount, quote, config, outputType);\n\t}\n\n\t/**\n\t * Mints proofs for a bolt12 quote.\n\t *\n\t * @param amount Amount to mint.\n\t * @param quote Bolt12 mint quote.\n\t * @param privkey Private key to unlock the quote.\n\t * @param config Optional parameters (e.g. keysetId).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Minted proofs.\n\t */\n\tasync mintProofsBolt12(\n\t\tamount: number,\n\t\tquote: MintQuoteBolt12Response,\n\t\tprivkey: string,\n\t\tconfig?: { keysetId?: string },\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt12', amount, quote, { ...config, privkey }, outputType);\n\t}\n\n\t/**\n\t * Internal helper for minting proofs with bolt11 or bolt12.\n\t *\n\t * @remarks\n\t * Handles blinded messages, signatures, and proof construction. Use public methods like\n\t * mintProofs or helpers for API access.\n\t * @param method 'bolt11' or 'bolt12'.\n\t * @param amount Amount to mint (must be positive).\n\t * @param quote Quote ID or object.\n\t * @param config Optional (privkey, keysetId).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns Minted proofs.\n\t * @throws If params are invalid or mint returns errors.\n\t */\n\tprivate async _mintProofs<T extends 'bolt11' | 'bolt12'>(\n\t\tmethod: T,\n\t\tamount: number,\n\t\tquote: string | (T extends 'bolt11' ? MintQuoteBolt11Response : MintQuoteBolt12Response),\n\t\tconfig?: MintProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<Proof[]> {\n\t\tthis.assertAmount(amount, `_mintProofs: ${method}`);\n\t\toutputType = outputType ?? this.defaultOutputType(); // Fallback to policy\n\t\tconst { privkey, keysetId, proofsWeHave, onCountersReserved } = config ?? {};\n\n\t\t// Shape output type and denominations for our proofs\n\t\t// we are receiving, so no includeFees.\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tlet mintOT = this.configureOutputs(\n\t\t\tamount,\n\t\t\tkeyset,\n\t\t\toutputType,\n\t\t\tfalse, // no fees\n\t\t\tproofsWeHave,\n\t\t);\n\t\tconst mintAmount = this.preparedTotal(mintOT);\n\n\t\t// Assign counters atomically if OutputType is deterministic\n\t\t// and the counter is zero (auto-assign)\n\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, mintOT);\n\t\t[mintOT] = autoCounters.outputTypes;\n\t\tif (autoCounters.used) {\n\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'mintProofs' });\n\t\t}\n\t\tthis._logger.debug('mint counter', { counter: autoCounters.used, mintOT });\n\n\t\t// Create outputs and mint payload\n\t\tconst outputs = this.createOutputData(mintAmount, keyset, mintOT);\n\t\tconst blindedMessages = outputs.map((d) => d.blindedMessage);\n\t\tconst mintPayload: MintRequest = {\n\t\t\toutputs: blindedMessages,\n\t\t\tquote: typeof quote === 'string' ? quote : quote.quote,\n\t\t};\n\n\t\t// Sign payload if the quote carries a public key\n\t\tif (typeof quote !== 'string' && quote.pubkey) {\n\t\t\tthis.failIf(!privkey, 'Can not sign locked quote without private key');\n\t\t\tconst mintQuoteSignature = signMintQuote(privkey!, quote.quote, blindedMessages);\n\t\t\tmintPayload.signature = mintQuoteSignature;\n\t\t}\n\t\t// Mint proofs\n\t\tlet signatures;\n\t\tif (method === 'bolt12') {\n\t\t\t({ signatures } = await this.mint.mintBolt12(mintPayload));\n\t\t} else {\n\t\t\t({ signatures } = await this.mint.mintBolt11(mintPayload));\n\t\t}\n\t\tthis.failIf(\n\t\t\tsignatures.length !== outputs.length,\n\t\t\t`Mint returned ${signatures.length} signatures, expected ${outputs.length}`,\n\t\t);\n\n\t\tthis._logger.debug('MINT COMPLETED', { amounts: outputs.map((o) => o.blindedMessage.amount) });\n\t\treturn outputs.map((d, i) => d.toProof(signatures[i], keyset));\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Create Melt Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use createMeltQuoteBolt11.\n\t */\n\tasync createMeltQuote(invoice: string, amountMsat?: number): Promise<MeltQuoteBolt11Response> {\n\t\treturn this.createMeltQuoteBolt11(invoice, amountMsat);\n\t}\n\n\t/**\n\t * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order\n\t * to pay a Lightning invoice.\n\t *\n\t * @param invoice LN invoice that needs to get a fee estimate.\n\t * @param amountMsat Optional amount in millisatoshis to attach for amountless invoices, must not\n\t *   be provided for invoices that already encode an amount.\n\t * @returns The mint will create and return a melt quote for the invoice with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMeltQuoteBolt11(\n\t\tinvoice: string,\n\t\tamountMsat?: number,\n\t): Promise<MeltQuoteBolt11Response> {\n\t\tif (amountMsat !== undefined) {\n\t\t\tthis.failIf(\n\t\t\t\tinvoiceHasAmountInHRP(invoice),\n\t\t\t\t'amountMsat supplied but invoice already contains an amount. Leave amountMsat undefined for non-zero invoices.',\n\t\t\t);\n\n\t\t\tthis.assertAmount(amountMsat, 'createMeltQuoteBolt11');\n\t\t}\n\n\t\tconst supportsAmountless = this._mintInfo?.supportsAmountless?.('bolt11', this._unit) ?? false;\n\n\t\tconst meltQuotePayload: MeltQuoteBolt11Request = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\n\t\t\t...(supportsAmountless && amountMsat !== undefined\n\t\t\t\t? {\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tamountless: {\n\t\t\t\t\t\t\t\tamount_msat: amountMsat,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: {}),\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuoteBolt11(meltQuotePayload);\n\t\treturn {\n\t\t\t...meltQuote,\n\t\t\tunit: meltQuote.unit || this._unit,\n\t\t\trequest: meltQuote.request || invoice,\n\t\t};\n\t}\n\n\t/**\n\t * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order\n\t * to pay a BOLT12 offer.\n\t *\n\t * @param offer BOLT12 offer that needs to get a fee estimate.\n\t * @param amountMsat Amount in millisatoshis for amount-less offers. If this is defined and the\n\t *   offer has an amount, they **MUST** be equal.\n\t * @returns The mint will create and return a melt quote for the offer with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMeltQuoteBolt12(\n\t\toffer: string,\n\t\tamountMsat?: number,\n\t): Promise<MeltQuoteBolt12Response> {\n\t\treturn this.mint.createMeltQuoteBolt12({\n\t\t\tunit: this._unit,\n\t\t\trequest: offer,\n\t\t\toptions: amountMsat\n\t\t\t\t? {\n\t\t\t\t\t\tamountless: {\n\t\t\t\t\t\t\tamount_msat: amountMsat,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: undefined,\n\t\t});\n\t}\n\n\t/**\n\t * Requests a multi path melt quote from the mint.\n\t *\n\t * @remarks\n\t * Uses NUT-15 Partial multi-path payments for BOLT11.\n\t * @param invoice LN invoice that needs to get a fee estimate.\n\t * @param partialAmount The partial amount of the invoice's total to be paid by this instance.\n\t * @returns The mint will create and return a melt quote for the invoice with an amount and fee\n\t *   reserve.\n\t * @see https://github.com/cashubtc/nuts/blob/main/15.md\n\t */\n\tasync createMultiPathMeltQuote(\n\t\tinvoice: string,\n\t\tmillisatPartialAmount: number,\n\t): Promise<MeltQuoteBolt11Response> {\n\t\tthis.assertAmount(millisatPartialAmount, 'createMultiPathMeltQuote');\n\t\tconst { supported, params } = this.getMintInfo().isSupported(15);\n\t\tthis.failIf(!supported, 'Mint does not support NUT-15');\n\t\tthis.failIf(\n\t\t\t!params?.some((p) => p.method === 'bolt11' && p.unit === this._unit),\n\t\t\t`Mint does not support MPP for bolt11 and ${this._unit}`,\n\t\t);\n\t\tconst meltQuotePayload: MeltQuoteBolt11Request = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\t\t\toptions: { mpp: { amount: millisatPartialAmount } },\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuoteBolt11(meltQuotePayload);\n\t\treturn { ...meltQuote, request: invoice, unit: this._unit };\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Check Melt Quote\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use checkMeltQuoteBolt11()\n\t */\n\tasync checkMeltQuote(quote: string | MeltQuoteBolt11Response): Promise<MeltQuoteBolt11Response> {\n\t\treturn this.checkMeltQuoteBolt11(quote);\n\t}\n\n\t/**\n\t * Returns an existing bolt11 melt quote from the mint.\n\t *\n\t * @param quote ID of the melt quote.\n\t * @returns The mint will return an existing melt quote.\n\t */\n\tasync checkMeltQuoteBolt11(\n\t\tquote: string | MeltQuoteBolt11Response,\n\t): Promise<MeltQuoteBolt11Response> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst meltQuote = await this.mint.checkMeltQuoteBolt11(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn meltQuote;\n\t\t}\n\t\treturn { ...meltQuote, request: quote.request, unit: quote.unit };\n\t}\n\n\t/**\n\t * Returns an existing bolt12 melt quote from the mint.\n\t *\n\t * @param quote ID of the melt quote.\n\t * @returns The mint will return an existing melt quote.\n\t */\n\tasync checkMeltQuoteBolt12(quote: string): Promise<MeltQuoteBolt12Response> {\n\t\treturn this.mint.checkMeltQuoteBolt12(quote);\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Melt Proofs\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * @deprecated Use meltProofsBolt11()\n\t */\n\tasync meltProofs(\n\t\tmeltQuote: MeltQuoteBolt11Response,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltProofsResponse<MeltQuoteBolt11Response>> {\n\t\treturn this.meltProofsBolt11(meltQuote, proofsToSend, config, outputType);\n\t}\n\n\t/**\n\t * Melt proofs for a bolt11 melt quote.\n\t *\n\t * @remarks\n\t * ProofsToSend must be at least amount+fee_reserve from the melt quote. This function does not\n\t * perform coin selection!.\n\t * @param meltQuote ID of the melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param config Optional parameters.\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns MeltProofsResponse with quote and change proofs.\n\t */\n\tasync meltProofsBolt11(\n\t\tmeltQuote: MeltQuoteBolt11Response,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltProofsResponse<MeltQuoteBolt11Response>> {\n\t\tconst meltTxn = await this.prepareMelt('bolt11', meltQuote, proofsToSend, config, outputType);\n\t\tconst preferAsync: boolean = typeof config?.onChangeOutputsCreated === 'function';\n\t\treturn this.completeMelt<MeltQuoteBolt11Response>(meltTxn, config?.privkey, preferAsync);\n\t}\n\n\t/**\n\t * Melt proofs for a bolt12 melt quote, returns change proofs using specified outputType.\n\t *\n\t * @remarks\n\t * ProofsToSend must be at least amount+fee_reserve from the melt quote. This function does not\n\t * perform coin selection!.\n\t * @param meltQuote ID of the melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param config Optional parameters.\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns MeltProofsResponse with quote and change proofs.\n\t */\n\tasync meltProofsBolt12(\n\t\tmeltQuote: MeltQuoteBolt12Response,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltProofsResponse<MeltQuoteBolt12Response>> {\n\t\tconst meltTxn = await this.prepareMelt('bolt12', meltQuote, proofsToSend, config, outputType);\n\t\tconst preferAsync: boolean = typeof config?.onChangeOutputsCreated === 'function';\n\t\treturn this.completeMelt<MeltQuoteBolt12Response>(meltTxn, config?.privkey, preferAsync);\n\t}\n\n\t/**\n\t * Prepare A Melt Transaction.\n\t *\n\t * @remarks\n\t * Allows you to preview fees for a melt, get concrete outputs for P2PK SIG_ALL melts, and do any\n\t * pre-melt tasks (such as marking proofs in-flight etc). Creates NUT-08 blanks (1-sat) for\n\t * Lightning fee return and returns a MeltPreview, which you can melt using completeMelt.\n\t * @param method Payment method of the quote.\n\t * @param meltQuote The melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param config Optional (keysetId, onChangeOutputsCreated).\n\t * @param outputType Configuration for proof generation. Defaults to wallet.defaultOutputType().\n\t * @returns MeltPreview.\n\t * @throws If params are invalid.\n\t * @see https://github.com/cashubtc/nuts/blob/main/08.md.\n\t */\n\tasync prepareMelt<TQuote extends MeltQuoteBaseResponse>(\n\t\tmethod: string,\n\t\tmeltQuote: TQuote,\n\t\tproofsToSend: Proof[],\n\t\tconfig?: MeltProofsConfig,\n\t\toutputType?: OutputType,\n\t): Promise<MeltPreview<TQuote>> {\n\t\toutputType = outputType ?? this.defaultOutputType(); // Fallback to policy\n\t\tconst { keysetId, onChangeOutputsCreated, onCountersReserved } = config || {};\n\t\tconst keyset = this.getKeyset(keysetId); // specified or wallet keyset\n\t\tconst sendAmount = sumProofs(proofsToSend);\n\n\t\t// feeReserve is the overage above the invoice/offer amount.\n\t\t// In the common case where selected proofs = amount + fee_reserve,\n\t\t// this equals the quoteâ€™s fee_reserve. If you overshoot more,\n\t\t// the extra also becomes NUT-08 lightning fee change.\n\t\tconst feeReserve = sendAmount - meltQuote.amount;\n\t\tlet outputData: OutputDataLike[] = [];\n\n\t\t// bolt11 does not allow partial payment, and although bolt12 could, mints\n\t\t// like CDK forbid it. So let's fail loudly up front...\n\t\tthis.failIf(feeReserve < 0, 'Not enough proofs to cover amount + fee reserve', {\n\t\t\tsendAmount,\n\t\t\tquoteAmount: meltQuote.amount,\n\t\t});\n\n\t\tif (outputType.type === 'custom') {\n\t\t\toutputData = outputType.data;\n\t\t}\n\t\t// Create NUT-08 blanks for return of Lightning fee change\n\t\t// Note: zero amount + zero denomination passes splitAmount validation\n\t\telse if (feeReserve > 0) {\n\t\t\tlet count = Math.ceil(Math.log2(feeReserve)) || 1;\n\t\t\tif (count < 0) count = 0; // Prevents: -Infinity\n\t\t\tconst denominations: number[] = count ? new Array<number>(count).fill(0) : [];\n\t\t\tthis._logger.debug('Creating NUT-08 blanks for fee reserve', {\n\t\t\t\tfeeReserve,\n\t\t\t\tdenominations,\n\t\t\t});\n\n\t\t\tlet meltOT: OutputType = { ...outputType, denominations };\n\t\t\t// Assign counter atomically if OutputType is deterministic\n\t\t\t// and the counter is zero (auto-assign)\n\t\t\tconst autoCounters = await this.addCountersToOutputTypes(keyset.id, meltOT);\n\t\t\t[meltOT] = autoCounters.outputTypes;\n\t\t\tif (autoCounters.used) {\n\t\t\t\tthis.safeCallback(onCountersReserved, autoCounters.used, { op: 'meltProofs' });\n\t\t\t}\n\t\t\tthis._logger.debug('melt counter', { counter: autoCounters.used, meltOT });\n\t\t\t// Generate the blank outputs (no fees as we are receiving change)\n\t\t\t// Remember, zero amount + zero denomination passes splitAmount validation\n\t\t\toutputData = this.createOutputData(0, keyset, meltOT);\n\t\t}\n\n\t\t// Create melt preview\n\t\tconst meltPreview: MeltPreview<TQuote> = {\n\t\t\tmethod,\n\t\t\tinputs: proofsToSend,\n\t\t\toutputData,\n\t\t\tkeysetId: keyset.id,\n\t\t\tquote: meltQuote,\n\t\t};\n\n\t\t// Fire legacy event(s) after preview creation\n\t\t// Note: These events are deprecated and should be removed in a future version\n\t\tif (outputData.length > 0) {\n\t\t\tconst blanks: MeltBlanks<TQuote> = {\n\t\t\t\tmethod: method as 'bolt11' | 'bolt12',\n\t\t\t\tpayload: {\n\t\t\t\t\tquote: meltQuote.quote,\n\t\t\t\t\tinputs: proofsToSend,\n\t\t\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t\t\t},\n\t\t\t\toutputData,\n\t\t\t\tkeyset,\n\t\t\t\tquote: meltQuote,\n\t\t\t};\n\t\t\tthis.safeCallback(onChangeOutputsCreated, blanks, { op: 'meltProofs' });\n\t\t\tthis.on._emitMeltBlanksCreated(blanks); // global callback\n\t\t}\n\n\t\treturn meltPreview;\n\t}\n\n\t/**\n\t * Completes a pending melt by calling the melt endpoint and constructing change proofs.\n\t *\n\t * @remarks\n\t * Use with a MeltPreview returned from prepareMelt or the legacy MeltBlanks object returned by\n\t * the meltBlanksCreated or onChangeOutputsCreated callback. This method lets you sign P2PK locked\n\t * proofs before melting. If the payment is pending or unpaid, the change array will be empty.\n\t * @param meltPreview The preview from prepareMelt().\n\t * @param privkey The private key(s) for signing.\n\t * @param preferAsync Optional override to set 'respond-async' header.\n\t * @returns Updated MeltProofsResponse.\n\t * @throws If melt fails or signatures don't match output count.\n\t */\n\tasync completeMelt<TQuote extends MeltQuoteBaseResponse>(\n\t\tmeltPreview: MeltPreview<TQuote> | MeltBlanks<TQuote>,\n\t\tprivkey?: string | string[],\n\t\tpreferAsync?: boolean,\n\t): Promise<MeltProofsResponse<TQuote>> {\n\t\t// Convert from legacy MeltBlanks if needed\n\t\tmeltPreview = this.maybeConvertMeltBlanks(meltPreview);\n\n\t\t// Extract vars from MeltPreview\n\t\tlet inputs = meltPreview.inputs;\n\t\tconst outputs = meltPreview.outputData.map((d) => d.blindedMessage);\n\t\tconst quote = meltPreview.quote.quote;\n\t\tconst keyset = this.getKeyset(meltPreview.keysetId);\n\n\t\t// Sign proofs if needed\n\t\tif (privkey) {\n\t\t\tinputs = this.signP2PKProofs(inputs, privkey, meltPreview.outputData, quote);\n\t\t}\n\n\t\t// Prepare proofs for mint\n\t\tinputs = this._prepareInputsForMint(inputs);\n\n\t\t// Construct melt payload\n\t\tconst meltPayload: MeltRequest = { quote, inputs, outputs };\n\n\t\t// Make melt call (note: bolt11 has legacy data handling)\n\t\tconst meltResponse: MeltQuoteBaseResponse =\n\t\t\tmeltPreview.method === 'bolt11'\n\t\t\t\t? await this.mint.meltBolt11(meltPayload, { preferAsync })\n\t\t\t\t: await this.mint.melt<TQuote>(meltPreview.method, meltPayload, {\n\t\t\t\t\t\tpreferAsync,\n\t\t\t\t\t});\n\n\t\t// Check for too many blind signatures before mapping\n\t\tthis.failIf(\n\t\t\t(meltResponse.change?.length ?? 0) > meltPreview.outputData.length,\n\t\t\t`Mint returned ${meltResponse.change?.length ?? 0} signatures, but only ${meltPreview.outputData.length} blanks were provided`,\n\t\t);\n\n\t\t// Construct change (shorter ok)\n\t\tconst change =\n\t\t\tmeltResponse.change?.map((s, i) => meltPreview.outputData[i].toProof(s, keyset)) ?? [];\n\n\t\tif (preferAsync) {\n\t\t\tthis._logger.debug('ASYNC MELT REQUESTED', meltResponse);\n\t\t} else {\n\t\t\tthis._logger.debug('MELT COMPLETED', { changeAmounts: change.map((p) => p.amount) });\n\t\t}\n\n\t\tconst mergedQuote = {\n\t\t\t...meltPreview.quote,\n\t\t\t...meltResponse,\n\t\t} as TQuote;\n\n\t\treturn { quote: mergedQuote, change } as MeltProofsResponse<TQuote>;\n\t}\n\n\t/**\n\t * Helper to ease transition from MeltBlanks to MeltPreview.\n\t */\n\tprivate maybeConvertMeltBlanks<TQuote extends MeltQuoteBaseResponse>(\n\t\tmelt: MeltPreview<TQuote> | MeltBlanks<TQuote>,\n\t): MeltPreview<TQuote> {\n\t\t// New shape already, just return as is\n\t\tif (!('payload' in melt)) {\n\t\t\treturn melt;\n\t\t}\n\t\t// Legacy MeltBlanks, adapt it to MeltPreview\n\t\tthis._logger.warn(\n\t\t\t'MeltBlanks objects and the meltBlanksCreated / onChangeOutputsCreated events are deprecated. Please use wallet.prepareMelt() to create a MeltPreview instead.',\n\t\t);\n\t\tconst { method, payload, outputData, keyset, quote } = melt;\n\t\treturn {\n\t\t\tmethod,\n\t\t\tinputs: payload.inputs,\n\t\t\toutputData,\n\t\t\tkeysetId: keyset.id,\n\t\t\tquote,\n\t\t};\n\t}\n\n\t// -----------------------------------------------------------------\n\t// Section: Proof States\n\t// -----------------------------------------------------------------\n\n\t/**\n\t * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)\n\t *\n\t * @param proofs (only the `secret` field is required)\n\t * @returns NUT-07 state for each proof, in same order.\n\t */\n\tasync checkProofsStates(proofs: Array<Pick<Proof, 'secret'>>): Promise<ProofState[]> {\n\t\tconst enc = new TextEncoder();\n\t\tconst Ys = proofs.map((p: Pick<Proof, 'secret'>) =>\n\t\t\thashToCurve(enc.encode(p.secret)).toHex(true),\n\t\t);\n\t\t// TODO: Replace this with a value from the info endpoint of the mint eventually\n\t\tconst BATCH_SIZE = 100;\n\t\tconst states: ProofState[] = [];\n\t\tfor (let i = 0; i < Ys.length; i += BATCH_SIZE) {\n\t\t\tconst YsSlice = Ys.slice(i, i + BATCH_SIZE);\n\t\t\tconst { states: batchStates } = await this.mint.check({\n\t\t\t\tYs: YsSlice,\n\t\t\t});\n\t\t\tconst stateMap: { [y: string]: ProofState } = {};\n\t\t\tbatchStates.forEach((s) => {\n\t\t\t\tstateMap[s.Y] = s;\n\t\t\t});\n\t\t\tfor (let j = 0; j < YsSlice.length; j++) {\n\t\t\t\tconst state = stateMap[YsSlice[j]];\n\t\t\t\tthis.failIfNullish(state, 'Could not find state for proof with Y: ' + YsSlice[j]);\n\t\t\t\tstates.push(state);\n\t\t\t}\n\t\t}\n\t\treturn states;\n\t}\n\n\t/**\n\t * Groups proofs by their corresponding state, preserving order within each group.\n\t *\n\t * @param proofs (only the `secret` field is required)\n\t * @returns An object with arrays of proofs grouped by CheckStateEnum state.\n\t */\n\tasync groupProofsByState(\n\t\tproofs: Proof[],\n\t): Promise<{ unspent: Proof[]; pending: Proof[]; spent: Proof[] }> {\n\t\tconst states: ProofState[] = await this.checkProofsStates(proofs);\n\t\tconst result = {\n\t\t\tunspent: [] as Proof[],\n\t\t\tpending: [] as Proof[],\n\t\t\tspent: [] as Proof[],\n\t\t};\n\t\tfor (let i = 0; i < states.length; i++) {\n\t\t\tconst proof = proofs[i];\n\t\t\tswitch (states[i].state) {\n\t\t\t\tcase CheckStateEnum.UNSPENT:\n\t\t\t\t\tresult.unspent.push(proof);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CheckStateEnum.PENDING:\n\t\t\t\t\tresult.pending.push(proof);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CheckStateEnum.SPENT:\n\t\t\t\t\tresult.spent.push(proof);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport { Wallet };\n","import type { AuthProvider } from './AuthProvider';\nimport request, { type RequestFn } from '../transport';\nimport { joinUrls, hasValidDleq, encodeJsonToBase64, Bytes } from '../utils';\nimport { MintInfo } from '../model/MintInfo';\nimport { OutputData } from '../model/OutputData';\nimport type {\n\tGetInfoResponse,\n\tGetKeysResponse,\n\tGetKeysetsResponse,\n\tProof,\n\tSerializedBlindedSignature,\n} from '../model/types';\nimport { type Logger, NULL_LOGGER } from '../logger';\nimport { type OIDCAuth, type TokenResponse } from './OIDCAuth';\nimport { KeyChain, type Keyset } from '../wallet';\n\nexport type AuthManagerOptions = {\n\t/**\n\t * Hard limit to target when minting BATs in one request. If omitted, we'll read\n\t * `nuts['22'].bat_max_mint` from the mint \"/v1/info\" endpoint.\n\t */\n\tmaxPerMint?: number;\n\t/**\n\t * Desired BAT pool size. Weâ€™ll top-up to min(desiredPoolSize, bat_max_mint) on demand.\n\t */\n\tdesiredPoolSize?: number;\n\t/**\n\t * Custom request fn (e.g. for tests or host env).\n\t */\n\trequest?: RequestFn;\n\t/**\n\t * Logger.\n\t */\n\tlogger?: Logger;\n};\n\ntype StoredTokens = {\n\taccessToken?: string;\n\trefreshToken?: string;\n\t/**\n\t * Epoch timestamp (ms).\n\t */\n\texpiresAt?: number;\n};\n\n/**\n * Response from the mint after blind auth minting.\n */\ntype BlindAuthMintResponse = {\n\tsignatures: SerializedBlindedSignature[];\n};\n\n/**\n * AuthManager.\n *\n * - Owns CAT lifecycle (stores, optional refresh via attached OIDCAuth)\n * - Mints and serves BATs (NUT-22)\n * - Validates DLEQs for BATs per NUT-12.\n * - Supplies serialized BATs for 'Blind-auth' and CAT for 'Clear-auth'\n */\nexport class AuthManager implements AuthProvider {\n\tprivate readonly mintUrl: string;\n\tprivate readonly req: RequestFn;\n\tprivate readonly logger: Logger;\n\tprivate info?: MintInfo;\n\tprivate lockChain?: Promise<void>;\n\tprivate inflightRefresh?: Promise<void>;\n\tprivate static readonly MIN_VALID_SECS = 30;\n\n\t// Open ID Connect (OIDC)\n\tprivate oidc?: OIDCAuth;\n\tprivate tokens: StoredTokens = {};\n\n\t// Blind Auth Token (BAT) pool\n\tprivate pool: Proof[] = [];\n\tprivate desiredPoolSize = 10;\n\tprivate maxPerMint = 10;\n\n\t// Keychain for 'auth' unit\n\tprivate keychain?: KeyChain;\n\n\tconstructor(mintUrl: string, opts?: AuthManagerOptions) {\n\t\tthis.mintUrl = mintUrl;\n\t\tthis.req = opts?.request ?? request;\n\t\tthis.logger = opts?.logger ?? NULL_LOGGER;\n\t\tthis.desiredPoolSize = Math.max(1, opts?.desiredPoolSize ?? this.desiredPoolSize);\n\t\tthis.maxPerMint = Math.max(1, opts?.maxPerMint ?? this.maxPerMint);\n\t}\n\n\t// ------------------------------\n\t// Public API\n\t// ------------------------------\n\n\t/**\n\t * Attach an OIDCAuth instance so this manager can refresh CATs. Registers a listener to update\n\t * internal CAT/refresh state on new tokens.\n\t */\n\tattachOIDC(oidc: OIDCAuth): this {\n\t\tthis.oidc = oidc;\n\t\tthis.oidc.addTokenListener((t) => this.updateFromOIDC(t));\n\t\treturn this;\n\t}\n\n\tget poolSize(): number {\n\t\treturn this.pool.length;\n\t}\n\tget poolTarget(): number {\n\t\treturn this.desiredPoolSize;\n\t}\n\tget activeAuthKeysetId(): string | undefined {\n\t\ttry {\n\t\t\treturn this.keychain?.getCheapestKeyset().id;\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\tget hasCAT(): boolean {\n\t\treturn !!this.tokens.accessToken;\n\t}\n\n\t// ------------------------------\n\t// AuthProvider (NUT-21, Clear-auth)\n\t// ------------------------------\n\n\tgetCAT(): string | undefined {\n\t\treturn this.tokens.accessToken;\n\t}\n\n\tsetCAT(cat: string | undefined): void {\n\t\tthis.tokens.accessToken = cat;\n\t\tif (!cat) {\n\t\t\tthis.tokens.refreshToken = undefined;\n\t\t\tthis.tokens.expiresAt = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Ensure a valid CAT is available (refresh if expiring soon). Returns a token safe to send right\n\t * now, or undefined if unobtainable.\n\t */\n\tasync ensureCAT(minValidSecs?: number): Promise<string | undefined> {\n\t\tif (this.validForAtLeast(minValidSecs)) {\n\t\t\treturn this.tokens.accessToken;\n\t\t}\n\n\t\tif (!this.oidc || !this.tokens.refreshToken) {\n\t\t\treturn this.tokens.accessToken; // nothing we can do\n\t\t}\n\n\t\t// One refresh at a time\n\t\tif (!this.inflightRefresh) {\n\t\t\tthis.inflightRefresh = (async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst tok = await this.oidc!.refresh(this.tokens.refreshToken!);\n\t\t\t\t\tthis.updateFromOIDC(tok);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tthis.logger.warn('AuthManager: CAT refresh failed', { err });\n\t\t\t\t} finally {\n\t\t\t\t\tthis.inflightRefresh = undefined;\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\t\tawait this.inflightRefresh;\n\t\treturn this.validForAtLeast(0) ? this.tokens.accessToken : undefined;\n\t}\n\n\t// Returns true if expiry date is >minValidSecs away\n\tprivate validForAtLeast(minValidSecs: number = AuthManager.MIN_VALID_SECS): boolean {\n\t\tconst { accessToken, expiresAt } = this.tokens;\n\t\tif (!accessToken) return false;\n\t\tif (!expiresAt) return true; // Unknown expiry, allow and rely on server to reject if invalid\n\t\treturn Date.now() + minValidSecs * 1000 < expiresAt;\n\t}\n\n\t// Updates access and refresh tokens in our store, using either the explicit expires_in key or falling back to the JWT expiry.\n\tprivate updateFromOIDC(t: TokenResponse): void {\n\t\tif (!t.access_token) return;\n\t\tconst nowMs = Date.now();\n\t\tthis.tokens.accessToken = t.access_token;\n\t\tif (t.refresh_token) this.tokens.refreshToken = t.refresh_token;\n\t\tif (typeof t.expires_in === 'number' && t.expires_in > 0) {\n\t\t\tthis.tokens.expiresAt = nowMs + t.expires_in * 1000; // Prefer expires_in\n\t\t} else {\n\t\t\t// Fall back to JWT exp, else undefined\n\t\t\tconst expSec = this.parseJwtExpSec(t.access_token);\n\t\t\tthis.tokens.expiresAt = expSec ? expSec * 1000 : undefined;\n\t\t}\n\t\tthis.logger.debug('AuthManager: OIDC tokens updated', { expiresAt: this.tokens.expiresAt });\n\t}\n\n\t// ------------------------------\n\t// AuthProvider (NUT-22, Blind-auth)\n\t// ------------------------------\n\n\t/**\n\t * Ensure there are enough BAT tokens (topping up if needed)\n\t *\n\t * @param minTokens Minimum tokens needed.\n\t */\n\tasync ensure(minTokens: number): Promise<void> {\n\t\tawait this.init();\n\t\tif (this.pool.length >= minTokens) return;\n\t\tconst toTarget = Math.max(this.desiredPoolSize, minTokens);\n\t\tconst batMax = this.getBatMaxMint();\n\t\tconst batch = Math.min(toTarget - this.pool.length, batMax);\n\t\tif (batch <= 0) return;\n\t\tawait this.topUp(batch);\n\t}\n\n\t/**\n\t * Gets a Blind Authentication Token (BAT)\n\t *\n\t * @param {method, path} to Call (not used in our implementation)\n\t * @returns The serialized BAT ready to insert into request header.\n\t */\n\tasync getBlindAuthToken({\n\t\tmethod,\n\t\tpath,\n\t}: {\n\t\tmethod: 'GET' | 'POST';\n\t\tpath: string;\n\t}): Promise<string> {\n\t\tif (this.info && !this.info.requiresBlindAuthToken(method, path)) {\n\t\t\tthis.logger.warn('Endpoint is not marked as protected by NUT-22; still issuing BAT', {\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t});\n\t\t}\n\n\t\treturn this.withLock(async () => {\n\t\t\tawait this.ensure(1);\n\t\t\tif (this.pool.length === 0) {\n\t\t\t\tthrow new Error('AuthManager: no BATs available and minting failed');\n\t\t\t}\n\t\t\t// Pop one BAT and serialize without DLEQ for the header. Per NUT-22, wallets\n\t\t\t// SHOULD delete BAT even on error, so no need to track it in-flight.\n\t\t\tconst proof = this.pool.pop()!;\n\t\t\tthis.logger.debug('AuthManager: BAT requested', {\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\tremaining: this.pool.length,\n\t\t\t});\n\t\t\treturn serializeBAT(proof);\n\t\t});\n\t}\n\n\t/**\n\t * Replace or merge the current BAT pool with previously persisted BATs.\n\t */\n\timportPool(proofs: Proof[], mode: 'replace' | 'merge' = 'replace'): void {\n\t\tif (mode === 'replace') {\n\t\t\tthis.pool = [];\n\t\t}\n\t\tconst seen = new Map(this.pool.map((p) => [p.secret, p]));\n\t\tfor (const p of proofs) {\n\t\t\tif (!p || !p.secret || !p.C || !p.id) continue; // shape check\n\t\t\tif (!seen.has(p.secret)) {\n\t\t\t\tthis.pool.push(p);\n\t\t\t\tseen.set(p.secret, p);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return a deep-copied snapshot of the current BAT pool (full Proofs, including dleq).\n\t */\n\texportPool(): Proof[] {\n\t\treturn this.pool.map((p) => ({ ...p, dleq: p.dleq ? { ...p.dleq } : undefined }));\n\t}\n\n\t// ------------------------------\n\t// Internals\n\t// ------------------------------\n\n\t/**\n\t * Extract exp, seconds since epoch, from a JWT access token.\n\t */\n\tprivate parseJwtExpSec(token?: string): number | undefined {\n\t\tif (!token) return;\n\t\tconst parts = token.split('.');\n\t\tif (parts.length !== 3) return;\n\t\ttry {\n\t\t\tconst jsonStr = Bytes.toString(Bytes.fromBase64(parts[1]));\n\t\t\tconst obj = JSON.parse(jsonStr) as { exp?: unknown };\n\t\t\tconst exp = typeof obj.exp === 'number' ? obj.exp : Number(obj.exp);\n\t\t\tif (Number.isFinite(exp) && exp > 0) return exp;\n\t\t} catch {\n\t\t\tthis.logger.warn('JWT access token was malformed.', {\n\t\t\t\ttoken,\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n\n\t/**\n\t * Simple mutex lock - chains promises in order.\n\t */\n\tprivate async withLock<T>(fn: () => T | Promise<T>): Promise<T> {\n\t\tconst prev = this.lockChain ?? Promise.resolve();\n\t\tlet release!: () => void;\n\t\tconst lock = new Promise<void>((resolve) => {\n\t\t\trelease = resolve;\n\t\t});\n\t\tconst chain = prev.then(() => lock); // capture the exact Promise we assign\n\t\tthis.lockChain = chain;\n\t\ttry {\n\t\t\tawait prev;\n\t\t\treturn await fn();\n\t\t} finally {\n\t\t\trelease();\n\t\t\t// Only clear if no newer chain has been installed\n\t\t\tif (this.lockChain === chain) this.lockChain = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Initialise mint info and auth keysets/keys as needed.\n\t */\n\tprivate async init(): Promise<void> {\n\t\tif (!this.info) {\n\t\t\tconst info = await this.req<GetInfoResponse>({\n\t\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/info'),\n\t\t\t\tmethod: 'GET',\n\t\t\t});\n\t\t\tthis.info = new MintInfo(info);\n\t\t}\n\t\tif (!this.keychain) {\n\t\t\t// fetch blind keysets and keys for unit 'auth'\n\t\t\tconst [allKeysets, allKeys] = await Promise.all([\n\t\t\t\tthis.req<GetKeysetsResponse>({\n\t\t\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/auth/blind/keysets'),\n\t\t\t\t\tmethod: 'GET',\n\t\t\t\t}),\n\t\t\t\tthis.req<GetKeysResponse>({\n\t\t\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/auth/blind/keys'),\n\t\t\t\t\tmethod: 'GET',\n\t\t\t\t}),\n\t\t\t]);\n\t\t\t// build a KeyChain preloaded with caches, unit 'auth'\n\t\t\t// Then smoke test to surface errors early - no need to init() with cached keys\n\t\t\tthis.keychain = new KeyChain(this.mintUrl, 'auth', allKeysets.keysets, allKeys.keysets);\n\t\t\tthis.keychain.getCheapestKeyset();\n\t\t}\n\t}\n\n\t/**\n\t * Gets the BAT minting limit: lower of manager limit and Mintâ€™s NUT-22 limit.\n\t */\n\tprivate getBatMaxMint(): number {\n\t\tif (!this.info) throw new Error('AuthManager: mint info not loaded');\n\t\tconst n22 = this.info.nuts['22'];\n\t\tconst mintMax = n22?.bat_max_mint ?? this.maxPerMint;\n\t\treturn Math.max(1, Math.min(this.maxPerMint, mintMax));\n\t}\n\n\tprivate getActiveKeys(): Keyset {\n\t\tif (!this.keychain) throw new Error('AuthManager: keyset not loaded for active keyset');\n\t\treturn this.keychain.getCheapestKeyset();\n\t}\n\n\t/**\n\t * Mint a batch of BATs using the current CAT if the endpoint is protected by NUT-21.\n\t */\n\tprivate async topUp(n: number): Promise<void> {\n\t\tif (!this.info) throw new Error('AuthManager: mint info not loaded');\n\n\t\t// Check NUT-21 protection of the BAT mint endpoint\n\t\tconst needsCAT = this.info.requiresClearAuthToken('POST', '/v1/auth/blind/mint');\n\t\tlet cat: string | undefined;\n\t\tif (needsCAT) {\n\t\t\tcat = await this.ensureCAT();\n\t\t\tif (!cat) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'AuthManager: Clear-auth token required for /v1/auth/blind/mint but not available. Authenticate with the mint to obtain a CAT first.',\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t// Create blinded messages for amount n in unit 'auth' (supports only 1s)\n\t\tconst keys = this.getActiveKeys();\n\t\tconst outputs = OutputData.createRandomData(n, keys);\n\t\tconst payload = { outputs: outputs.map((d) => d.blindedMessage) };\n\t\t// Set CAT header if needed\n\t\tconst headers: Record<string, string> = {};\n\t\tif (cat) headers['Clear-auth'] = cat;\n\t\t// Do the topup\n\t\tconst res = await this.req<BlindAuthMintResponse>({\n\t\t\tendpoint: joinUrls(this.mintUrl, '/v1/auth/blind/mint'),\n\t\t\tmethod: 'POST',\n\t\t\theaders,\n\t\t\trequestBody: payload as unknown as Record<string, unknown>,\n\t\t});\n\t\tif (!Array.isArray(res?.signatures) || res.signatures.length !== outputs.length) {\n\t\t\tthrow new Error('AuthManager: bad BAT mint response');\n\t\t}\n\t\t// Create BAT proofs and check DLEQ\n\t\tconst proofs = outputs.map((d, i) => d.toProof(res.signatures[i], keys));\n\t\tfor (const p of proofs) {\n\t\t\tif (!hasValidDleq(p, keys)) {\n\t\t\t\tthrow new Error('AuthManager: mint returned BAT with invalid DLEQ');\n\t\t\t}\n\t\t}\n\t\t// Add BAT proofs to pool\n\t\tthis.pool.push(...proofs);\n\t\tthis.logger.debug('AuthManager: performed topUp', {\n\t\t\tminted: proofs.length,\n\t\t\tpool: this.pool.length,\n\t\t});\n\t}\n}\n\n// ------------------------------\n// Helpers\n// ------------------------------\n\n/**\n * Serialize an Auth Proof as a BAT header value: \"authA\" + base64(JSON_without_dleq)\n */\nfunction serializeBAT(proof: Proof): string {\n\t// strip dleq per NUT-22\n\tconst token = { id: proof.id, secret: proof.secret, C: proof.C };\n\tconst base64Data = encodeJsonToBase64(token);\n\treturn `authA${base64Data}`;\n}\n","import { type Logger } from '../logger';\nimport { Mint } from '../mint/Mint';\nimport { Wallet } from '../wallet/Wallet';\nimport { AuthManager } from './AuthManager';\nimport type { OIDCAuth, OIDCAuthOptions } from './OIDCAuth';\n\n/**\n * High-level helper to create a fully authenticated wallet session.\n *\n * @remarks\n * Like a dependency injector, it wires AuthManager->Mint->OIDCAuth->Wallet in the correct order.\n * Wallet is returned ready to use.\n * @param mintUrl URL of the mint to connect to.\n * @param options.authPool Optional. Desired BAT pool size (default 10)\n * @param options.oidc Optional. Options for OIDCAuth (scope, clientId, logger, etc.)\n * @returns {mint, auth, oidc, wallet} â€” hydrated, ready to use.\n * @throws If mint does not require authentication.\n */\nexport async function createAuthWallet(\n\tmintUrl: string,\n\toptions?: {\n\t\tauthPool?: number;\n\t\toidc?: OIDCAuthOptions;\n\t\tlogger?: Logger;\n\t},\n): Promise<{ mint: Mint; auth: AuthManager; oidc: OIDCAuth; wallet: Wallet }> {\n\t// 1. Create an AuthManager for both BAT and CAT handling\n\tconst auth = new AuthManager(mintUrl, {\n\t\tdesiredPoolSize: options?.authPool ?? 10,\n\t\tlogger: options?.logger,\n\t});\n\n\t// 2. Create a Mint instance using the AuthManager\n\tconst mint = new Mint(mintUrl, { authProvider: auth, logger: options?.logger });\n\n\t// 3. Discover and configure OIDCAuth from the mint\n\tconst oidc = await mint.oidcAuth({\n\t\t...options?.oidc,\n\t\tlogger: options?.logger,\n\t\tonTokens: (t) => auth.setCAT(t.access_token), // set CAT automatically\n\t});\n\n\t// 4. Attach OIDCAuth back into AuthManager for refresh, etc.\n\tauth.attachOIDC(oidc);\n\n\t// 5. Hydrate wallet using the same mint and auth provider\n\tconst wallet = new Wallet(mint, { authProvider: auth, logger: options?.logger });\n\tawait wallet.loadMint();\n\n\treturn { mint, auth, oidc, wallet };\n}\n"],"names":["HttpResponseError","message","status","NetworkError","MintOperationError","code","detail","NULL_LOGGER","fail","logger","context","failIf","condition","failIfNullish","value","safeCallback","cb","payload","maybePromise","error","LEVEL_ORDER","ConsoleLogger","minLevel","level","ctx","out","k","v","line","fn","msg","measureTime","start","globalRequestOptions","requestLogger","setGlobalRequestOptions","options","setRequestLogger","_request","endpoint","requestBody","requestHeaders","body","headers","response","err","errorData","errorMessage","request","_WS","injectWebSocketImpl","ws","getWebSocketImpl","Bytes","hex","matches","byte","bytes","str","arrays","totalLength","sum","arr","result","offset","size","buffer","i","chunk","base64","normalizedBase64","c","a","b","minLength","temp","length","encodeUint8toBase64Url","encodeBase64toUint8","base64String","encodeJsonToBase64","jsonObj","jsonString","base64urlFromBase64","encodeBase64ToJson","base64urlToBase64","isBase64String","base64url","normalized","padLength","padded","decoded","reStandard","reUrl","originalNoPad","LIMIT_LENGTH","assertBech32mFormat","separatorIndex","encodeBech32m","hrp","data","limitLength","words","bech32m","decodeBech32m","encoded","prefix","decodeBech32mToBytes","isResultKeyType","encodeCBOR","encodeItem","encodeNumber","encodeString","encodeArray","encodeByteString","encodeObject","encodeUnsigned","encodeSigned","unsigned","encodeFloat64","ab","dv","utf8","item","keys","key","decodeCBOR","view","decodeItem","initialByte","majorType","additionalInfo","decodeUnsigned","decodeSigned","decodeByteString","decodeString","decodeArray","decodeMap","decodeSimpleAndFloat","ensureAvailable","needed","decodeLength","hi","lo","newOffset","array","currentOffset","map","keyResult","valueResult","decodeFloat16","uint16","exponent","fraction","sign","isBytes","anumber","n","title","abytes","len","needsLen","ofLen","got","ahash","h","aexists","instance","checkFinished","aoutput","min","clean","createView","rotr","word","shift","rotl","hasHexBuiltin","hexes","_","bytesToHex","asciis","asciiToBase16","ch","hexToBytes","hl","al","ai","n1","n2","char","utf8ToBytes","concatBytes","res","pad","createHasher","hashCons","info","hashC","opts","tmp","randomBytes","bytesLength","cr","oidNist","suffix","Chi","Maj","HashMD","blockLen","outputLen","padOffset","isLE","__publicField","pos","take","dataView","oview","outLen","state","to","finished","destroyed","SHA256_IV","SHA512_IV","U32_MASK64","_32n","fromBig","le","split","lst","Ah","Al","l","shrSH","_l","s","shrSL","rotrSH","rotrSL","rotrBH","rotrBL","add","Bh","Bl","add3L","Cl","add3H","low","Ch","add4L","Dl","add4H","Dh","add5L","El","add5H","Eh","SHA256_K","SHA256_W","SHA2_32B","A","B","C","D","E","F","G","H","W15","W2","s0","s1","sigma1","T1","T2","_SHA256","K512","u64.split","SHA512_Kh","SHA512_Kl","SHA512_W_H","SHA512_W_L","SHA2_64B","Fh","Fl","Gh","Gl","Hh","Hl","W15h","W15l","s0h","u64.rotrSH","u64.shrSH","s0l","u64.rotrSL","u64.shrSL","W2h","W2l","s1h","u64.rotrBH","s1l","u64.rotrBL","SUMl","u64.add4L","SUMh","u64.add4H","sigma1h","sigma1l","CHIh","CHIl","T1ll","u64.add5L","T1h","u64.add5H","T1l","sigma0h","sigma0l","MAJh","MAJl","u64.add","All","u64.add3L","u64.add3H","_SHA512","sha256","sha512","_0n","_1n","abool","abignumber","isPosBig","numberToHexUnpadded","num","hexToNumber","bytesToNumberBE","bytesToHex_","bytesToNumberLE","copyBytes","abytes_","numberToBytesBE","hexToBytes_","numberToBytesLE","asciiToBytes","ascii","charCode","inRange","max","aInRange","bitLen","bitMask","createHmacDrbg","hashLen","qByteLen","hmacFn","u8n","NULL","byte0","byte1","_maxDrbgIters","reset","msgs","concatBytes_","reseed","seed","gen","sl","pred","validateObject","object","fields","optFields","checkField","fieldName","expectedType","isOpt","val","current","iter","f","memoized","arg","args","computed","_2n","_3n","_4n","_5n","_7n","_8n","_9n","_16n","mod","pow2","x","power","modulo","invert","number","u","q","r","m","assertIsSquare","Fp","root","sqrt3mod4","p1div4","sqrt5mod8","p5div8","nv","sqrt9mod16","P","Fp_","Field","tn","tonelliShanks","c1","c2","c3","c4","tv1","tv2","tv3","tv4","e1","e2","e3","Q","S","Z","_Fp","FpLegendre","cc","Q1div2","M","t","R","t_tmp","FpSqrt","FIELD_FIELDS","validateField","field","initial","FpPow","p","d","FpInvertBatch","nums","passZero","inverted","multipliedAcc","acc","invertedAcc","p1mod2","powered","yes","zero","no","nLength","nBitLength","_nBitLength","nByteLength","_Field","ORDER","_nbitLength","lhs","rhs","skipValidation","allowedLengths","BYTES","modFromBytes","scalar","getFieldBytesLength","fieldOrder","bitLength","getMinHashLength","mapHashToField","fieldLen","minLen","reduced","negateCt","neg","normalizeZ","points","invertedZs","validateW","W","bits","calcWOpts","scalarBits","windows","windowSize","maxNumber","mask","shiftBy","calcOffsets","window","wOpts","wbits","nextN","offsetStart","isZero","isNeg","isNegF","pointPrecomputes","pointWindowSizes","getW","assert0","wNAF","Point","elm","point","base","precomputes","wo","offsetF","transform","comp","prev","mulEndoUnsafe","k1","k2","p1","p2","createField","order","createCurveFields","type","CURVE","curveOpts","FpFnLE","Fn","params","createKeygen","randomSecretKey","getPublicKey","secretKey","_HMAC","hash","buf","oHash","iHash","hmac","divNearest","den","_splitEndoScalar","basis","a1","b1","a2","b2","k1neg","k2neg","MAX_NUM","validateSigFormat","format","validateSigOpts","def","optsn","optName","DERErr","DER","tag","dataLen","lenLen","first","isLong","lengthBytes","int","tlv","seqBytes","seqLeftBytes","rBytes","rLeftBytes","sBytes","sLeftBytes","sig","rs","ss","seq","weierstrass","extraOpts","validated","cofactor","CURVE_ORDER","endo","lengths","getWLengths","assertCompressionIsSupported","pointToBytes","_c","isCompressed","y","bx","hasEvenY","pprefix","pointFromBytes","uncomp","head","tail","y2","weierstrassEquation","sqrtError","evenY","L","isValidXY","encodePoint","decodePoint","x2","x3","left","right","_4a3","_27b2","acoord","banZero","aprjpoint","other","splitEndoScalarN","toAffineMemo","iz","X","Y","is0","zz","assertValidMemo","finishEndo","endoBeta","k1p","k2p","_Point","isLazy","wnaf","X1","Y1","Z1","X2","Y2","Z2","U1","U2","b3","X3","Y3","Z3","t0","t1","t2","t3","t4","t5","fake","mul","k1f","k2f","sc","invertedZ","isTorsionFree","clearCofactor","ecdh","ecdhOpts","randomBytes_","wcRandomBytes","isValidSecretKey","isValidPublicKey","publicKey","publicKeyUncompressed","isProbPub","getSharedSecret","secretKeyA","publicKeyB","utils","keygen","ecdsa","ecdsaOpts","nobleHmac","fnBits","defaultSigOpts","hasLargeCofactor","isBiggerThanHalfOrder","HALF","validateRS","assertSmallCofactor","validateSigLength","sizer","Signature","recovery","recid","messageHash","radj","ir","bits2int_modN","u1","u2","rb","sb","bits2int","delta","ORDER_MASK","int2octets","validateMsgAndHash","prehash","prepSig","lowS","extraEntropy","h1int","seedArgs","e","k2sig","kBytes","ik","normS","verify","signature","end","is","recoverPublicKey","secp256k1_CURVE","secp256k1_ENDO","sqrtMod","_6n","_11n","_22n","_23n","_44n","_88n","b6","b9","b11","b22","b44","b88","b176","b220","b223","Fpk1","Pointk1","secp256k1","TAGGED_HASH_PREFIXES","taggedHash","messages","tagP","tagH","hasEven","schnorrGetExtPubKey","priv","BASE","d_","lift_x","xx","challenge","schnorrGetPublicKey","schnorrSign","auxRand","px","rand","rx","schnorrVerify","pub","schnorr","DOMAIN_SEPARATOR","hashToCurve","secret","msgToHash","counter","maxIterations","counterBytes","pointFromHex","hash_e","pubkeys","e_","getKeysetIdInt","keysetId","keysetIdInt","createRandomSecretKey","createBlindSignature","B_","privateKey","amount","id","createRandomBlindedMessage","_deprecated","createRandomRawBlindedMessage","secretStr","secretBytes","blindMessage","rG","unblindSignature","C_","constructProofFromPromise","promise","serializeProof","proof","deserializeProof","schnorrSignMessage","msghash","privKeyBytes","schnorrVerifyMessage","pubkey","throws","pubkeyX","getValidSigners","signatures","meetsSignerThreshold","threshold","Rho160","Id160","Pi160","idxLR","j","idxL","idxR","shifts160","shiftsL160","idx","shiftsR160","Kl160","Kr160","ripemd_f","group","z","BUF_160","_RIPEMD160","h0","h1","h2","h3","h4","ar","bl","br","cl","dl","dr","el","er","rGroup","hbl","hbr","rl","rr","sr","tl","tr","ripemd160","secp","base58check","createBase58check","MASTER_SECRET","BITCOIN_VERSIONS","HARDENED_OFFSET","hash160","fromU32","toU32","HDKey","opt","versions","I","chainCode","base58key","keyBuffer","keyView","version","isPriv","json","path","parts","child","m1","index","childTweak","ctweak","added","DERIVATION_PATH","serializeMintKeys","mintKeys","serializedMintKeys","deserializeMintKeys","getPubKeyFromPrivKey","privKey","createNewMintKeys","pow2height","expiry","input_fee_ppk","unit","versionByte","pubKeys","privKeys","masterKey","deriveKeysetId","verifyProof","createSecret","kind","tags","newSecret","parseSecret","parsed","tt","assertSecretKind","allowed","kinds","actual","getSecretKind","getSecretData","getDataField","getTags","hasTag","getTag","getTagScalar","vals","getTagInt","P2BK_DST","deriveP2BKBlindedPubkeys","eBytes","kid","deriveP2BKBlindingTweakFromECDH","P_","deriveP2BKSecretKeys","Ehex","blindPubKey","keysetIdHex","privs","pubs","privHex","hexP_","kHex","deriveP2BKSecretKey","privkey","rBlind","blindPubkey","naturalPub","skStd","skNeg","numberToHexPadded64","xP","xNaturalPub","yP","yNaturalPub","slotIndex","Zx","iByte","createP2PKsecret","parseP2PKSecret","getP2PKExpectedWitnessPubkeys","lockState","getP2PKLockState","locktimeKeys","getP2PKWitnessPubkeys","refundKeys","getP2PKWitnessRefundkeys","allKeys","getP2PKLocktime","ts","nowSeconds","locktime","getP2PKNSigs","getP2PKNSigsRefund","getP2PKSigFlag","getP2PKWitnessSignatures","witness","parseWitnessData","signP2PKProofs","proofs","toHex","privateKeyHex","privateKeys","maybeDeriveP2BKPrivateKeys","signedProof","signP2PKProof","witnesses","w","newWitness","hasP2PKSignedProof","isP2PKSigAll","verifyP2PKSpendingConditions","mainKeys","nsigs","mainSigners","resultBase","nSigsRefund","refundSigners","refundBase","isP2PKSpendAuthorised","assertSigAllInputs","inputs","data0","tags0","si","buildP2PKSigAllMessage","outputs","quoteId","o","buildInterimP2PKSigAllMessage","buildLegacyP2PKSigAllMessage","signP2PKSecret","verifyP2PKSecretSignature","getP2PKExpectedKWitnessPubkeys","verifyP2PKSig","arraysEqual","arr1","arr2","verifyDLEQProof","dleq","sG","eA","sB_","eC_","R_1","R_2","verifyDLEQProof_reblind","bG","createDLEQProof","scalar_a","scalar_e","s_scalar","STANDARD_DERIVATION_PATH","SECP256K1_N","deriveSecret","isValidHex","derive_deprecated","derive","deriveBlindingFactor","secretOrBlinding","hmacDigest","hdkey","derivationPath","derived","createHTLCsecret","parseHTLCSecret","createHTLCHash","preimage","hasPreimage","piBytes","verifyHTLCHash","valid","verifyHTLCSpendingConditions","p2pkResult","getHTLCWitnessPreimage","isHTLCSpendAuthorised","constructMessage","quote","blindedMessages","blindedMessage","msgbytes","signMintQuote","privkeyBytes","verifyMintQuoteSignature","sigbytes","pubkeyBytes","PaymentRequestTransportType","TAG_ID","TAG_AMOUNT","TAG_UNIT","TAG_SINGLE_USE","TAG_MINT","TAG_DESCRIPTION","TAG_TRANSPORT","TAG_NUT10","TRANSPORT_TAG_KIND","TRANSPORT_TAG_TARGET","TRANSPORT_TAG_TAG_TUPLE","TRANSPORT_KIND_NOSTR","TRANSPORT_KIND_HTTP_POST","NUT10_TAG_KIND","NUT10_TAG_DATA","NUT10_TAG_TAG_TUPLE","NUT10_KIND_P2PK","NUT10_KIND_HTLC","decodeTLV","decodeAllParts","part","parseString","parseU64","parseU8","parseTransport","parseNut10","decodeNextPart","transportKindToType","nut10KindToType","targetBytes","parseTagTuple","target","relayUrls","tuple","encodeNprofile","finalTags","kindNum","encodeTLV","encodeTLVPart","encodeU64","encodeU8","mint","transport","encodeTransport","nut10","encodeNut10","transportTypeToKind","nut10TypeToKind","relayTags","relays","decodeNprofile","relay","allTags","encodeTagTuple","encoder","nprofile","bech32","tlvData","encodePubkeyRelaysTLV","encodedRelays","totalSize","PaymentRequest","mints","description","singleUse","nut26","rawRequest","tlvRequest","tlvBytes","rawPaymentRequest","transports","encodedRequest","lowerRequest","encodedData","splitAmount","keyset","totalSplitAmount","sumArray","positive","amt","totalPositive","hasCorrespondingKey","sortedKeyAmounts","getKeysetAmounts","requireCount","getKeepAmounts","proofsWeHave","amountToKeep","targetCount","amountsWeWant","amountsWeHave","countWeHave","countWeWant","amountDiff","bytesToNumber","hasNonHexId","bigIntStringify","_key","getEncodedTokenV3","token","removeDleq","convertToShortKeysetId","stripDleq","v3TokenObj","newP","getEncodedToken","getEncodedTokenV4","tokenTemplate","templateFromToken","base64Data","idMap","validateAmount","allowZero","tokenFromTemplate","template","decodedToken","getDecodedToken","tokenString","keysetOrIds","keysetIds","ks","tokenStr","removePrefix","handleTokens","mapShortKeysetIds","getTokenMetadata","tokenObj","sumProofs","encodedToken","parsedV3Token","entry","uInt8Token","tokenData","arg2","isDeprecatedBase64","pubkeysConcat","amountA","amountB","pubKey","curr","mergeUInt8Arrays","mergedArray","sortProofsById","isObj","checkResponse","joinUrls","sanitizeUrl","url","decodePaymentRequest","paymentRequest","MessageNode","node","MessageQueue","messageNode","newNode","verifyKeysetId","isBase64","newProofs","idBytes","hasValidDleq","concatByteArrays","byteArray","pointer","getEncodedTokenBinary","utf8Encoder","binaryTemplate","getDecodedTokenBinary","utfDecoder","binaryToken","deepEqual","keysA","keysB","invoiceHasAmountInHRP","invoice","ConnectionManager","existing","newConn","WSConnection","timeoutMs","resolve","reject","opened","settled","timer","settle","cleanupSocket","ev","reason","method","subId","callback","listeners","errorCallback","notification","rpcId","MintQuoteState","MeltQuoteState","CheckStateEnum","handleMeltQuoteResponseDeprecated","handleMintQuoteResponseDeprecated","handleMintInfoContactFieldDeprecated","contact","MintInfo","pe22","pe21","cacheKey","cached","exactHit","prefixHit","mintMeltInfo","maybe","rec","mm","pp","endpoints","exact","met","meltMethods","OIDCAuth","discoveryUrl","n21","clientId","scope","text","cfg","rnd","verifier","vBytes","chBytes","input","form","tok","ep","device_code","intervalSec","delay","interval","aborted","refresh_token","username","password","listener","enc","formBody","ms","Mint","mintUrl","customRequest","swapPayload","mintQuotePayload","mintPayload","meltQuotePayload","meltPayload","checkPayload","targetUrl","restorePayload","wsSegment","wsUrl","bat","init","requestInstance","cat","Keyset","active","final_expiry","meta","KeyChain","cachedKeysets","cachedKeys","arrayOfKeys","cache","chain","allKeysets","keysById","maybeKeys","kc","keysets","forceRefresh","allKeysetsResponse","allKeysResponse","unitKeysets","keysMap","mk","activeKeysets","metaList","keysList","BlindedMessage","RESERVED_P2PK_TAGS","assertValidTagKey","MAX_SECRET_LENGTH","EPHEMERAL_E","setEphemeralE","takeEphemeralE","OutputData","blindingFactor","blindSignature","serializedProof","p2pk","customSplit","lockKeys","reqLock","reqRefund","isHTLC","refund","ordered","blinded","_E","charCount","od","randomHex","secretBytesAsHex","utf8SecretBytes","deterministicR","output","normalisePubkey","pk","toUnixSeconds","P2PKBuilder","when","values","hashlock","locks","refunds","total","selectProofsRGLI","amountToSend","keyChain","includeFees","exactMatch","_logger","bestSubset","bestDelta","bestAmount","bestFeePPK","feeForProof","sumExFees","feePPK","shuffleArray","shuffled","binarySearchIndex","lessOrEqual","mid","midValue","insertSorted","obj","calculateDelta","totalAmount","totalFeePPK","proofWithFees","ppkfee","exFee","spendableProofs","endIndex","rightIndex","biggerIndex","nextBiggerExFee","totalNetSum","maxOverAmount","trial","newAmount","newFeePPK","netSum","SSet","others","indices","objP","tempAmount","tempFeePPK","tempNetSum","qIndex","objQ","tempS","tempDelta","bestSum","bestProofs","bestSubsetSet","keep","EphemeralCounterSource","release","cur","minNext","next","WalletOps","wallet","SendBuilder","ReceiveBuilder","MintBuilder","MeltBuilder","denoms","factory","on","requireDleq","outputConfig","bolt12","preview","safeStringify","seen","_k","normalizeError","makeAbortError","cancelSafely","WalletEvents","signal","cancel","onAbort","subscribeFn","timeoutMsg","cancelP","done","cleanup","ids","uniq","proofMap","ys","handler","unique","cancels","lastError","fullyRegistered","thisCanceller","queue","notify","dropMode","wake","push","dropped","cancelled","cancelAll","WalletCounters","src","PENDING_KEYSET_ID","Wallet","op","promises","mintInfo","cheapestId","totalOutputs","ot","outputTypes","manual","ranges","maxManualEnd","range","cursor","patched","need","used","newWallet","outputType","customTotal","denominations","receiveFee","receiveFeeAmounts","splitSum","outputData","keepOutputs","sendOutputs","mergedBlindingData","keepVector","sortedOutputData","sortedKeepVector","config","txn","onCountersReserved","tokenMintUrl","swapFee","receiveOT","autoCounters","send","sendPrepared","wantsDeterministicByPolicy","isPlainRandom","reasons","expectedFee","sendOT","sendAmount","unselectedProofs","selectedProofs","selectedSum","changeAmount","keepOT","keepAmount","swapPreview","swapTransaction","swapProofs","reorderedProofs","reorderedKeepVector","keepProofs","sendProofs","cryptoSignP2PKProofs","rest","signedFirst","sumPPK","nInputs","keepDleq","p2pk_e","gapLimit","batchSize","requiredEmptyBatches","restoredProofs","lastCounterWithSignature","emptyBatchesFound","restoreRes","count","zeros","signatureMap","matchingSig","supported","resPubkey","baseRes","mintOT","mintAmount","mintQuoteSignature","amountMsat","supportsAmountless","meltQuote","offer","millisatPartialAmount","proofsToSend","meltTxn","preferAsync","onChangeOutputsCreated","feeReserve","meltOT","meltPreview","blanks","meltResponse","change","melt","Ys","BATCH_SIZE","states","YsSlice","batchStates","stateMap","_AuthManager","oidc","minValidSecs","accessToken","expiresAt","nowMs","expSec","minTokens","toTarget","batMax","batch","serializeBAT","mode","jsonStr","exp","lock","mintMax","needsCAT","AuthManager","createAuthWallet","auth"],"mappings":"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","x_google_ignoreList":[10,11,12,13,14,15,16,17,18,19,21,22]}