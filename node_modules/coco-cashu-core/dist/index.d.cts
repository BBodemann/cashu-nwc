import * as _cashu_cashu_ts0 from "@cashu/cashu-ts";
import { GetKeysetsResponse, MeltQuoteBolt11Response, MeltQuoteBolt12Response, MeltQuoteState, Mint as Mint$1, MintKeys, MintKeyset, MintQuoteBolt11Response, MintQuoteState, OutputData, PaymentRequest, Proof, SerializedBlindedSignature, Token, Wallet, getDecodedToken, getEncodedToken } from "@cashu/cashu-ts";

//#region types.d.ts
type MintInfo = Awaited<ReturnType<Mint$1['getInfo']>>;
type ProofState = 'inflight' | 'ready' | 'spent';
interface CoreProof extends Proof {
  mintUrl: string;
  state: ProofState;
  /**
   * ID of the operation that is using this proof as input.
   * When set, the proof is reserved and should not be used by other operations.
   */
  usedByOperationId?: string;
  /**
   * ID of the operation that created this proof as output.
   * Used for auditing and rollback purposes.
   */
  createdByOperationId?: string;
}
//#endregion
//#region models/Mint.d.ts
interface Mint {
  mintUrl: string;
  name: string;
  mintInfo: MintInfo;
  trusted: boolean;
  createdAt: number;
  updatedAt: number;
}
//#endregion
//#region models/Keyset.d.ts
interface Keyset {
  mintUrl: string;
  id: string;
  unit: string;
  keypairs: Record<number, string>;
  active: boolean;
  feePpk: number;
  updatedAt: number;
}
//#endregion
//#region models/Counter.d.ts
interface Counter {
  mintUrl: string;
  keysetId: string;
  counter: number;
}
//#endregion
//#region models/MintQuote.d.ts
interface MintQuote extends MintQuoteBolt11Response {
  mintUrl: string;
}
//#endregion
//#region models/MeltQuote.d.ts
interface MeltQuote extends MeltQuoteBolt11Response {
  mintUrl: string;
}
//#endregion
//#region models/History.d.ts
type BaseHistoryEntry = {
  id: string;
  createdAt: number;
  mintUrl: string;
  unit: string;
  metadata?: Record<string, string>;
};
type MintHistoryEntry = BaseHistoryEntry & {
  type: 'mint';
  paymentRequest: string;
  quoteId: string;
  state: MintQuoteState;
  amount: number;
};
type MeltHistoryEntry = BaseHistoryEntry & {
  type: 'melt';
  quoteId: string;
  state: MeltQuoteState;
  amount: number;
};
/**
 * Simplified state for send history entries.
 * Maps from SendOperationState to a user-facing state.
 */
type SendHistoryState = 'prepared' | 'pending' | 'finalized' | 'rolledBack';
type SendHistoryEntry = BaseHistoryEntry & {
  type: 'send';
  amount: number;
  operationId: string;
  state: SendHistoryState; /** Token is only available after execute (state >= pending) */
  token?: Token;
};
type ReceiveHistoryEntry = BaseHistoryEntry & {
  type: 'receive';
  amount: number;
  token?: Token;
};
type HistoryEntry = MintHistoryEntry | MeltHistoryEntry | SendHistoryEntry | ReceiveHistoryEntry;
//#endregion
//#region models/Keypair.d.ts
type Keypair = {
  publicKeyHex: string;
  secretKey: Uint8Array;
  derivationIndex?: number;
};
//#endregion
//#region logging/Logger.d.ts
type LogLevel = 'error' | 'warn' | 'info' | 'debug';
interface Logger {
  error(message: string, ...meta: unknown[]): void;
  warn(message: string, ...meta: unknown[]): void;
  info(message: string, ...meta: unknown[]): void;
  debug(message: string, ...meta: unknown[]): void;
  log?(level: LogLevel, message: string, ...meta: unknown[]): void;
  child?(bindings: Record<string, unknown>): Logger;
}
//#endregion
//#region utils.d.ts
/**
 * Serialized form of a BlindedMessage (JSON-safe)
 */
interface SerializedBlindedMessage {
  amount: number;
  id: string;
  B_: string;
}
/**
 * Serialized form of a single OutputData entry (JSON-safe)
 */
interface SerializedOutput {
  blindedMessage: SerializedBlindedMessage;
  blindingFactor: string;
  secret: string;
}
/**
 * Serialized form of OutputData for keep and send (JSON-safe)
 */
interface SerializedOutputData {
  keep: SerializedOutput[];
  send: SerializedOutput[];
}
/**
 * Normalize a mint URL to prevent duplicates from variations like:
 * - Trailing slashes: https://mint.com/ -> https://mint.com
 * - Case differences in hostname: https://MINT.com -> https://mint.com
 * - Default ports: https://mint.com:443 -> https://mint.com
 * - Redundant path segments: https://mint.com/./path -> https://mint.com/path
 */
declare function normalizeMintUrl(mintUrl: string): string;
//#endregion
//#region operations/send/SendOperation.d.ts
/**
 * State machine for send operations:
 *
 * init ──► prepared ──► executing ──► pending ──► finalized
 *   │         │            │            │
 *   │         │            │            └──► rolling_back ──► rolled_back
 *   │         │            │                      │
 *   └─────────┴────────────┴──────────────────────┴──► rolled_back
 *
 * - init: Operation created, nothing reserved yet
 * - prepared: Proofs reserved, outputs created, ready to execute
 * - executing: Swap/token creation in progress
 * - pending: Token returned to consumer, awaiting confirmation (proofs spent)
 * - finalized: Sent proofs confirmed spent, operation finalized
 * - rolling_back: Rollback in progress (reclaim swap being executed)
 * - rolled_back: Operation cancelled, proofs reclaimed
 */
type SendOperationState = 'init' | 'prepared' | 'executing' | 'pending' | 'finalized' | 'rolling_back' | 'rolled_back';
/**
 * Base fields present in all send operations
 */
interface SendOperationBase {
  /** Unique identifier for this operation */
  id: string;
  /** The mint URL for this operation */
  mintUrl: string;
  /** The amount requested to send (before fees) */
  amount: number;
  /** Timestamp when the operation was created */
  createdAt: number;
  /** Timestamp when the operation was last updated */
  updatedAt: number;
  /** Error message if the operation failed */
  error?: string;
}
/**
 * Data set during the prepare phase
 */
interface PreparedData$1 {
  /** Whether the operation requires a swap (false = exact match send) */
  needsSwap: boolean;
  /** Calculated fee for the swap (0 if exact match) */
  fee: number;
  /** Total amount of input proofs selected */
  inputAmount: number;
  /** Secrets of proofs reserved as input for this operation */
  inputProofSecrets: string[];
  /**
   * Serialized OutputData for the swap operation.
   * Only present if needsSwap is true.
   * Contains all information needed for recovery:
   * - Blinded messages (with keyset ID)
   * - Blinding factors
   * - Secrets (for deriving proof secrets)
   */
  outputData?: SerializedOutputData;
}
/**
 * Initial state - operation just created, nothing reserved yet
 */
interface InitSendOperation extends SendOperationBase {
  state: 'init';
}
/**
 * Prepared state - proofs reserved, outputs calculated, ready to execute
 */
interface PreparedSendOperation extends SendOperationBase, PreparedData$1 {
  state: 'prepared';
}
/**
 * Executing state - swap/token creation in progress
 */
interface ExecutingSendOperation extends SendOperationBase, PreparedData$1 {
  state: 'executing';
}
/**
 * Pending state - token returned, awaiting confirmation that proofs are spent
 */
interface PendingSendOperation extends SendOperationBase, PreparedData$1 {
  state: 'pending';
}
/**
 * Finalized state - sent proofs confirmed spent, operation finalized
 */
interface FinalizedSendOperation extends SendOperationBase, PreparedData$1 {
  state: 'finalized';
}
/**
 * Rolling back state - rollback in progress, reclaim swap being executed.
 * This is a transient state used to prevent race conditions with ProofStateWatcher.
 * Only used when rolling back from 'pending' state (which requires a reclaim swap).
 */
interface RollingBackSendOperation extends SendOperationBase, PreparedData$1 {
  state: 'rolling_back';
}
/**
 * Rolled back state - operation cancelled, proofs reclaimed
 * Can be rolled back from prepared, executing, or pending states
 */
interface RolledBackSendOperation extends SendOperationBase, PreparedData$1 {
  state: 'rolled_back';
}
/**
 * Discriminated union of all send operation states.
 * TypeScript will narrow the type based on the `state` field.
 */
type SendOperation = InitSendOperation | PreparedSendOperation | ExecutingSendOperation | PendingSendOperation | FinalizedSendOperation | RollingBackSendOperation | RolledBackSendOperation;
/**
 * Any operation that has been prepared (has PreparedData)
 */
type PreparedOrLaterOperation = PreparedSendOperation | ExecutingSendOperation | PendingSendOperation | FinalizedSendOperation | RollingBackSendOperation | RolledBackSendOperation;
/**
 * Terminal states - operation is finished
 * Note: 'rolling_back' is NOT terminal - it's a transient state that needs recovery
 */
type TerminalSendOperation = FinalizedSendOperation | RolledBackSendOperation;
declare function isInitOperation(op: SendOperation): op is InitSendOperation;
declare function isPreparedOperation(op: SendOperation): op is PreparedSendOperation;
declare function isExecutingOperation(op: SendOperation): op is ExecutingSendOperation;
declare function isPendingOperation(op: SendOperation): op is PendingSendOperation;
declare function isFinalizedOperation(op: SendOperation): op is FinalizedSendOperation;
declare function isRollingBackOperation(op: SendOperation): op is RollingBackSendOperation;
declare function isRolledBackOperation(op: SendOperation): op is RolledBackSendOperation;
/**
 * Check if operation has PreparedData (any state after init)
 */
declare function hasPreparedData(op: SendOperation): op is PreparedOrLaterOperation;
/**
 * Check if operation is in a terminal state
 */
declare function isTerminalOperation(op: SendOperation): op is TerminalSendOperation;
/**
 * Get the secrets of proofs that will be sent (for finalization tracking).
 * - If needsSwap: secrets come from outputData.send
 * - If !needsSwap: secrets are the inputProofSecrets (exact match)
 */
declare function getSendProofSecrets(op: PreparedOrLaterOperation): string[];
/**
 * Get the secrets of proofs we keep (change from swap).
 * - If needsSwap: secrets come from outputData.keep
 * - If !needsSwap: empty (no change proofs)
 */
declare function getKeepProofSecrets(op: PreparedOrLaterOperation): string[];
/**
 * Creates a new SendOperation in init state
 */
declare function createSendOperation(id: string, mintUrl: string, amount: number): InitSendOperation;
//#endregion
//#region events/EventBus.d.ts
type EventHandler<Payload> = (payload: Payload) => void | Promise<void>;
type EventBusOptions<Events extends { [K in keyof Events]: unknown }> = {
  onError?: (args: {
    event: keyof Events;
    payload: Events[keyof Events];
    error: unknown;
  }) => void | Promise<void>;
  concurrency?: 'sequential' | 'parallel';
  throwOnError?: boolean;
};
type EmitOptions = {
  throwOnError?: boolean;
  failFast?: boolean;
};
declare class EventBus<Events extends { [K in keyof Events]: unknown }> {
  private readonly options;
  private listeners;
  constructor(options?: EventBusOptions<Events>);
  on<E extends keyof Events>(event: E, handler: EventHandler<Events[E]>): () => void;
  once<E extends keyof Events>(event: E, handler: EventHandler<Events[E]>): () => void;
  off<E extends keyof Events>(event: E, handler: EventHandler<Events[E]>): void;
  emit<E extends keyof Events>(event: E, payload: Events[E], options?: EmitOptions): Promise<void>;
}
//#endregion
//#region infra/MintRequestProvider.d.ts
/**
 * A function compatible with cashu-ts's `_customRequest` parameter.
 */
type MintRequestFn = <T>(options: {
  endpoint: string;
  requestBody?: Record<string, unknown>;
  headers?: Record<string, string>;
}) => Promise<T>;
interface MintRequestProviderOptions {
  /** Default capacity for rate limiters (default: 20) */
  capacity?: number;
  /** Default refill rate per minute (default: 20) */
  refillPerMinute?: number;
  /** Path prefixes to bypass rate limiting */
  bypassPathPrefixes?: string[];
  /** Optional per-mint configuration override */
  configForMint?: (mintUrl: string) => Partial<{
    capacity: number;
    refillPerMinute: number;
    bypassPathPrefixes: string[];
  }>;
  logger?: Logger;
}
/**
 * Manages per-mint request rate limiters.
 *
 * This class provides a centralized way to share rate limiters across
 * all components that need to make HTTP requests to mints (WalletService,
 * MintAdapter, etc.).
 */
declare class MintRequestProvider {
  private readonly limiters;
  private readonly options;
  constructor(options?: MintRequestProviderOptions);
  /**
   * Get the request function for a specific mint.
   * Creates a new rate limiter if one doesn't exist for this mint.
   */
  getRequestFn(mintUrl: string): MintRequestFn;
  /**
   * Get or create a rate limiter for a specific mint.
   */
  private getOrCreateLimiter;
  /**
   * Clear the rate limiter for a specific mint.
   */
  clearMint(mintUrl: string): void;
  /**
   * Clear all rate limiters.
   */
  clearAll(): void;
}
//#endregion
//#region infra/MintAdapter.d.ts
/**
 * Adapter for making HTTP requests to Cashu mints.
 *
 * All requests are rate-limited through the MintRequestProvider,
 * sharing the same rate limits with other components (e.g., WalletService).
 */
declare class MintAdapter {
  private cashuMints;
  private readonly requestProvider;
  constructor(requestProvider: MintRequestProvider);
  fetchMintInfo(mintUrl: string): Promise<MintInfo>;
  fetchKeysets(mintUrl: string): Promise<GetKeysetsResponse>;
  fetchKeysForId(mintUrl: string, id: string): Promise<Record<number, string>>;
  private getCashuMint;
  checkMintQuoteState(mintUrl: string, quoteId: string): Promise<unknown>;
  checkMeltQuote(mintUrl: string, quoteId: string): Promise<MeltQuoteBolt11Response>;
  checkMeltQuoteState(mintUrl: string, quoteId: string): Promise<MeltQuoteBolt11Response['state']>;
  checkProofStates(mintUrl: string, Ys: string[]): Promise<_cashu_cashu_ts0.ProofState[]>;
  customMeltBolt11(mintUrl: string, proofsToSend: Proof[], changeOutputs: OutputData[], quoteId: string): Promise<MeltQuoteBolt11Response>;
  customMeltBolt12(mintUrl: string, proofsToSend: Proof[], changeOutputs: OutputData[], quoteId: string): Promise<MeltQuoteBolt12Response>;
}
//#endregion
//#region services/MintService.d.ts
declare class MintService {
  private readonly mintRepo;
  private readonly keysetRepo;
  private readonly mintAdapter;
  private readonly eventBus?;
  private readonly logger?;
  constructor(mintRepo: MintRepository, keysetRepo: KeysetRepository, mintAdapter: MintAdapter, logger?: Logger, eventBus?: EventBus<CoreEvents>);
  /**
   * Add a new mint by URL, running a single update cycle to fetch info & keysets.
   * If the mint already exists, it ensures it is updated.
   * New mints are added as untrusted by default unless explicitly specified.
   *
   * @param mintUrl - The URL of the mint to add
   * @param options - Optional configuration
   * @param options.trusted - Whether to add the mint as trusted (default: false)
   */
  addMintByUrl(mintUrl: string, options?: {
    trusted?: boolean;
  }): Promise<{
    mint: Mint;
    keysets: Keyset[];
  }>;
  updateMintData(mintUrl: string): Promise<{
    mint: Mint;
    keysets: Keyset[];
  }>;
  isTrustedMint(mintUrl: string): Promise<boolean>;
  ensureUpdatedMint(mintUrl: string): Promise<{
    mint: Mint;
    keysets: Keyset[];
  }>;
  deleteMint(mintUrl: string): Promise<void>;
  getMintInfo(mintUrl: string): Promise<MintInfo>;
  getAllMints(): Promise<Mint[]>;
  getAllTrustedMints(): Promise<Mint[]>;
  trustMint(mintUrl: string): Promise<void>;
  untrustMint(mintUrl: string): Promise<void>;
  private updateMint;
}
//#endregion
//#region services/SeedService.d.ts
declare class SeedService {
  private readonly seedGetter;
  private readonly seedTtlMs;
  private cachedSeed;
  private cachedUntil;
  private inFlight;
  constructor(seedGetter: () => Promise<Uint8Array>, options?: {
    seedTtlMs?: number;
  });
  getSeed(): Promise<Uint8Array>;
  clear(): void;
}
//#endregion
//#region services/WalletService.d.ts
declare class WalletService {
  private walletCache;
  private readonly CACHE_TTL;
  private readonly mintService;
  private readonly seedService;
  private inFlight;
  private readonly logger?;
  private readonly requestProvider;
  constructor(mintService: MintService, seedService: SeedService, requestProvider: MintRequestProvider, logger?: Logger);
  getWallet(mintUrl: string): Promise<Wallet>;
  getWalletWithActiveKeysetId(mintUrl: string): Promise<{
    wallet: Wallet;
    keysetId: string;
    keyset: MintKeyset;
    keys: MintKeys;
  }>;
  /**
   * Clear cached wallet for a specific mint URL
   */
  clearCache(mintUrl: string): void;
  /**
   * Clear all cached wallets
   */
  clearAllCaches(): void;
  /**
   * Force refresh mint data and get fresh wallet
   */
  refreshWallet(mintUrl: string): Promise<Wallet>;
  private buildWallet;
}
//#endregion
//#region infra/WsConnectionManager.d.ts
interface WebSocketLike {
  send(data: string): void;
  close(code?: number, reason?: string): void;
  addEventListener(type: 'open' | 'message' | 'error' | 'close', listener: (event: any) => void): void;
  removeEventListener(type: 'open' | 'message' | 'error' | 'close', listener: (event: any) => void): void;
}
type WebSocketFactory = (url: string) => WebSocketLike;
interface WsConnectionManagerOptions {
  /**
   * If true, don't attempt to reconnect after close/error.
   * Useful when another mechanism (e.g., polling) handles recovery.
   * Default: false
   */
  disableReconnect?: boolean;
}
declare class WsConnectionManager {
  private readonly wsFactory;
  private readonly sockets;
  private readonly isOpenByMint;
  private readonly sendQueueByMint;
  private readonly logger?;
  private readonly listenersByMint;
  private readonly reconnectAttemptsByMint;
  private readonly reconnectTimeoutByMint;
  private readonly options;
  private paused;
  constructor(wsFactory: WebSocketFactory, logger?: Logger, options?: WsConnectionManagerOptions);
  private buildWsUrl;
  private ensureSocket;
  private scheduleReconnect;
  on(mintUrl: string, type: 'open' | 'message' | 'error' | 'close', listener: (event: any) => void): void;
  off(mintUrl: string, type: 'open' | 'message' | 'error' | 'close', listener: (event: any) => void): void;
  send(mintUrl: string, message: unknown): void;
  closeAll(): void;
  closeMint(mintUrl: string): void;
  pause(): void;
  resume(): void;
}
//#endregion
//#region infra/SubscriptionProtocol.d.ts
type JsonRpcId = number;
type WsRequestMethod = 'subscribe' | 'unsubscribe';
type SubscriptionKind = 'bolt11_mint_quote' | 'bolt11_melt_quote' | 'proof_state';
type UnsubscribeHandler = () => Promise<void>;
interface SubscribeParams {
  kind: SubscriptionKind;
  subId: string;
  filters: string[];
}
interface UnsubscribeParams {
  subId: string;
}
type WsRequest = {
  jsonrpc: '2.0';
  method: WsRequestMethod;
  params: SubscribeParams | UnsubscribeParams;
  id: JsonRpcId;
};
//#endregion
//#region infra/RealTimeTransport.d.ts
type TransportEvent = 'open' | 'message' | 'close' | 'error';
interface RealTimeTransport {
  on(mintUrl: string, event: TransportEvent, handler: (evt: any) => void): void;
  send(mintUrl: string, req: WsRequest): void;
  closeAll(): void;
  closeMint(mintUrl: string): void;
  pause(): void;
  resume(): void;
}
//#endregion
//#region infra/SubscriptionManager.d.ts
type SubscriptionCallback<TPayload = unknown> = (payload: TPayload) => void | Promise<void>;
interface SubscriptionManagerOptions {
  /** Slow polling interval while WS is connected (default: 20000ms) */
  slowPollingIntervalMs?: number;
  /** Fast polling interval after WS fails (default: 5000ms) */
  fastPollingIntervalMs?: number;
}
declare class SubscriptionManager {
  private readonly nextIdByMint;
  private readonly subscriptions;
  private readonly activeByMint;
  private readonly pendingSubscribeByMint;
  private readonly transportByMint;
  private readonly logger?;
  private readonly messageHandlerByMint;
  private readonly openHandlerByMint;
  private readonly hasOpenedByMint;
  private readonly wsFactory?;
  private readonly mintAdapter;
  private readonly options;
  private paused;
  constructor(wsFactoryOrManager: WebSocketFactory | RealTimeTransport, mintAdapter: MintAdapter, logger?: Logger, options?: SubscriptionManagerOptions);
  /**
   * Get or create a transport for a mint.
   *
   * Uses HybridTransport (WS + polling in parallel) when a wsFactory is available.
   * HybridTransport handles WS failures gracefully by speeding up polling, so we
   * don't need to check mint capabilities or WebSocket availability upfront.
   *
   * Falls back to pure PollingTransport only when no wsFactory is provided.
   */
  private getTransport;
  private getNextId;
  private ensureMessageListener;
  subscribe<TPayload = unknown>(mintUrl: string, kind: SubscriptionKind, filters: string[], onNotification?: SubscriptionCallback<TPayload>): Promise<{
    subId: string;
    unsubscribe: UnsubscribeHandler;
  }>;
  addCallback<TPayload = unknown>(subId: string, cb: SubscriptionCallback<TPayload>): void;
  removeCallback<TPayload = unknown>(subId: string, cb: SubscriptionCallback<TPayload>): void;
  unsubscribe(mintUrl: string, subId: string): Promise<void>;
  closeAll(): void;
  closeMint(mintUrl: string): void;
  private reSubscribeMint;
  pause(): void;
  resume(): void;
}
//#endregion
//#region infra/handlers/MeltHandlerProvider.d.ts
/**
 * Runtime registry for melt method handlers.
 * Keeps wiring concerns out of the core melt domain.
 */
declare class MeltHandlerProvider {
  private registry;
  constructor(initialHandlers?: Partial<MeltMethodHandlerRegistry>);
  register<M extends MeltMethod>(method: M, handler: MeltMethodHandler<M>): void;
  registerMany(handlers: Partial<MeltMethodHandlerRegistry>): void;
  get<M extends MeltMethod>(method: M): MeltMethodHandler<M>;
  getAll(): MeltMethodHandlerRegistry;
}
//#endregion
//#region operations/melt/MeltOperationService.d.ts
/**
 * MeltOperationService orchestrates melt sagas while delegating
 * method-specific behavior to MeltMethodHandlers.
 */
declare class MeltOperationService {
  private readonly handlerProvider;
  private readonly meltOperationRepository;
  private readonly proofRepository;
  private readonly proofService;
  private readonly mintService;
  private readonly walletService;
  private readonly mintAdapter;
  private readonly eventBus;
  private readonly logger?;
  private readonly operationLocks;
  private recoveryLock;
  constructor(handlerProvider: MeltHandlerProvider, meltOperationRepository: MeltOperationRepository, proofRepository: ProofRepository, proofService: ProofService, mintService: MintService, walletService: WalletService, mintAdapter: MintAdapter, eventBus: EventBus<CoreEvents>, logger?: Logger);
  private buildDeps;
  private acquireOperationLock;
  isOperationLocked(operationId: string): boolean;
  isRecoveryInProgress(): boolean;
  init(mintUrl: string, method: MeltMethod, methodData: MeltMethodData): Promise<InitMeltOperation>;
  /**
   * Prepare the operation by reserving proofs and creating outputs.
   * After this step, the operation can be executed or rolled back.
   *
   * If preparation fails, automatically attempts to recover the init operation.
   * Throws if the operation is already in progress.
   */
  prepare(operationId: string): Promise<PreparedMeltOperation>;
  /**
   * Execute the prepared operation.
   * Performs the melt (swap if needed) and processes the result.
   *
   * If execution fails after transitioning to 'executing' state,
   * automatically attempts to recover the operation.
   * Throws if the operation is already in progress.
   */
  execute(operationId: string): Promise<PendingMeltOperation | FinalizedMeltOperation>;
  finalize(operationId: string): Promise<void>;
  rollback(operationId: string, reason?: string): Promise<void>;
  /**
   * Recover pending operations on startup.
   * This should be called during initialization.
   * Throws if recovery is already in progress.
   */
  recoverPendingOperations(): Promise<void>;
  checkPendingOperation(operationId: string): Promise<PendingCheckResult>;
  private markAsRolledBack;
  /**
   * Clean up a failed init operation.
   * Releases any orphaned proof reservations and deletes the operation.
   */
  private recoverInitOperation;
  /**
   * Attempts to recover an init operation, swallowing recovery errors.
   * If recovery fails, logs warning and leaves for startup recovery.
   */
  private tryRecoverInitOperation;
  /**
   * Recover an executing operation.
   * Delegates to handler for proof cleanup and state determination.
   * Updates operation state based on handler result (finalized, pending, or failed).
   */
  private recoverExecutingOperation;
  /**
   * Attempts to recover an executing operation, swallowing recovery errors.
   * If recovery fails (e.g., mint unreachable), logs warning and leaves
   * for startup recovery.
   */
  private tryRecoverExecutingOperation;
  getOperation(operationId: string): Promise<MeltOperation | null>;
  getOperationByQuote(mintUrl: string, quoteId: string): Promise<MeltOperation | null>;
  getPendingOperations(): Promise<MeltOperation[]>;
}
//#endregion
//#region events/types.d.ts
interface CoreEvents {
  'mint:added': {
    mint: Mint;
    keysets: Keyset[];
  };
  'mint:updated': {
    mint: Mint;
    keysets: Keyset[];
  };
  'mint:trusted': {
    mintUrl: string;
  };
  'mint:untrusted': {
    mintUrl: string;
  };
  'counter:updated': Counter;
  'proofs:saved': {
    mintUrl: string;
    keysetId: string;
    proofs: CoreProof[];
  };
  'proofs:state-changed': {
    mintUrl: string;
    secrets: string[];
    state: ProofState;
  };
  'proofs:deleted': {
    mintUrl: string;
    secrets: string[];
  };
  'proofs:wiped': {
    mintUrl: string;
    keysetId: string;
  };
  'proofs:reserved': {
    mintUrl: string;
    operationId: string;
    secrets: string[];
    amount: number;
  };
  'proofs:released': {
    mintUrl: string;
    secrets: string[];
  };
  'mint-quote:state-changed': {
    mintUrl: string;
    quoteId: string;
    state: MintQuoteState;
  };
  'mint-quote:created': {
    mintUrl: string;
    quoteId: string;
    quote: MintQuoteBolt11Response;
  };
  'mint-quote:added': {
    mintUrl: string;
    quoteId: string;
    quote: MintQuoteBolt11Response;
  };
  'mint-quote:requeue': {
    mintUrl: string;
    quoteId: string;
  };
  'mint-quote:redeemed': {
    mintUrl: string;
    quoteId: string;
    quote: MintQuoteBolt11Response;
  };
  'melt-quote:created': {
    mintUrl: string;
    quoteId: string;
    quote: MeltQuoteBolt11Response;
  };
  'melt-quote:state-changed': {
    mintUrl: string;
    quoteId: string;
    state: MeltQuoteState;
  };
  'melt-quote:paid': {
    mintUrl: string;
    quoteId: string;
    quote: MeltQuoteBolt11Response;
  };
  /** Emitted when send operation is prepared (proofs reserved) */
  'send:prepared': {
    mintUrl: string;
    operationId: string;
    operation: SendOperation;
  };
  /** Emitted when send operation is executed (token created) */
  'send:pending': {
    mintUrl: string;
    operationId: string;
    operation: SendOperation;
    token: Token;
  };
  /** Emitted when send operation is executed (token created) this one should be cleaned up in the future */
  'send:created': {
    mintUrl: string;
    token: Token;
  };
  /** Emitted when send operation is finalized (proofs confirmed spent) */
  'send:finalized': {
    mintUrl: string;
    operationId: string;
    operation: SendOperation;
  };
  /** Emitted when send operation is rolled back */
  'send:rolled-back': {
    mintUrl: string;
    operationId: string;
    operation: SendOperation;
  };
  'receive:created': {
    mintUrl: string;
    token: Token;
  };
  'history:updated': {
    mintUrl: string;
    entry: HistoryEntry;
  };
  'melt-op:prepared': {
    mintUrl: string;
    operationId: string;
    operation: MeltOperation;
  };
  'melt-op:pending': {
    mintUrl: string;
    operationId: string;
    operation: MeltOperation;
  };
  'melt-op:finalized': {
    mintUrl: string;
    operationId: string;
    operation: MeltOperation;
  };
  'melt-op:rolled-back': {
    mintUrl: string;
    operationId: string;
    operation: MeltOperation;
  };
  'subscriptions:paused': void;
  'subscriptions:resumed': void;
}
//#endregion
//#region services/CounterService.d.ts
declare class CounterService {
  private readonly counterRepo;
  private readonly eventBus?;
  private readonly logger?;
  constructor(counterRepo: CounterRepository, logger?: Logger, eventBus?: EventBus<CoreEvents>);
  getCounter(mintUrl: string, keysetId: string): Promise<Counter>;
  incrementCounter(mintUrl: string, keysetId: string, n: number): Promise<{
    counter: number;
    mintUrl: string;
    keysetId: string;
  }>;
  overwriteCounter(mintUrl: string, keysetId: string, counter: number): Promise<{
    mintUrl: string;
    keysetId: string;
    counter: number;
  }>;
}
//#endregion
//#region logging/ConsoleLogger.d.ts
type ConsoleLoggerOptions = {
  level?: LogLevel;
};
declare class ConsoleLogger implements Logger {
  private prefix;
  private level;
  private static readonly levelPriority;
  constructor(prefix?: string, options?: ConsoleLoggerOptions);
  private shouldLog;
  error(message: string, ...meta: unknown[]): void;
  warn(message: string, ...meta: unknown[]): void;
  info(message: string, ...meta: unknown[]): void;
  debug(message: string, ...meta: unknown[]): void;
  log(level: LogLevel, message: string, ...meta: unknown[]): void;
  child(bindings: Record<string, unknown>): Logger;
}
//#endregion
//#region services/KeyRingService.d.ts
declare class KeyRingService {
  private readonly logger?;
  private readonly keyRingRepository;
  private readonly seedService;
  constructor(keyRingRepository: KeyRingRepository, seedService: SeedService, logger?: Logger);
  generateNewKeyPair(): Promise<{
    publicKeyHex: string;
  }>;
  generateNewKeyPair(options: {
    dumpSecretKey: true;
  }): Promise<Keypair>;
  generateNewKeyPair(options: {
    dumpSecretKey: false;
  }): Promise<{
    publicKeyHex: string;
  }>;
  addKeyPair(secretKey: Uint8Array): Promise<Keypair>;
  removeKeyPair(publicKey: string): Promise<void>;
  getKeyPair(publicKey: string): Promise<Keypair | null>;
  getLatestKeyPair(): Promise<Keypair | null>;
  getAllKeyPairs(): Promise<Keypair[]>;
  signProof(proof: Proof, publicKey: string): Promise<Proof>;
  /**
   * Converts a secret key to its corresponding public key in SEC1 compressed format.
   * Note: schnorr.getPublicKey() returns a 32-byte x-only public key (BIP340).
   * We prepend '02' to create a 33-byte SEC1 compressed format as expected by Cashu.
   */
  private getPublicKeyHex;
}
//#endregion
//#region services/ProofService.d.ts
declare class ProofService {
  private readonly counterService;
  private readonly proofRepository;
  private readonly eventBus?;
  private readonly walletService;
  private readonly mintService;
  private readonly keyRingService;
  private readonly seedService;
  private readonly logger?;
  constructor(counterService: CounterService, proofRepository: ProofRepository, walletService: WalletService, mintService: MintService, keyRingService: KeyRingService, seedService: SeedService, logger?: Logger, eventBus?: EventBus<CoreEvents>);
  /**
   * Calculates the send amount including receiver fees.
   * This is used when the sender pays fees for the receiver.
   */
  calculateSendAmountWithFees(mintUrl: string, sendAmount: number): Promise<number>;
  checkInflightProofs(): Promise<void>;
  createOutputsAndIncrementCounters(mintUrl: string, amount: {
    keep: number;
    send: number;
  }, options?: {
    includeFees?: boolean;
  }): Promise<{
    keep: OutputData[];
    send: OutputData[];
    sendAmount: number;
    keepAmount: number;
  }>;
  saveProofs(mintUrl: string, proofs: CoreProof[]): Promise<void>;
  getReadyProofs(mintUrl: string): Promise<CoreProof[]>;
  getAllReadyProofs(): Promise<CoreProof[]>;
  /**
   * Gets the balance for a single mint by summing ready proof amounts.
   * @param mintUrl - The URL of the mint
   * @returns The total balance for the mint
   */
  getBalance(mintUrl: string): Promise<number>;
  /**
   * Gets balances for all mints by summing ready proof amounts.
   * @returns An object mapping mint URLs to their balances
   */
  getBalances(): Promise<{
    [mintUrl: string]: number;
  }>;
  /**
   * Gets balances for trusted mints only by summing ready proof amounts.
   * @returns An object mapping trusted mint URLs to their balances
   */
  getTrustedBalances(): Promise<{
    [mintUrl: string]: number;
  }>;
  setProofState(mintUrl: string, secrets: string[], state: 'inflight' | 'ready' | 'spent'): Promise<void>;
  /**
   * Reserve proofs for an operation.
   * Validates that proofs are available (ready and not already reserved) before reserving.
   * Emits 'proofs:reserved' event on success.
   *
   * @throws ProofOperationError if any proof is not available for reservation
   */
  reserveProofs(mintUrl: string, secrets: string[], operationId: string): Promise<{
    amount: number;
  }>;
  /**
   * Release proofs from an operation.
   * Clears the reservation so proofs become available again.
   * Emits 'proofs:released' event on success.
   */
  releaseProofs(mintUrl: string, secrets: string[]): Promise<void>;
  /**
   * Restore proofs to ready state and clear their operation reservation.
   * Used during rollback when inflight proofs need to be made available again.
   * This sets state to 'ready' and clears usedByOperationId.
   */
  restoreProofsToReady(mintUrl: string, secrets: string[]): Promise<void>;
  deleteProofs(mintUrl: string, secrets: string[]): Promise<void>;
  wipeProofsByKeysetId(mintUrl: string, keysetId: string): Promise<void>;
  /**
   * Select proofs to send for a given amount.
   * Uses the wallet's proof selection algorithm to choose optimal denominations.
   *
   * @param mintUrl - The mint URL to select proofs from
   * @param amount - The amount to send
   * @param includeFees - Whether to include fees in the selection (default: true)
   * @returns The selected proofs
   * @throws ProofValidationError if insufficient balance to cover the amount
   */
  selectProofsToSend(mintUrl: string, amount: number, includeFees?: boolean): Promise<Proof[]>;
  private groupProofsByKeysetId;
  getProofsByKeysetId(mintUrl: string, keysetId: string): Promise<CoreProof[]>;
  hasProofsForKeyset(mintUrl: string, keysetId: string): Promise<boolean>;
  prepareProofsForReceiving(proofs: Proof[]): Promise<Proof[]>;
  createBlankOutputs(amount: number, mintUrl: string): Promise<OutputData[]>;
  /**
   * Unblind change signatures and save the resulting proofs.
   * Used after melt operations to process change returned by the mint.
   *
   * @param mintUrl - The mint URL
   * @param outputData - The output data used to create blank outputs for change
   * @param changeSignatures - The blinded signatures returned by the mint
   * @param keys - The mint keys for unblinding
   * @param options - Optional settings including createdByOperationId
   * @returns The saved change proofs
   */
  unblindAndSaveChangeProofs(mintUrl: string, outputData: OutputData[], changeSignatures: SerializedBlindedSignature[], options?: {
    createdByOperationId?: string;
  }): Promise<CoreProof[]>;
  /**
   * Recover proofs from a completed swap using the mint's restore endpoint.
   * This is used when a swap succeeded but proofs were not saved (e.g., crash recovery).
   *
   * First checks if the proofs are still unspent before attempting recovery.
   * Only unspent proofs will be recovered and saved.
   *
   * @param mintUrl - The mint URL
   * @param serializedOutputData - The serialized output data containing secrets and blinding factors
   * @returns The recovered proofs (only unspent ones)
   */
  recoverProofsFromOutputData(mintUrl: string, serializedOutputData: SerializedOutputData): Promise<Proof[]>;
}
//#endregion
//#region operations/melt/MeltMethodHandler.d.ts
/**
 * Registry of supported melt methods and their payload shapes.
 * Extend via declaration merging if you need to add methods externally.
 */
interface MeltMethodDefinitions {
  bolt11: {
    invoice: string;
    amountSats?: number;
  };
  bolt12: {
    offer: string;
    amountSats?: number;
  };
  onchain: {
    address: string;
    amountSats: number;
  };
}
type MeltMethod = keyof MeltMethodDefinitions;
type MeltMethodData<M extends MeltMethod = MeltMethod> = MeltMethodDefinitions[M];
interface MeltMethodMeta<M extends MeltMethod = MeltMethod> {
  method: M;
  methodData: MeltMethodData<M>;
}
interface BaseHandlerDeps {
  proofRepository: ProofRepository;
  proofService: ProofService;
  walletService: WalletService;
  mintService: MintService;
  mintAdapter: MintAdapter;
  eventBus: EventBus<CoreEvents>;
  logger?: Logger;
}
interface BasePrepareContext<M extends MeltMethod = MeltMethod> extends BaseHandlerDeps {
  operation: InitMeltOperation & MeltMethodMeta<M>;
  wallet: Wallet;
}
interface ExecuteContext<M extends MeltMethod = MeltMethod> extends BaseHandlerDeps {
  operation: ExecutingMeltOperation & MeltMethodMeta<M>;
  wallet: Wallet;
  reservedProofs: Proof[];
}
interface PendingContext<M extends MeltMethod = MeltMethod> extends BaseHandlerDeps {
  operation: PendingMeltOperation & MeltMethodMeta<M>;
  wallet: Wallet;
}
interface FinalizeContext<M extends MeltMethod = MeltMethod> extends BaseHandlerDeps {
  operation: PendingMeltOperation & MeltMethodMeta<M>;
}
interface RollbackContext<M extends MeltMethod = MeltMethod> extends BaseHandlerDeps {
  operation: PreparedOrLaterOperation$1 & MeltMethodMeta<M>;
  wallet: Wallet;
}
interface RecoverExecutingContext<M extends MeltMethod = MeltMethod> extends BaseHandlerDeps {
  operation: ExecutingMeltOperation & MeltMethodMeta<M>;
  wallet: Wallet;
}
type ExecutionResult<M extends MeltMethod = MeltMethod> = {
  status: 'PAID';
  finalized: FinalizedMeltOperation & MeltMethodMeta<M>;
  sendProofs?: Proof[];
  keepProofs?: Proof[];
} | {
  status: 'PENDING';
  pending: PendingMeltOperation & MeltMethodMeta<M>;
  sendProofs?: Proof[];
  keepProofs?: Proof[];
} | {
  status: 'FAILED';
  failed: FailedMeltOperation & MeltMethodMeta<M>;
  sendProofs?: Proof[];
  keepProofs?: Proof[];
};
type PendingCheckResult = 'finalize' | 'stay_pending' | 'rollback';
interface MeltMethodHandler<M extends MeltMethod = MeltMethod> {
  prepare(ctx: BasePrepareContext<M>): Promise<PreparedMeltOperation & MeltMethodMeta<M>>;
  execute(ctx: ExecuteContext<M>): Promise<ExecutionResult<M>>;
  finalize?(ctx: FinalizeContext<M>): Promise<void>;
  rollback?(ctx: RollbackContext<M>): Promise<void>;
  checkPending?(ctx: PendingContext<M>): Promise<PendingCheckResult>;
  /**
   * Recover an executing operation that failed mid-execution.
   * Handlers must implement this method to handle recovery logic.
   */
  recoverExecuting(ctx: RecoverExecutingContext<M>): Promise<ExecutionResult<M>>;
}
type MeltMethodHandlerRegistry = Record<MeltMethod, MeltMethodHandler<any>>;
//#endregion
//#region operations/melt/MeltOperation.d.ts
/**
 * State machine for melt operations:
 *
 * init ──► prepared ──► executing ──► pending ──► finalized
 *   │         │            │            │            │
 *   │         │            └────────────┴────────────┘ (if PAID)
 *   │         │            │            │
 *   │         │            │            └──► rolling_back ──► rolled_back
 *   │         │            │                      │
 *   └─────────┴────────────┴──────────────────────┴──► rolled_back
 *
 * - init: Operation created, nothing reserved yet
 * - prepared: Proofs reserved, fees calculated, change outputs created, ready to execute
 * - executing: Swap/melt in progress
 * - pending: Melt started, payment inflight (only if PENDING response)
 * - finalized: melt successful, change claimed, operation finalized (can be reached directly from executing if PAID)
 * - failed: melt failed, proofs reclaimed
 * - rolling_back: Rollback in progress (reclaim swap being executed)
 * - rolled_back: Operation cancelled, proofs reclaimed
 */
type MeltOperationState = 'init' | 'prepared' | 'executing' | 'pending' | 'finalized' | 'rolling_back' | 'rolled_back';
/**
 * Base fields present in all melt operations
 */
interface MeltOperationBase extends MeltMethodMeta {
  /** Unique identifier for this operation */
  id: string;
  /** The mint URL for this operation */
  mintUrl: string;
  /** Timestamp when the operation was created */
  createdAt: number;
  /** Timestamp when the operation was last updated */
  updatedAt: number;
  /** Error message if the operation failed */
  error?: string;
}
/**
 * Data set during the prepare phase
 */
interface PreparedData {
  /** Whether the operation requires a swap (false = exact match melt) */
  needsSwap: boolean;
  /** The amount requested to melt (before fees) */
  amount: number;
  /** Calculated fee for the swap (0 if exact match) */
  fee_reserve: number;
  /** The ID of the quote used for the melt operation */
  quoteId: string;
  /** The fee for the swap (0 if exact match) */
  swap_fee: number;
  /** Total amount of input proofs selected */
  inputAmount: number;
  /** Secrets of proofs reserved as input for this operation */
  inputProofSecrets: string[];
  /**
   * Serialized OutputData (change) for the melt operation.
   */
  changeOutputData: SerializedOutputData;
  /**
   * Serialized OutputData (swap) for the melt operation.
   */
  swapOutputData?: SerializedOutputData;
}
/**
 * Initial state - operation just created, nothing reserved yet
 */
interface InitMeltOperation extends MeltOperationBase {
  state: 'init';
}
/**
 * Prepared state - proofs reserved, outputs calculated, ready to execute
 */
interface PreparedMeltOperation extends MeltOperationBase, PreparedData {
  state: 'prepared';
}
/**
 * Executing state - swap/token creation in progress
 */
interface ExecutingMeltOperation extends MeltOperationBase, PreparedData {
  state: 'executing';
}
/**
 * Pending state - token returned, awaiting confirmation that proofs are spent
 */
interface PendingMeltOperation extends MeltOperationBase, PreparedData {
  state: 'pending';
}
/**
 * Finalized state - sent proofs confirmed spent, operation finalized
 */
interface FinalizedMeltOperation extends MeltOperationBase, PreparedData {
  state: 'finalized';
}
/**
 * Failed state - melt failed, proofs reclaimed
 */
interface FailedMeltOperation extends MeltOperationBase, PreparedData {
  state: 'failed';
}
/**
 * Rolling back state - rollback in progress, reclaim swap being executed.
 * This is a transient state used to prevent race conditions with ProofStateWatcher.
 * Only used when rolling back from 'pending' state (which requires a reclaim swap).
 */
interface RollingBackMeltOperation extends MeltOperationBase, PreparedData {
  state: 'rolling_back';
}
/**
 * Rolled back state - operation cancelled, proofs reclaimed
 * Can be rolled back from prepared, executing, or pending states
 */
interface RolledBackMeltOperation extends MeltOperationBase, PreparedData {
  state: 'rolled_back';
}
/**
 * Discriminated union of all melt operation states.
 * TypeScript will narrow the type based on the `state` field.
 */
type MeltOperation = InitMeltOperation | PreparedMeltOperation | ExecutingMeltOperation | PendingMeltOperation | FinalizedMeltOperation | FailedMeltOperation | RollingBackMeltOperation | RolledBackMeltOperation;
/**
 * Any operation that has been prepared (has PreparedData)
 */
type PreparedOrLaterOperation$1 = PreparedMeltOperation | ExecutingMeltOperation | PendingMeltOperation | FinalizedMeltOperation | FailedMeltOperation | RollingBackMeltOperation | RolledBackMeltOperation;
//#endregion
//#region repositories/memory/MemoryCounterRepository.d.ts
declare class MemoryCounterRepository implements CounterRepository {
  private counters;
  private key;
  getCounter(mintUrl: string, keysetId: string): Promise<Counter | null>;
  setCounter(mintUrl: string, keysetId: string, counter: number): Promise<void>;
}
//#endregion
//#region repositories/memory/MemoryKeysetRepository.d.ts
declare class MemoryKeysetRepository implements KeysetRepository {
  private keysetsByMint;
  private getMintMap;
  getKeysetsByMintUrl(mintUrl: string): Promise<Keyset[]>;
  getKeysetById(mintUrl: string, id: string): Promise<Keyset | null>;
  updateKeyset(keyset: Omit<Keyset, 'keypairs' | 'updatedAt'>): Promise<void>;
  addKeyset(keyset: Omit<Keyset, 'updatedAt'>): Promise<void>;
  deleteKeyset(mintUrl: string, keysetId: string): Promise<void>;
}
//#endregion
//#region repositories/memory/MemoryKeyRingRepository.d.ts
declare class MemoryKeyRingRepository implements KeyRingRepository {
  private keyPairs;
  private insertionOrder;
  getPersistedKeyPair(publicKey: string): Promise<Keypair | null>;
  setPersistedKeyPair(keyPair: Keypair): Promise<void>;
  deletePersistedKeyPair(publicKey: string): Promise<void>;
  getAllPersistedKeyPairs(): Promise<Keypair[]>;
  getLatestKeyPair(): Promise<Keypair | null>;
  getLastDerivationIndex(): Promise<number>;
}
//#endregion
//#region repositories/memory/MemoryMintRepository.d.ts
declare class MemoryMintRepository implements MintRepository {
  private mints;
  isTrustedMint(mintUrl: string): Promise<boolean>;
  getMintByUrl(mintUrl: string): Promise<Mint>;
  getAllMints(): Promise<Mint[]>;
  getAllTrustedMints(): Promise<Mint[]>;
  addNewMint(mint: Mint): Promise<void>;
  addOrUpdateMint(mint: Mint): Promise<void>;
  updateMint(mint: Mint): Promise<void>;
  setMintTrusted(mintUrl: string, trusted: boolean): Promise<void>;
  deleteMint(mintUrl: string): Promise<void>;
}
//#endregion
//#region repositories/memory/MemoryProofRepository.d.ts
declare class MemoryProofRepository implements ProofRepository {
  private proofsByMint;
  private getMintMap;
  saveProofs(mintUrl: string, proofs: CoreProof[]): Promise<void>;
  getReadyProofs(mintUrl: string): Promise<CoreProof[]>;
  getInflightProofs(mintUrls?: string[]): Promise<CoreProof[]>;
  getAllReadyProofs(): Promise<CoreProof[]>;
  getProofsByKeysetId(mintUrl: string, keysetId: string): Promise<CoreProof[]>;
  setProofState(mintUrl: string, secrets: string[], state: ProofState): Promise<void>;
  deleteProofs(mintUrl: string, secrets: string[]): Promise<void>;
  wipeProofsByKeysetId(mintUrl: string, keysetId: string): Promise<void>;
  reserveProofs(mintUrl: string, secrets: string[], operationId: string): Promise<void>;
  releaseProofs(mintUrl: string, secrets: string[]): Promise<void>;
  setCreatedByOperation(mintUrl: string, secrets: string[], operationId: string): Promise<void>;
  getProofBySecret(mintUrl: string, secret: string): Promise<CoreProof | null>;
  getProofsByOperationId(mintUrl: string, operationId: string): Promise<CoreProof[]>;
  getAvailableProofs(mintUrl: string): Promise<CoreProof[]>;
  getReservedProofs(): Promise<CoreProof[]>;
}
//#endregion
//#region repositories/memory/MemoryRepositories.d.ts
declare class MemoryRepositories implements Repositories {
  mintRepository: MintRepository;
  keyRingRepository: KeyRingRepository;
  counterRepository: CounterRepository;
  keysetRepository: KeysetRepository;
  proofRepository: ProofRepository;
  mintQuoteRepository: MintQuoteRepository;
  meltQuoteRepository: MeltQuoteRepository;
  historyRepository: HistoryRepository;
  sendOperationRepository: SendOperationRepository;
  meltOperationRepository: MeltOperationRepository;
  constructor();
  init(): Promise<void>;
  withTransaction<T>(fn: (repos: RepositoryTransactionScope) => Promise<T>): Promise<T>;
}
//#endregion
//#region repositories/memory/MemoryMintQuoteRepository.d.ts
declare class MemoryMintQuoteRepository implements MintQuoteRepository {
  private readonly quotes;
  private makeKey;
  getMintQuote(mintUrl: string, quoteId: string): Promise<MintQuote | null>;
  addMintQuote(quote: MintQuote): Promise<void>;
  setMintQuoteState(mintUrl: string, quoteId: string, state: MintQuote['state']): Promise<void>;
  getPendingMintQuotes(): Promise<MintQuote[]>;
}
//#endregion
//#region repositories/memory/MemoryMeltQuoteRepository.d.ts
declare class MemoryMeltQuoteRepository implements MeltQuoteRepository {
  private readonly quotes;
  private makeKey;
  getMeltQuote(mintUrl: string, quoteId: string): Promise<MeltQuote | null>;
  addMeltQuote(quote: MeltQuote): Promise<void>;
  setMeltQuoteState(mintUrl: string, quoteId: string, state: MeltQuote['state']): Promise<void>;
  getPendingMeltQuotes(): Promise<MeltQuote[]>;
}
//#endregion
//#region repositories/memory/MemoryHistoryRepository.d.ts
type NewHistoryEntry = Omit<MintHistoryEntry, 'id'> | Omit<MeltHistoryEntry, 'id'> | Omit<SendHistoryEntry, 'id'> | Omit<ReceiveHistoryEntry, 'id'>;
declare class MemoryHistoryRepository implements HistoryRepository {
  private readonly entries;
  private nextId;
  getPaginatedHistoryEntries(limit: number, offset: number): Promise<HistoryEntry[]>;
  getHistoryEntryById(id: string): Promise<HistoryEntry | null>;
  addHistoryEntry(history: NewHistoryEntry): Promise<HistoryEntry>;
  getMintHistoryEntry(mintUrl: string, quoteId: string): Promise<MintHistoryEntry | null>;
  getMeltHistoryEntry(mintUrl: string, quoteId: string): Promise<MeltHistoryEntry | null>;
  getSendHistoryEntry(mintUrl: string, operationId: string): Promise<SendHistoryEntry | null>;
  updateHistoryEntry(history: Omit<MintHistoryEntry, 'id' | 'createdAt'> | Omit<MeltHistoryEntry, 'id' | 'createdAt'> | Omit<SendHistoryEntry, 'id' | 'createdAt'>): Promise<HistoryEntry>;
  updateSendHistoryState(mintUrl: string, operationId: string, state: SendHistoryState): Promise<void>;
  deleteHistoryEntry(mintUrl: string, quoteId: string): Promise<void>;
}
//#endregion
//#region repositories/memory/MemorySendOperationRepository.d.ts
declare class MemorySendOperationRepository implements SendOperationRepository {
  private readonly operations;
  create(operation: SendOperation): Promise<void>;
  update(operation: SendOperation): Promise<void>;
  getById(id: string): Promise<SendOperation | null>;
  getByState(state: SendOperationState): Promise<SendOperation[]>;
  getPending(): Promise<SendOperation[]>;
  getByMintUrl(mintUrl: string): Promise<SendOperation[]>;
  delete(id: string): Promise<void>;
}
//#endregion
//#region repositories/memory/MemoryMeltOperationRepository.d.ts
declare class MemoryMeltOperationRepository implements MeltOperationRepository {
  private readonly operations;
  create(operation: MeltOperation): Promise<void>;
  update(operation: MeltOperation): Promise<void>;
  getById(id: string): Promise<MeltOperation | null>;
  getByState(state: MeltOperationState): Promise<MeltOperation[]>;
  getPending(): Promise<MeltOperation[]>;
  getByMintUrl(mintUrl: string): Promise<MeltOperation[]>;
  getByQuoteId(mintUrl: string, quoteId: string): Promise<MeltOperation[]>;
  delete(id: string): Promise<void>;
}
//#endregion
//#region repositories/index.d.ts
interface MintRepository {
  isTrustedMint(mintUrl: string): Promise<boolean>;
  getMintByUrl(mintUrl: string): Promise<Mint>;
  getAllMints(): Promise<Mint[]>;
  getAllTrustedMints(): Promise<Mint[]>;
  addNewMint(mint: Mint): Promise<void>;
  addOrUpdateMint(mint: Mint): Promise<void>;
  updateMint(mint: Mint): Promise<void>;
  setMintTrusted(mintUrl: string, trusted: boolean): Promise<void>;
  deleteMint(mintUrl: string): Promise<void>;
}
interface KeysetRepository {
  getKeysetsByMintUrl(mintUrl: string): Promise<Keyset[]>;
  getKeysetById(mintUrl: string, id: string): Promise<Keyset | null>;
  updateKeyset(keyset: Omit<Keyset, 'keypairs' | 'updatedAt'>): Promise<void>;
  addKeyset(keyset: Omit<Keyset, 'updatedAt'>): Promise<void>;
  deleteKeyset(mintUrl: string, keysetId: string): Promise<void>;
}
interface CounterRepository {
  getCounter(mintUrl: string, keysetId: string): Promise<Counter | null>;
  setCounter(mintUrl: string, keysetId: string, counter: number): Promise<void>;
}
interface ProofRepository {
  saveProofs(mintUrl: string, proofs: CoreProof[]): Promise<void>;
  getReadyProofs(mintUrl: string): Promise<CoreProof[]>;
  /**
   * Retrieves all proofs marked as inflight. Can be optionally filtered by a list of mint URLs.
   */
  getInflightProofs(mintUrls?: string[]): Promise<CoreProof[]>;
  getAllReadyProofs(): Promise<CoreProof[]>;
  setProofState(mintUrl: string, secrets: string[], state: ProofState): Promise<void>;
  deleteProofs(mintUrl: string, secrets: string[]): Promise<void>;
  getProofsByKeysetId(mintUrl: string, keysetId: string): Promise<CoreProof[]>;
  wipeProofsByKeysetId(mintUrl: string, keysetId: string): Promise<void>;
  /**
   * Reserve proofs for an operation by setting usedByOperationId.
   * Only proofs that are 'ready' and not already reserved can be reserved.
   */
  reserveProofs(mintUrl: string, secrets: string[], operationId: string): Promise<void>;
  /**
   * Release proofs from an operation by clearing usedByOperationId.
   */
  releaseProofs(mintUrl: string, secrets: string[]): Promise<void>;
  /**
   * Set the createdByOperationId for proofs.
   */
  setCreatedByOperation(mintUrl: string, secrets: string[], operationId: string): Promise<void>;
  /**
   * Get a single proof by its secret.
   */
  getProofBySecret(mintUrl: string, secret: string): Promise<CoreProof | null>;
  /**
   * Get proofs associated with a specific operation (as input or output).
   */
  getProofsByOperationId(mintUrl: string, operationId: string): Promise<CoreProof[]>;
  /**
   * Get available (ready and not reserved) proofs for a mint.
   * This filters out proofs that have usedByOperationId set.
   */
  getAvailableProofs(mintUrl: string): Promise<CoreProof[]>;
  /**
   * Get all proofs that are reserved (have usedByOperationId set) and are still in ready state.
   * Used for detecting orphaned reservations during recovery.
   */
  getReservedProofs(): Promise<CoreProof[]>;
}
interface MintQuoteRepository {
  getMintQuote(mintUrl: string, quoteId: string): Promise<MintQuote | null>;
  addMintQuote(quote: MintQuote): Promise<void>;
  setMintQuoteState(mintUrl: string, quoteId: string, state: MintQuote['state']): Promise<void>;
  getPendingMintQuotes(): Promise<MintQuote[]>;
}
interface KeyRingRepository {
  getPersistedKeyPair(publicKey: string): Promise<Keypair | null>;
  setPersistedKeyPair(keyPair: Keypair): Promise<void>;
  deletePersistedKeyPair(publicKey: string): Promise<void>;
  getAllPersistedKeyPairs(): Promise<Keypair[]>;
  getLatestKeyPair(): Promise<Keypair | null>;
  getLastDerivationIndex(): Promise<number>;
}
interface MeltQuoteRepository {
  getMeltQuote(mintUrl: string, quoteId: string): Promise<MeltQuote | null>;
  addMeltQuote(quote: MeltQuote): Promise<void>;
  setMeltQuoteState(mintUrl: string, quoteId: string, state: MeltQuote['state']): Promise<void>;
  getPendingMeltQuotes(): Promise<MeltQuote[]>;
}
interface HistoryRepository {
  getPaginatedHistoryEntries(limit: number, offset: number): Promise<HistoryEntry[]>;
  getHistoryEntryById(id: string): Promise<HistoryEntry | null>;
  addHistoryEntry(history: Omit<HistoryEntry, 'id'>): Promise<HistoryEntry>;
  getMintHistoryEntry(mintUrl: string, quoteId: string): Promise<MintHistoryEntry | null>;
  getMeltHistoryEntry(mintUrl: string, quoteId: string): Promise<MeltHistoryEntry | null>;
  getSendHistoryEntry(mintUrl: string, operationId: string): Promise<SendHistoryEntry | null>;
  updateHistoryEntry(history: Omit<HistoryEntry, 'id' | 'createdAt'>): Promise<HistoryEntry>;
  updateSendHistoryState(mintUrl: string, operationId: string, state: SendHistoryState): Promise<void>;
  deleteHistoryEntry(mintUrl: string, quoteId: string): Promise<void>;
}
interface SendOperationRepository {
  /** Create a new send operation */
  create(operation: SendOperation): Promise<void>;
  /** Update an existing send operation */
  update(operation: SendOperation): Promise<void>;
  /** Get a send operation by ID */
  getById(id: string): Promise<SendOperation | null>;
  /** Get all send operations in a specific state */
  getByState(state: SendOperationState): Promise<SendOperation[]>;
  /** Get all pending operations (state in ['executing', 'pending']) */
  getPending(): Promise<SendOperation[]>;
  /** Get all operations for a specific mint */
  getByMintUrl(mintUrl: string): Promise<SendOperation[]>;
  /** Delete a send operation */
  delete(id: string): Promise<void>;
}
interface MeltOperationRepository {
  /** Create a new melt operation */
  create(operation: MeltOperation): Promise<void>;
  /** Update an existing melt operation */
  update(operation: MeltOperation): Promise<void>;
  /** Get a melt operation by ID */
  getById(id: string): Promise<MeltOperation | null>;
  /** Get all melt operations in a specific state */
  getByState(state: MeltOperationState): Promise<MeltOperation[]>;
  /** Get all pending operations (state in ['executing', 'pending']) */
  getPending(): Promise<MeltOperation[]>;
  /** Get all operations for a specific mint */
  getByMintUrl(mintUrl: string): Promise<MeltOperation[]>;
  /** Get all operations for a mint/quote pair */
  getByQuoteId(mintUrl: string, quoteId: string): Promise<MeltOperation[]>;
  /** Delete a melt operation */
  delete(id: string): Promise<void>;
}
interface RepositoriesBase {
  mintRepository: MintRepository;
  keyRingRepository: KeyRingRepository;
  counterRepository: CounterRepository;
  keysetRepository: KeysetRepository;
  proofRepository: ProofRepository;
  mintQuoteRepository: MintQuoteRepository;
  meltQuoteRepository: MeltQuoteRepository;
  historyRepository: HistoryRepository;
  sendOperationRepository: SendOperationRepository;
  meltOperationRepository: MeltOperationRepository;
}
interface Repositories extends RepositoriesBase {
  init(): Promise<void>;
  withTransaction<T>(fn: (repos: RepositoryTransactionScope) => Promise<T>): Promise<T>;
}
type RepositoryTransactionScope = RepositoriesBase;
//#endregion
//#region services/MintQuoteService.d.ts
declare class MintQuoteService {
  private readonly mintQuoteRepo;
  private readonly mintService;
  private readonly walletService;
  private readonly proofService;
  private readonly eventBus;
  private readonly logger?;
  constructor(mintQuoteRepo: MintQuoteRepository, mintService: MintService, walletService: WalletService, proofService: ProofService, eventBus: EventBus<CoreEvents>, logger?: Logger);
  createMintQuote(mintUrl: string, amount: number): Promise<MintQuoteBolt11Response>;
  redeemMintQuote(mintUrl: string, quoteId: string): Promise<void>;
  addExistingMintQuotes(mintUrl: string, quotes: MintQuoteBolt11Response[]): Promise<{
    added: string[];
    skipped: string[];
  }>;
  updateStateFromRemote(mintUrl: string, quoteId: string, state: MintQuoteState): Promise<void>;
  private setMintQuoteState;
  /**
   * Requeue all PAID (but not yet ISSUED) quotes for processing.
   * Only requeues quotes for trusted mints.
   * Emits `mint-quote:requeue` for each PAID quote so the processor can enqueue them.
   */
  requeuePaidMintQuotes(mintUrl?: string): Promise<{
    requeued: string[];
  }>;
}
//#endregion
//#region services/watchers/MintQuoteWatcherService.d.ts
interface MintQuoteWatcherOptions {
  watchExistingPendingOnStart?: boolean;
}
declare class MintQuoteWatcherService {
  private readonly repo;
  private readonly subs;
  private readonly mintService;
  private readonly quotes;
  private readonly bus;
  private readonly logger?;
  private readonly options;
  private running;
  private unsubscribeByKey;
  private offCreated?;
  private offAdded?;
  private offUntrusted?;
  constructor(repo: MintQuoteRepository, subs: SubscriptionManager, mintService: MintService, quotes: MintQuoteService, bus: EventBus<CoreEvents>, logger?: Logger, options?: MintQuoteWatcherOptions);
  isRunning(): boolean;
  start(): Promise<void>;
  stop(): Promise<void>;
  watchQuote(mintUrl: string, quoteOrQuotes: string | string[]): Promise<void>;
  private stopWatching;
  stopWatchingMint(mintUrl: string): Promise<void>;
}
//#endregion
//#region services/watchers/MintQuoteProcessor.d.ts
interface QuoteHandler {
  canHandle(quoteType: string): boolean;
  process(mintUrl: string, quoteId: string): Promise<void>;
}
interface MintQuoteProcessorOptions {
  processIntervalMs?: number;
  maxRetries?: number;
  baseRetryDelayMs?: number;
  initialEnqueueDelayMs?: number;
}
declare class MintQuoteProcessor {
  private readonly quotes;
  private readonly bus;
  private readonly logger?;
  private running;
  private queue;
  private processing;
  private processingTimer?;
  private offStateChanged?;
  private offQuoteAdded?;
  private offRequeue?;
  private offUntrusted?;
  private handlers;
  private readonly processIntervalMs;
  private readonly maxRetries;
  private readonly baseRetryDelayMs;
  private readonly initialEnqueueDelayMs;
  constructor(quotes: MintQuoteService, bus: EventBus<CoreEvents>, logger?: Logger, options?: MintQuoteProcessorOptions);
  registerHandler(quoteType: string, handler: QuoteHandler): void;
  isRunning(): boolean;
  start(): Promise<void>;
  stop(): Promise<void>;
  /**
   * Wait for the queue to be empty and all processing to complete.
   * Useful for CLI applications that want to ensure all quotes are processed before exiting.
   */
  waitForCompletion(): Promise<void>;
  /**
   * Remove all queued items for a specific mint.
   * Called when a mint is untrusted to stop processing its quotes.
   */
  clearMintFromQueue(mintUrl: string): void;
  private enqueue;
  private scheduleNextProcess;
  private processNext;
  private processItem;
  private handleProcessingError;
  private updateQuoteState;
}
//#endregion
//#region operations/send/SendOperationService.d.ts
/**
 * Service that manages send operations as sagas.
 *
 * This service provides crash recovery and rollback capabilities for send operations
 * by breaking them into discrete steps: init → prepare → execute → finalize/rollback.
 */
declare class SendOperationService {
  private readonly sendOperationRepository;
  private readonly proofRepository;
  private readonly proofService;
  private readonly mintService;
  private readonly walletService;
  private readonly eventBus;
  private readonly logger?;
  /** In-memory locks to prevent concurrent operations on the same operation ID */
  private readonly operationLocks;
  /** Lock for the global recovery process */
  private recoveryLock;
  constructor(sendOperationRepository: SendOperationRepository, proofRepository: ProofRepository, proofService: ProofService, mintService: MintService, walletService: WalletService, eventBus: EventBus<CoreEvents>, logger?: Logger);
  /**
   * Acquire a lock for an operation.
   * Returns a release function that must be called when the operation completes.
   * Throws if the operation is already locked.
   */
  private acquireOperationLock;
  /**
   * Check if an operation is currently locked.
   */
  isOperationLocked(operationId: string): boolean;
  /**
   * Check if recovery is currently in progress.
   */
  isRecoveryInProgress(): boolean;
  /**
   * Create a new send operation.
   * This is the entry point for the saga.
   */
  init(mintUrl: string, amount: number): Promise<InitSendOperation>;
  /**
   * Prepare the operation by reserving proofs and creating outputs.
   * After this step, the operation can be executed or rolled back.
   *
   * If preparation fails, automatically attempts to recover the init operation.
   * Throws if the operation is already in progress.
   */
  prepare(operation: InitSendOperation): Promise<PreparedSendOperation>;
  /**
   * Internal prepare logic, separated for error handling.
   */
  private prepareInternal;
  /**
   * Execute the prepared operation.
   * Performs the swap (if needed) and creates the token.
   *
   * If execution fails after transitioning to 'executing' state,
   * automatically attempts to recover the operation.
   * Throws if the operation is already in progress.
   */
  execute(operation: PreparedSendOperation): Promise<{
    operation: PendingSendOperation;
    token: Token;
  }>;
  /**
   * Internal execute logic, separated for error handling.
   */
  private executeInternal;
  /**
   * High-level send method that orchestrates init → prepare → execute.
   * This is the main entry point for consumers.
   */
  send(mintUrl: string, amount: number): Promise<Token>;
  /**
   * Finalize a pending operation after its proofs have been spent.
   * This method is idempotent - calling it on an already finalized operation is a no-op.
   * If the operation was rolled back, finalization is skipped (rollback takes precedence).
   * Throws if the operation is already in progress.
   */
  finalize(operationId: string): Promise<void>;
  /**
   * Rollback an operation by reclaiming the proofs.
   * Only works for operations in 'prepared', 'executing', or 'pending' state.
   * Throws if the operation is already in progress.
   */
  rollback(operationId: string): Promise<void>;
  /**
   * Recover pending operations on startup.
   * This should be called during initialization.
   * Throws if recovery is already in progress.
   */
  recoverPendingOperations(): Promise<void>;
  /**
   * Clean up a failed init operation.
   * Releases any orphaned proof reservations and deletes the operation.
   */
  private recoverInitOperation;
  /**
   * Attempts to recover an init operation, swallowing recovery errors.
   * If recovery fails, logs warning and leaves for startup recovery.
   */
  private tryRecoverInitOperation;
  /**
   * Recover an executing operation.
   * Determines if swap happened and recovers accordingly.
   */
  private recoverExecutingOperation;
  /**
   * Attempts to recover an executing operation, swallowing recovery errors.
   * If recovery fails (e.g., mint unreachable), logs warning and leaves
   * for startup recovery.
   */
  private tryRecoverExecutingOperation;
  /**
   * Recover proofs from a completed swap using the mint's restore endpoint.
   */
  private recoverProofsFromSwap;
  /**
   * Check a pending operation to see if it should be finalized.
   */
  checkPendingOperation(op: PendingSendOperation): Promise<void>;
  /**
   * Check proof states with the mint.
   */
  private checkProofStatesWithMint;
  /**
   * Mark an operation as rolled back with an error message.
   */
  private markAsRolledBack;
  /**
   * Clean up orphaned proof reservations.
   * Finds proofs that are reserved but point to non-existent or terminal operations.
   */
  private cleanupOrphanedReservations;
  /**
   * Get an operation by ID.
   */
  getOperation(operationId: string): Promise<SendOperation | null>;
  /**
   * Get all pending operations.
   */
  getPendingOperations(): Promise<SendOperation[]>;
}
//#endregion
//#region services/watchers/ProofStateWatcherService.d.ts
interface ProofStateWatcherOptions {
  watchExistingInflightOnStart?: boolean;
}
declare class ProofStateWatcherService {
  private readonly subs;
  private readonly mintService;
  private readonly proofs;
  private readonly proofRepository;
  private readonly bus;
  private readonly logger?;
  private readonly options;
  private sendOperationService?;
  private running;
  private unsubscribeByKey;
  private inflightByKey;
  private offProofsStateChanged?;
  private offProofsSaved?;
  private offUntrusted?;
  constructor(subs: SubscriptionManager, mintService: MintService, proofs: ProofService, proofRepository: ProofRepository, bus: EventBus<CoreEvents>, logger?: Logger, options?: ProofStateWatcherOptions);
  /**
   * Set the SendOperationService for auto-finalizing send operations.
   * This is set after construction to avoid circular dependencies.
   */
  setSendOperationService(service: SendOperationService): void;
  isRunning(): boolean;
  start(): Promise<void>;
  stop(): Promise<void>;
  watchProof(mintUrl: string, secrets: string[]): Promise<void>;
  private bootstrapInflightProofs;
  private stopWatching;
  stopWatchingMint(mintUrl: string): Promise<void>;
  /**
   * Check if a spent proof is part of a send operation and finalize it if all send proofs are spent.
   */
  private tryFinalizeSendOperation;
}
//#endregion
//#region services/WalletRestoreService.d.ts
declare class WalletRestoreService {
  private readonly proofService;
  private readonly counterService;
  private readonly walletService;
  private readonly requestProvider;
  private readonly logger?;
  private readonly restoreBatchSize;
  private readonly restoreGapLimit;
  private readonly restoreStartCounter;
  constructor(proofService: ProofService, counterService: CounterService, walletService: WalletService, requestProvider: MintRequestProvider, logger?: Logger);
  sweepKeyset(mintUrl: string, keysetId: string, bip39seed: Uint8Array): Promise<void>;
  /**
   * Restore and persist proofs for a single keyset.
   * Enforces the invariant: restored proofs must be >= previously stored proofs.
   * Throws on any validation or persistence error. No transactions are used here.
   */
  restoreKeyset(mintUrl: string, wallet: Wallet, keysetId: string): Promise<void>;
}
//#endregion
//#region services/MeltQuoteService.d.ts
declare class MeltQuoteService {
  private readonly mintService;
  private readonly proofService;
  private readonly walletService;
  private readonly meltQuoteRepo;
  private readonly logger?;
  private readonly eventBus;
  constructor(mintService: MintService, proofService: ProofService, walletService: WalletService, meltQuoteRepo: MeltQuoteRepository, eventBus: EventBus<CoreEvents>, logger?: Logger);
  createMeltQuote(mintUrl: string, invoice: string): Promise<MeltQuoteBolt11Response>;
  payMeltQuote(mintUrl: string, quoteId: string): Promise<void>;
  private setMeltQuoteState;
}
//#endregion
//#region services/HistoryService.d.ts
declare class HistoryService {
  private readonly historyRepository;
  private readonly logger?;
  private readonly eventBus;
  constructor(historyRepository: HistoryRepository, eventBus: EventBus<CoreEvents>, logger?: Logger);
  getPaginatedHistory(offset?: number, limit?: number): Promise<HistoryEntry[]>;
  getHistoryEntryById(id: string): Promise<HistoryEntry | null>;
  /**
   * Get the operationId for a send history entry.
   * @throws Error if entry not found or is not a send entry
   */
  getOperationIdFromHistoryEntry(historyId: string): Promise<string>;
  handleSendPrepared(mintUrl: string, operationId: string, operation: SendOperation): Promise<void>;
  handleSendPending(mintUrl: string, operationId: string, token: Token): Promise<void>;
  handleSendStateChanged(mintUrl: string, operationId: string, state: SendHistoryState): Promise<void>;
  handleReceiveCreated(mintUrl: string, token: Token): Promise<void>;
  handleMintQuoteStateChanged(mintUrl: string, quoteId: string, state: MintQuoteState): Promise<void>;
  handleMeltQuoteStateChanged(mintUrl: string, quoteId: string, state: MeltQuoteState): Promise<void>;
  handleMeltQuoteCreated(mintUrl: string, quoteId: string, quote: MeltQuoteBolt11Response): Promise<void>;
  handleMintQuoteCreated(mintUrl: string, quoteId: string, quote: MintQuoteBolt11Response): Promise<void>;
  handleMintQuoteAdded(mintUrl: string, quoteId: string, quote: MintQuoteBolt11Response): Promise<void>;
  handleHistoryUpdated(mintUrl: string, entry: HistoryEntry): Promise<void>;
}
//#endregion
//#region services/TransactionService.d.ts
declare class TransactionService {
  private readonly mintService;
  private readonly walletService;
  private readonly proofService;
  private readonly eventBus;
  private readonly logger?;
  constructor(mintService: MintService, walletService: WalletService, proofService: ProofService, eventBus: EventBus<CoreEvents>, logger?: Logger);
  receive(token: Token | string): Promise<void>;
  send(mintUrl: string, amount: number): Promise<Token>;
}
//#endregion
//#region services/PaymentRequestService.d.ts
type InbandTransport = {
  type: 'inband';
};
type HttpTransport = {
  type: 'http';
  url: string;
};
type Transport = InbandTransport | HttpTransport;
type ParsedPaymentRequest = {
  paymentRequest: PaymentRequest;
  matchingMints: string[];
  requiredMints: string[];
  amount?: number;
  transport: Transport;
};
type PaymentRequestTransaction = {
  sendOperation: PreparedSendOperation;
  request: ParsedPaymentRequest;
};
declare class PaymentRequestService {
  private readonly sendOperationService;
  private readonly proofService;
  private readonly logger?;
  constructor(sendOperationService: SendOperationService, proofService: ProofService, logger?: Logger);
  /**
   * Process a payment request and return a parsed payment request.
   * @param paymentRequest - The payment request to process
   * @returns The parsed payment request
   */
  processPaymentRequest(paymentRequest: string): Promise<ParsedPaymentRequest>;
  /**
   * Handle an inband payment request by sending tokens and calling the handler.
   * @param mintUrl - The mint to send from
   * @param request - The prepared payment request
   * @param inbandHandler - Callback to deliver the token
   * @param amount - Optional amount (required if not specified in request)
   */
  preparePaymentRequestTransaction(mintUrl: string, request: ParsedPaymentRequest, amount?: number): Promise<PaymentRequestTransaction>;
  /**
   * Handle an HTTP payment request by sending tokens to the specified URL.
   * @param mintUrl - The mint to send from
   * @param request - The prepared payment request
   * @param amount - Optional amount (required if not specified in request)
   * @returns The HTTP response from the payment endpoint
   */
  handleInbandPaymentRequest(transaction: PaymentRequestTransaction, inbandHandler: (token: Token) => Promise<void>): Promise<void>;
  /**
   * Handle an HTTP payment request by sending tokens to the specified URL.
   * @param mintUrl - The mint to send from
   * @param request - The prepared payment request
   * @param amount - Optional amount (required if not specified in request)
   * @returns The HTTP response from the payment endpoint
   */
  handleHttpPaymentRequest(transaction: PaymentRequestTransaction): Promise<Response>;
  private readPaymentRequest;
  private validateMint;
  private getPaymentRequestTransport;
  private findMatchingMints;
  private validateAmount;
}
//#endregion
//#region api/WalletApi.d.ts
declare class WalletApi {
  private mintService;
  private walletService;
  private proofService;
  private walletRestoreService;
  private transactionService;
  private paymentRequestService;
  private sendOperationService;
  private readonly logger?;
  constructor(mintService: MintService, walletService: WalletService, proofService: ProofService, walletRestoreService: WalletRestoreService, transactionService: TransactionService, paymentRequestService: PaymentRequestService, sendOperationService: SendOperationService, logger?: Logger);
  receive(token: Token | string): Promise<void>;
  /**
   * Send tokens from a mint.
   *
   * @deprecated Use `SendApi.prepareSend()` and SendApi.executePreparedSend() instead.
   *
   * @param mintUrl - The mint URL to send from
   * @param amount - The amount to send
   * @returns The token to share with the recipient
   */
  send(mintUrl: string, amount: number): Promise<Token>;
  getBalances(): Promise<{
    [mintUrl: string]: number;
  }>;
  /**
   * Parse and validate a payment request string.
   */
  processPaymentRequest(paymentRequest: string): Promise<ParsedPaymentRequest>;
  /**
   * Prepare a payment request transaction.
   * @param mintUrl - The mint to send from
   * @param request - The parsed payment request
   * @param amount - Optional amount (required if not specified in request)
   * @returns The payment request transaction
   */
  preparePaymentRequestTransaction(mintUrl: string, request: ParsedPaymentRequest, amount?: number): Promise<PaymentRequestTransaction>;
  /**
   * Handle an inband payment request by sending tokens and calling the handler.
   * @param mintUrl - The mint to send from
   * @param request - The prepared payment request (from readPaymentRequest)
   * @param inbandHandler - Callback to deliver the token (e.g., display QR, send via NFC)
   * @param amount - Optional amount (required if not specified in request)
   */
  handleInbandPaymentRequest(transaction: PaymentRequestTransaction, inbandHandler: (token: Token) => Promise<void>): Promise<void>;
  /**
   * Handle an HTTP payment request by sending tokens to the specified URL.
   * @param mintUrl - The mint to send from
   * @param request - The prepared payment request (from readPaymentRequest)
   * @param amount - Optional amount (required if not specified in request)
   * @returns The HTTP response from the payment endpoint
   */
  handleHttpPaymentRequest(transaction: PaymentRequestTransaction): Promise<Response>;
  restore(mintUrl: string): Promise<void>;
  /**
   * Sweeps a mint by sweeping each keyset and adds the swept proofs to the wallet
   * @param mintUrl - The URL of the mint to sweep
   * @param bip39seed - The BIP39 seed of the wallet to sweep
   */
  sweep(mintUrl: string, bip39seed: Uint8Array): Promise<void>;
  decodeToken(tokenString: string): Promise<Token>;
  encodeToken(token: Token): string;
}
//#endregion
//#region api/QuotesApi.d.ts
declare class QuotesApi {
  private mintQuoteService;
  private meltQuoteService;
  private meltOperationService;
  constructor(mintQuoteService: MintQuoteService, meltQuoteService: MeltQuoteService, meltOperationService: MeltOperationService);
  createMintQuote(mintUrl: string, amount: number): Promise<MintQuoteBolt11Response>;
  redeemMintQuote(mintUrl: string, quoteId: string): Promise<void>;
  /**
   * Create a bolt11 melt quote
   * @deprecated Use {@link prepareMeltBolt11} instead
   */
  createMeltQuote(mintUrl: string, invoice: string): Promise<MeltQuoteBolt11Response>;
  /**
   * Pay a bolt11 melt quote
   * @deprecated Use {@link executeMeltBolt11} instead
   */
  payMeltQuote(mintUrl: string, quoteId: string): Promise<void>;
  prepareMeltBolt11(mintUrl: string, invoice: string): Promise<PreparedMeltOperation>;
  executeMelt(operationId: string): Promise<PendingMeltOperation | FinalizedMeltOperation>;
  executeMeltByQuote(mintUrl: string, quoteId: string): Promise<PendingMeltOperation | FinalizedMeltOperation | null>;
  checkPendingMelt(operationId: string): Promise<PendingCheckResult>;
  checkPendingMeltByQuote(mintUrl: string, quoteId: string): Promise<PendingCheckResult | null>;
  addMintQuote(mintUrl: string, quotes: MintQuoteBolt11Response[]): Promise<{
    added: string[];
    skipped: string[];
  }>;
  requeuePaidMintQuotes(mintUrl?: string): Promise<{
    requeued: string[];
  }>;
}
//#endregion
//#region models/Error.d.ts
declare class UnknownMintError extends Error {
  constructor(message: string);
}
declare class MintFetchError extends Error {
  readonly mintUrl: string;
  constructor(mintUrl: string, message?: string, cause?: unknown);
}
declare class KeysetSyncError extends Error {
  readonly mintUrl: string;
  readonly keysetId: string;
  constructor(mintUrl: string, keysetId: string, message?: string, cause?: unknown);
}
declare class ProofValidationError extends Error {
  constructor(message: string);
}
declare class TokenValidationError extends Error {
  constructor(message: string);
}
declare class ProofOperationError extends Error {
  readonly mintUrl: string;
  readonly keysetId?: string;
  constructor(mintUrl: string, message?: string, keysetId?: string, cause?: unknown);
}
/**
 * This error is thrown when a HTTP response is not 2XX nor a protocol error.
 */
declare class HttpResponseError extends Error {
  status: number;
  constructor(message: string, status: number);
}
/**
 * This error is thrown when a network request fails.
 */
declare class NetworkError extends Error {
  constructor(message: string);
}
/**
 * This error is thrown when a protocol error occurs per Cashu NUT-00 error codes.
 */
declare class MintOperationError extends HttpResponseError {
  code: number;
  constructor(code: number, detail: string);
}
/**
 * This error is thrown when a payment request is invalid or cannot be processed.
 */
declare class PaymentRequestError extends Error {
  constructor(message: string, cause?: unknown);
}
/**
 * This error is thrown when attempting to modify an operation that is already in progress.
 */
declare class OperationInProgressError extends Error {
  readonly operationId: string;
  constructor(operationId: string);
}
//#endregion
//#region api/MintApi.d.ts
declare class MintApi {
  private readonly mintService;
  constructor(mintService: MintService);
  addMint(mintUrl: string, options?: {
    trusted?: boolean;
  }): Promise<{
    mint: Mint;
    keysets: Keyset[];
  }>;
  getMintInfo(mintUrl: string): Promise<MintInfo>;
  isTrustedMint(mintUrl: string): Promise<boolean>;
  getAllMints(): Promise<Mint[]>;
  getAllTrustedMints(): Promise<Mint[]>;
  trustMint(mintUrl: string): Promise<void>;
  untrustMint(mintUrl: string): Promise<void>;
}
//#endregion
//#region api/KeyRingApi.d.ts
declare class KeyRingApi {
  private readonly keyRingService;
  constructor(keyRingService: KeyRingService);
  /**
   * Generates a new keypair and stores it in the keyring.
   * @param dumpSecretKey - If true, returns the full keypair including the secret key.
   *                        If false or omitted, returns only the public key.
   *                        WARNING: The secret key is sensitive cryptographic material. Handle with care.
   * @returns The full keypair (if dumpSecretKey is true) or just the public key (if false/omitted)
   */
  generateKeyPair(): Promise<{
    publicKeyHex: string;
  }>;
  generateKeyPair(dumpSecretKey: true): Promise<Keypair>;
  generateKeyPair(dumpSecretKey: false): Promise<{
    publicKeyHex: string;
  }>;
  /**
   * Adds an existing keypair to the keyring using a secret key.
   * @param secretKey - The 32-byte secret key as Uint8Array
   */
  addKeyPair(secretKey: Uint8Array): Promise<Keypair>;
  /**
   * Removes a keypair from the keyring.
   * @param publicKey - The public key (hex string) of the keypair to remove
   */
  removeKeyPair(publicKey: string): Promise<void>;
  /**
   * Retrieves a specific keypair by its public key.
   * @param publicKey - The public key (hex string) to look up
   * @returns The keypair if found, null otherwise
   */
  getKeyPair(publicKey: string): Promise<Keypair | null>;
  /**
   * Gets the most recently added keypair.
   * @returns The latest keypair if any exist, null otherwise
   */
  getLatestKeyPair(): Promise<Keypair | null>;
  /**
   * Gets all keypairs stored in the keyring.
   * @returns Array of all keypairs
   */
  getAllKeyPairs(): Promise<Keypair[]>;
}
//#endregion
//#region api/SubscriptionApi.d.ts
declare class SubscriptionApi {
  private readonly subs;
  private readonly logger?;
  constructor(subs: SubscriptionManager, logger?: Logger);
  awaitMintQuotePaid(mintUrl: string, quoteId: string): Promise<unknown>;
  awaitMeltQuotePaid(mintUrl: string, quoteId: string): Promise<unknown>;
  private awaitFirstNotification;
}
//#endregion
//#region api/HistoryApi.d.ts
declare class HistoryApi {
  private historyService;
  constructor(historyService: HistoryService);
  getPaginatedHistory(offset?: number, limit?: number): Promise<HistoryEntry[]>;
  getHistoryEntryById(id: string): Promise<HistoryEntry | null>;
}
//#endregion
//#region api/SendApi.d.ts
/**
 * API for managing send operations.
 *
 * Provides methods to:
 * - Query pending send operations
 * - Rollback or finalize operations by operationId
 * - Recover pending operations on startup
 */
declare class SendApi {
  private readonly sendOperationService;
  constructor(sendOperationService: SendOperationService);
  /**
   * Prepare a send operation without executing it.
   * This reserves the proofs and calculates the fee.
   *
   * Use this when you want to show the user the fee before committing.
   * The returned operation contains:
   * - `fee`: The swap fee (0 if exact match)
   * - `needsSwap`: Whether a swap is required
   * - `inputAmount`: Total input proof amount
   *
   * After reviewing, call `executePreparedSend()` to execute, or `rollback()` to cancel.
   *
   * @param mintUrl - The mint URL to send from
   * @param amount - The amount to send
   * @returns The prepared operation with fee information
   */
  prepareSend(mintUrl: string, amount: number): Promise<PreparedSendOperation>;
  /**
   * Execute a prepared send operation.
   * Call this after `prepareSend()` to complete the send.
   *
   * @param operationId - The ID of the prepared operation
   * @returns The pending operation and the token to share
   * @throws If the operation is not in 'prepared' state
   */
  executePreparedSend(operationId: string): Promise<{
    operation: PendingSendOperation;
    token: Token;
  }>;
  /**
   * Get a send operation by its ID.
   */
  getOperation(operationId: string): Promise<SendOperation | null>;
  /**
   * Get all pending send operations.
   * Pending operations are in 'executing' or 'pending' state.
   */
  getPendingOperations(): Promise<SendOperation[]>;
  /**
   * Finalize a send operation by operationId.
   * This marks the operation as completed after proofs are confirmed spent.
   */
  finalize(operationId: string): Promise<void>;
  /**
   * Rollback a send operation by operationId.
   * Reclaims proofs and cancels the operation.
   */
  rollback(operationId: string): Promise<void>;
  /**
   * Recover all pending operations.
   * Should be called during application initialization.
   */
  recoverPendingOperations(): Promise<void>;
  /**
   * Check a pending operation and finalize it if it should be finalized.
   */
  checkPendingOperation(operationId: string): Promise<void>;
  /**
   * Check if a specific operation is currently locked (in progress).
   * Useful for UI to disable buttons while an operation is executing.
   */
  isOperationLocked(operationId: string): boolean;
  /**
   * Check if recovery is currently in progress.
   * Useful to prevent multiple recovery calls.
   */
  isRecoveryInProgress(): boolean;
}
//#endregion
//#region plugins/types.d.ts
type ServiceKey = keyof ServiceMap;
interface ServiceMap {
  mintService: MintService;
  walletService: WalletService;
  proofService: ProofService;
  keyRingService: KeyRingService;
  seedService: SeedService;
  walletRestoreService: WalletRestoreService;
  counterService: CounterService;
  mintQuoteService: MintQuoteService;
  meltQuoteService: MeltQuoteService;
  historyService: HistoryService;
  transactionService: TransactionService;
  sendOperationService: SendOperationService;
  meltOperationService: MeltOperationService;
  paymentRequestService: PaymentRequestService;
  subscriptions: SubscriptionManager;
  eventBus: EventBus<CoreEvents>;
  logger: Logger;
}
interface PluginContext<Req extends readonly ServiceKey[] = readonly ServiceKey[]> {
  services: Pick<ServiceMap, Req[number]>;
  /**
   * Register an API extension accessible via manager.ext.<key>
   * @param key - Unique identifier for this extension
   * @param api - The API object to expose
   * @throws ExtensionRegistrationError if key is already registered
   */
  registerExtension<K extends string>(key: K, api: unknown): void;
}
type CleanupFn = () => void | Promise<void>;
type Cleanup = void | CleanupFn | Promise<void | CleanupFn>;
interface Plugin<Req extends readonly ServiceKey[] = readonly ServiceKey[]> {
  name: string;
  required: Req;
  optional?: readonly ServiceKey[];
  onInit?(ctx: PluginContext<Req>): Cleanup;
  onReady?(ctx: PluginContext<Req>): Cleanup;
  onDispose?(): void | Promise<void>;
}
/**
 * Base interface for plugin extensions.
 * Plugin authors should augment this interface via module augmentation:
 *
 * @example
 * declare module '@coco/core' {
 *   interface PluginExtensions {
 *     myPlugin: MyPluginApi;
 *   }
 * }
 */
interface PluginExtensions {}
/**
 * Error thrown when a plugin attempts to register an extension key that is already registered.
 */
declare class ExtensionRegistrationError extends Error {
  constructor(pluginName: string, key: string);
}
//#endregion
//#region Manager.d.ts
/**
 * Configuration options for initializing the Coco Cashu manager
 */
interface CocoConfig {
  /** Repository implementations for data persistence */
  repo: Repositories;
  /** Function that returns the wallet seed as Uint8Array */
  seedGetter: () => Promise<Uint8Array>;
  /** Optional logger instance (defaults to NullLogger) */
  logger?: Logger;
  /** Optional WebSocket factory for real-time subscriptions */
  webSocketFactory?: WebSocketFactory;
  /** Optional plugins to extend functionality */
  plugins?: Plugin[];
  /**
   * Watcher configuration (all enabled by default)
   * - Omit to use defaults (enabled)
   * - Set `disabled: true` to disable
   * - Provide options to customize behavior
   */
  watchers?: {
    /** Mint quote watcher (enabled by default) */mintQuoteWatcher?: {
      disabled?: boolean;
      watchExistingPendingOnStart?: boolean;
    }; /** Proof state watcher (enabled by default) */
    proofStateWatcher?: {
      disabled?: boolean; /** When enabled, scan existing inflight proofs on start (default: true) */
      watchExistingInflightOnStart?: boolean;
    };
  };
  /**
   * Processor configuration (all enabled by default)
   * - Omit to use defaults (enabled)
   * - Set `disabled: true` to disable
   * - Provide options to customize behavior
   */
  processors?: {
    /** Mint quote processor (enabled by default) */mintQuoteProcessor?: {
      disabled?: boolean;
      processIntervalMs?: number;
      maxRetries?: number;
      baseRetryDelayMs?: number;
      initialEnqueueDelayMs?: number;
    };
  };
  /**
   * Subscription transport configuration
   * Controls the hybrid WebSocket + polling behavior
   */
  subscriptions?: {
    /**
     * Polling interval (ms) while WebSocket is connected.
     * Only used as backup to catch silent WS failures.
     * Default: 20000 (20 seconds)
     */
    slowPollingIntervalMs?: number;
    /**
     * Polling interval (ms) after WebSocket fails.
     * Used as primary transport when WS is unavailable.
     * Default: 5000 (5 seconds)
     */
    fastPollingIntervalMs?: number;
  };
}
/**
 * Initializes and configures a new Coco Cashu manager instance
 * @param config - Configuration options including repositories, seed, and optional features
 * @returns A fully initialized Manager instance
 */
declare function initializeCoco(config: CocoConfig): Promise<Manager>;
declare class Manager {
  readonly mint: MintApi;
  readonly wallet: WalletApi;
  readonly quotes: QuotesApi;
  readonly keyring: KeyRingApi;
  readonly subscription: SubscriptionApi;
  readonly history: HistoryApi;
  readonly send: SendApi;
  readonly ext: PluginExtensions;
  private mintService;
  private walletService;
  private proofService;
  private walletRestoreService;
  private keyRingService;
  private eventBus;
  private logger;
  readonly subscriptions: SubscriptionManager;
  private mintQuoteService;
  private mintQuoteWatcher?;
  private mintQuoteProcessor?;
  private mintQuoteRepository;
  private proofStateWatcher?;
  private meltQuoteService;
  private historyService;
  private seedService;
  private counterService;
  private transactionService;
  private paymentRequestService;
  private sendOperationService;
  private sendOperationRepository;
  private meltOperationService;
  private meltOperationRepository;
  private proofRepository;
  private readonly pluginHost;
  private subscriptionsPaused;
  private originalWatcherConfig;
  private originalProcessorConfig;
  private readonly mintRequestProvider;
  private readonly mintAdapter;
  constructor(repositories: Repositories, seedGetter: () => Promise<Uint8Array>, logger?: Logger, webSocketFactory?: WebSocketFactory, plugins?: Plugin[], watchers?: CocoConfig['watchers'], processors?: CocoConfig['processors'], subscriptions?: CocoConfig['subscriptions']);
  on<E extends keyof CoreEvents>(event: E, handler: (payload: CoreEvents[E]) => void | Promise<void>): () => void;
  once<E extends keyof CoreEvents>(event: E, handler: (payload: CoreEvents[E]) => void | Promise<void>): () => void;
  use(plugin: Plugin): void;
  /**
   * Initialize the plugin system.
   * This is called automatically by `initializeCoco()`.
   * Only call this directly if you instantiate Manager without using the factory.
   */
  initPlugins(): Promise<void>;
  dispose(): Promise<void>;
  off<E extends keyof CoreEvents>(event: E, handler: (payload: CoreEvents[E]) => void | Promise<void>): void;
  enableMintQuoteWatcher(options?: {
    watchExistingPendingOnStart?: boolean;
  }): Promise<void>;
  disableMintQuoteWatcher(): Promise<void>;
  enableMintQuoteProcessor(options?: {
    processIntervalMs?: number;
    maxRetries?: number;
    baseRetryDelayMs?: number;
    initialEnqueueDelayMs?: number;
  }): Promise<boolean>;
  disableMintQuoteProcessor(): Promise<void>;
  waitForMintQuoteProcessor(): Promise<void>;
  enableProofStateWatcher(options?: {
    watchExistingInflightOnStart?: boolean;
  }): Promise<void>;
  disableProofStateWatcher(): Promise<void>;
  recoverPendingSendOperations(): Promise<void>;
  recoverPendingMeltOperations(): Promise<void>;
  pauseSubscriptions(): Promise<void>;
  resumeSubscriptions(): Promise<void>;
  private getChildLogger;
  private createEventBus;
  private createSubscriptionManager;
  private buildCoreServices;
  private buildApis;
}
//#endregion
//#region plugins/PluginHost.d.ts
declare class PluginHost {
  private readonly plugins;
  private readonly cleanups;
  private readonly extensions;
  private services?;
  private initialized;
  private readyPhase;
  use(plugin: Plugin): void;
  init(services: ServiceMap): Promise<void>;
  ready(): Promise<void>;
  dispose(): Promise<void>;
  /**
   * Get all registered plugin extensions
   */
  getExtensions(): Record<string, unknown>;
  private runInit;
  private runReady;
  private createContext;
}
//#endregion
export { Cleanup, CleanupFn, CocoConfig, ConsoleLogger, type CoreProof, Counter, CounterRepository, CounterService, ExecutingSendOperation, ExtensionRegistrationError, FinalizedSendOperation, HistoryApi, HistoryEntry, HistoryRepository, HistoryService, HttpResponseError, type HttpTransport, type InbandTransport, InitSendOperation, KeyRingApi, KeyRingRepository, KeyRingService, Keypair, Keyset, KeysetRepository, KeysetSyncError, type Logger, Manager, MeltHistoryEntry, MeltMethod, MeltMethodData, MeltOperation, MeltOperationRepository, MeltOperationService, MeltOperationState, MeltQuote, MeltQuoteRepository, MeltQuoteService, MemoryCounterRepository, MemoryHistoryRepository, MemoryKeyRingRepository, MemoryKeysetRepository, MemoryMeltOperationRepository, MemoryMeltQuoteRepository, MemoryMintQuoteRepository, MemoryMintRepository, MemoryProofRepository, MemoryRepositories, MemorySendOperationRepository, Mint, MintApi, MintFetchError, MintHistoryEntry, MintOperationError, MintQuote, MintQuoteProcessor, MintQuoteProcessorOptions, MintQuoteRepository, MintQuoteService, MintQuoteWatcherOptions, MintQuoteWatcherService, MintRepository, MintService, NetworkError, OperationInProgressError, type ParsedPaymentRequest, PaymentRequestError, PaymentRequestService, PaymentRequestTransaction, PendingSendOperation, Plugin, PluginContext, PluginExtensions, PluginHost, PreparedOrLaterOperation, PreparedSendOperation, ProofOperationError, ProofRepository, ProofService, type ProofState, ProofStateWatcherOptions, ProofStateWatcherService, ProofValidationError, QuotesApi, ReceiveHistoryEntry, Repositories, RepositoryTransactionScope, RolledBackSendOperation, RollingBackSendOperation, SeedService, SendApi, SendHistoryEntry, SendHistoryState, SendOperation, SendOperationRepository, SendOperationService, SendOperationState, ServiceKey, ServiceMap, SubscriptionApi, SubscriptionManager, TerminalSendOperation, TokenValidationError, TransactionService, type Transport, UnknownMintError, WalletApi, WalletRestoreService, WalletService, type WebSocketFactory, type WebSocketLike, WsConnectionManager, createSendOperation, getDecodedToken, getEncodedToken, getKeepProofSecrets, getSendProofSecrets, hasPreparedData, initializeCoco, isExecutingOperation, isFinalizedOperation, isInitOperation, isPendingOperation, isPreparedOperation, isRolledBackOperation, isRollingBackOperation, isTerminalOperation, normalizeMintUrl };