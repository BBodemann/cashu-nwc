import { Mint, OutputData, PaymentRequest, PaymentRequestTransportType, Wallet, getDecodedToken, getDecodedToken as getDecodedToken$1, getEncodedToken, getEncodedToken as getEncodedToken$1, getTokenMetadata, hashToCurve } from "@cashu/cashu-ts";
import { schnorr } from "@noble/curves/secp256k1.js";
import { bytesToHex } from "@noble/curves/utils.js";
import { sha256 } from "@noble/hashes/sha2.js";
import { HDKey } from "@scure/bip32";

//#region events/EventBus.ts
var EventBus = class {
	listeners = /* @__PURE__ */ new Map();
	constructor(options = {}) {
		this.options = options;
	}
	on(event, handler) {
		let set = this.listeners.get(event);
		if (!set) {
			set = /* @__PURE__ */ new Set();
			this.listeners.set(event, set);
		}
		set.add(handler);
		return () => this.off(event, handler);
	}
	once(event, handler) {
		const wrapped = async (payload) => {
			this.off(event, wrapped);
			await handler(payload);
		};
		return this.on(event, wrapped);
	}
	off(event, handler) {
		const set = this.listeners.get(event);
		if (!set) return;
		set.delete(handler);
		if (set.size === 0) this.listeners.delete(event);
	}
	async emit(event, payload, options) {
		const set = this.listeners.get(event);
		if (!set || set.size === 0) return;
		const handlers = Array.from(set);
		const effectiveThrow = options?.throwOnError ?? this.options.throwOnError ?? false;
		if ((this.options.concurrency ?? "sequential") === "parallel") {
			const results = await Promise.allSettled(handlers.map((h) => h(payload)));
			const errors = [];
			for (const r of results) if (r.status === "rejected") {
				errors.push(r.reason);
				if (this.options.onError) await this.options.onError({
					event,
					payload,
					error: r.reason
				});
			}
			if (errors.length && effectiveThrow) throw new AggregateError(errors, `Event "${String(event)}" had ${errors.length} handler error(s)`);
			return;
		}
		const collectedErrors = [];
		for (const handler of handlers) try {
			await handler(payload);
		} catch (error) {
			if (this.options.onError) await this.options.onError({
				event,
				payload,
				error
			});
			if (effectiveThrow && options?.failFast) throw error;
			if (effectiveThrow) collectedErrors.push(error);
		}
		if (collectedErrors.length && effectiveThrow) throw new AggregateError(collectedErrors, `Event "${String(event)}" had ${collectedErrors.length} handler error(s)`);
	}
};

//#endregion
//#region models/Error.ts
var UnknownMintError = class extends Error {
	constructor(message) {
		super(message);
		this.name = "UnknownMintError";
	}
};
var MintFetchError = class extends Error {
	mintUrl;
	constructor(mintUrl, message, cause) {
		super(message ?? `Failed to fetch mint ${mintUrl}`);
		this.name = "MintFetchError";
		this.mintUrl = mintUrl;
		this.cause = cause;
	}
};
var KeysetSyncError = class extends Error {
	mintUrl;
	keysetId;
	constructor(mintUrl, keysetId, message, cause) {
		super(message ?? `Failed to sync keyset ${keysetId} for mint ${mintUrl}`);
		this.name = "KeysetSyncError";
		this.mintUrl = mintUrl;
		this.keysetId = keysetId;
		this.cause = cause;
	}
};
var ProofValidationError = class extends Error {
	constructor(message) {
		super(message);
		this.name = "ProofValidationError";
	}
};
var TokenValidationError = class extends Error {
	constructor(message) {
		super(message);
		this.name = "TokenValidationError";
	}
};
var ProofOperationError = class extends Error {
	mintUrl;
	keysetId;
	constructor(mintUrl, message, keysetId, cause) {
		super(message ?? `Proof operation failed for mint ${mintUrl}${keysetId ? ` keyset ${keysetId}` : ""}`);
		this.name = "ProofOperationError";
		this.mintUrl = mintUrl;
		this.keysetId = keysetId;
		this.cause = cause;
	}
};
/**
* This error is thrown when a HTTP response is not 2XX nor a protocol error.
*/
var HttpResponseError = class HttpResponseError extends Error {
	status;
	constructor(message, status) {
		super(message);
		this.status = status;
		this.name = "HttpResponseError";
		Object.setPrototypeOf(this, HttpResponseError.prototype);
	}
};
/**
* This error is thrown when a network request fails.
*/
var NetworkError = class NetworkError extends Error {
	constructor(message) {
		super(message);
		this.name = "NetworkError";
		Object.setPrototypeOf(this, NetworkError.prototype);
	}
};
/**
* This error is thrown when a protocol error occurs per Cashu NUT-00 error codes.
*/
var MintOperationError = class MintOperationError extends HttpResponseError {
	code;
	constructor(code, detail) {
		super(detail || "Unknown mint operation error", 400);
		this.code = code;
		this.name = "MintOperationError";
		Object.setPrototypeOf(this, MintOperationError.prototype);
	}
};
/**
* This error is thrown when a payment request is invalid or cannot be processed.
*/
var PaymentRequestError = class extends Error {
	constructor(message, cause) {
		super(message);
		this.name = "PaymentRequestError";
		this.cause = cause;
	}
};
/**
* This error is thrown when attempting to modify an operation that is already in progress.
*/
var OperationInProgressError = class extends Error {
	operationId;
	constructor(operationId) {
		super(`Operation ${operationId} is already in progress`);
		this.name = "OperationInProgressError";
		this.operationId = operationId;
	}
};

//#endregion
//#region utils.ts
/**
* Convert a Uint8Array to hex string
*/
function uint8ArrayToHex(arr) {
	return Array.from(arr).map((b) => b.toString(16).padStart(2, "0")).join("");
}
/**
* Convert a hex string to Uint8Array
*/
function hexToUint8Array(hex) {
	const bytes = new Uint8Array(hex.length / 2);
	for (let i = 0; i < hex.length; i += 2) bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
	return bytes;
}
/**
* Serialize a single OutputData to JSON-safe format
*/
function serializeOutput(output) {
	return {
		blindedMessage: {
			amount: output.blindedMessage.amount,
			id: output.blindedMessage.id,
			B_: output.blindedMessage.B_
		},
		blindingFactor: output.blindingFactor.toString(16),
		secret: uint8ArrayToHex(output.secret)
	};
}
/**
* Deserialize a single SerializedOutput back to OutputData
*/
function deserializeOutput(serialized) {
	return new OutputData({
		amount: serialized.blindedMessage.amount,
		id: serialized.blindedMessage.id,
		B_: serialized.blindedMessage.B_
	}, BigInt("0x" + serialized.blindingFactor), hexToUint8Array(serialized.secret));
}
/**
* Serialize OutputData arrays for keep and send to JSON-safe format
*/
function serializeOutputData(data) {
	return {
		keep: data.keep.map(serializeOutput),
		send: data.send.map(serializeOutput)
	};
}
/**
* Deserialize SerializedOutputData back to OutputData arrays
*/
function deserializeOutputData(serialized) {
	return {
		keep: serialized.keep.map(deserializeOutput),
		send: serialized.send.map(deserializeOutput)
	};
}
/**
* Decode a hex-encoded secret to its string representation (matching proof.secret)
*/
function decodeSecretHex(hexSecret) {
	const bytes = hexToUint8Array(hexSecret);
	return new TextDecoder().decode(bytes);
}
/**
* Extract secrets from serialized output data.
* Returns the string form of secrets (matching proof.secret in Proof objects).
*/
function getSecretsFromSerializedOutputData(serialized) {
	return {
		keepSecrets: serialized.keep.map((o) => decodeSecretHex(o.secret)),
		sendSecrets: serialized.send.map((o) => decodeSecretHex(o.secret))
	};
}
function mapProofToCoreProof(mintUrl, state, proofs, options) {
	return proofs.map((p) => ({
		...p,
		mintUrl,
		state,
		createdByOperationId: options?.createdByOperationId
	}));
}
function assertNonNegativeInteger(paramName, value, logger) {
	if (!Number.isFinite(value) || !Number.isInteger(value) || value < 0) {
		logger?.warn("Invalid numeric value", { [paramName]: value });
		throw new Error(`${paramName} must be a non-negative integer`);
	}
}
function toBase64Url(bytes) {
	let base64;
	const Buf = globalThis.Buffer;
	if (typeof Buf !== "undefined") base64 = Buf.from(bytes).toString("base64");
	else if (typeof btoa !== "undefined") {
		let bin = "";
		for (const b of bytes) bin += String.fromCharCode(b);
		base64 = btoa(bin);
	}
	if (!base64) return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
	return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function generateSubId() {
	const length = 16;
	const bytes = new Uint8Array(length);
	const cryptoObj = globalThis.crypto;
	if (cryptoObj && typeof cryptoObj.getRandomValues === "function") cryptoObj.getRandomValues(bytes);
	else for (let i = 0; i < length; i++) bytes[i] = Math.floor(Math.random() * 256);
	return toBase64Url(bytes);
}
/**
* Compute the Y point (hex, compressed) for a single secret using hash-to-curve.
*/
function computeYHexForSecrets(secrets) {
	const encoder = new TextEncoder();
	return secrets.map((secret) => hashToCurve(encoder.encode(secret)).toHex(true));
}
/**
* Build bidirectional maps between secrets and their Y points (hex) using hash-to-curve.
* - yHexBySecret: secret -> Y hex
* - secretByYHex: Y hex -> secret
*/
function buildYHexMapsForSecrets(secrets) {
	const yHexBySecret = /* @__PURE__ */ new Map();
	const secretByYHex = /* @__PURE__ */ new Map();
	const yHexes = computeYHexForSecrets(secrets);
	for (let i = 0; i < secrets.length; i++) {
		const secret = secrets[i];
		const yHex = yHexes[i];
		if (!secret || !yHex) continue;
		yHexBySecret.set(secret, yHex);
		secretByYHex.set(yHex, secret);
	}
	return {
		yHexBySecret,
		secretByYHex
	};
}
/**
* Normalize a mint URL to prevent duplicates from variations like:
* - Trailing slashes: https://mint.com/ -> https://mint.com
* - Case differences in hostname: https://MINT.com -> https://mint.com
* - Default ports: https://mint.com:443 -> https://mint.com
* - Redundant path segments: https://mint.com/./path -> https://mint.com/path
*/
function normalizeMintUrl(mintUrl) {
	const url = new URL(mintUrl);
	if (url.protocol === "https:" && url.port === "443" || url.protocol === "http:" && url.port === "80") url.port = "";
	let normalized = `${url.protocol}//${url.host}${url.pathname}`;
	if (normalized.endsWith("/") && url.pathname !== "/") normalized = normalized.slice(0, -1);
	else if (url.pathname === "/") normalized = `${url.protocol}//${url.host}`;
	return normalized;
}

//#endregion
//#region services/CounterService.ts
var CounterService = class {
	counterRepo;
	eventBus;
	logger;
	constructor(counterRepo, logger, eventBus) {
		this.counterRepo = counterRepo;
		this.logger = logger;
		this.eventBus = eventBus;
	}
	async getCounter(mintUrl, keysetId) {
		const counter = await this.counterRepo.getCounter(mintUrl, keysetId);
		if (!counter) {
			const newCounter = {
				mintUrl,
				keysetId,
				counter: 0
			};
			await this.counterRepo.setCounter(mintUrl, keysetId, 0);
			this.logger?.debug("Initialized counter", {
				mintUrl,
				keysetId
			});
			return newCounter;
		}
		return counter;
	}
	async incrementCounter(mintUrl, keysetId, n) {
		assertNonNegativeInteger("n", n, this.logger);
		const current = await this.getCounter(mintUrl, keysetId);
		const updatedValue = current.counter + n;
		await this.counterRepo.setCounter(mintUrl, keysetId, updatedValue);
		const updated = {
			...current,
			counter: updatedValue
		};
		await this.eventBus?.emit("counter:updated", updated);
		this.logger?.info("Counter incremented", {
			mintUrl,
			keysetId,
			counter: updatedValue
		});
		return updated;
	}
	async overwriteCounter(mintUrl, keysetId, counter) {
		assertNonNegativeInteger("counter", counter, this.logger);
		await this.counterRepo.setCounter(mintUrl, keysetId, counter);
		const updated = {
			mintUrl,
			keysetId,
			counter
		};
		await this.eventBus?.emit("counter:updated", updated);
		this.logger?.info("Counter overwritten", {
			mintUrl,
			keysetId,
			counter
		});
		return updated;
	}
};

//#endregion
//#region services/KeyRingService.ts
var KeyRingService = class {
	logger;
	keyRingRepository;
	seedService;
	constructor(keyRingRepository, seedService, logger) {
		this.keyRingRepository = keyRingRepository;
		this.logger = logger;
		this.seedService = seedService;
	}
	async generateNewKeyPair(options) {
		this.logger?.debug("Generating new key pair");
		const nextDerivationIndex = await this.keyRingRepository.getLastDerivationIndex() + 1;
		const seed = await this.seedService.getSeed();
		const hdKey = HDKey.fromMasterSeed(seed);
		const derivationPath = `m/129373'/10'/0'/0'/${nextDerivationIndex}`;
		const { privateKey: secretKey } = hdKey.derive(derivationPath);
		if (!secretKey) throw new Error("Failed to derive secret key");
		const publicKeyHex = this.getPublicKeyHex(secretKey);
		await this.keyRingRepository.setPersistedKeyPair({
			publicKeyHex,
			secretKey,
			derivationIndex: nextDerivationIndex
		});
		this.logger?.debug("New key pair generated", { publicKeyHex });
		if (options?.dumpSecretKey) return {
			publicKeyHex,
			secretKey
		};
		return { publicKeyHex };
	}
	async addKeyPair(secretKey) {
		this.logger?.debug("Adding key pair with secret key...");
		if (secretKey.length !== 32) throw new Error("Secret key must be exactly 32 bytes");
		const publicKeyHex = this.getPublicKeyHex(secretKey);
		await this.keyRingRepository.setPersistedKeyPair({
			publicKeyHex,
			secretKey
		});
		this.logger?.debug("Key pair added", { publicKeyHex });
		return {
			publicKeyHex,
			secretKey
		};
	}
	async removeKeyPair(publicKey) {
		this.logger?.debug("Removing key pair", { publicKey });
		await this.keyRingRepository.deletePersistedKeyPair(publicKey);
		this.logger?.debug("Key pair removed", { publicKey });
	}
	async getKeyPair(publicKey) {
		if (!publicKey || typeof publicKey !== "string") throw new Error("Public key is required and must be a string");
		return this.keyRingRepository.getPersistedKeyPair(publicKey);
	}
	async getLatestKeyPair() {
		return this.keyRingRepository.getLatestKeyPair();
	}
	async getAllKeyPairs() {
		return this.keyRingRepository.getAllPersistedKeyPairs();
	}
	async signProof(proof, publicKey) {
		this.logger?.debug("Signing proof", {
			proof,
			publicKey
		});
		if (!proof.secret || typeof proof.secret !== "string") throw new Error("Proof secret is required and must be a string");
		const keyPair = await this.keyRingRepository.getPersistedKeyPair(publicKey);
		if (!keyPair) {
			const publicKeyPreview = publicKey.substring(0, 8);
			this.logger?.error("Key pair not found", { publicKey });
			throw new Error(`Key pair not found for public key: ${publicKeyPreview}...`);
		}
		const message = new TextEncoder().encode(proof.secret);
		const signature = schnorr.sign(sha256(message), keyPair.secretKey);
		const signedProof = {
			...proof,
			witness: JSON.stringify({ signatures: [bytesToHex(signature)] })
		};
		this.logger?.debug("Proof signed successfully", { publicKey });
		return signedProof;
	}
	/**
	* Converts a secret key to its corresponding public key in SEC1 compressed format.
	* Note: schnorr.getPublicKey() returns a 32-byte x-only public key (BIP340).
	* We prepend '02' to create a 33-byte SEC1 compressed format as expected by Cashu.
	*/
	getPublicKeyHex(secretKey) {
		return "02" + bytesToHex(schnorr.getPublicKey(secretKey));
	}
};

//#endregion
//#region services/MintService.ts
const MINT_REFRESH_TTL_S = 300;
var MintService = class {
	mintRepo;
	keysetRepo;
	mintAdapter;
	eventBus;
	logger;
	constructor(mintRepo, keysetRepo, mintAdapter, logger, eventBus) {
		this.mintRepo = mintRepo;
		this.keysetRepo = keysetRepo;
		this.mintAdapter = mintAdapter;
		this.logger = logger;
		this.eventBus = eventBus;
	}
	/**
	* Add a new mint by URL, running a single update cycle to fetch info & keysets.
	* If the mint already exists, it ensures it is updated.
	* New mints are added as untrusted by default unless explicitly specified.
	*
	* @param mintUrl - The URL of the mint to add
	* @param options - Optional configuration
	* @param options.trusted - Whether to add the mint as trusted (default: false)
	*/
	async addMintByUrl(mintUrl, options) {
		mintUrl = normalizeMintUrl(mintUrl);
		const trusted = options?.trusted ?? false;
		this.logger?.info("Adding mint by URL", {
			mintUrl,
			trusted
		});
		const exists = await this.mintRepo.getMintByUrl(mintUrl).catch(() => null);
		if (exists) {
			if (options?.trusted !== void 0 && exists.trusted !== options.trusted) {
				await this.mintRepo.setMintTrusted(mintUrl, options.trusted);
				this.logger?.info("Updated mint trust status", {
					mintUrl,
					trusted: options.trusted
				});
				if (options.trusted) await this.eventBus?.emit("mint:trusted", { mintUrl });
				else await this.eventBus?.emit("mint:untrusted", { mintUrl });
				const updated = await this.ensureUpdatedMint(mintUrl);
				await this.eventBus?.emit("mint:updated", updated);
				return updated;
			}
			return this.ensureUpdatedMint(mintUrl);
		}
		const now = Math.floor(Date.now() / 1e3);
		const newMint = {
			mintUrl,
			name: mintUrl,
			mintInfo: {},
			trusted,
			createdAt: now,
			updatedAt: 0
		};
		const added = await this.updateMint(newMint);
		await this.eventBus?.emit("mint:added", added);
		this.logger?.info("Mint added", {
			mintUrl,
			trusted
		});
		return added;
	}
	async updateMintData(mintUrl) {
		mintUrl = normalizeMintUrl(mintUrl);
		const mint = await this.mintRepo.getMintByUrl(mintUrl).catch(() => null);
		if (!mint) {
			const now = Math.floor(Date.now() / 1e3);
			const newMint = {
				mintUrl,
				name: mintUrl,
				mintInfo: {},
				trusted: false,
				createdAt: now,
				updatedAt: 0
			};
			return this.updateMint(newMint);
		}
		return this.updateMint(mint);
	}
	async isTrustedMint(mintUrl) {
		return await this.mintRepo.isTrustedMint(normalizeMintUrl(mintUrl));
	}
	async ensureUpdatedMint(mintUrl) {
		mintUrl = normalizeMintUrl(mintUrl);
		let mint = await this.mintRepo.getMintByUrl(mintUrl).catch(() => null);
		if (!mint) {
			const now = Math.floor(Date.now() / 1e3);
			mint = {
				mintUrl,
				name: mintUrl,
				mintInfo: {},
				trusted: false,
				createdAt: now,
				updatedAt: 0
			};
		}
		const now = Math.floor(Date.now() / 1e3);
		if (mint.updatedAt < now - MINT_REFRESH_TTL_S) {
			this.logger?.debug("Refreshing stale mint", { mintUrl });
			const updated = await this.updateMint(mint);
			await this.eventBus?.emit("mint:updated", updated);
			return updated;
		}
		const keysets = await this.keysetRepo.getKeysetsByMintUrl(mint.mintUrl);
		return {
			mint,
			keysets
		};
	}
	async deleteMint(mintUrl) {
		mintUrl = normalizeMintUrl(mintUrl);
		if (!await this.mintRepo.getMintByUrl(mintUrl).catch(() => null)) return;
		const keysets = await this.keysetRepo.getKeysetsByMintUrl(mintUrl);
		await Promise.all(keysets.map((ks) => this.keysetRepo.deleteKeyset(mintUrl, ks.id)));
		await this.mintRepo.deleteMint(mintUrl);
	}
	async getMintInfo(mintUrl) {
		const { mint } = await this.ensureUpdatedMint(normalizeMintUrl(mintUrl));
		return mint.mintInfo;
	}
	async getAllMints() {
		return await this.mintRepo.getAllMints();
	}
	async getAllTrustedMints() {
		return await this.mintRepo.getAllTrustedMints();
	}
	async trustMint(mintUrl) {
		mintUrl = normalizeMintUrl(mintUrl);
		this.logger?.info("Trusting mint", { mintUrl });
		await this.mintRepo.setMintTrusted(mintUrl, true);
		await this.eventBus?.emit("mint:trusted", { mintUrl });
		await this.eventBus?.emit("mint:updated", await this.ensureUpdatedMint(mintUrl));
	}
	async untrustMint(mintUrl) {
		mintUrl = normalizeMintUrl(mintUrl);
		this.logger?.info("Untrusting mint", { mintUrl });
		await this.mintRepo.setMintTrusted(mintUrl, false);
		await this.eventBus?.emit("mint:untrusted", { mintUrl });
		await this.eventBus?.emit("mint:updated", await this.ensureUpdatedMint(mintUrl));
	}
	async updateMint(mint) {
		let mintInfo;
		try {
			this.logger?.debug("Fetching mint info", { mintUrl: mint.mintUrl });
			mintInfo = await this.mintAdapter.fetchMintInfo(mint.mintUrl);
		} catch (err) {
			this.logger?.error("Failed to fetch mint info", {
				mintUrl: mint.mintUrl,
				err
			});
			throw new MintFetchError(mint.mintUrl, void 0, err);
		}
		let keysets;
		try {
			this.logger?.debug("Fetching keysets", { mintUrl: mint.mintUrl });
			({keysets} = await this.mintAdapter.fetchKeysets(mint.mintUrl));
		} catch (err) {
			this.logger?.error("Failed to fetch keysets", {
				mintUrl: mint.mintUrl,
				err
			});
			throw new MintFetchError(mint.mintUrl, "Failed to fetch keysets", err);
		}
		await Promise.all(keysets.map(async (ks) => {
			if (await this.keysetRepo.getKeysetById(mint.mintUrl, ks.id)) {
				const keysetModel = {
					mintUrl: mint.mintUrl,
					id: ks.id,
					unit: ks.unit,
					active: ks.active,
					feePpk: ks.input_fee_ppk || 0
				};
				return this.keysetRepo.updateKeyset(keysetModel);
			} else try {
				const keysRes = await this.mintAdapter.fetchKeysForId(mint.mintUrl, ks.id);
				const keypairs = Object.fromEntries(Object.entries(keysRes).map(([k, v]) => [Number(k), v]));
				return this.keysetRepo.addKeyset({
					mintUrl: mint.mintUrl,
					id: ks.id,
					unit: ks.unit,
					keypairs,
					active: ks.active,
					feePpk: ks.input_fee_ppk || 0
				});
			} catch (err) {
				this.logger?.error("Failed to sync keyset", {
					mintUrl: mint.mintUrl,
					keysetId: ks.id,
					err
				});
				throw new KeysetSyncError(mint.mintUrl, ks.id, void 0, err);
			}
		}));
		mint.mintInfo = mintInfo;
		mint.updatedAt = Math.floor(Date.now() / 1e3);
		await this.mintRepo.addOrUpdateMint(mint);
		const repoKeysets = await this.keysetRepo.getKeysetsByMintUrl(mint.mintUrl);
		this.logger?.info("Mint updated", {
			mintUrl: mint.mintUrl,
			keysets: repoKeysets.length
		});
		return {
			mint,
			keysets: repoKeysets
		};
	}
};

//#endregion
//#region services/WalletService.ts
const DEFAULT_UNIT = "sat";
var WalletService = class {
	walletCache = /* @__PURE__ */ new Map();
	CACHE_TTL = 300 * 1e3;
	mintService;
	seedService;
	inFlight = /* @__PURE__ */ new Map();
	logger;
	requestProvider;
	constructor(mintService, seedService, requestProvider, logger) {
		this.mintService = mintService;
		this.seedService = seedService;
		this.requestProvider = requestProvider;
		this.logger = logger;
	}
	async getWallet(mintUrl) {
		if (!mintUrl || mintUrl.trim().length === 0) throw new Error("mintUrl is required");
		const cached = this.walletCache.get(mintUrl);
		if (cached && Date.now() - cached.lastCheck < this.CACHE_TTL) {
			this.logger?.debug("Wallet served from cache", { mintUrl });
			return cached.wallet;
		}
		const existing = this.inFlight.get(mintUrl);
		if (existing) return existing;
		const promise = this.buildWallet(mintUrl).finally(() => {
			this.inFlight.delete(mintUrl);
		});
		this.inFlight.set(mintUrl, promise);
		return promise;
	}
	async getWalletWithActiveKeysetId(mintUrl) {
		const wallet = await this.getWallet(mintUrl);
		const keyset = wallet.keyChain.getCheapestKeyset();
		const mintKeys = keyset.toMintKeys();
		if (mintKeys === null) throw new Error("MintKeys is null. Cannot return a valid response.");
		return {
			wallet,
			keysetId: keyset.id,
			keyset: keyset.toMintKeyset(),
			keys: mintKeys
		};
	}
	/**
	* Clear cached wallet for a specific mint URL
	*/
	clearCache(mintUrl) {
		this.walletCache.delete(mintUrl);
		this.logger?.debug("Wallet cache cleared", { mintUrl });
	}
	/**
	* Clear all cached wallets
	*/
	clearAllCaches() {
		this.walletCache.clear();
		this.logger?.debug("All wallet caches cleared");
	}
	/**
	* Force refresh mint data and get fresh wallet
	*/
	async refreshWallet(mintUrl) {
		this.clearCache(mintUrl);
		this.inFlight.delete(mintUrl);
		await this.mintService.updateMintData(mintUrl);
		return this.getWallet(mintUrl);
	}
	async buildWallet(mintUrl) {
		const { mint, keysets } = await this.mintService.ensureUpdatedMint(mintUrl);
		const validKeysets = keysets.filter((keyset) => keyset.keypairs && Object.keys(keyset.keypairs).length > 0 && keyset.unit === DEFAULT_UNIT);
		if (validKeysets.length === 0) throw new Error(`No valid keysets found for mint ${mintUrl}`);
		const keysetCache = validKeysets.map((keyset) => ({
			id: keyset.id,
			unit: keyset.unit,
			active: keyset.active,
			input_fee_ppk: keyset.feePpk,
			keys: keyset.keypairs
		}));
		const cache = {
			mintUrl: mint.mintUrl,
			unit: DEFAULT_UNIT,
			keysets: keysetCache
		};
		const seed = await this.seedService.getSeed();
		const wallet = new Wallet(new Mint(mintUrl, { customRequest: this.requestProvider.getRequestFn(mintUrl) }), {
			unit: DEFAULT_UNIT,
			logger: this.logger && this.logger.child ? this.logger.child({ module: "Wallet" }) : void 0,
			bip39seed: seed
		});
		wallet.loadMintFromCache(mint.mintInfo, cache);
		this.walletCache.set(mintUrl, {
			wallet,
			lastCheck: Date.now()
		});
		this.logger?.info("Wallet built", {
			mintUrl,
			keysetCount: validKeysets.length
		});
		return wallet;
	}
};

//#endregion
//#region services/ProofService.ts
var ProofService = class {
	counterService;
	proofRepository;
	eventBus;
	walletService;
	mintService;
	keyRingService;
	seedService;
	logger;
	constructor(counterService, proofRepository, walletService, mintService, keyRingService, seedService, logger, eventBus) {
		this.counterService = counterService;
		this.walletService = walletService;
		this.mintService = mintService;
		this.keyRingService = keyRingService;
		this.proofRepository = proofRepository;
		this.seedService = seedService;
		this.logger = logger;
		this.eventBus = eventBus;
	}
	/**
	* Calculates the send amount including receiver fees.
	* This is used when the sender pays fees for the receiver.
	*/
	async calculateSendAmountWithFees(mintUrl, sendAmount) {
		const { wallet, keys, keysetId } = await this.walletService.getWalletWithActiveKeysetId(mintUrl);
		let denominations = splitAmount(sendAmount, keys.keys);
		let receiveFee = wallet.getFeesForKeyset(denominations.length, keysetId);
		let receiveFeeAmounts = splitAmount(receiveFee, keys.keys);
		while (wallet.getFeesForKeyset(denominations.length + receiveFeeAmounts.length, keysetId) > receiveFee) {
			receiveFee++;
			receiveFeeAmounts = splitAmount(receiveFee, keys.keys);
		}
		return sendAmount + receiveFee;
	}
	async checkInflightProofs() {
		const inflightProofs = await this.proofRepository.getInflightProofs();
		this.logger?.debug("Checking inflight proofs", { count: inflightProofs.length });
		if (inflightProofs.length === 0) return;
		const batchedByMint = {};
		for (const proof of inflightProofs) {
			const mintUrl = proof.mintUrl;
			if (!mintUrl) continue;
			(batchedByMint[mintUrl] ?? (batchedByMint[mintUrl] = [])).push(proof);
		}
		const mintUrls = Object.keys(batchedByMint);
		for (const mintUrl of mintUrls) {
			const proofs = batchedByMint[mintUrl];
			if (!proofs || proofs.length === 0) continue;
			this.logger?.debug("Checking inflight proofs for mint", {
				mintUrl,
				count: proofs.length
			});
			try {
				const { wallet } = await this.walletService.getWalletWithActiveKeysetId(mintUrl);
				const proofStates = await wallet.checkProofsStates(proofs);
				if (!Array.isArray(proofStates) || proofStates.length !== proofs.length) {
					this.logger?.warn("Malformed proof state check response", {
						mintUrl,
						expected: proofs.length,
						received: proofStates?.length ?? 0
					});
					continue;
				}
				const spentSecrets = proofStates.reduce((acc, state, index) => {
					if (state?.state === "SPENT" && proofs[index]?.secret) acc.push(proofs[index].secret);
					return acc;
				}, []);
				if (spentSecrets.length > 0) {
					await this.setProofState(mintUrl, spentSecrets, "spent");
					this.logger?.info("Marked inflight proofs as spent after check", {
						mintUrl,
						count: spentSecrets.length
					});
				}
			} catch (error) {
				this.logger?.warn("Failed to check inflight proofs for mint", {
					mintUrl,
					error
				});
			}
		}
	}
	async createOutputsAndIncrementCounters(mintUrl, amount, options) {
		if (!mintUrl || mintUrl.trim().length === 0) throw new ProofValidationError("mintUrl is required");
		if (!Number.isFinite(amount.keep) || !Number.isFinite(amount.send) || amount.keep < 0 || amount.send < 0) return {
			keep: [],
			send: [],
			sendAmount: 0,
			keepAmount: 0
		};
		const { wallet, keys, keysetId } = await this.walletService.getWalletWithActiveKeysetId(mintUrl);
		const seed = await this.seedService.getSeed();
		const currentCounter = await this.counterService.getCounter(mintUrl, keys.id);
		const data = {
			keep: [],
			send: []
		};
		let sendAmount = amount.send;
		let keepAmount = amount.keep;
		if (options?.includeFees && amount.send > 0) {
			sendAmount = await this.calculateSendAmountWithFees(mintUrl, amount.send);
			const feeAmount = sendAmount - amount.send;
			keepAmount = Math.max(0, amount.keep - feeAmount);
			this.logger?.debug("Fee calculation for send amount", {
				mintUrl,
				originalSendAmount: amount.send,
				originalKeepAmount: amount.keep,
				feeAmount,
				finalSendAmount: sendAmount,
				adjustedKeepAmount: keepAmount
			});
		}
		if (keepAmount > 0) {
			data.keep = OutputData.createDeterministicData(keepAmount, seed, currentCounter.counter, keys);
			if (data.keep.length > 0) await this.counterService.incrementCounter(mintUrl, keys.id, data.keep.length);
		}
		if (sendAmount > 0) {
			data.send = OutputData.createDeterministicData(sendAmount, seed, currentCounter.counter + data.keep.length, keys);
			if (data.send.length > 0) await this.counterService.incrementCounter(mintUrl, keys.id, data.send.length);
		}
		this.logger?.debug("Deterministic outputs created", {
			mintUrl,
			keysetId: keys.id,
			amount,
			outputs: data.keep.length + data.send.length
		});
		return {
			keep: data.keep,
			send: data.send,
			sendAmount,
			keepAmount
		};
	}
	async saveProofs(mintUrl, proofs) {
		if (!mintUrl || mintUrl.trim().length === 0) throw new ProofValidationError("mintUrl is required");
		if (!Array.isArray(proofs) || proofs.length === 0) return;
		const groupedByKeyset = this.groupProofsByKeysetId(proofs);
		const tasks = Array.from(groupedByKeyset.entries()).map(([keysetId, group]) => (async () => {
			await this.proofRepository.saveProofs(mintUrl, group);
			await this.eventBus?.emit("proofs:saved", {
				mintUrl,
				keysetId,
				proofs: group
			});
			this.logger?.info("Proofs saved", {
				mintUrl,
				keysetId,
				count: group.length
			});
		})().catch((error) => {
			throw {
				keysetId,
				error
			};
		}));
		const failed = (await Promise.allSettled(tasks)).filter((r) => r.status === "rejected");
		if (failed.length > 0) {
			for (const fr of failed) {
				const { keysetId, error } = fr.reason;
				this.logger?.error("Failed to persist proofs for keyset", {
					mintUrl,
					keysetId,
					error
				});
			}
			const details = failed.map((fr) => fr.reason);
			const failedKeysets = details.map((d) => d.keysetId).filter((id) => Boolean(id));
			const aggregate = new AggregateError(details.map((d) => d?.error instanceof Error ? d.error : new Error(String(d?.error))), `Failed to persist proofs for ${failed.length} keyset group(s)`);
			throw new ProofOperationError(mintUrl, failedKeysets.length > 0 ? `Failed to persist proofs for ${failed.length} keyset group(s) [${failedKeysets.join(", ")}]` : `Failed to persist proofs for ${failed.length} keyset group(s)`, void 0, aggregate);
		}
	}
	async getReadyProofs(mintUrl) {
		return this.proofRepository.getReadyProofs(mintUrl);
	}
	async getAllReadyProofs() {
		return this.proofRepository.getAllReadyProofs();
	}
	/**
	* Gets the balance for a single mint by summing ready proof amounts.
	* @param mintUrl - The URL of the mint
	* @returns The total balance for the mint
	*/
	async getBalance(mintUrl) {
		if (!mintUrl || mintUrl.trim().length === 0) throw new ProofValidationError("mintUrl is required");
		return (await this.getReadyProofs(mintUrl)).reduce((acc, proof) => acc + proof.amount, 0);
	}
	/**
	* Gets balances for all mints by summing ready proof amounts.
	* @returns An object mapping mint URLs to their balances
	*/
	async getBalances() {
		const proofs = await this.getAllReadyProofs();
		const balances = {};
		for (const proof of proofs) {
			const mintUrl = proof.mintUrl;
			balances[mintUrl] = (balances[mintUrl] || 0) + proof.amount;
		}
		return balances;
	}
	/**
	* Gets balances for trusted mints only by summing ready proof amounts.
	* @returns An object mapping trusted mint URLs to their balances
	*/
	async getTrustedBalances() {
		const balances = await this.getBalances();
		const trustedMints = await this.mintService.getAllTrustedMints();
		const trustedUrls = new Set(trustedMints.map((m) => m.mintUrl));
		const trustedBalances = {};
		for (const [mintUrl, balance] of Object.entries(balances)) if (trustedUrls.has(mintUrl)) trustedBalances[mintUrl] = balance;
		return trustedBalances;
	}
	async setProofState(mintUrl, secrets, state) {
		if (!mintUrl || mintUrl.trim().length === 0) throw new ProofValidationError("mintUrl is required");
		if (!secrets || secrets.length === 0) return;
		await this.proofRepository.setProofState(mintUrl, secrets, state);
		await this.eventBus?.emit("proofs:state-changed", {
			mintUrl,
			secrets,
			state
		});
		this.logger?.debug("Proof state updated", {
			mintUrl,
			count: secrets.length,
			state
		});
	}
	/**
	* Reserve proofs for an operation.
	* Validates that proofs are available (ready and not already reserved) before reserving.
	* Emits 'proofs:reserved' event on success.
	*
	* @throws ProofOperationError if any proof is not available for reservation
	*/
	async reserveProofs(mintUrl, secrets, operationId) {
		if (!mintUrl || mintUrl.trim().length === 0) throw new ProofValidationError("mintUrl is required");
		if (!operationId || operationId.trim().length === 0) throw new ProofValidationError("operationId is required");
		if (!secrets || secrets.length === 0) return { amount: 0 };
		await this.proofRepository.reserveProofs(mintUrl, secrets, operationId);
		const amount = (await this.proofRepository.getProofsByOperationId(mintUrl, operationId)).reduce((acc, p) => acc + p.amount, 0);
		await this.eventBus?.emit("proofs:reserved", {
			mintUrl,
			operationId,
			secrets,
			amount
		});
		this.logger?.debug("Proofs reserved", {
			mintUrl,
			operationId,
			count: secrets.length,
			amount
		});
		return { amount };
	}
	/**
	* Release proofs from an operation.
	* Clears the reservation so proofs become available again.
	* Emits 'proofs:released' event on success.
	*/
	async releaseProofs(mintUrl, secrets) {
		if (!mintUrl || mintUrl.trim().length === 0) throw new ProofValidationError("mintUrl is required");
		if (!secrets || secrets.length === 0) return;
		await this.proofRepository.releaseProofs(mintUrl, secrets);
		await this.eventBus?.emit("proofs:released", {
			mintUrl,
			secrets
		});
		this.logger?.debug("Proofs released", {
			mintUrl,
			count: secrets.length
		});
	}
	/**
	* Restore proofs to ready state and clear their operation reservation.
	* Used during rollback when inflight proofs need to be made available again.
	* This sets state to 'ready' and clears usedByOperationId.
	*/
	async restoreProofsToReady(mintUrl, secrets) {
		if (!mintUrl || mintUrl.trim().length === 0) throw new ProofValidationError("mintUrl is required");
		if (!secrets || secrets.length === 0) return;
		await this.proofRepository.setProofState(mintUrl, secrets, "ready");
		await this.proofRepository.releaseProofs(mintUrl, secrets);
		await this.eventBus?.emit("proofs:state-changed", {
			mintUrl,
			secrets,
			state: "ready"
		});
		await this.eventBus?.emit("proofs:released", {
			mintUrl,
			secrets
		});
		this.logger?.debug("Proofs restored to ready", {
			mintUrl,
			count: secrets.length
		});
	}
	async deleteProofs(mintUrl, secrets) {
		if (!mintUrl || mintUrl.trim().length === 0) throw new ProofValidationError("mintUrl is required");
		if (!secrets || secrets.length === 0) return;
		await this.proofRepository.deleteProofs(mintUrl, secrets);
		await this.eventBus?.emit("proofs:deleted", {
			mintUrl,
			secrets
		});
		this.logger?.info("Proofs deleted", {
			mintUrl,
			count: secrets.length
		});
	}
	async wipeProofsByKeysetId(mintUrl, keysetId) {
		if (!mintUrl || mintUrl.trim().length === 0) throw new ProofValidationError("mintUrl is required");
		if (!keysetId || keysetId.trim().length === 0) throw new ProofValidationError("keysetId is required");
		await this.proofRepository.wipeProofsByKeysetId(mintUrl, keysetId);
		await this.eventBus?.emit("proofs:wiped", {
			mintUrl,
			keysetId
		});
		this.logger?.info("Proofs wiped by keyset", {
			mintUrl,
			keysetId
		});
	}
	/**
	* Select proofs to send for a given amount.
	* Uses the wallet's proof selection algorithm to choose optimal denominations.
	*
	* @param mintUrl - The mint URL to select proofs from
	* @param amount - The amount to send
	* @param includeFees - Whether to include fees in the selection (default: true)
	* @returns The selected proofs
	* @throws ProofValidationError if insufficient balance to cover the amount
	*/
	async selectProofsToSend(mintUrl, amount, includeFees = true) {
		const proofs = await this.getReadyProofs(mintUrl);
		if (proofs.reduce((acc, proof) => acc + proof.amount, 0) < amount) throw new ProofValidationError("Not enough proofs to send");
		const selectedProofs = (await this.walletService.getWallet(mintUrl)).selectProofsToSend(proofs, amount, includeFees);
		this.logger?.debug("Selected proofs to send", {
			mintUrl,
			amount,
			selectedProofs,
			count: selectedProofs.send.length
		});
		return selectedProofs.send;
	}
	groupProofsByKeysetId(proofs) {
		const map = /* @__PURE__ */ new Map();
		for (const proof of proofs) {
			if (!proof.secret) throw new ProofValidationError("Proof missing secret");
			const keysetId = proof.id;
			if (!keysetId || keysetId.trim().length === 0) throw new ProofValidationError("Proof missing keyset id");
			const existing = map.get(keysetId);
			if (existing) existing.push(proof);
			else map.set(keysetId, [proof]);
		}
		return map;
	}
	async getProofsByKeysetId(mintUrl, keysetId) {
		return this.proofRepository.getProofsByKeysetId(mintUrl, keysetId);
	}
	async hasProofsForKeyset(mintUrl, keysetId) {
		if (!mintUrl || mintUrl.trim().length === 0) throw new ProofValidationError("mintUrl is required");
		if (!keysetId || keysetId.trim().length === 0) throw new ProofValidationError("keysetId is required");
		const proofs = await this.proofRepository.getProofsByKeysetId(mintUrl, keysetId);
		const hasProofs = proofs.length > 0;
		this.logger?.debug("Checked proofs for keyset", {
			mintUrl,
			keysetId,
			hasProofs,
			totalProofs: proofs.length
		});
		return hasProofs;
	}
	async prepareProofsForReceiving(proofs) {
		this.logger?.debug("Preparing proofs for receiving", { totalProofs: proofs.length });
		const preparedProofs = [...proofs];
		let regularProofCount = 0;
		let p2pkProofCount = 0;
		for (let i = 0; i < preparedProofs.length; i++) {
			const proof = preparedProofs[i];
			if (!proof) continue;
			let parsedSecret;
			try {
				parsedSecret = JSON.parse(proof.secret);
			} catch (parseError) {
				this.logger?.debug("Regular proof detected, skipping P2PK processing", { proofIndex: i });
				regularProofCount++;
				continue;
			}
			if (parsedSecret[0] !== "P2PK") {
				this.logger?.error("Unsupported locking script type", {
					proofIndex: i,
					scriptType: parsedSecret[0]
				});
				throw new ProofValidationError("Only P2PK locking scripts are supported");
			}
			const additionalKeysTag = parsedSecret[1].tags?.find((tag) => tag[0] === "pubkeys");
			if (additionalKeysTag && additionalKeysTag[1] && additionalKeysTag[1].length > 0) {
				this.logger?.error("Multisig P2PK proof detected", { proofIndex: i });
				throw new ProofValidationError("Multisig is not supported");
			}
			try {
				preparedProofs[i] = await this.keyRingService.signProof(proof, parsedSecret[1].data);
				this.logger?.debug("P2PK proof signed successfully", {
					proofIndex: i,
					recipient: parsedSecret[1].data
				});
				p2pkProofCount++;
			} catch (error) {
				this.logger?.error("Failed to sign P2PK proof for receiving", {
					proofIndex: i,
					recipient: parsedSecret[1].data,
					error
				});
				throw error;
			}
		}
		this.logger?.info("Proofs prepared for receiving", {
			totalProofs: proofs.length,
			regularProofs: regularProofCount,
			p2pkProofs: p2pkProofCount
		});
		return preparedProofs;
	}
	async createBlankOutputs(amount, mintUrl) {
		if (!Number.isFinite(amount) || amount < 0) throw new ProofValidationError("amount must be a non-negative number");
		const { keys } = await this.walletService.getWalletWithActiveKeysetId(mintUrl);
		if (amount === 0) return [];
		const outputNumber = Math.max(Math.ceil(Math.log2(amount)), 1);
		const currentCounter = await this.counterService.getCounter(mintUrl, keys.id);
		const seed = await this.seedService.getSeed();
		const outputData = Array(outputNumber).fill(0).map((_, index) => {
			return OutputData.createSingleDeterministicData(0, seed, currentCounter.counter + index, keys.id);
		});
		if (outputData.length > 0) await this.counterService.incrementCounter(mintUrl, keys.id, outputData.length);
		return outputData;
	}
	/**
	* Unblind change signatures and save the resulting proofs.
	* Used after melt operations to process change returned by the mint.
	*
	* @param mintUrl - The mint URL
	* @param outputData - The output data used to create blank outputs for change
	* @param changeSignatures - The blinded signatures returned by the mint
	* @param keys - The mint keys for unblinding
	* @param options - Optional settings including createdByOperationId
	* @returns The saved change proofs
	*/
	async unblindAndSaveChangeProofs(mintUrl, outputData, changeSignatures, options) {
		if (!mintUrl || mintUrl.trim().length === 0) throw new ProofValidationError("mintUrl is required");
		if (!outputData || outputData.length === 0 || !changeSignatures || changeSignatures.length === 0) return [];
		const { keysets } = await this.mintService.ensureUpdatedMint(mintUrl);
		const keysetMap = {};
		keysets.forEach((ks) => {
			keysetMap[ks.id] = ks;
		});
		const proofs = outputData.slice(0, changeSignatures.length).flatMap((output, i) => {
			const sig = changeSignatures[i];
			const keyset = keysetMap[output.blindedMessage.id];
			if (!sig || !keyset) {
				const reason = !sig ? "missing signature" : "missing keyset";
				this.logger?.warn("Failed to create change proof", {
					reason,
					index: i
				});
				return [];
			}
			return [output.toProof(sig, {
				id: keyset.id,
				keys: keyset.keypairs
			})];
		});
		if (proofs.length === 0) return [];
		const coreProofs = mapProofToCoreProof(mintUrl, "ready", proofs, { createdByOperationId: options?.createdByOperationId });
		await this.saveProofs(mintUrl, coreProofs);
		this.logger?.info("Change proofs unblinded and saved", {
			mintUrl,
			count: coreProofs.length,
			operationId: options?.createdByOperationId
		});
		return coreProofs;
	}
	/**
	* Recover proofs from a completed swap using the mint's restore endpoint.
	* This is used when a swap succeeded but proofs were not saved (e.g., crash recovery).
	*
	* First checks if the proofs are still unspent before attempting recovery.
	* Only unspent proofs will be recovered and saved.
	*
	* @param mintUrl - The mint URL
	* @param serializedOutputData - The serialized output data containing secrets and blinding factors
	* @returns The recovered proofs (only unspent ones)
	*/
	async recoverProofsFromOutputData(mintUrl, serializedOutputData) {
		if (!mintUrl || mintUrl.trim().length === 0) throw new ProofValidationError("mintUrl is required");
		if (!serializedOutputData) throw new ProofValidationError("serializedOutputData is required");
		const { wallet } = await this.walletService.getWalletWithActiveKeysetId(mintUrl);
		const outputData = deserializeOutputData(serializedOutputData);
		const allOutputs = [...outputData.keep, ...outputData.send];
		if (allOutputs.length === 0) return [];
		const blindedMessages = allOutputs.map((o) => o.blindedMessage);
		const restoreResult = await wallet.mint.restore({ outputs: blindedMessages });
		const restoredProofs = [];
		for (let i = 0; i < restoreResult.outputs.length; i++) {
			const output = allOutputs.find((o) => o.blindedMessage.B_ === restoreResult.outputs[i]?.B_);
			const signature = restoreResult.signatures[i];
			if (output && signature) {
				const proof = {
					id: signature.id,
					amount: signature.amount,
					secret: new TextDecoder().decode(output.secret),
					C: signature.C_
				};
				restoredProofs.push(proof);
			}
		}
		if (restoredProofs.length === 0) {
			this.logger?.debug("No proofs found to restore", { mintUrl });
			return [];
		}
		const proofStates = await wallet.checkProofsStates(restoredProofs);
		const unspentProofs = restoredProofs.filter((_, index) => {
			const state = proofStates[index];
			return state && state.state === "UNSPENT";
		});
		if (unspentProofs.length === 0) {
			this.logger?.debug("All restored proofs are already spent", {
				mintUrl,
				totalRestored: restoredProofs.length
			});
			return [];
		}
		await this.saveProofs(mintUrl, mapProofToCoreProof(mintUrl, "ready", unspentProofs));
		this.logger?.info("Recovered proofs from output data", {
			mintUrl,
			totalRestored: restoredProofs.length,
			unspentCount: unspentProofs.length,
			spentCount: restoredProofs.length - unspentProofs.length
		});
		return unspentProofs;
	}
};
/**
* Splits the amount into denominations of the provided keyset.
*
* @remarks
* Partial splits will be filled up to value using minimum splits required. Sorting is only applied
* if a fill was made - exact custom splits are always returned in the same order.
* @param value Amount to split.
* @param keyset Keys to look up split amounts.
* @param split? Optional custom split amounts.
* @param order? Optional order for split amounts (if fill was required)
* @returns Array of split amounts.
* @throws Error if split sum is greater than value or mint does not have keys for requested split.
*/
function splitAmount(value, keys) {
	const split = [];
	const sortedKeyAmounts = Object.keys(keys).map((key) => Number(key)).sort((a, b) => b - a);
	if (!sortedKeyAmounts || sortedKeyAmounts.length === 0) throw new Error("Cannot split amount, keyset is inactive or contains no keys");
	for (const amt of sortedKeyAmounts) {
		if (amt <= 0) continue;
		const requireCount = Math.floor(value / amt);
		split.push(...Array(requireCount).fill(amt));
		value -= amt * requireCount;
		if (value === 0) break;
	}
	if (value !== 0) throw new Error(`Unable to split remaining amount: ${value}`);
	return split;
}

//#endregion
//#region services/MintQuoteService.ts
var MintQuoteService = class {
	mintQuoteRepo;
	mintService;
	walletService;
	proofService;
	eventBus;
	logger;
	constructor(mintQuoteRepo, mintService, walletService, proofService, eventBus, logger) {
		this.mintQuoteRepo = mintQuoteRepo;
		this.mintService = mintService;
		this.walletService = walletService;
		this.proofService = proofService;
		this.eventBus = eventBus;
		this.logger = logger;
	}
	async createMintQuote(mintUrl, amount) {
		this.logger?.info("Creating mint quote", {
			mintUrl,
			amount
		});
		if (!await this.mintService.isTrustedMint(mintUrl)) throw new UnknownMintError(`Mint ${mintUrl} is not trusted`);
		try {
			const { wallet } = await this.walletService.getWalletWithActiveKeysetId(mintUrl);
			const quote = await wallet.createMintQuoteBolt11(amount);
			await this.mintQuoteRepo.addMintQuote({
				...quote,
				mintUrl
			});
			await this.eventBus.emit("mint-quote:created", {
				mintUrl,
				quoteId: quote.quote,
				quote
			});
			return quote;
		} catch (err) {
			this.logger?.error("Failed to create mint quote", {
				mintUrl,
				amount,
				err
			});
			throw err;
		}
	}
	async redeemMintQuote(mintUrl, quoteId) {
		this.logger?.info("Redeeming mint quote", {
			mintUrl,
			quoteId
		});
		if (!await this.mintService.isTrustedMint(mintUrl)) throw new UnknownMintError(`Mint ${mintUrl} is not trusted`);
		try {
			const quote = await this.mintQuoteRepo.getMintQuote(mintUrl, quoteId);
			if (!quote) {
				this.logger?.warn("Mint quote not found", {
					mintUrl,
					quoteId
				});
				throw new Error("Quote not found");
			}
			if (!quote.amount) {
				this.logger?.warn("Mint quote had undefined amount", {
					mintUrl,
					quoteId
				});
				throw new Error("Quote amount undefined");
			}
			const { wallet } = await this.walletService.getWalletWithActiveKeysetId(mintUrl);
			const { keep } = await this.proofService.createOutputsAndIncrementCounters(mintUrl, {
				keep: quote.amount,
				send: 0
			});
			const proofs = await wallet.mintProofsBolt11(quote.amount, quote.quote, void 0, {
				type: "custom",
				data: keep
			});
			await this.eventBus.emit("mint-quote:redeemed", {
				mintUrl,
				quoteId,
				quote
			});
			this.logger?.info("Mint quote redeemed, proofs minted", {
				mintUrl,
				quoteId,
				amount: quote.amount,
				proofs: proofs.length
			});
			await this.setMintQuoteState(mintUrl, quoteId, "ISSUED");
			await this.proofService.saveProofs(mintUrl, mapProofToCoreProof(mintUrl, "ready", proofs));
			this.logger?.debug("Proofs saved to repository", {
				mintUrl,
				count: proofs.length
			});
		} catch (err) {
			this.logger?.error("Failed to redeem mint quote", {
				mintUrl,
				quoteId,
				err
			});
			throw err;
		}
	}
	async addExistingMintQuotes(mintUrl, quotes) {
		this.logger?.info("Adding existing mint quotes", {
			mintUrl,
			count: quotes.length
		});
		const added = [];
		const skipped = [];
		for (const quote of quotes) try {
			if (await this.mintQuoteRepo.getMintQuote(mintUrl, quote.quote)) {
				this.logger?.debug("Quote already exists, skipping", {
					mintUrl,
					quoteId: quote.quote
				});
				skipped.push(quote.quote);
				continue;
			}
			await this.mintQuoteRepo.addMintQuote({
				...quote,
				mintUrl
			});
			added.push(quote.quote);
			await this.eventBus.emit("mint-quote:added", {
				mintUrl,
				quoteId: quote.quote,
				quote
			});
			this.logger?.debug("Added existing mint quote", {
				mintUrl,
				quoteId: quote.quote,
				state: quote.state
			});
		} catch (err) {
			this.logger?.error("Failed to add existing mint quote", {
				mintUrl,
				quoteId: quote.quote,
				err
			});
			skipped.push(quote.quote);
		}
		this.logger?.info("Finished adding existing mint quotes", {
			mintUrl,
			added: added.length,
			skipped: skipped.length
		});
		return {
			added,
			skipped
		};
	}
	async updateStateFromRemote(mintUrl, quoteId, state) {
		this.logger?.info("Updating mint quote state from remote", {
			mintUrl,
			quoteId,
			state
		});
		await this.setMintQuoteState(mintUrl, quoteId, state);
	}
	async setMintQuoteState(mintUrl, quoteId, state) {
		this.logger?.debug("Setting mint quote state", {
			mintUrl,
			quoteId,
			state
		});
		await this.mintQuoteRepo.setMintQuoteState(mintUrl, quoteId, state);
		await this.eventBus.emit("mint-quote:state-changed", {
			mintUrl,
			quoteId,
			state
		});
		this.logger?.debug("Mint quote state updated", {
			mintUrl,
			quoteId,
			state
		});
	}
	/**
	* Requeue all PAID (but not yet ISSUED) quotes for processing.
	* Only requeues quotes for trusted mints.
	* Emits `mint-quote:requeue` for each PAID quote so the processor can enqueue them.
	*/
	async requeuePaidMintQuotes(mintUrl) {
		const requeued = [];
		try {
			const pending = await this.mintQuoteRepo.getPendingMintQuotes();
			for (const q of pending) {
				if (mintUrl && q.mintUrl !== mintUrl) continue;
				if (q.state !== "PAID") continue;
				if (!await this.mintService.isTrustedMint(q.mintUrl)) {
					this.logger?.debug("Skipping requeue for untrusted mint", {
						mintUrl: q.mintUrl,
						quoteId: q.quote
					});
					continue;
				}
				await this.eventBus.emit("mint-quote:requeue", {
					mintUrl: q.mintUrl,
					quoteId: q.quote
				});
				requeued.push(q.quote);
			}
			this.logger?.info("Requeued PAID mint quotes", {
				count: requeued.length,
				mintUrl
			});
		} catch (err) {
			this.logger?.error("Failed to requeue PAID mint quotes", {
				mintUrl,
				err
			});
		}
		return { requeued };
	}
};

//#endregion
//#region services/watchers/MintQuoteWatcherService.ts
function toKey$1(mintUrl, quoteId) {
	return `${mintUrl}::${quoteId}`;
}
var MintQuoteWatcherService = class {
	repo;
	subs;
	mintService;
	quotes;
	bus;
	logger;
	options;
	running = false;
	unsubscribeByKey = /* @__PURE__ */ new Map();
	offCreated;
	offAdded;
	offUntrusted;
	constructor(repo, subs, mintService, quotes, bus, logger, options = { watchExistingPendingOnStart: true }) {
		this.repo = repo;
		this.subs = subs;
		this.mintService = mintService;
		this.quotes = quotes;
		this.bus = bus;
		this.logger = logger;
		this.options = options;
	}
	isRunning() {
		return this.running;
	}
	async start() {
		if (this.running) return;
		this.running = true;
		this.logger?.info("MintQuoteWatcherService started");
		this.offCreated = this.bus.on("mint-quote:created", async ({ mintUrl, quoteId }) => {
			try {
				await this.watchQuote(mintUrl, quoteId);
			} catch (err) {
				this.logger?.error("Failed to start watching quote from event", {
					mintUrl,
					quoteId,
					err
				});
			}
		});
		this.offAdded = this.bus.on("mint-quote:added", async ({ mintUrl, quoteId, quote }) => {
			if (quote.state !== "ISSUED" && quote.state !== "PAID") try {
				await this.watchQuote(mintUrl, quoteId);
			} catch (err) {
				this.logger?.error("Failed to start watching added quote", {
					mintUrl,
					quoteId,
					state: quote.state,
					err
				});
			}
		});
		this.offUntrusted = this.bus.on("mint:untrusted", async ({ mintUrl }) => {
			try {
				await this.stopWatchingMint(mintUrl);
			} catch (err) {
				this.logger?.error("Failed to stop watching mint quotes on untrust", {
					mintUrl,
					err
				});
			}
		});
		if (this.options.watchExistingPendingOnStart) try {
			const pending = await this.repo.getPendingMintQuotes();
			const byMint = /* @__PURE__ */ new Map();
			for (const q of pending) {
				let arr = byMint.get(q.mintUrl);
				if (!arr) {
					arr = [];
					byMint.set(q.mintUrl, arr);
				}
				arr.push(q.quote);
			}
			for (const [mintUrl, quoteIds] of byMint.entries()) {
				if (!await this.mintService.isTrustedMint(mintUrl)) {
					this.logger?.debug("Skipping pending quotes for untrusted mint", {
						mintUrl,
						count: quoteIds.length
					});
					continue;
				}
				try {
					await this.watchQuote(mintUrl, quoteIds);
				} catch (err) {
					this.logger?.warn("Failed to watch pending quotes batch", {
						mintUrl,
						count: quoteIds.length,
						err
					});
				}
			}
		} catch (err) {
			this.logger?.error("Failed to load pending mint quotes to watch", { err });
		}
	}
	async stop() {
		if (!this.running) return;
		this.running = false;
		if (this.offCreated) try {
			this.offCreated();
		} catch {} finally {
			this.offCreated = void 0;
		}
		if (this.offAdded) try {
			this.offAdded();
		} catch {} finally {
			this.offAdded = void 0;
		}
		if (this.offUntrusted) try {
			this.offUntrusted();
		} catch {} finally {
			this.offUntrusted = void 0;
		}
		const entries = Array.from(this.unsubscribeByKey.entries());
		this.unsubscribeByKey.clear();
		for (const [key, unsub] of entries) try {
			await unsub();
			this.logger?.debug("Stopped watching quote", { key });
		} catch (err) {
			this.logger?.warn("Failed to unsubscribe watcher", {
				key,
				err
			});
		}
		this.logger?.info("MintQuoteWatcherService stopped");
	}
	async watchQuote(mintUrl, quoteOrQuotes) {
		if (!this.running) return;
		if (!await this.mintService.isTrustedMint(mintUrl)) {
			this.logger?.debug("Skipping watch for untrusted mint", { mintUrl });
			return;
		}
		const input = Array.isArray(quoteOrQuotes) ? quoteOrQuotes : [quoteOrQuotes];
		const toWatch = Array.from(new Set(input)).filter((id) => !this.unsubscribeByKey.has(toKey$1(mintUrl, id)));
		if (toWatch.length === 0) return;
		const chunks = [];
		for (let i = 0; i < toWatch.length; i += 100) chunks.push(toWatch.slice(i, i + 100));
		for (const batch of chunks) {
			const { subId, unsubscribe } = await this.subs.subscribe(mintUrl, "bolt11_mint_quote", batch, async (payload) => {
				if (payload.state !== "PAID" && payload.state !== "ISSUED") return;
				const quoteId = payload.quote;
				if (!quoteId) return;
				const key = toKey$1(mintUrl, quoteId);
				try {
					await this.quotes.updateStateFromRemote(mintUrl, quoteId, payload.state);
				} catch (err) {
					this.logger?.error("Failed to update quote state from remote", {
						mintUrl,
						quoteId,
						state: payload.state,
						err
					});
				}
				if (payload.state === "ISSUED") await this.stopWatching(key);
			});
			let didUnsubscribe = false;
			const remaining = new Set(batch);
			const groupUnsubscribeOnce = async () => {
				if (didUnsubscribe) return;
				didUnsubscribe = true;
				await unsubscribe();
			};
			for (const quoteId of batch) {
				const key = toKey$1(mintUrl, quoteId);
				const perKeyStop = async () => {
					if (remaining.has(quoteId)) remaining.delete(quoteId);
					if (remaining.size === 0) await groupUnsubscribeOnce();
				};
				this.unsubscribeByKey.set(key, perKeyStop);
			}
			this.logger?.debug("Watching mint quote batch", {
				mintUrl,
				subId,
				count: batch.length
			});
		}
	}
	async stopWatching(key) {
		const unsubscribe = this.unsubscribeByKey.get(key);
		if (!unsubscribe) return;
		try {
			await unsubscribe();
		} catch (err) {
			this.logger?.warn("Unsubscribe watcher failed", {
				key,
				err
			});
		} finally {
			this.unsubscribeByKey.delete(key);
		}
	}
	async stopWatchingMint(mintUrl) {
		this.logger?.info("Stopping all quote watchers for mint", { mintUrl });
		const prefix = `${mintUrl}::`;
		const keysToStop = [];
		for (const key of this.unsubscribeByKey.keys()) if (key.startsWith(prefix)) keysToStop.push(key);
		for (const key of keysToStop) await this.stopWatching(key);
		this.logger?.info("Stopped quote watchers for mint", {
			mintUrl,
			count: keysToStop.length
		});
	}
};

//#endregion
//#region services/watchers/MintQuoteProcessor.ts
var Bolt11QuoteHandler = class {
	constructor(quotes, logger) {
		this.quotes = quotes;
		this.logger = logger;
	}
	canHandle(quoteType) {
		return quoteType === "bolt11";
	}
	async process(mintUrl, quoteId) {
		await this.quotes.redeemMintQuote(mintUrl, quoteId);
	}
};
var MintQuoteProcessor = class {
	quotes;
	bus;
	logger;
	running = false;
	queue = [];
	processing = false;
	processingTimer;
	offStateChanged;
	offQuoteAdded;
	offRequeue;
	offUntrusted;
	handlers = /* @__PURE__ */ new Map();
	processIntervalMs;
	maxRetries;
	baseRetryDelayMs;
	initialEnqueueDelayMs;
	constructor(quotes, bus, logger, options) {
		this.quotes = quotes;
		this.bus = bus;
		this.logger = logger;
		this.processIntervalMs = options?.processIntervalMs ?? 3e3;
		this.maxRetries = options?.maxRetries ?? 3;
		this.baseRetryDelayMs = options?.baseRetryDelayMs ?? 5e3;
		this.initialEnqueueDelayMs = options?.initialEnqueueDelayMs ?? 500;
		this.registerHandler("bolt11", new Bolt11QuoteHandler(quotes, logger));
	}
	registerHandler(quoteType, handler) {
		this.handlers.set(quoteType, handler);
		this.logger?.debug("Registered quote handler", { quoteType });
	}
	isRunning() {
		return this.running;
	}
	async start() {
		if (this.running) return;
		this.running = true;
		this.logger?.info("MintQuoteProcessor started");
		this.offStateChanged = this.bus.on("mint-quote:state-changed", async ({ mintUrl, quoteId, state }) => {
			if (state === "PAID") this.enqueue(mintUrl, quoteId, "bolt11");
		});
		this.offQuoteAdded = this.bus.on("mint-quote:added", async ({ mintUrl, quoteId, quote }) => {
			if (quote.state === "PAID") this.enqueue(mintUrl, quoteId, "bolt11");
		});
		this.offRequeue = this.bus.on("mint-quote:requeue", async ({ mintUrl, quoteId }) => {
			this.enqueue(mintUrl, quoteId, "bolt11");
		});
		this.offUntrusted = this.bus.on("mint:untrusted", ({ mintUrl }) => {
			this.clearMintFromQueue(mintUrl);
		});
		this.scheduleNextProcess();
	}
	async stop() {
		if (!this.running) return;
		this.running = false;
		if (this.offStateChanged) try {
			this.offStateChanged();
		} catch {} finally {
			this.offStateChanged = void 0;
		}
		if (this.offQuoteAdded) try {
			this.offQuoteAdded();
		} catch {} finally {
			this.offQuoteAdded = void 0;
		}
		if (this.offRequeue) try {
			this.offRequeue();
		} catch {} finally {
			this.offRequeue = void 0;
		}
		if (this.offUntrusted) try {
			this.offUntrusted();
		} catch {} finally {
			this.offUntrusted = void 0;
		}
		if (this.processingTimer) {
			clearTimeout(this.processingTimer);
			this.processingTimer = void 0;
		}
		while (this.processing) await new Promise((resolve) => setTimeout(resolve, 100));
		this.logger?.info("MintQuoteProcessor stopped", { pendingItems: this.queue.length });
	}
	/**
	* Wait for the queue to be empty and all processing to complete.
	* Useful for CLI applications that want to ensure all quotes are processed before exiting.
	*/
	async waitForCompletion() {
		while (this.queue.length > 0 || this.processing) await new Promise((resolve) => setTimeout(resolve, 100));
	}
	/**
	* Remove all queued items for a specific mint.
	* Called when a mint is untrusted to stop processing its quotes.
	*/
	clearMintFromQueue(mintUrl) {
		const before = this.queue.length;
		this.queue = this.queue.filter((item) => item.mintUrl !== mintUrl);
		const removed = before - this.queue.length;
		if (removed > 0) this.logger?.info("Cleared mint quotes from processor queue", {
			mintUrl,
			removed
		});
	}
	enqueue(mintUrl, quoteId, quoteType) {
		if (this.queue.find((item) => item.mintUrl === mintUrl && item.quoteId === quoteId)) {
			this.logger?.debug("Quote already in queue", {
				mintUrl,
				quoteId
			});
			return;
		}
		const wasEmpty = this.queue.length === 0;
		this.queue.push({
			mintUrl,
			quoteId,
			quoteType,
			retryCount: 0,
			nextRetryAt: 0
		});
		this.logger?.debug("Quote enqueued for processing", {
			mintUrl,
			quoteId,
			quoteType,
			queueLength: this.queue.length
		});
		if (wasEmpty && this.running && !this.processing) {
			if (this.processingTimer) {
				clearTimeout(this.processingTimer);
				this.processingTimer = void 0;
			}
			this.processingTimer = setTimeout(() => {
				this.processingTimer = void 0;
				this.processNext();
			}, this.initialEnqueueDelayMs);
		}
	}
	scheduleNextProcess() {
		if (!this.running || this.processingTimer) return;
		this.processingTimer = setTimeout(() => {
			this.processingTimer = void 0;
			this.processNext();
		}, this.processIntervalMs);
	}
	async processNext() {
		if (!this.running || this.processing || this.queue.length === 0) {
			if (this.running) this.scheduleNextProcess();
			return;
		}
		const now = Date.now();
		const readyIndex = this.queue.findIndex((item) => item.nextRetryAt <= now);
		if (readyIndex === -1) {
			const nextReady = Math.min(...this.queue.map((item) => item.nextRetryAt));
			const delay = Math.max(this.processIntervalMs, nextReady - now);
			this.processingTimer = setTimeout(() => {
				this.processingTimer = void 0;
				this.processNext();
			}, delay);
			return;
		}
		const [item] = this.queue.splice(readyIndex, 1);
		if (!item) return;
		this.processing = true;
		try {
			await this.processItem(item);
		} catch (err) {
			this.handleProcessingError(item, err);
		} finally {
			this.processing = false;
			if (this.running) this.scheduleNextProcess();
		}
	}
	async processItem(item) {
		const { mintUrl, quoteId, quoteType } = item;
		const handler = this.handlers.get(quoteType);
		if (!handler) {
			this.logger?.warn("No handler registered for quote type", {
				quoteType,
				mintUrl,
				quoteId
			});
			return;
		}
		this.logger?.info("Processing mint quote", {
			mintUrl,
			quoteId,
			quoteType,
			attempt: item.retryCount + 1
		});
		try {
			await handler.process(mintUrl, quoteId);
			this.logger?.info("Successfully processed mint quote", {
				mintUrl,
				quoteId,
				quoteType
			});
		} catch (err) {
			throw err;
		}
	}
	handleProcessingError(item, err) {
		const { mintUrl, quoteId } = item;
		if (err instanceof MintOperationError) {
			if (err.code === 20007) {
				this.logger?.warn("Mint quote expired", {
					mintUrl,
					quoteId
				});
				return;
			} else if (err.code === 20002) {
				this.logger?.info("Mint quote already issued, updating state", {
					mintUrl,
					quoteId
				});
				this.updateQuoteState(mintUrl, quoteId, "ISSUED");
				return;
			}
			this.logger?.error("Mint operation error, not retrying", {
				mintUrl,
				quoteId,
				code: err.code,
				detail: err.message
			});
			return;
		}
		if (err instanceof NetworkError || err instanceof Error && err.message.includes("network")) {
			item.retryCount++;
			if (item.retryCount <= this.maxRetries) {
				const delay = this.baseRetryDelayMs * Math.pow(2, item.retryCount - 1);
				item.nextRetryAt = Date.now() + delay;
				this.logger?.warn("Network error, will retry", {
					mintUrl,
					quoteId,
					attempt: item.retryCount,
					maxRetries: this.maxRetries,
					retryInMs: delay
				});
				this.queue.push(item);
				return;
			}
			this.logger?.error("Max retries exceeded for network error", {
				mintUrl,
				quoteId,
				maxRetries: this.maxRetries
			});
			return;
		}
		this.logger?.error("Failed to process mint quote", {
			mintUrl,
			quoteId,
			err
		});
	}
	async updateQuoteState(mintUrl, quoteId, state) {
		try {
			await this.quotes.updateStateFromRemote(mintUrl, quoteId, state);
		} catch (err) {
			this.logger?.error("Failed to update quote state", {
				mintUrl,
				quoteId,
				state,
				err
			});
		}
	}
};

//#endregion
//#region operations/send/SendOperation.ts
function isInitOperation(op) {
	return op.state === "init";
}
function isPreparedOperation(op) {
	return op.state === "prepared";
}
function isExecutingOperation(op) {
	return op.state === "executing";
}
function isPendingOperation(op) {
	return op.state === "pending";
}
function isFinalizedOperation(op) {
	return op.state === "finalized";
}
function isRollingBackOperation(op) {
	return op.state === "rolling_back";
}
function isRolledBackOperation(op) {
	return op.state === "rolled_back";
}
/**
* Check if operation has PreparedData (any state after init)
*/
function hasPreparedData(op) {
	return op.state !== "init";
}
/**
* Check if operation is in a terminal state
*/
function isTerminalOperation(op) {
	return op.state === "finalized" || op.state === "rolled_back";
}
/**
* Get the secrets of proofs that will be sent (for finalization tracking).
* - If needsSwap: secrets come from outputData.send
* - If !needsSwap: secrets are the inputProofSecrets (exact match)
*/
function getSendProofSecrets(op) {
	if (!op.needsSwap) return op.inputProofSecrets;
	if (!op.outputData) return [];
	const { sendSecrets } = getSecretsFromSerializedOutputData(op.outputData);
	return sendSecrets;
}
/**
* Get the secrets of proofs we keep (change from swap).
* - If needsSwap: secrets come from outputData.keep
* - If !needsSwap: empty (no change proofs)
*/
function getKeepProofSecrets(op) {
	if (!op.needsSwap) return [];
	if (!op.outputData) return [];
	const { keepSecrets } = getSecretsFromSerializedOutputData(op.outputData);
	return keepSecrets;
}
/**
* Creates a new SendOperation in init state
*/
function createSendOperation(id, mintUrl, amount) {
	const now = Date.now();
	return {
		id,
		state: "init",
		mintUrl,
		amount,
		createdAt: now,
		updatedAt: now
	};
}

//#endregion
//#region services/watchers/ProofStateWatcherService.ts
function toKey(mintUrl, secret) {
	return `${mintUrl}::${secret}`;
}
var ProofStateWatcherService = class {
	subs;
	mintService;
	proofs;
	proofRepository;
	bus;
	logger;
	options;
	sendOperationService;
	running = false;
	unsubscribeByKey = /* @__PURE__ */ new Map();
	inflightByKey = /* @__PURE__ */ new Set();
	offProofsStateChanged;
	offProofsSaved;
	offUntrusted;
	constructor(subs, mintService, proofs, proofRepository, bus, logger, options = { watchExistingInflightOnStart: true }) {
		this.subs = subs;
		this.mintService = mintService;
		this.proofs = proofs;
		this.proofRepository = proofRepository;
		this.bus = bus;
		this.logger = logger;
		this.options = options;
	}
	/**
	* Set the SendOperationService for auto-finalizing send operations.
	* This is set after construction to avoid circular dependencies.
	*/
	setSendOperationService(service) {
		this.sendOperationService = service;
	}
	isRunning() {
		return this.running;
	}
	async start() {
		if (this.running) return;
		this.running = true;
		this.logger?.info("ProofStateWatcherService started");
		this.offProofsStateChanged = this.bus.on("proofs:state-changed", async ({ mintUrl, secrets, state }) => {
			try {
				if (!this.running) return;
				if (state === "inflight") try {
					await this.watchProof(mintUrl, secrets);
				} catch (err) {
					this.logger?.warn("Failed to watch inflight proofs", {
						mintUrl,
						count: secrets.length,
						err
					});
				}
				else if (state === "spent") for (const secret of secrets) {
					const key = toKey(mintUrl, secret);
					try {
						await this.stopWatching(key);
					} catch (err) {
						this.logger?.warn("Failed to stop watcher on spent proof", {
							mintUrl,
							secret,
							err
						});
					}
				}
			} catch (err) {
				this.logger?.error("Error handling proofs:state-changed", { err });
			}
		});
		this.offProofsSaved = this.bus.on("proofs:saved", async ({ mintUrl, proofs }) => {
			try {
				if (!this.running) return;
				const inflightSecrets = proofs.filter((p) => p.state === "inflight").map((p) => p.secret);
				if (inflightSecrets.length > 0) try {
					await this.watchProof(mintUrl, inflightSecrets);
				} catch (err) {
					this.logger?.warn("Failed to watch inflight proofs from saved event", {
						mintUrl,
						count: inflightSecrets.length,
						err
					});
				}
			} catch (err) {
				this.logger?.error("Error handling proofs:saved", { err });
			}
		});
		this.offUntrusted = this.bus.on("mint:untrusted", async ({ mintUrl }) => {
			try {
				await this.stopWatchingMint(mintUrl);
			} catch (err) {
				this.logger?.error("Failed to stop watching mint proofs on untrust", {
					mintUrl,
					err
				});
			}
		});
		if (this.options.watchExistingInflightOnStart) this.bootstrapInflightProofs().catch((err) => {
			this.logger?.warn("Failed to bootstrap inflight proof watchers", { err });
		});
	}
	async stop() {
		if (!this.running) return;
		this.running = false;
		if (this.offProofsStateChanged) try {
			this.offProofsStateChanged();
		} catch {} finally {
			this.offProofsStateChanged = void 0;
		}
		if (this.offProofsSaved) try {
			this.offProofsSaved();
		} catch {} finally {
			this.offProofsSaved = void 0;
		}
		if (this.offUntrusted) try {
			this.offUntrusted();
		} catch {} finally {
			this.offUntrusted = void 0;
		}
		const entries = Array.from(this.unsubscribeByKey.entries());
		this.unsubscribeByKey.clear();
		for (const [key, unsub] of entries) try {
			await unsub();
			this.logger?.debug("Stopped watching proof", { key });
		} catch (err) {
			this.logger?.warn("Failed to unsubscribe proof watcher", {
				key,
				err
			});
		}
		this.inflightByKey.clear();
		this.logger?.info("ProofStateWatcherService stopped");
	}
	async watchProof(mintUrl, secrets) {
		if (!this.running) return;
		if (!await this.mintService.isTrustedMint(mintUrl)) {
			this.logger?.debug("Skipping watch for untrusted mint", { mintUrl });
			return;
		}
		const toWatch = Array.from(new Set(secrets)).filter((secret) => !this.unsubscribeByKey.has(toKey(mintUrl, secret)));
		if (toWatch.length === 0) return;
		const { secretByYHex, yHexBySecret } = buildYHexMapsForSecrets(toWatch);
		const filters = Array.from(secretByYHex.keys());
		const { subId, unsubscribe } = await this.subs.subscribe(mintUrl, "proof_state", filters, async (payload) => {
			if (payload.state !== "SPENT") return;
			const secret = secretByYHex.get(payload.Y);
			if (!secret) return;
			const key = toKey(mintUrl, secret);
			if (this.inflightByKey.has(key)) return;
			this.inflightByKey.add(key);
			try {
				await this.proofs.setProofState(mintUrl, [secret], "spent");
				this.logger?.info("Marked inflight proof as spent from mint notification", {
					mintUrl,
					subId
				});
				await this.stopWatching(key);
				await this.tryFinalizeSendOperation(mintUrl, secret);
			} catch (err) {
				this.logger?.error("Failed to mark inflight proof as spent", {
					mintUrl,
					subId,
					err
				});
			} finally {
				this.inflightByKey.delete(key);
			}
		});
		let didUnsubscribe = false;
		const remaining = new Set(filters);
		const groupUnsubscribeOnce = async () => {
			if (didUnsubscribe) return;
			didUnsubscribe = true;
			await unsubscribe();
			this.logger?.debug("Unsubscribed watcher for inflight proof group", {
				mintUrl,
				subId
			});
		};
		for (const secret of toWatch) {
			const key = toKey(mintUrl, secret);
			const yHex = yHexBySecret.get(secret);
			const perKeyStop = async () => {
				if (remaining.has(yHex)) remaining.delete(yHex);
				if (remaining.size === 0) await groupUnsubscribeOnce();
			};
			this.unsubscribeByKey.set(key, perKeyStop);
		}
		this.logger?.debug("Watching inflight proof states", {
			mintUrl,
			subId,
			filterCount: filters.length
		});
	}
	async bootstrapInflightProofs() {
		if (!this.running) return;
		this.logger?.info("Bootstrapping inflight proof watchers");
		await this.proofs.checkInflightProofs();
		if (!this.running) return;
		const inflightProofs = await this.proofRepository.getInflightProofs();
		if (!this.running || inflightProofs.length === 0) return;
		const byMint = /* @__PURE__ */ new Map();
		for (const proof of inflightProofs) {
			if (!proof.mintUrl || !proof.secret) continue;
			const secrets = byMint.get(proof.mintUrl) ?? [];
			secrets.push(proof.secret);
			byMint.set(proof.mintUrl, secrets);
		}
		for (const [mintUrl, secrets] of byMint.entries()) {
			if (!this.running) return;
			if (secrets.length === 0) continue;
			try {
				await this.watchProof(mintUrl, secrets);
			} catch (err) {
				this.logger?.warn("Failed to watch existing inflight proofs", {
					mintUrl,
					count: secrets.length,
					err
				});
			}
		}
	}
	async stopWatching(key) {
		const unsubscribe = this.unsubscribeByKey.get(key);
		if (!unsubscribe) return;
		try {
			await unsubscribe();
		} catch (err) {
			this.logger?.warn("Unsubscribe proof watcher failed", {
				key,
				err
			});
		} finally {
			this.unsubscribeByKey.delete(key);
		}
	}
	async stopWatchingMint(mintUrl) {
		this.logger?.info("Stopping all proof watchers for mint", { mintUrl });
		const prefix = `${mintUrl}::`;
		const keysToStop = [];
		for (const key of this.unsubscribeByKey.keys()) if (key.startsWith(prefix)) keysToStop.push(key);
		for (const key of this.inflightByKey) if (key.startsWith(prefix)) this.inflightByKey.delete(key);
		for (const key of keysToStop) await this.stopWatching(key);
		this.logger?.info("Stopped proof watchers for mint", {
			mintUrl,
			count: keysToStop.length
		});
	}
	/**
	* Check if a spent proof is part of a send operation and finalize it if all send proofs are spent.
	*/
	async tryFinalizeSendOperation(mintUrl, secret) {
		if (!this.sendOperationService) return;
		try {
			const spentProof = await this.proofRepository.getProofBySecret(mintUrl, secret);
			const operationId = spentProof?.usedByOperationId || spentProof?.createdByOperationId;
			if (!operationId) return;
			const operation = await this.sendOperationService.getOperation(operationId);
			if (!operation || operation.state !== "pending") return;
			if (!hasPreparedData(operation)) return;
			const sendProofSecrets = getSendProofSecrets(operation);
			if (sendProofSecrets.length === 0) return;
			let allSpent = true;
			for (const sendSecret of sendProofSecrets) {
				const proof = await this.proofRepository.getProofBySecret(mintUrl, sendSecret);
				if (!proof || proof.state !== "spent") {
					allSpent = false;
					break;
				}
			}
			if (allSpent) {
				this.logger?.info("All send proofs spent, finalizing operation", { operationId });
				await this.sendOperationService.finalize(operationId);
			}
		} catch (err) {
			this.logger?.error("Failed to check/finalize send operation", {
				mintUrl,
				secret,
				err
			});
		}
	}
};

//#endregion
//#region services/SeedService.ts
var SeedService = class {
	seedGetter;
	seedTtlMs;
	cachedSeed = null;
	cachedUntil = 0;
	inFlight = null;
	constructor(seedGetter, options) {
		this.seedGetter = seedGetter;
		this.seedTtlMs = Math.max(0, options?.seedTtlMs ?? 0);
	}
	async getSeed() {
		const now = Date.now();
		if (this.cachedSeed && now < this.cachedUntil) return new Uint8Array(this.cachedSeed);
		if (this.inFlight) {
			const seed = await this.inFlight;
			return new Uint8Array(seed);
		}
		this.inFlight = (async () => {
			const seed = await this.seedGetter();
			if (!(seed instanceof Uint8Array) || seed.length !== 64) throw new Error("SeedService: seedGetter must return a 64-byte Uint8Array");
			if (this.seedTtlMs > 0) {
				this.cachedSeed = new Uint8Array(seed);
				this.cachedUntil = Date.now() + this.seedTtlMs;
			} else {
				this.cachedSeed = null;
				this.cachedUntil = 0;
			}
			return seed;
		})();
		try {
			const seed = await this.inFlight;
			return new Uint8Array(seed);
		} finally {
			this.inFlight = null;
		}
	}
	clear() {
		this.cachedSeed = null;
		this.cachedUntil = 0;
	}
};

//#endregion
//#region services/WalletRestoreService.ts
var WalletRestoreService = class {
	proofService;
	counterService;
	walletService;
	requestProvider;
	logger;
	restoreBatchSize = 300;
	restoreGapLimit = 100;
	restoreStartCounter = 0;
	constructor(proofService, counterService, walletService, requestProvider, logger) {
		this.proofService = proofService;
		this.counterService = counterService;
		this.walletService = walletService;
		this.requestProvider = requestProvider;
		this.logger = logger;
	}
	async sweepKeyset(mintUrl, keysetId, bip39seed) {
		this.logger?.debug("Sweeping keyset", {
			mintUrl,
			keysetId
		});
		const { wallet } = await this.walletService.getWalletWithActiveKeysetId(mintUrl);
		const sweepWallet = new Wallet(new Mint(mintUrl, { customRequest: this.requestProvider.getRequestFn(mintUrl) }), { bip39seed });
		await sweepWallet.loadMint();
		const { proofs } = await sweepWallet.batchRestore(this.restoreBatchSize, this.restoreGapLimit, this.restoreStartCounter, keysetId);
		if (proofs.length === 0) {
			this.logger?.warn("No proofs to sweep", {
				mintUrl,
				keysetId
			});
			return;
		}
		this.logger?.debug("Proofs found for sweep", {
			mintUrl,
			keysetId,
			count: proofs.length
		});
		const states = await sweepWallet.checkProofsStates(proofs);
		if (!Array.isArray(states) || states.length !== proofs.length) {
			this.logger?.error("Malformed state check", {
				mintUrl,
				keysetId,
				statesLength: states?.length,
				proofsLength: proofs.length
			});
			throw new Error("Malformed state check");
		}
		const checkedProofs = {
			spent: [],
			ready: []
		};
		for (const [index, state] of states.entries()) {
			if (!proofs[index]) {
				this.logger?.error("Proof not found", {
					mintUrl,
					keysetId,
					index
				});
				throw new Error("Proof not found");
			}
			if (state.state === "SPENT") checkedProofs.spent.push(proofs[index]);
			else checkedProofs.ready.push(proofs[index]);
		}
		this.logger?.debug("Checked proof states", {
			mintUrl,
			keysetId,
			ready: checkedProofs.ready.length,
			spent: checkedProofs.spent.length
		});
		if (checkedProofs.ready.length === 0) {
			this.logger?.warn("No ready proofs to sweep, all spent", {
				mintUrl,
				keysetId,
				spentCount: checkedProofs.spent.length
			});
			return;
		}
		const sweepFee = sweepWallet.getFeesForProofs(checkedProofs.ready);
		const sweepAmount = checkedProofs.ready.reduce((acc, proof) => acc + proof.amount, 0);
		const sweepTotalAmount = sweepAmount - sweepFee;
		if (sweepTotalAmount < 0) {
			this.logger?.warn("Sweep amount is less than fee", {
				mintUrl,
				keysetId,
				amount: sweepAmount,
				fee: sweepFee,
				total: sweepTotalAmount
			});
			return;
		}
		this.logger?.debug("Sweep calculation", {
			mintUrl,
			keysetId,
			amount: sweepAmount,
			fee: sweepFee,
			total: sweepTotalAmount
		});
		const outputResults = await this.proofService.createOutputsAndIncrementCounters(mintUrl, {
			keep: 0,
			send: sweepTotalAmount
		});
		const outputConfig = {
			send: {
				type: "custom",
				data: outputResults.send
			},
			keep: {
				type: "custom",
				data: outputResults.keep
			}
		};
		const { send, keep } = await wallet.send(sweepTotalAmount, checkedProofs.ready, void 0, outputConfig);
		await this.proofService.saveProofs(mintUrl, mapProofToCoreProof(mintUrl, "ready", [...keep, ...send]));
		this.logger?.info("Keyset sweep completed", {
			mintUrl,
			keysetId,
			readyProofs: checkedProofs.ready.length,
			spentProofs: checkedProofs.spent.length,
			sweptAmount: sweepAmount,
			fee: sweepFee
		});
	}
	/**
	* Restore and persist proofs for a single keyset.
	* Enforces the invariant: restored proofs must be >= previously stored proofs.
	* Throws on any validation or persistence error. No transactions are used here.
	*/
	async restoreKeyset(mintUrl, wallet, keysetId) {
		this.logger?.debug("Restoring keyset", {
			mintUrl,
			keysetId
		});
		const oldProofs = await this.proofService.getProofsByKeysetId(mintUrl, keysetId);
		this.logger?.debug("Existing proofs before restore", {
			mintUrl,
			keysetId,
			count: oldProofs.length
		});
		const { proofs, lastCounterWithSignature } = await wallet.batchRestore(this.restoreBatchSize, this.restoreGapLimit, this.restoreStartCounter, keysetId);
		if (proofs.length === 0) {
			this.logger?.warn("No proofs to restore", {
				mintUrl,
				keysetId
			});
			return;
		}
		this.logger?.info("Batch restore result", {
			mintUrl,
			keysetId,
			restored: proofs.length,
			lastCounterWithSignature
		});
		if (oldProofs.length > proofs.length) {
			this.logger?.warn("Restored fewer proofs than previously stored", {
				mintUrl,
				keysetId,
				previous: oldProofs.length,
				restored: proofs.length
			});
			throw new Error("Restored less proofs than expected.");
		}
		const states = await wallet.checkProofsStates(proofs);
		if (!Array.isArray(states) || states.length !== proofs.length) {
			this.logger?.error("Malformed state check", {
				mintUrl,
				keysetId,
				statesLength: states?.length,
				proofsLength: proofs.length
			});
			throw new Error("Malformed state check");
		}
		const checkedProofs = {
			spent: [],
			ready: []
		};
		for (const [index, state] of states.entries()) {
			if (!proofs[index]) {
				this.logger?.error("Proof not found", {
					mintUrl,
					keysetId,
					index
				});
				throw new Error("Proof not found");
			}
			if (state.state === "SPENT") checkedProofs.spent.push(proofs[index]);
			else checkedProofs.ready.push(proofs[index]);
		}
		this.logger?.debug("Checked proof states", {
			mintUrl,
			keysetId,
			ready: checkedProofs.ready.length,
			spent: checkedProofs.spent.length
		});
		const newCounter = lastCounterWithSignature ? lastCounterWithSignature + 1 : 0;
		await this.counterService.overwriteCounter(mintUrl, keysetId, newCounter);
		this.logger?.debug("Requested counter overwrite for keyset", {
			mintUrl,
			keysetId,
			counter: newCounter
		});
		await this.proofService.saveProofs(mintUrl, mapProofToCoreProof(mintUrl, "ready", checkedProofs.ready));
		this.logger?.info("Saved restored proofs for keyset", {
			mintUrl,
			keysetId,
			total: checkedProofs.ready.length + checkedProofs.spent.length
		});
	}
};

//#endregion
//#region services/MeltQuoteService.ts
var MeltQuoteService = class {
	mintService;
	proofService;
	walletService;
	meltQuoteRepo;
	logger;
	eventBus;
	constructor(mintService, proofService, walletService, meltQuoteRepo, eventBus, logger) {
		this.mintService = mintService;
		this.proofService = proofService;
		this.walletService = walletService;
		this.meltQuoteRepo = meltQuoteRepo;
		this.eventBus = eventBus;
		this.logger = logger;
	}
	async createMeltQuote(mintUrl, invoice) {
		if (!mintUrl || !mintUrl.trim()) {
			this.logger?.warn("Invalid parameter: mintUrl is required for createMeltQuote");
			throw new Error("mintUrl is required");
		}
		if (!invoice || !invoice.trim()) {
			this.logger?.warn("Invalid parameter: invoice is required for createMeltQuote", { mintUrl });
			throw new Error("invoice is required");
		}
		if (!await this.mintService.isTrustedMint(mintUrl)) throw new UnknownMintError(`Mint ${mintUrl} is not trusted`);
		this.logger?.info("Creating melt quote", { mintUrl });
		try {
			const { wallet } = await this.walletService.getWalletWithActiveKeysetId(mintUrl);
			const quote = await wallet.createMeltQuoteBolt11(invoice);
			await this.meltQuoteRepo.addMeltQuote({
				...quote,
				mintUrl
			});
			await this.eventBus.emit("melt-quote:created", {
				mintUrl,
				quoteId: quote.quote,
				quote
			});
			return quote;
		} catch (err) {
			this.logger?.error("Failed to create melt quote", {
				mintUrl,
				err
			});
			throw err;
		}
	}
	async payMeltQuote(mintUrl, quoteId) {
		if (!mintUrl || !mintUrl.trim()) {
			this.logger?.warn("Invalid parameter: mintUrl is required for payMeltQuote");
			throw new Error("mintUrl is required");
		}
		if (!quoteId || !quoteId.trim()) {
			this.logger?.warn("Invalid parameter: quoteId is required for payMeltQuote", { mintUrl });
			throw new Error("quoteId is required");
		}
		if (!await this.mintService.isTrustedMint(mintUrl)) throw new UnknownMintError(`Mint ${mintUrl} is not trusted`);
		this.logger?.info("Paying melt quote", {
			mintUrl,
			quoteId
		});
		try {
			const quote = await this.meltQuoteRepo.getMeltQuote(mintUrl, quoteId);
			if (!quote) {
				this.logger?.warn("Melt quote not found", {
					mintUrl,
					quoteId
				});
				throw new Error("Quote not found");
			}
			const { wallet } = await this.walletService.getWalletWithActiveKeysetId(mintUrl);
			let targetAmount = quote.amount + quote.fee_reserve;
			const selectedProofs = await this.proofService.selectProofsToSend(mintUrl, targetAmount);
			const selectedInputFee = wallet.getFeesForProofs(selectedProofs);
			targetAmount = targetAmount + selectedInputFee;
			const selectedAmount = selectedProofs.reduce((acc, proof) => acc + proof.amount, 0);
			if (selectedAmount < targetAmount) {
				this.logger?.warn("Insufficient proofs to cover melt amount with fee", {
					mintUrl,
					quoteId,
					required: targetAmount,
					available: selectedAmount
				});
				throw new Error("Insufficient proofs to pay melt quote");
			}
			if (selectedAmount === targetAmount) {
				this.logger?.debug("Exact amount match, skipping send/swap", {
					mintUrl,
					quoteId,
					amount: targetAmount
				});
				await this.proofService.setProofState(mintUrl, selectedProofs.map((proof) => proof.secret), "inflight");
				const { change } = await wallet.meltProofsBolt11(quote, selectedProofs);
				await this.proofService.saveProofs(mintUrl, mapProofToCoreProof(mintUrl, "ready", change));
				await this.proofService.setProofState(mintUrl, selectedProofs.map((proof) => proof.secret), "spent");
			} else {
				this.logger?.debug("Selected amount is greater than amount with fee, need to swap proofs", {
					mintUrl,
					quoteId,
					selectedAmount,
					targetAmount,
					selectedProofs
				});
				const swapFees = wallet.getFeesForProofs(selectedProofs);
				const totalSendAmount = quote.amount + quote.fee_reserve + swapFees;
				if (selectedAmount < totalSendAmount) {
					this.logger?.warn("Insufficient proofs after fee calculation", {
						mintUrl,
						quoteId,
						selectedAmount,
						totalSendAmount,
						swapFees
					});
					throw new Error("Insufficient proofs to pay melt quote after fees");
				}
				const sendAmount = quote.amount + quote.fee_reserve;
				const keepAmount = selectedAmount - sendAmount - swapFees;
				const changeDelta = sendAmount - quote.amount;
				const blankOutputs = await this.proofService.createBlankOutputs(changeDelta, mintUrl);
				const outputData = await this.proofService.createOutputsAndIncrementCounters(mintUrl, {
					keep: keepAmount,
					send: sendAmount
				}, { includeFees: true });
				const outputConfig = {
					send: {
						type: "custom",
						data: outputData.send
					},
					keep: {
						type: "custom",
						data: outputData.keep
					}
				};
				const { send, keep } = await wallet.send(outputData.sendAmount, selectedProofs, void 0, outputConfig);
				this.logger?.debug("Swapped successfully", {
					mintUrl,
					quoteId,
					send,
					keep
				});
				await this.proofService.saveProofs(mintUrl, mapProofToCoreProof(mintUrl, "ready", [...keep, ...send]));
				await this.proofService.setProofState(mintUrl, selectedProofs.map((proof) => proof.secret), "spent");
				await this.proofService.setProofState(mintUrl, send.map((proof) => proof.secret), "inflight");
				const { change } = await wallet.meltProofsBolt11(quote, send, void 0, {
					type: "custom",
					data: blankOutputs
				});
				await this.proofService.saveProofs(mintUrl, mapProofToCoreProof(mintUrl, "ready", change));
				await this.proofService.setProofState(mintUrl, send.map((proof) => proof.secret), "spent");
			}
			await this.setMeltQuoteState(mintUrl, quoteId, "PAID");
			await this.eventBus.emit("melt-quote:paid", {
				mintUrl,
				quoteId,
				quote
			});
		} catch (err) {
			this.logger?.error("Failed to pay melt quote", {
				mintUrl,
				quoteId,
				err
			});
			throw err;
		}
	}
	async setMeltQuoteState(mintUrl, quoteId, state) {
		this.logger?.debug("Setting melt quote state", {
			mintUrl,
			quoteId,
			state
		});
		await this.meltQuoteRepo.setMeltQuoteState(mintUrl, quoteId, state);
		await this.eventBus.emit("melt-quote:state-changed", {
			mintUrl,
			quoteId,
			state
		});
		this.logger?.debug("Melt quote state updated", {
			mintUrl,
			quoteId,
			state
		});
	}
};

//#endregion
//#region services/HistoryService.ts
var HistoryService = class {
	historyRepository;
	logger;
	eventBus;
	constructor(historyRepository, eventBus, logger) {
		this.historyRepository = historyRepository;
		this.logger = logger;
		this.eventBus = eventBus;
		this.eventBus.on("mint-quote:state-changed", ({ mintUrl, quoteId, state }) => {
			this.handleMintQuoteStateChanged(mintUrl, quoteId, state);
		});
		this.eventBus.on("mint-quote:created", ({ mintUrl, quoteId, quote }) => {
			this.handleMintQuoteCreated(mintUrl, quoteId, quote);
		});
		this.eventBus.on("mint-quote:added", ({ mintUrl, quoteId, quote }) => {
			this.handleMintQuoteAdded(mintUrl, quoteId, quote);
		});
		this.eventBus.on("melt-quote:created", ({ mintUrl, quoteId, quote }) => {
			this.handleMeltQuoteCreated(mintUrl, quoteId, quote);
		});
		this.eventBus.on("melt-quote:state-changed", ({ mintUrl, quoteId, state }) => {
			this.handleMeltQuoteStateChanged(mintUrl, quoteId, state);
		});
		this.eventBus.on("send:prepared", ({ mintUrl, operationId, operation }) => {
			this.handleSendPrepared(mintUrl, operationId, operation);
		});
		this.eventBus.on("send:pending", ({ mintUrl, operationId, token }) => {
			this.handleSendPending(mintUrl, operationId, token);
		});
		this.eventBus.on("send:finalized", ({ mintUrl, operationId }) => {
			this.handleSendStateChanged(mintUrl, operationId, "finalized");
		});
		this.eventBus.on("send:rolled-back", ({ mintUrl, operationId }) => {
			this.handleSendStateChanged(mintUrl, operationId, "rolledBack");
		});
		this.eventBus.on("receive:created", ({ mintUrl, token }) => {
			this.handleReceiveCreated(mintUrl, token);
		});
	}
	async getPaginatedHistory(offset = 0, limit = 25) {
		return this.historyRepository.getPaginatedHistoryEntries(limit, offset);
	}
	async getHistoryEntryById(id) {
		return this.historyRepository.getHistoryEntryById(id);
	}
	/**
	* Get the operationId for a send history entry.
	* @throws Error if entry not found or is not a send entry
	*/
	async getOperationIdFromHistoryEntry(historyId) {
		const entry = await this.historyRepository.getHistoryEntryById(historyId);
		if (!entry) throw new Error(`History entry ${historyId} not found`);
		if (entry.type !== "send") throw new Error(`History entry ${historyId} is not a send entry`);
		return entry.operationId;
	}
	async handleSendPrepared(mintUrl, operationId, operation) {
		const entry = {
			type: "send",
			createdAt: Date.now(),
			unit: "sat",
			amount: operation.amount,
			mintUrl,
			operationId,
			state: "prepared"
		};
		try {
			const entryRes = await this.historyRepository.addHistoryEntry(entry);
			await this.handleHistoryUpdated(mintUrl, entryRes);
		} catch (err) {
			this.logger?.error("Failed to add send prepared history entry", {
				mintUrl,
				operationId,
				err
			});
		}
	}
	async handleSendPending(mintUrl, operationId, token) {
		try {
			const entry = await this.historyRepository.getSendHistoryEntry(mintUrl, operationId);
			if (!entry) {
				this.logger?.error("Send pending history entry not found", {
					mintUrl,
					operationId
				});
				return;
			}
			entry.state = "pending";
			entry.token = token;
			entry.unit = token.unit || "sat";
			await this.historyRepository.updateHistoryEntry(entry);
			await this.handleHistoryUpdated(mintUrl, entry);
		} catch (err) {
			this.logger?.error("Failed to update send pending history entry", {
				mintUrl,
				operationId,
				err
			});
		}
	}
	async handleSendStateChanged(mintUrl, operationId, state) {
		try {
			await this.historyRepository.updateSendHistoryState(mintUrl, operationId, state);
			const entry = await this.historyRepository.getSendHistoryEntry(mintUrl, operationId);
			if (entry) await this.handleHistoryUpdated(mintUrl, entry);
		} catch (err) {
			this.logger?.error("Failed to update send state history entry", {
				mintUrl,
				operationId,
				state,
				err
			});
		}
	}
	async handleReceiveCreated(mintUrl, token) {
		const entry = {
			type: "receive",
			createdAt: Date.now(),
			unit: token.unit || "sat",
			amount: token.proofs.reduce((acc, proof) => acc + proof.amount, 0),
			mintUrl,
			token
		};
		try {
			const entryRes = await this.historyRepository.addHistoryEntry(entry);
			await this.handleHistoryUpdated(mintUrl, entryRes);
		} catch (err) {
			this.logger?.error("Failed to add receive created history entry", {
				mintUrl,
				token,
				err
			});
		}
	}
	async handleMintQuoteStateChanged(mintUrl, quoteId, state) {
		try {
			const entry = await this.historyRepository.getMintHistoryEntry(mintUrl, quoteId);
			if (!entry) {
				this.logger?.error("Mint quote state changed history entry not found", {
					mintUrl,
					quoteId
				});
				return;
			}
			entry.state = state;
			await this.historyRepository.updateHistoryEntry(entry);
			await this.handleHistoryUpdated(mintUrl, {
				...entry,
				state
			});
		} catch (err) {
			this.logger?.error("Failed to add mint quote state changed history entry", {
				mintUrl,
				quoteId,
				err
			});
		}
	}
	async handleMeltQuoteStateChanged(mintUrl, quoteId, state) {
		try {
			const entry = await this.historyRepository.getMeltHistoryEntry(mintUrl, quoteId);
			if (!entry) {
				this.logger?.error("Melt quote state changed history entry not found", {
					mintUrl,
					quoteId
				});
				return;
			}
			entry.state = state;
			await this.historyRepository.updateHistoryEntry(entry);
			await this.handleHistoryUpdated(mintUrl, {
				...entry,
				state
			});
		} catch (err) {
			this.logger?.error("Failed to add melt quote state changed history entry", {
				mintUrl,
				quoteId,
				err
			});
		}
	}
	async handleMeltQuoteCreated(mintUrl, quoteId, quote) {
		const entry = {
			type: "melt",
			createdAt: Date.now(),
			unit: quote.unit,
			amount: quote.amount,
			mintUrl,
			quoteId,
			state: quote.state
		};
		try {
			await this.historyRepository.addHistoryEntry(entry);
		} catch (err) {
			this.logger?.error("Failed to add melt quote created history entry", {
				mintUrl,
				quoteId,
				err
			});
		}
	}
	async handleMintQuoteCreated(mintUrl, quoteId, quote) {
		const entry = {
			type: "mint",
			mintUrl,
			unit: quote.unit,
			paymentRequest: quote.request,
			quoteId,
			state: quote.state,
			createdAt: Date.now(),
			amount: quote.amount
		};
		try {
			await this.historyRepository.addHistoryEntry(entry);
		} catch (err) {
			this.logger?.error("Failed to add mint quote created history entry", {
				mintUrl,
				quoteId,
				err
			});
		}
	}
	async handleMintQuoteAdded(mintUrl, quoteId, quote) {
		if (await this.historyRepository.getMintHistoryEntry(mintUrl, quoteId)) {
			this.logger?.debug("History entry already exists for added mint quote", {
				mintUrl,
				quoteId
			});
			return;
		}
		const entry = {
			type: "mint",
			mintUrl,
			unit: quote.unit,
			paymentRequest: quote.request,
			quoteId,
			state: quote.state,
			createdAt: Date.now(),
			amount: quote.amount
		};
		try {
			const created = await this.historyRepository.addHistoryEntry(entry);
			await this.eventBus.emit("history:updated", {
				mintUrl,
				entry: created
			});
			this.logger?.debug("Added history entry for externally added mint quote", {
				mintUrl,
				quoteId,
				state: quote.state
			});
		} catch (err) {
			this.logger?.error("Failed to add mint quote added history entry", {
				mintUrl,
				quoteId,
				err
			});
		}
	}
	async handleHistoryUpdated(mintUrl, entry) {
		try {
			await this.eventBus.emit("history:updated", {
				mintUrl,
				entry: { ...entry }
			});
		} catch (err) {
			this.logger?.error("Failed to emit history entry", {
				mintUrl,
				entry,
				err
			});
		}
	}
};

//#endregion
//#region services/TransactionService.ts
var TransactionService = class {
	mintService;
	walletService;
	proofService;
	eventBus;
	logger;
	constructor(mintService, walletService, proofService, eventBus, logger) {
		this.mintService = mintService;
		this.walletService = walletService;
		this.proofService = proofService;
		this.eventBus = eventBus;
		this.logger = logger;
	}
	async receive(token) {
		let mint;
		try {
			mint = typeof token === "string" ? getTokenMetadata(token).mint : token.mint;
		} catch (err) {
			this.logger?.warn("Failed to decode token for receive", { err });
			throw new ProofValidationError("Invalid token");
		}
		if (!await this.mintService.isTrustedMint(mint)) throw new UnknownMintError(`Mint ${mint} is not trusted`);
		try {
			const { keysets } = await this.mintService.ensureUpdatedMint(mint);
			const { wallet } = await this.walletService.getWalletWithActiveKeysetId(mint);
			const keysetIds = keysets.map((keyset) => keyset.id);
			let proofs = typeof token === "string" ? getDecodedToken$1(token, keysetIds).proofs : token.proofs;
			proofs = await this.proofService.prepareProofsForReceiving(proofs);
			if (!Array.isArray(proofs) || proofs.length === 0) {
				this.logger?.warn("Token contains no proofs", { mint });
				throw new ProofValidationError("Token contains no proofs");
			}
			const receiveAmount = proofs.reduce((acc, proof) => acc + proof.amount, 0);
			if (!Number.isFinite(receiveAmount) || receiveAmount <= 0) {
				this.logger?.warn("Token has invalid or non-positive amount", {
					mint,
					receiveAmount
				});
				throw new ProofValidationError("Token amount must be a positive integer");
			}
			this.logger?.info("Receiving token", {
				mint,
				proofs: proofs.length,
				amount: receiveAmount
			});
			const fees = wallet.getFeesForProofs(proofs);
			const { keep: outputData } = await this.proofService.createOutputsAndIncrementCounters(mint, {
				keep: receiveAmount - fees,
				send: 0
			});
			if (!outputData || outputData.length === 0) {
				this.logger?.error("Failed to create deterministic outputs for receive", {
					mint,
					amount: receiveAmount
				});
				throw new Error("Failed to create outputs for receive");
			}
			const newProofs = await wallet.receive({
				mint,
				proofs,
				unit: wallet.unit
			}, void 0, {
				type: "custom",
				data: outputData
			});
			await this.proofService.saveProofs(mint, mapProofToCoreProof(mint, "ready", newProofs));
			await this.eventBus.emit("receive:created", {
				mintUrl: mint,
				token: {
					mint,
					proofs
				}
			});
			this.logger?.debug("Token received and proofs saved", {
				mint,
				newProofs: newProofs.length
			});
		} catch (err) {
			this.logger?.error("Failed to receive token", {
				mint,
				err
			});
			throw err;
		}
	}
	async send(mintUrl, amount) {
		if (!await this.mintService.isTrustedMint(mintUrl)) throw new UnknownMintError(`Mint ${mintUrl} is not trusted`);
		const { wallet } = await this.walletService.getWalletWithActiveKeysetId(mintUrl);
		const exactProofs = await this.proofService.selectProofsToSend(mintUrl, amount, false);
		if (exactProofs.reduce((acc, proof) => acc + proof.amount, 0) === amount && exactProofs.length > 0) {
			this.logger?.info("Exact amount match, skipping swap", {
				mintUrl,
				amountToSend: amount,
				proofCount: exactProofs.length
			});
			await this.proofService.setProofState(mintUrl, exactProofs.map((proof) => proof.secret), "inflight");
			const token = {
				mint: mintUrl,
				proofs: exactProofs
			};
			await this.eventBus.emit("send:created", {
				mintUrl,
				token
			});
			return token;
		}
		const selectedProofs = await this.proofService.selectProofsToSend(mintUrl, amount, true);
		const fees = wallet.getFeesForProofs(selectedProofs);
		const selectedAmount = selectedProofs.reduce((acc, proof) => acc + proof.amount, 0);
		const outputData = await this.proofService.createOutputsAndIncrementCounters(mintUrl, {
			keep: selectedAmount - amount - fees,
			send: amount
		});
		this.logger?.info("Sending with swap", {
			mintUrl,
			amountToSend: amount,
			fees,
			selectedAmount,
			proofCount: selectedProofs.length
		});
		const outputConfig = {
			send: {
				type: "custom",
				data: outputData.send
			},
			keep: {
				type: "custom",
				data: outputData.keep
			}
		};
		const { send, keep } = await wallet.send(amount, selectedProofs, void 0, outputConfig);
		await this.proofService.saveProofs(mintUrl, mapProofToCoreProof(mintUrl, "ready", [...keep, ...send]));
		await this.proofService.setProofState(mintUrl, selectedProofs.map((proof) => proof.secret), "spent");
		await this.proofService.setProofState(mintUrl, send.map((proof) => proof.secret), "inflight");
		const token = {
			mint: mintUrl,
			proofs: send
		};
		await this.eventBus.emit("send:created", {
			mintUrl,
			token
		});
		return token;
	}
};

//#endregion
//#region services/PaymentRequestService.ts
var PaymentRequestService = class {
	sendOperationService;
	proofService;
	logger;
	constructor(sendOperationService, proofService, logger) {
		this.sendOperationService = sendOperationService;
		this.proofService = proofService;
		this.logger = logger;
	}
	/**
	* Process a payment request and return a parsed payment request.
	* @param paymentRequest - The payment request to process
	* @returns The parsed payment request
	*/
	async processPaymentRequest(paymentRequest) {
		const decodedPaymentRequest = await this.readPaymentRequest(paymentRequest);
		const transport = this.getPaymentRequestTransport(decodedPaymentRequest);
		const matchingMints = await this.findMatchingMints(decodedPaymentRequest);
		if (matchingMints.length === 0) throw new PaymentRequestError("No matching mints found");
		return {
			paymentRequest: decodedPaymentRequest,
			matchingMints,
			requiredMints: decodedPaymentRequest.mints ?? [],
			amount: decodedPaymentRequest.amount,
			transport
		};
	}
	/**
	* Handle an inband payment request by sending tokens and calling the handler.
	* @param mintUrl - The mint to send from
	* @param request - The prepared payment request
	* @param inbandHandler - Callback to deliver the token
	* @param amount - Optional amount (required if not specified in request)
	*/
	async preparePaymentRequestTransaction(mintUrl, request, amount) {
		this.validateMint(mintUrl, request.requiredMints);
		const finalAmount = this.validateAmount(request, amount);
		this.logger?.debug("Preparing payment request transaction", {
			mintUrl,
			amount: finalAmount
		});
		const initSend = await this.sendOperationService.init(mintUrl, finalAmount);
		const preparedSend = await this.sendOperationService.prepare(initSend);
		this.logger?.debug("Payment request transaction prepared", {
			mintUrl,
			amount: finalAmount
		});
		return {
			sendOperation: preparedSend,
			request
		};
	}
	/**
	* Handle an HTTP payment request by sending tokens to the specified URL.
	* @param mintUrl - The mint to send from
	* @param request - The prepared payment request
	* @param amount - Optional amount (required if not specified in request)
	* @returns The HTTP response from the payment endpoint
	*/
	async handleInbandPaymentRequest(transaction, inbandHandler) {
		if (transaction.request.transport.type !== "inband") throw new PaymentRequestError("Invalid transport type");
		this.logger?.debug("Creating inband payment request token", {
			mintUrl: transaction.sendOperation.mintUrl,
			amount: transaction.request.amount
		});
		const token = await this.sendOperationService.execute(transaction.sendOperation);
		this.logger?.debug("Executing inband payment request handler", {
			mintUrl: transaction.sendOperation.mintUrl,
			amount: transaction.request.amount
		});
		await inbandHandler(token.token);
	}
	/**
	* Handle an HTTP payment request by sending tokens to the specified URL.
	* @param mintUrl - The mint to send from
	* @param request - The prepared payment request
	* @param amount - Optional amount (required if not specified in request)
	* @returns The HTTP response from the payment endpoint
	*/
	async handleHttpPaymentRequest(transaction) {
		if (transaction.request.transport.type !== "http") throw new PaymentRequestError("Invalid transport type");
		this.logger?.debug("Handling HTTP payment request", {
			mintUrl: transaction.sendOperation.mintUrl,
			amount: transaction.request.amount,
			url: transaction.request.transport.url
		});
		const token = await this.sendOperationService.execute(transaction.sendOperation);
		const response = await fetch(transaction.request.transport.url, {
			method: "POST",
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify(token)
		});
		this.logger?.debug("HTTP payment request completed", {
			mintUrl: transaction.sendOperation.mintUrl,
			amount: transaction.request.amount,
			url: transaction.request.transport.url,
			status: response.status
		});
		return response;
	}
	async readPaymentRequest(paymentRequest) {
		this.logger?.debug("Reading payment request", { paymentRequest });
		const decodedPaymentRequest = PaymentRequest.fromEncodedRequest(paymentRequest);
		this.logger?.info("Payment request decoded", { decodedPaymentRequest });
		return decodedPaymentRequest;
	}
	validateMint(mintUrl, mints) {
		if (mints && mints.length > 0 && !mints.includes(mintUrl)) throw new PaymentRequestError(`Mint ${mintUrl} is not in the allowed mints list: ${mints.join(", ")}`);
	}
	getPaymentRequestTransport(pr) {
		if (!pr.transport || Array.isArray(pr.transport) && pr.transport.length === 0) return { type: "inband" };
		if (!Array.isArray(pr.transport)) throw new PaymentRequestError("Malformed payment request: Invalid transport");
		const httpTransport = pr.transport.find((t) => t.type === PaymentRequestTransportType.POST);
		if (httpTransport) return {
			type: "http",
			url: httpTransport.target
		};
		throw new PaymentRequestError(`Unsupported transport type. Only HTTP POST is supported, found: ${pr.transport.map((t) => t.type).join(", ")}`);
	}
	async findMatchingMints(paymentRequest) {
		const balances = await this.proofService.getTrustedBalances();
		const amount = paymentRequest.amount ?? 0;
		const mintRequirement = paymentRequest.mints;
		const matchingMints = [];
		for (const [mintUrl, balance] of Object.entries(balances)) if (balance >= amount && (!mintRequirement || mintRequirement.includes(mintUrl))) matchingMints.push(mintUrl);
		return matchingMints;
	}
	validateAmount(request, amount) {
		if (request.amount && amount && request.amount !== amount) throw new PaymentRequestError(`Amount mismatch: request specifies ${request.amount} but ${amount} was provided`);
		const finalAmount = request.amount ?? amount;
		if (!finalAmount) throw new PaymentRequestError("Amount is required but was not provided");
		return finalAmount;
	}
};

//#endregion
//#region operations/send/SendOperationService.ts
/**
* Service that manages send operations as sagas.
*
* This service provides crash recovery and rollback capabilities for send operations
* by breaking them into discrete steps: init  prepare  execute  finalize/rollback.
*/
var SendOperationService = class {
	sendOperationRepository;
	proofRepository;
	proofService;
	mintService;
	walletService;
	eventBus;
	logger;
	/** In-memory locks to prevent concurrent operations on the same operation ID */
	operationLocks = /* @__PURE__ */ new Map();
	/** Lock for the global recovery process */
	recoveryLock = null;
	constructor(sendOperationRepository, proofRepository, proofService, mintService, walletService, eventBus, logger) {
		this.sendOperationRepository = sendOperationRepository;
		this.proofRepository = proofRepository;
		this.proofService = proofService;
		this.mintService = mintService;
		this.walletService = walletService;
		this.eventBus = eventBus;
		this.logger = logger;
	}
	/**
	* Acquire a lock for an operation.
	* Returns a release function that must be called when the operation completes.
	* Throws if the operation is already locked.
	*/
	async acquireOperationLock(operationId) {
		if (this.operationLocks.get(operationId)) throw new OperationInProgressError(operationId);
		let releaseLock;
		const lockPromise = new Promise((resolve) => {
			releaseLock = resolve;
		});
		this.operationLocks.set(operationId, lockPromise);
		return () => {
			this.operationLocks.delete(operationId);
			releaseLock();
		};
	}
	/**
	* Check if an operation is currently locked.
	*/
	isOperationLocked(operationId) {
		return this.operationLocks.has(operationId);
	}
	/**
	* Check if recovery is currently in progress.
	*/
	isRecoveryInProgress() {
		return this.recoveryLock !== null;
	}
	/**
	* Create a new send operation.
	* This is the entry point for the saga.
	*/
	async init(mintUrl, amount) {
		if (!await this.mintService.isTrustedMint(mintUrl)) throw new UnknownMintError(`Mint ${mintUrl} is not trusted`);
		if (!Number.isFinite(amount) || amount <= 0) throw new ProofValidationError("Amount must be a positive number");
		const id = generateSubId();
		const operation = createSendOperation(id, mintUrl, amount);
		await this.sendOperationRepository.create(operation);
		this.logger?.debug("Send operation created", {
			operationId: id,
			mintUrl,
			amount
		});
		return operation;
	}
	/**
	* Prepare the operation by reserving proofs and creating outputs.
	* After this step, the operation can be executed or rolled back.
	*
	* If preparation fails, automatically attempts to recover the init operation.
	* Throws if the operation is already in progress.
	*/
	async prepare(operation) {
		const releaseLock = await this.acquireOperationLock(operation.id);
		try {
			return await this.prepareInternal(operation);
		} catch (e) {
			await this.tryRecoverInitOperation(operation);
			throw e;
		} finally {
			releaseLock();
		}
	}
	/**
	* Internal prepare logic, separated for error handling.
	*/
	async prepareInternal(operation) {
		const { mintUrl, amount } = operation;
		const { wallet, keys } = await this.walletService.getWalletWithActiveKeysetId(mintUrl);
		const availableProofs = await this.proofRepository.getAvailableProofs(mintUrl);
		const totalAvailable = availableProofs.reduce((acc, p) => acc + p.amount, 0);
		if (totalAvailable < amount) throw new ProofValidationError(`Insufficient balance: need ${amount}, have ${totalAvailable}`);
		const exactProofs = wallet.selectProofsToSend(availableProofs, amount, false);
		const needsSwap = exactProofs.send.reduce((acc, p) => acc + p.amount, 0) !== amount || exactProofs.send.length === 0;
		let selectedProofs;
		let fee = 0;
		let serializedOutputData;
		if (!needsSwap && exactProofs.send.length > 0) {
			selectedProofs = exactProofs.send;
			this.logger?.debug("Exact match found for send", {
				operationId: operation.id,
				amount,
				proofCount: selectedProofs.length
			});
		} else {
			selectedProofs = wallet.selectProofsToSend(availableProofs, amount, true).send;
			const selectedAmount = selectedProofs.reduce((acc, p) => acc + p.amount, 0);
			fee = wallet.getFeesForProofs(selectedProofs);
			const keepAmount = selectedAmount - amount - fee;
			const outputResult = await this.proofService.createOutputsAndIncrementCounters(mintUrl, {
				keep: keepAmount,
				send: amount
			});
			serializedOutputData = serializeOutputData({
				keep: outputResult.keep,
				send: outputResult.send
			});
			this.logger?.debug("Swap required for send", {
				operationId: operation.id,
				amount,
				fee,
				keepAmount,
				selectedAmount,
				proofCount: selectedProofs.length,
				keepOutputs: outputResult.keep.length,
				sendOutputs: outputResult.send.length
			});
		}
		const inputSecrets = selectedProofs.map((p) => p.secret);
		await this.proofService.reserveProofs(mintUrl, inputSecrets, operation.id);
		const prepared = {
			id: operation.id,
			state: "prepared",
			mintUrl: operation.mintUrl,
			amount: operation.amount,
			createdAt: operation.createdAt,
			updatedAt: Date.now(),
			error: operation.error,
			needsSwap,
			fee,
			inputAmount: selectedProofs.reduce((acc, p) => acc + p.amount, 0),
			inputProofSecrets: inputSecrets,
			outputData: serializedOutputData
		};
		await this.sendOperationRepository.update(prepared);
		await this.eventBus.emit("send:prepared", {
			mintUrl,
			operationId: prepared.id,
			operation: prepared
		});
		this.logger?.info("Send operation prepared", {
			operationId: operation.id,
			needsSwap,
			fee,
			inputProofCount: inputSecrets.length
		});
		return prepared;
	}
	/**
	* Execute the prepared operation.
	* Performs the swap (if needed) and creates the token.
	*
	* If execution fails after transitioning to 'executing' state,
	* automatically attempts to recover the operation.
	* Throws if the operation is already in progress.
	*/
	async execute(operation) {
		const releaseLock = await this.acquireOperationLock(operation.id);
		try {
			const executing = {
				...operation,
				state: "executing",
				updatedAt: Date.now()
			};
			await this.sendOperationRepository.update(executing);
			try {
				return await this.executeInternal(executing);
			} catch (e) {
				await this.tryRecoverExecutingOperation(executing);
				throw e;
			}
		} finally {
			releaseLock();
		}
	}
	/**
	* Internal execute logic, separated for error handling.
	*/
	async executeInternal(executing) {
		const { mintUrl, amount, needsSwap, inputProofSecrets } = executing;
		const { wallet } = await this.walletService.getWalletWithActiveKeysetId(mintUrl);
		const inputProofs = (await this.proofRepository.getProofsByOperationId(mintUrl, executing.id)).filter((p) => inputProofSecrets.includes(p.secret));
		if (inputProofs.length !== inputProofSecrets.length) throw new Error("Could not find all reserved proofs");
		let sendProofs;
		let keepProofs = [];
		if (!needsSwap) {
			sendProofs = inputProofs;
			this.logger?.debug("Executing exact match send", {
				operationId: executing.id,
				proofCount: sendProofs.length
			});
			const sendSecrets = sendProofs.map((p) => p.secret);
			await this.proofService.setProofState(mintUrl, sendSecrets, "inflight");
		} else {
			if (!executing.outputData) throw new Error("Missing output data for swap operation");
			const outputData = deserializeOutputData(executing.outputData);
			this.logger?.debug("Executing swap", {
				operationId: executing.id,
				keepOutputs: outputData.keep.length,
				sendOutputs: outputData.send.length
			});
			const outputConfig = {
				send: {
					type: "custom",
					data: outputData.send
				},
				keep: {
					type: "custom",
					data: outputData.keep
				}
			};
			const result = await wallet.send(amount, inputProofs, void 0, outputConfig);
			sendProofs = result.send;
			keepProofs = result.keep;
			const keepCoreProofs = mapProofToCoreProof(mintUrl, "ready", keepProofs, { createdByOperationId: executing.id });
			const sendCoreProofs = mapProofToCoreProof(mintUrl, "inflight", sendProofs, { createdByOperationId: executing.id });
			await this.proofService.saveProofs(mintUrl, [...keepCoreProofs, ...sendCoreProofs]);
			await this.proofService.setProofState(mintUrl, inputProofSecrets, "spent");
		}
		const pending = {
			...executing,
			state: "pending",
			updatedAt: Date.now()
		};
		await this.sendOperationRepository.update(pending);
		const token = {
			mint: mintUrl,
			proofs: sendProofs,
			unit: wallet.unit
		};
		await this.eventBus.emit("send:pending", {
			mintUrl,
			operationId: pending.id,
			operation: pending,
			token
		});
		this.logger?.info("Send operation executed", {
			operationId: executing.id,
			sendProofCount: sendProofs.length,
			keepProofCount: keepProofs.length
		});
		return {
			operation: pending,
			token
		};
	}
	/**
	* High-level send method that orchestrates init  prepare  execute.
	* This is the main entry point for consumers.
	*/
	async send(mintUrl, amount) {
		const initOp = await this.init(mintUrl, amount);
		const preparedOp = await this.prepare(initOp);
		const { token } = await this.execute(preparedOp);
		return token;
	}
	/**
	* Finalize a pending operation after its proofs have been spent.
	* This method is idempotent - calling it on an already finalized operation is a no-op.
	* If the operation was rolled back, finalization is skipped (rollback takes precedence).
	* Throws if the operation is already in progress.
	*/
	async finalize(operationId) {
		const preCheck = await this.sendOperationRepository.getById(operationId);
		if (!preCheck) throw new Error(`Operation ${operationId} not found`);
		if (preCheck.state === "finalized") {
			this.logger?.debug("Operation already finalized", { operationId });
			return;
		}
		if (preCheck.state === "rolled_back" || preCheck.state === "rolling_back") {
			this.logger?.debug("Operation was rolled back or is rolling back, skipping finalization", { operationId });
			return;
		}
		const releaseLock = await this.acquireOperationLock(operationId);
		try {
			const operation = await this.sendOperationRepository.getById(operationId);
			if (!operation) throw new Error(`Operation ${operationId} not found`);
			if (operation.state === "finalized") {
				this.logger?.debug("Operation already finalized", { operationId });
				return;
			}
			if (operation.state === "rolled_back" || operation.state === "rolling_back") {
				this.logger?.debug("Operation was rolled back or is rolling back, skipping finalization", { operationId });
				return;
			}
			if (operation.state !== "pending") throw new Error(`Cannot finalize operation in state ${operation.state}`);
			const pendingOp = operation;
			const finalized = {
				...pendingOp,
				state: "finalized",
				updatedAt: Date.now()
			};
			await this.sendOperationRepository.update(finalized);
			const sendSecrets = getSendProofSecrets(pendingOp);
			const keepSecrets = getKeepProofSecrets(pendingOp);
			await this.proofService.releaseProofs(pendingOp.mintUrl, pendingOp.inputProofSecrets);
			if (sendSecrets.length > 0) await this.proofService.releaseProofs(pendingOp.mintUrl, sendSecrets);
			if (keepSecrets.length > 0) await this.proofService.releaseProofs(pendingOp.mintUrl, keepSecrets);
			await this.eventBus.emit("send:finalized", {
				mintUrl: pendingOp.mintUrl,
				operationId,
				operation: finalized
			});
			this.logger?.info("Send operation finalized", { operationId });
		} finally {
			releaseLock();
		}
	}
	/**
	* Rollback an operation by reclaiming the proofs.
	* Only works for operations in 'prepared', 'executing', or 'pending' state.
	* Throws if the operation is already in progress.
	*/
	async rollback(operationId) {
		const releaseLock = await this.acquireOperationLock(operationId);
		try {
			const operation = await this.sendOperationRepository.getById(operationId);
			if (!operation) throw new Error(`Operation ${operationId} not found`);
			if (operation.state === "finalized" || operation.state === "rolled_back" || operation.state === "rolling_back" || operation.state === "executing" || operation.state === "init") throw new Error(`Cannot rollback operation in state ${operation.state}`);
			if (!hasPreparedData(operation)) throw new Error(`Operation ${operationId} is not in a rollbackable state`);
			const { mintUrl, inputProofSecrets } = operation;
			if (operation.state === "prepared") {
				await this.proofService.releaseProofs(mintUrl, inputProofSecrets);
				this.logger?.info("Rolling back prepared/executing operation - released reserved proofs", { operationId });
			} else if (operation.state === "pending") {
				const rollingBack = {
					...operation,
					state: "rolling_back",
					updatedAt: Date.now()
				};
				await this.sendOperationRepository.update(rollingBack);
				const sendSecrets = getSendProofSecrets(operation);
				if (sendSecrets.length > 0) {
					const { wallet } = await this.walletService.getWalletWithActiveKeysetId(mintUrl);
					const sendProofs = (await this.proofRepository.getProofsByOperationId(mintUrl, operationId)).filter((p) => sendSecrets.includes(p.secret) && p.state === "inflight");
					if (sendProofs.length > 0) {
						const reclaimAmount = sendProofs.reduce((acc, p) => acc + p.amount, 0) - wallet.getFeesForProofs(sendProofs);
						if (reclaimAmount > 0) {
							const outputResult = await this.proofService.createOutputsAndIncrementCounters(mintUrl, {
								keep: reclaimAmount,
								send: 0
							});
							const keep = await wallet.receive({
								mint: mintUrl,
								proofs: sendProofs,
								unit: wallet.unit
							}, void 0, {
								type: "custom",
								data: outputResult.keep
							});
							await this.proofService.saveProofs(mintUrl, mapProofToCoreProof(mintUrl, "ready", keep));
							await this.proofService.setProofState(mintUrl, sendProofs.map((p) => p.secret), "spent");
							this.logger?.info("Reclaimed proofs from pending operation", {
								operationId,
								reclaimedAmount: reclaimAmount,
								proofCount: keep.length
							});
						}
					}
				}
				await this.proofService.releaseProofs(mintUrl, inputProofSecrets);
				const keepSecrets = getKeepProofSecrets(operation);
				if (keepSecrets.length > 0) await this.proofService.releaseProofs(mintUrl, keepSecrets);
			}
			await this.markAsRolledBack(operation, "Rolled back by user action");
		} finally {
			releaseLock();
		}
	}
	/**
	* Recover pending operations on startup.
	* This should be called during initialization.
	* Throws if recovery is already in progress.
	*/
	async recoverPendingOperations() {
		if (this.recoveryLock) throw new Error("Recovery is already in progress");
		let releaseRecoveryLock;
		this.recoveryLock = new Promise((resolve) => {
			releaseRecoveryLock = resolve;
		});
		try {
			let initCount = 0;
			let executingCount = 0;
			let pendingCount = 0;
			let rollingBackCount = 0;
			let orphanCount = 0;
			const initOps = await this.sendOperationRepository.getByState("init");
			for (const op of initOps) {
				await this.recoverInitOperation(op);
				initCount++;
			}
			const preparedOps = await this.sendOperationRepository.getByState("prepared");
			for (const op of preparedOps) this.logger?.warn("Found stale prepared operation, user can rollback manually", { operationId: op.id });
			const executingOps = await this.sendOperationRepository.getByState("executing");
			for (const op of executingOps) try {
				await this.recoverExecutingOperation(op);
				executingCount++;
			} catch (e) {
				this.logger?.error("Error recovering executing operation", {
					operationId: op.id,
					error: e instanceof Error ? e.message : String(e)
				});
			}
			const pendingOps = await this.sendOperationRepository.getByState("pending");
			for (const op of pendingOps) try {
				await this.checkPendingOperation(op);
				pendingCount++;
			} catch (e) {
				this.logger?.error("Error checking pending operation", {
					operationId: op.id,
					error: e instanceof Error ? e.message : String(e)
				});
			}
			const rollingBackOps = await this.sendOperationRepository.getByState("rolling_back");
			for (const op of rollingBackOps) {
				this.logger?.warn("Found operation stuck in rolling_back state. This indicates a crash during rollback. Manual recovery via seed restore may be needed.", {
					operationId: op.id,
					mintUrl: op.mintUrl,
					amount: op.amount
				});
				rollingBackCount++;
			}
			orphanCount = await this.cleanupOrphanedReservations();
			this.logger?.info("Recovery completed", {
				initOperations: initCount,
				executingOperations: executingCount,
				pendingOperations: pendingCount,
				rollingBackOperations: rollingBackCount,
				orphanedReservations: orphanCount
			});
		} finally {
			this.recoveryLock = null;
			releaseRecoveryLock();
		}
	}
	/**
	* Clean up a failed init operation.
	* Releases any orphaned proof reservations and deletes the operation.
	*/
	async recoverInitOperation(op) {
		const orphanedForOp = (await this.proofRepository.getReservedProofs()).filter((p) => p.usedByOperationId === op.id);
		if (orphanedForOp.length > 0) await this.proofService.releaseProofs(op.mintUrl, orphanedForOp.map((p) => p.secret));
		await this.sendOperationRepository.delete(op.id);
		this.logger?.info("Cleaned up failed init operation", { operationId: op.id });
	}
	/**
	* Attempts to recover an init operation, swallowing recovery errors.
	* If recovery fails, logs warning and leaves for startup recovery.
	*/
	async tryRecoverInitOperation(op) {
		try {
			await this.recoverInitOperation(op);
			this.logger?.info("Recovered init operation after failure", { operationId: op.id });
		} catch (recoveryError) {
			this.logger?.warn("Failed to recover init operation, will retry on next startup", {
				operationId: op.id,
				error: recoveryError instanceof Error ? recoveryError.message : String(recoveryError)
			});
		}
	}
	/**
	* Recover an executing operation.
	* Determines if swap happened and recovers accordingly.
	*/
	async recoverExecutingOperation(op) {
		if (!op.needsSwap) {
			await this.proofService.releaseProofs(op.mintUrl, op.inputProofSecrets);
			await this.markAsRolledBack(op, "Recovered: no swap needed, operation never finalized");
			return;
		}
		let inputStates;
		try {
			inputStates = await this.checkProofStatesWithMint(op.mintUrl, op.inputProofSecrets);
		} catch (e) {
			this.logger?.warn("Could not reach mint for recovery, will retry later", {
				operationId: op.id,
				mintUrl: op.mintUrl
			});
			return;
		}
		if (!inputStates.every((s) => s.state === "SPENT")) {
			await this.proofService.releaseProofs(op.mintUrl, op.inputProofSecrets);
			await this.markAsRolledBack(op, "Recovered: swap never executed");
		} else {
			const existingProofs = await this.proofRepository.getProofsByOperationId(op.mintUrl, op.id);
			const outputSecrets = op.outputData ? getSecretsFromSerializedOutputData(op.outputData) : {
				keepSecrets: [],
				sendSecrets: []
			};
			const allOutputSecrets = [...outputSecrets.keepSecrets, ...outputSecrets.sendSecrets];
			if (!existingProofs.some((p) => allOutputSecrets.includes(p.secret)) && op.outputData) await this.recoverProofsFromSwap(op);
			await this.proofService.setProofState(op.mintUrl, op.inputProofSecrets, "spent");
			await this.markAsRolledBack(op, "Recovered: swap succeeded but token never returned");
		}
	}
	/**
	* Attempts to recover an executing operation, swallowing recovery errors.
	* If recovery fails (e.g., mint unreachable), logs warning and leaves
	* for startup recovery.
	*/
	async tryRecoverExecutingOperation(op) {
		try {
			await this.recoverExecutingOperation(op);
			this.logger?.info("Recovered executing operation after failure", { operationId: op.id });
		} catch (recoveryError) {
			this.logger?.warn("Failed to recover executing operation, will retry on next startup", {
				operationId: op.id,
				error: recoveryError instanceof Error ? recoveryError.message : String(recoveryError)
			});
		}
	}
	/**
	* Recover proofs from a completed swap using the mint's restore endpoint.
	*/
	async recoverProofsFromSwap(op) {
		if (!op.outputData) throw new Error("Cannot recover proofs without outputData");
		const recoveredProofs = await this.proofService.recoverProofsFromOutputData(op.mintUrl, op.outputData);
		if (recoveredProofs.length > 0) this.logger?.info("Recovered proofs from swap", {
			operationId: op.id,
			proofCount: recoveredProofs.length
		});
	}
	/**
	* Check a pending operation to see if it should be finalized.
	*/
	async checkPendingOperation(op) {
		const sendSecrets = getSendProofSecrets(op);
		let sendStates;
		try {
			sendStates = await this.checkProofStatesWithMint(op.mintUrl, sendSecrets);
		} catch (e) {
			this.logger?.warn("Could not reach mint for recovery, will retry later", {
				operationId: op.id,
				mintUrl: op.mintUrl
			});
			return;
		}
		if (sendStates.every((s) => s.state === "SPENT")) {
			await this.finalize(op.id);
			this.logger?.info("Send operation finalized during recovery", { operationId: op.id });
		} else this.logger?.debug("Pending operation token not yet claimed, leaving as pending", { operationId: op.id });
	}
	/**
	* Check proof states with the mint.
	*/
	async checkProofStatesWithMint(mintUrl, secrets) {
		const wallet = await this.walletService.getWallet(mintUrl);
		const proofInputs = secrets.map((secret) => ({ secret }));
		return wallet.checkProofsStates(proofInputs);
	}
	/**
	* Mark an operation as rolled back with an error message.
	*/
	async markAsRolledBack(op, error) {
		const rolledBack = {
			...op,
			state: "rolled_back",
			updatedAt: Date.now(),
			error
		};
		await this.sendOperationRepository.update(rolledBack);
		await this.eventBus.emit("send:rolled-back", {
			mintUrl: op.mintUrl,
			operationId: op.id,
			operation: rolledBack
		});
		this.logger?.info("Operation rolled back during recovery", {
			operationId: op.id,
			error
		});
		return rolledBack;
	}
	/**
	* Clean up orphaned proof reservations.
	* Finds proofs that are reserved but point to non-existent or terminal operations.
	*/
	async cleanupOrphanedReservations() {
		const reservedProofs = await this.proofRepository.getReservedProofs();
		const orphanedProofs = [];
		for (const proof of reservedProofs) {
			if (!proof.usedByOperationId) continue;
			const operation = await this.sendOperationRepository.getById(proof.usedByOperationId);
			if (!operation || isTerminalOperation(operation)) orphanedProofs.push(proof);
		}
		const byMint = /* @__PURE__ */ new Map();
		for (const proof of orphanedProofs) {
			const secrets = byMint.get(proof.mintUrl) || [];
			secrets.push(proof.secret);
			byMint.set(proof.mintUrl, secrets);
		}
		for (const [mintUrl, secrets] of byMint) await this.proofService.releaseProofs(mintUrl, secrets);
		if (orphanedProofs.length > 0) this.logger?.info("Released orphaned proof reservations", { count: orphanedProofs.length });
		return orphanedProofs.length;
	}
	/**
	* Get an operation by ID.
	*/
	async getOperation(operationId) {
		return this.sendOperationRepository.getById(operationId);
	}
	/**
	* Get all pending operations.
	*/
	async getPendingOperations() {
		return this.sendOperationRepository.getPending();
	}
};

//#endregion
//#region operations/melt/MeltOperation.ts
/**
* Check if operation has PreparedData (any state after init)
*/
function hasPreparedData$1(op) {
	return op.state !== "init";
}
/**
* Creates a new SendOperation in init state
*/
function createMeltOperation(id, mintUrl, meta) {
	const now = Date.now();
	return {
		...meta,
		id,
		state: "init",
		mintUrl,
		createdAt: now,
		updatedAt: now
	};
}

//#endregion
//#region operations/melt/MeltOperationService.ts
/**
* MeltOperationService orchestrates melt sagas while delegating
* method-specific behavior to MeltMethodHandlers.
*/
var MeltOperationService = class {
	handlerProvider;
	meltOperationRepository;
	proofRepository;
	proofService;
	mintService;
	walletService;
	mintAdapter;
	eventBus;
	logger;
	operationLocks = /* @__PURE__ */ new Map();
	recoveryLock = null;
	constructor(handlerProvider, meltOperationRepository, proofRepository, proofService, mintService, walletService, mintAdapter, eventBus, logger) {
		this.handlerProvider = handlerProvider;
		this.meltOperationRepository = meltOperationRepository;
		this.proofRepository = proofRepository;
		this.proofService = proofService;
		this.mintService = mintService;
		this.walletService = walletService;
		this.mintAdapter = mintAdapter;
		this.eventBus = eventBus;
		this.logger = logger;
	}
	buildDeps() {
		return {
			proofRepository: this.proofRepository,
			proofService: this.proofService,
			walletService: this.walletService,
			mintService: this.mintService,
			mintAdapter: this.mintAdapter,
			eventBus: this.eventBus,
			logger: this.logger
		};
	}
	async acquireOperationLock(operationId) {
		if (this.operationLocks.get(operationId)) throw new OperationInProgressError(operationId);
		let releaseLock;
		const lockPromise = new Promise((resolve) => {
			releaseLock = resolve;
		});
		this.operationLocks.set(operationId, lockPromise);
		return () => {
			this.operationLocks.delete(operationId);
			releaseLock();
		};
	}
	isOperationLocked(operationId) {
		return this.operationLocks.has(operationId);
	}
	isRecoveryInProgress() {
		return this.recoveryLock !== null;
	}
	async init(mintUrl, method, methodData) {
		if (!await this.mintService.isTrustedMint(mintUrl)) throw new UnknownMintError(`Mint ${mintUrl} is not trusted`);
		if (methodData.amountSats && (!Number.isFinite(methodData.amountSats) || methodData.amountSats <= 0)) throw new ProofValidationError("Amount must be a positive number");
		const id = generateSubId();
		const operation = createMeltOperation(id, mintUrl, {
			method,
			methodData
		});
		await this.meltOperationRepository.create(operation);
		this.logger?.debug("Melt operation created", {
			operationId: id,
			mintUrl,
			method
		});
		return operation;
	}
	/**
	* Prepare the operation by reserving proofs and creating outputs.
	* After this step, the operation can be executed or rolled back.
	*
	* If preparation fails, automatically attempts to recover the init operation.
	* Throws if the operation is already in progress.
	*/
	async prepare(operationId) {
		const releaseLock = await this.acquireOperationLock(operationId);
		try {
			const operation = await this.meltOperationRepository.getById(operationId);
			if (!operation || operation.state !== "init") throw new Error(`Cannot prepare operation ${operationId}: expected state 'init' but found '${operation?.state ?? "not found"}'`);
			const initOp = operation;
			try {
				const handler = this.handlerProvider.get(initOp.method);
				const { wallet } = await this.walletService.getWalletWithActiveKeysetId(initOp.mintUrl);
				const preparedOp = {
					...await handler.prepare({
						...this.buildDeps(),
						operation: initOp,
						wallet
					}),
					state: "prepared",
					updatedAt: Date.now()
				};
				await this.meltOperationRepository.update(preparedOp);
				await this.eventBus.emit("melt-op:prepared", {
					mintUrl: preparedOp.mintUrl,
					operationId: preparedOp.id,
					operation: preparedOp
				});
				this.logger?.info("Melt operation prepared", {
					operationId: preparedOp.id,
					method: preparedOp.method
				});
				return preparedOp;
			} catch (e) {
				await this.tryRecoverInitOperation(initOp);
				throw e;
			}
		} finally {
			releaseLock();
		}
	}
	/**
	* Execute the prepared operation.
	* Performs the melt (swap if needed) and processes the result.
	*
	* If execution fails after transitioning to 'executing' state,
	* automatically attempts to recover the operation.
	* Throws if the operation is already in progress.
	*/
	async execute(operationId) {
		const releaseLock = await this.acquireOperationLock(operationId);
		try {
			const operation = await this.meltOperationRepository.getById(operationId);
			if (!operation || operation.state !== "prepared") throw new Error(`Cannot execute operation ${operationId}: expected state 'prepared' but found '${operation?.state ?? "not found"}'`);
			const executing = {
				...operation,
				state: "executing",
				updatedAt: Date.now()
			};
			await this.meltOperationRepository.update(executing);
			try {
				const handler = this.handlerProvider.get(executing.method);
				const { wallet } = await this.walletService.getWalletWithActiveKeysetId(executing.mintUrl);
				const reservedProofs = (await this.proofRepository.getProofsByOperationId(executing.mintUrl, executing.id)).filter((p) => p.usedByOperationId === operationId);
				const result = await handler.execute({
					...this.buildDeps(),
					operation: executing,
					wallet,
					reservedProofs
				});
				switch (result.status) {
					case "PAID": {
						const finalizedOp = {
							...result.finalized,
							state: "finalized",
							updatedAt: Date.now()
						};
						await this.meltOperationRepository.update(finalizedOp);
						await this.eventBus.emit("melt-op:finalized", {
							mintUrl: finalizedOp.mintUrl,
							operationId: finalizedOp.id,
							operation: finalizedOp
						});
						this.logger?.info("Melt operation executing -> finalized (immediate)", {
							operationId: finalizedOp.id,
							method: finalizedOp.method
						});
						return finalizedOp;
					}
					case "PENDING": {
						const pendingOp = {
							...result.pending,
							state: "pending",
							updatedAt: Date.now()
						};
						await this.meltOperationRepository.update(pendingOp);
						await this.eventBus.emit("melt-op:pending", {
							mintUrl: pendingOp.mintUrl,
							operationId: pendingOp.id,
							operation: pendingOp
						});
						this.logger?.info("Melt operation executing -> pending", {
							operationId: pendingOp.id,
							method: pendingOp.method
						});
						return pendingOp;
					}
					case "FAILED": throw new Error(result.failed.error ?? "Melt execution failed");
				}
			} catch (e) {
				await this.tryRecoverExecutingOperation(executing);
				throw e;
			}
		} finally {
			releaseLock();
		}
	}
	async finalize(operationId) {
		const releaseLock = await this.acquireOperationLock(operationId);
		try {
			const operation = await this.meltOperationRepository.getById(operationId);
			if (!operation) throw new Error(`Operation ${operationId} not found`);
			if (operation.state === "finalized") {
				this.logger?.debug("Operation already finalized", { operationId });
				return;
			}
			if (operation.state === "rolled_back" || operation.state === "rolling_back") {
				this.logger?.debug("Operation was rolled back or is rolling back, skipping finalization", { operationId });
				return;
			}
			if (operation.state !== "pending") throw new Error(`Cannot finalize operation in state ${operation.state}`);
			const pendingOp = operation;
			await this.handlerProvider.get(pendingOp.method).finalize?.({
				...this.buildDeps(),
				operation: pendingOp
			});
			const finalized = {
				...pendingOp,
				state: "finalized",
				updatedAt: Date.now()
			};
			await this.meltOperationRepository.update(finalized);
			await this.eventBus.emit("melt-op:finalized", {
				mintUrl: pendingOp.mintUrl,
				operationId,
				operation: finalized
			});
			this.logger?.info("Melt operation finalized", { operationId });
		} finally {
			releaseLock();
		}
	}
	async rollback(operationId, reason = "Rolled back") {
		const releaseLock = await this.acquireOperationLock(operationId);
		try {
			const operation = await this.meltOperationRepository.getById(operationId);
			if (!operation) throw new Error(`Operation ${operationId} not found`);
			if (operation.state === "finalized" || operation.state === "rolled_back" || operation.state === "rolling_back" || operation.state === "init" || operation.state === "executing") throw new Error(`Cannot rollback operation in state ${operation.state}`);
			if (!hasPreparedData$1(operation)) throw new Error(`Operation ${operationId} is not in a rollbackable state`);
			const handler = this.handlerProvider.get(operation.method);
			const { wallet } = await this.walletService.getWalletWithActiveKeysetId(operation.mintUrl);
			if (operation.state === "pending") {
				const pendingOp = operation;
				const decision = await handler.checkPending?.({
					...this.buildDeps(),
					operation: pendingOp,
					wallet
				});
				if (decision !== "rollback") throw new Error(`Cannot rollback pending operation: quote state is not UNPAID (decision: ${decision})`);
			}
			let opForRollback = operation;
			const rolling = {
				...operation,
				state: "rolling_back",
				updatedAt: Date.now()
			};
			await this.meltOperationRepository.update(rolling);
			opForRollback = rolling;
			await handler.rollback?.({
				...this.buildDeps(),
				operation: opForRollback,
				wallet
			});
			await this.markAsRolledBack(opForRollback, reason);
		} finally {
			releaseLock();
		}
	}
	/**
	* Recover pending operations on startup.
	* This should be called during initialization.
	* Throws if recovery is already in progress.
	*/
	async recoverPendingOperations() {
		if (this.recoveryLock) throw new Error("Recovery is already in progress");
		let releaseRecoveryLock;
		this.recoveryLock = new Promise((resolve) => {
			releaseRecoveryLock = resolve;
		});
		try {
			let initCount = 0;
			let executingCount = 0;
			let pendingCount = 0;
			let rollingBackCount = 0;
			let orphanCount = 0;
			const initOps = await this.meltOperationRepository.getByState("init");
			for (const op of initOps) {
				await this.recoverInitOperation(op);
				initCount++;
			}
			const preparedOps = await this.meltOperationRepository.getByState("prepared");
			for (const op of preparedOps) this.logger?.warn("Found stale prepared operation, user can rollback manually", { operationId: op.id });
			const executingOps = await this.meltOperationRepository.getByState("executing");
			for (const op of executingOps) try {
				await this.recoverExecutingOperation(op);
				executingCount++;
			} catch (e) {
				this.logger?.error("Error recovering executing operation", {
					operationId: op.id,
					error: e instanceof Error ? e.message : String(e)
				});
			}
			const pendingOps = await this.meltOperationRepository.getByState("pending");
			for (const op of pendingOps) try {
				await this.checkPendingOperation(op.id);
				pendingCount++;
			} catch (e) {
				this.logger?.error("Error checking pending melt operation", {
					operationId: op.id,
					error: e instanceof Error ? e.message : String(e)
				});
			}
			const rollingBackOps = await this.meltOperationRepository.getByState("rolling_back");
			for (const op of rollingBackOps) {
				this.logger?.warn("Found operation stuck in rolling_back state. This indicates a crash during rollback. Manual recovery may be needed.", {
					operationId: op.id,
					mintUrl: op.mintUrl,
					method: op.method
				});
				rollingBackCount++;
			}
			this.logger?.info("Recovery completed", {
				initOperations: initCount,
				executingOperations: executingCount,
				pendingOperations: pendingCount,
				rollingBackOperations: rollingBackCount,
				orphanedReservations: orphanCount
			});
		} finally {
			this.recoveryLock = null;
			releaseRecoveryLock();
		}
	}
	async checkPendingOperation(operationId) {
		const op = await this.getOperation(operationId);
		if (!op || op.state !== "pending") throw new Error(`Cannot check operation ${operationId}: expected state 'pending' but found '${op?.state ?? "not found"}'`);
		const handler = this.handlerProvider.get(op.method);
		const { wallet } = await this.walletService.getWalletWithActiveKeysetId(op.mintUrl);
		const decision = await handler.checkPending?.({
			...this.buildDeps(),
			operation: op,
			wallet
		}) ?? "stay_pending";
		if (decision === "finalize") {
			await this.finalize(op.id);
			return "finalize";
		} else if (decision === "rollback") {
			await this.rollback(op.id, "Rollback requested by handler");
			return "rollback";
		} else {
			this.logger?.debug("Pending melt remains pending", { operationId: op.id });
			return "stay_pending";
		}
	}
	async markAsRolledBack(op, error) {
		const rolledBack = {
			...op,
			state: "rolled_back",
			updatedAt: Date.now(),
			error
		};
		await this.meltOperationRepository.update(rolledBack);
		await this.eventBus.emit("melt-op:rolled-back", {
			mintUrl: op.mintUrl,
			operationId: op.id,
			operation: rolledBack
		});
		this.logger?.info("Melt operation rolled back", {
			operationId: op.id,
			error
		});
		return rolledBack;
	}
	/**
	* Clean up a failed init operation.
	* Releases any orphaned proof reservations and deletes the operation.
	*/
	async recoverInitOperation(op) {
		const orphanedForOp = (await this.proofRepository.getReservedProofs()).filter((p) => p.usedByOperationId === op.id);
		if (orphanedForOp.length > 0) await this.proofService.releaseProofs(op.mintUrl, orphanedForOp.map((p) => p.secret));
		await this.meltOperationRepository.delete(op.id);
		this.logger?.info("Cleaned up failed init operation", { operationId: op.id });
	}
	/**
	* Attempts to recover an init operation, swallowing recovery errors.
	* If recovery fails, logs warning and leaves for startup recovery.
	*/
	async tryRecoverInitOperation(op) {
		try {
			await this.recoverInitOperation(op);
			this.logger?.info("Recovered init operation after failure", { operationId: op.id });
		} catch (recoveryError) {
			this.logger?.warn("Failed to recover init operation, will retry on next startup", {
				operationId: op.id,
				error: recoveryError instanceof Error ? recoveryError.message : String(recoveryError)
			});
		}
	}
	/**
	* Recover an executing operation.
	* Delegates to handler for proof cleanup and state determination.
	* Updates operation state based on handler result (finalized, pending, or failed).
	*/
	async recoverExecutingOperation(op) {
		const handler = this.handlerProvider.get(op.method);
		const { wallet } = await this.walletService.getWalletWithActiveKeysetId(op.mintUrl);
		const result = await handler.recoverExecuting({
			...this.buildDeps(),
			operation: op,
			wallet
		});
		switch (result.status) {
			case "PAID": {
				const finalizedOp = {
					...result.finalized,
					state: "finalized",
					updatedAt: Date.now()
				};
				await this.meltOperationRepository.update(finalizedOp);
				await this.eventBus.emit("melt-op:finalized", {
					mintUrl: finalizedOp.mintUrl,
					operationId: finalizedOp.id,
					operation: finalizedOp
				});
				this.logger?.info("Recovered executing operation as finalized", { operationId: op.id });
				break;
			}
			case "PENDING": {
				const pendingOp = {
					...result.pending,
					state: "pending",
					updatedAt: Date.now()
				};
				await this.meltOperationRepository.update(pendingOp);
				await this.eventBus.emit("melt-op:pending", {
					mintUrl: pendingOp.mintUrl,
					operationId: pendingOp.id,
					operation: pendingOp
				});
				this.logger?.info("Recovered executing operation as pending", { operationId: op.id });
				break;
			}
			case "FAILED":
				await this.markAsRolledBack(op, result.failed.error ?? "Recovered: operation failed");
				break;
		}
	}
	/**
	* Attempts to recover an executing operation, swallowing recovery errors.
	* If recovery fails (e.g., mint unreachable), logs warning and leaves
	* for startup recovery.
	*/
	async tryRecoverExecutingOperation(op) {
		try {
			await this.recoverExecutingOperation(op);
			this.logger?.info("Recovered executing operation after failure", { operationId: op.id });
		} catch (recoveryError) {
			this.logger?.warn("Failed to recover executing operation, will retry on next startup", {
				operationId: op.id,
				error: recoveryError instanceof Error ? recoveryError.message : String(recoveryError)
			});
		}
	}
	async getOperation(operationId) {
		return this.meltOperationRepository.getById(operationId);
	}
	async getOperationByQuote(mintUrl, quoteId) {
		const matching = (await this.meltOperationRepository.getByQuoteId(mintUrl, quoteId)).filter((operation) => hasPreparedData$1(operation));
		if (matching.length === 0) return null;
		if (matching.length > 1) throw new Error(`Found ${matching.length} melt operations for mint ${mintUrl} and quote ${quoteId}`);
		return matching[0];
	}
	async getPendingOperations() {
		return this.meltOperationRepository.getPending();
	}
};

//#endregion
//#region infra/MintAdapter.ts
/**
* Adapter for making HTTP requests to Cashu mints.
*
* All requests are rate-limited through the MintRequestProvider,
* sharing the same rate limits with other components (e.g., WalletService).
*/
var MintAdapter = class {
	cashuMints = {};
	requestProvider;
	constructor(requestProvider) {
		this.requestProvider = requestProvider;
	}
	async fetchMintInfo(mintUrl) {
		return await this.getCashuMint(mintUrl).getInfo();
	}
	async fetchKeysets(mintUrl) {
		return await this.getCashuMint(mintUrl).getKeySets();
	}
	async fetchKeysForId(mintUrl, id) {
		const { keysets } = await this.getCashuMint(mintUrl).getKeys(id);
		if (keysets.length !== 1 || !keysets[0]) throw new Error(`Expected 1 keyset for ${id}, got ${keysets.length}`);
		return keysets[0].keys;
	}
	getCashuMint(mintUrl) {
		if (!this.cashuMints[mintUrl]) {
			const requestFn = this.requestProvider.getRequestFn(mintUrl);
			this.cashuMints[mintUrl] = new Mint(mintUrl, { customRequest: requestFn });
		}
		return this.cashuMints[mintUrl];
	}
	async checkMintQuoteState(mintUrl, quoteId) {
		return await this.getCashuMint(mintUrl).checkMintQuoteBolt11(quoteId);
	}
	async checkMeltQuote(mintUrl, quoteId) {
		return await this.getCashuMint(mintUrl).checkMeltQuoteBolt11(quoteId);
	}
	async checkMeltQuoteState(mintUrl, quoteId) {
		return (await this.checkMeltQuote(mintUrl, quoteId)).state;
	}
	async checkProofStates(mintUrl, Ys) {
		const cashuMint = this.getCashuMint(mintUrl);
		const payload = { Ys };
		return (await cashuMint.check(payload)).states;
	}
	async customMeltBolt11(mintUrl, proofsToSend, changeOutputs, quoteId) {
		const cashuMint = this.getCashuMint(mintUrl);
		const blindedMessages = changeOutputs.map((output) => output.blindedMessage);
		return cashuMint.meltBolt11({
			quote: quoteId,
			inputs: proofsToSend,
			outputs: blindedMessages
		});
	}
	async customMeltBolt12(mintUrl, proofsToSend, changeOutputs, quoteId) {
		const cashuMint = this.getCashuMint(mintUrl);
		const blindedMessages = changeOutputs.map((output) => output.blindedMessage);
		return cashuMint.meltBolt12({
			quote: quoteId,
			inputs: proofsToSend,
			outputs: blindedMessages
		});
	}
};

//#endregion
//#region infra/RequestRateLimiter.ts
/**
* Token-bucket based request rate limiter that exposes a request-compatible API
* for the cashu-ts `_customRequest` parameter.
*
* - Token capacity determines max burst size.
* - Tokens refill continuously based on `refillPerMinute`.
* - Paths starting with any configured prefix are not throttled.
* - Requests are queued FIFO when tokens are exhausted.
*/
var RequestRateLimiter = class {
	capacity;
	refillPerMinute;
	tokens;
	lastRefillAt;
	bypassPathPrefixes;
	logger;
	queue = [];
	processingTimer = null;
	constructor(options) {
		this.capacity = Math.max(1, options?.capacity ?? 25);
		this.refillPerMinute = Math.max(1, options?.refillPerMinute ?? 25);
		this.tokens = this.capacity;
		this.lastRefillAt = Date.now();
		this.bypassPathPrefixes = options?.bypassPathPrefixes ?? [];
		this.logger = options?.logger;
	}
	/**
	* The request function compatible with cashu-ts's `request(options)` signature.
	* It uses the global fetch under the hood.
	*/
	request = async (options) => {
		const url = new URL(options.endpoint);
		if (this.shouldBypass(url.pathname)) return this.performFetch(options);
		await this.acquireToken();
		try {
			return await this.performFetch(options);
		} finally {
			this.scheduleProcessingIfNeeded();
		}
	};
	shouldBypass(pathname) {
		if (!this.bypassPathPrefixes.length) return false;
		return this.bypassPathPrefixes.some((p) => pathname.startsWith(p));
	}
	performFetch = async (options) => {
		const { endpoint, requestBody, headers, ...init } = options;
		const finalHeaders = new Headers({
			Accept: "application/json, text/plain, */*",
			...headers || {}
		});
		let body = void 0;
		if (requestBody !== void 0) {
			finalHeaders.set("Content-Type", "application/json");
			body = JSON.stringify(requestBody);
		}
		this.logger?.debug("Mint request", {
			method: init.method || "GET",
			endpoint,
			requestBody: requestBody ? JSON.stringify(requestBody, null, 2) : void 0
		});
		let response;
		try {
			response = await fetch(endpoint, {
				...init,
				headers: finalHeaders,
				body
			});
		} catch (err) {
			this.logger?.debug("Mint request network error", {
				endpoint,
				error: err instanceof Error ? err.message : String(err)
			});
			throw new NetworkError(err instanceof Error ? err.message : "Network request failed");
		}
		if (!response.ok) {
			let errorData = { error: "bad response" };
			try {
				errorData = await response.clone().json();
			} catch {}
			this.logger?.debug("Mint response error", {
				endpoint,
				status: response.status,
				errorData: JSON.stringify(errorData, null, 2)
			});
			if (response.status === 400 && errorData && typeof errorData.code === "number" && typeof errorData.detail === "string") {
				const { code, detail } = errorData;
				throw new MintOperationError(code, detail);
			}
			let errorMessage = "HTTP request failed";
			const anyErr = errorData;
			if (typeof anyErr?.error === "string") errorMessage = anyErr.error;
			else if (typeof anyErr?.detail === "string") errorMessage = anyErr.detail;
			throw new HttpResponseError(errorMessage, response.status);
		}
		try {
			const responseData = await response.json();
			this.logger?.debug("Mint response success", {
				endpoint,
				status: response.status,
				responseData: JSON.stringify(responseData, null, 2)
			});
			return responseData;
		} catch (err) {
			this.logger?.error("Failed to parse HTTP response", err);
			throw new HttpResponseError("bad response", response.status);
		}
	};
	acquireToken() {
		this.refillTokens();
		if (this.tokens >= 1) {
			this.tokens -= 1;
			this.logger?.debug("RateLimiter token granted immediately", {
				tokens: this.tokens,
				capacity: this.capacity
			});
			return Promise.resolve();
		}
		return new Promise((resolve) => {
			this.queue.push(() => {
				resolve();
			});
			this.logger?.debug("Queued request due to empty bucket", { queueLength: this.queue.length });
			this.scheduleProcessingIfNeeded();
		});
	}
	scheduleProcessingIfNeeded() {
		if (this.processingTimer) return;
		const delayMs = this.msUntilNextToken();
		this.processingTimer = setTimeout(() => {
			this.processingTimer = null;
			this.processQueue();
		}, delayMs);
	}
	processQueue() {
		this.refillTokens();
		while (this.tokens >= 1 && this.queue.length > 0) {
			const next = this.queue.shift();
			if (!next) continue;
			this.tokens -= 1;
			try {
				next();
			} catch (err) {
				this.logger?.error("RateLimiter queue task error", err);
			}
		}
		if (this.queue.length > 0) this.scheduleProcessingIfNeeded();
	}
	refillTokens() {
		const now = Date.now();
		const elapsedMs = now - this.lastRefillAt;
		if (elapsedMs <= 0) return;
		const refill = elapsedMs * (this.refillPerMinute / 6e4);
		const newTokens = Math.min(this.capacity, this.tokens + refill);
		if (newTokens !== this.tokens) {
			this.tokens = newTokens;
			this.lastRefillAt = now;
		} else this.lastRefillAt = now;
	}
	msUntilNextToken() {
		this.refillTokens();
		if (this.tokens >= 1) return 0;
		const tokensPerMs = this.refillPerMinute / 6e4;
		const deficit = 1 - this.tokens;
		return Math.max(1, Math.ceil(deficit / tokensPerMs));
	}
};

//#endregion
//#region infra/MintRequestProvider.ts
/**
* Manages per-mint request rate limiters.
*
* This class provides a centralized way to share rate limiters across
* all components that need to make HTTP requests to mints (WalletService,
* MintAdapter, etc.).
*/
var MintRequestProvider = class {
	limiters = /* @__PURE__ */ new Map();
	options;
	constructor(options) {
		this.options = {
			capacity: options?.capacity ?? 20,
			refillPerMinute: options?.refillPerMinute ?? 20,
			bypassPathPrefixes: options?.bypassPathPrefixes ?? [],
			configForMint: options?.configForMint,
			logger: options?.logger
		};
	}
	/**
	* Get the request function for a specific mint.
	* Creates a new rate limiter if one doesn't exist for this mint.
	*/
	getRequestFn(mintUrl) {
		return this.getOrCreateLimiter(mintUrl).request;
	}
	/**
	* Get or create a rate limiter for a specific mint.
	*/
	getOrCreateLimiter(mintUrl) {
		const existing = this.limiters.get(mintUrl);
		if (existing) return existing;
		const perMintConfig = this.options.configForMint?.(mintUrl) ?? {};
		const limiter = new RequestRateLimiter({
			capacity: perMintConfig.capacity ?? this.options.capacity,
			refillPerMinute: perMintConfig.refillPerMinute ?? this.options.refillPerMinute,
			bypassPathPrefixes: perMintConfig.bypassPathPrefixes ?? this.options.bypassPathPrefixes,
			logger: this.options.logger?.child ? this.options.logger.child({
				module: "RequestRateLimiter",
				mintUrl
			}) : this.options.logger
		});
		this.limiters.set(mintUrl, limiter);
		return limiter;
	}
	/**
	* Clear the rate limiter for a specific mint.
	*/
	clearMint(mintUrl) {
		this.limiters.delete(mintUrl);
	}
	/**
	* Clear all rate limiters.
	*/
	clearAll() {
		this.limiters.clear();
	}
};

//#endregion
//#region infra/PollingTransport.ts
var PollingTransport = class {
	logger;
	mintAdapter;
	options;
	listenersByMint = /* @__PURE__ */ new Map();
	schedByMint = /* @__PURE__ */ new Map();
	proofQueueByMint = /* @__PURE__ */ new Map();
	proofSetByMint = /* @__PURE__ */ new Map();
	yToSubsByMint = /* @__PURE__ */ new Map();
	subToYsByMint = /* @__PURE__ */ new Map();
	intervalByMint = /* @__PURE__ */ new Map();
	unsubscribedByMint = /* @__PURE__ */ new Map();
	paused = false;
	constructor(mintAdapter, options, logger) {
		this.logger = logger;
		this.mintAdapter = mintAdapter;
		this.options = { intervalMs: options?.intervalMs ?? 5e3 };
	}
	on(mintUrl, event, handler) {
		let map = this.listenersByMint.get(mintUrl);
		if (!map) {
			map = /* @__PURE__ */ new Map();
			this.listenersByMint.set(mintUrl, map);
		}
		let set = map.get(event);
		if (!set) {
			set = /* @__PURE__ */ new Set();
			map.set(event, set);
		}
		if (!set.has(handler)) set.add(handler);
		if (event === "open") {
			if (!((map.get("open")?.size ?? 0) > 0)) queueMicrotask(() => {
				try {
					handler({ type: "open" });
				} catch {}
			});
		}
		this.ensureScheduler(mintUrl);
	}
	send(mintUrl, req) {
		if (req.method === "subscribe") {
			const params = req.params;
			const subId = params.subId;
			const scheduler = this.ensureScheduler(mintUrl);
			if (params.kind === "proof_state") {
				const ys = params.filters || [];
				if (!ys.length) this.logger?.error("PollingTransport: subscribe proof_state with no filters", {
					mintUrl,
					req
				});
				let yToSubs = this.yToSubsByMint.get(mintUrl);
				if (!yToSubs) {
					yToSubs = /* @__PURE__ */ new Map();
					this.yToSubsByMint.set(mintUrl, yToSubs);
				}
				let subToYs = this.subToYsByMint.get(mintUrl);
				if (!subToYs) {
					subToYs = /* @__PURE__ */ new Map();
					this.subToYsByMint.set(mintUrl, subToYs);
				}
				let q = this.proofQueueByMint.get(mintUrl);
				if (!q) {
					q = [];
					this.proofQueueByMint.set(mintUrl, q);
				}
				let set = this.proofSetByMint.get(mintUrl);
				if (!set) {
					set = /* @__PURE__ */ new Set();
					this.proofSetByMint.set(mintUrl, set);
				}
				let subYs = subToYs.get(subId);
				if (!subYs) {
					subYs = /* @__PURE__ */ new Set();
					subToYs.set(subId, subYs);
				}
				for (const y of ys) {
					subYs.add(y);
					let subs = yToSubs.get(y);
					if (!subs) {
						subs = /* @__PURE__ */ new Set();
						yToSubs.set(y, subs);
					}
					subs.add(subId);
					if (!set.has(y)) {
						set.add(y);
						q.push(y);
					}
				}
				if (!scheduler.hasProofBatchTask) {
					scheduler.queue.push({
						kind: "proof_state",
						batch: true
					});
					scheduler.hasProofBatchTask = true;
				}
			} else {
				const filter = params.filters[0];
				if (!filter) {
					this.logger?.error("PollingTransport: subscribe with no filter", {
						mintUrl,
						req
					});
					return;
				}
				scheduler.queue.push({
					subId,
					kind: params.kind,
					filter
				});
			}
			const resp = {
				jsonrpc: "2.0",
				result: {
					status: "OK",
					subId
				},
				id: req.id
			};
			this.emit(mintUrl, "message", { data: JSON.stringify(resp) });
			this.maybeRun(mintUrl);
			return;
		}
		if (req.method === "unsubscribe") {
			const subId = req.params.subId;
			const scheduler = this.ensureScheduler(mintUrl);
			scheduler.queue = scheduler.queue.filter((t) => t.subId !== subId);
			let unsubscribed = this.unsubscribedByMint.get(mintUrl);
			if (!unsubscribed) {
				unsubscribed = /* @__PURE__ */ new Set();
				this.unsubscribedByMint.set(mintUrl, unsubscribed);
			}
			unsubscribed.add(subId);
			const subToYs = this.subToYsByMint.get(mintUrl);
			const yToSubs = this.yToSubsByMint.get(mintUrl);
			const q = this.proofQueueByMint.get(mintUrl);
			const set = this.proofSetByMint.get(mintUrl);
			if (subToYs && yToSubs) {
				const ys = subToYs.get(subId);
				if (ys) {
					for (const y of ys) {
						const subs = yToSubs.get(y);
						if (subs) {
							subs.delete(subId);
							if (subs.size === 0) {
								yToSubs.delete(y);
								if (set) set.delete(y);
								if (q) {
									const idx = q.indexOf(y);
									if (idx >= 0) q.splice(idx, 1);
								}
							}
						}
					}
					subToYs.delete(subId);
				}
				if (yToSubs.size === 0 && scheduler.hasProofBatchTask) {
					scheduler.queue = scheduler.queue.filter((t) => !(t.kind === "proof_state" && t.batch));
					scheduler.hasProofBatchTask = false;
				}
			}
			return;
		}
	}
	closeAll() {
		this.schedByMint.clear();
		this.listenersByMint.clear();
		this.proofQueueByMint.clear();
		this.proofSetByMint.clear();
		this.yToSubsByMint.clear();
		this.subToYsByMint.clear();
		this.intervalByMint.clear();
		this.unsubscribedByMint.clear();
	}
	closeMint(mintUrl) {
		this.schedByMint.delete(mintUrl);
		this.listenersByMint.delete(mintUrl);
		this.proofQueueByMint.delete(mintUrl);
		this.proofSetByMint.delete(mintUrl);
		this.yToSubsByMint.delete(mintUrl);
		this.subToYsByMint.delete(mintUrl);
		this.intervalByMint.delete(mintUrl);
		this.unsubscribedByMint.delete(mintUrl);
	}
	pause() {
		this.paused = true;
	}
	resume() {
		this.paused = false;
		for (const mintUrl of this.schedByMint.keys()) this.maybeRun(mintUrl);
	}
	/**
	* Set a custom polling interval for a specific mint.
	* If not set, the default interval from constructor options is used.
	*/
	setIntervalForMint(mintUrl, intervalMs) {
		this.intervalByMint.set(mintUrl, intervalMs);
	}
	/**
	* Get the polling interval for a mint (per-mint or default).
	*/
	getIntervalForMint(mintUrl) {
		return this.intervalByMint.get(mintUrl) ?? this.options.intervalMs;
	}
	ensureScheduler(mintUrl) {
		let s = this.schedByMint.get(mintUrl);
		if (!s) {
			s = {
				nextAllowedAt: 0,
				queue: [],
				running: false,
				hasProofBatchTask: false
			};
			this.schedByMint.set(mintUrl, s);
			if (!this.proofQueueByMint.get(mintUrl)) this.proofQueueByMint.set(mintUrl, []);
			if (!this.proofSetByMint.get(mintUrl)) this.proofSetByMint.set(mintUrl, /* @__PURE__ */ new Set());
			if (!this.yToSubsByMint.get(mintUrl)) this.yToSubsByMint.set(mintUrl, /* @__PURE__ */ new Map());
			if (!this.subToYsByMint.get(mintUrl)) this.subToYsByMint.set(mintUrl, /* @__PURE__ */ new Map());
		}
		return s;
	}
	async maybeRun(mintUrl) {
		if (this.paused) return;
		const s = this.ensureScheduler(mintUrl);
		if (s.running) return;
		if (Date.now() < s.nextAllowedAt) return;
		if (s.queue.length === 0) return;
		s.running = true;
		const task = s.queue.shift();
		try {
			await this.performTask(mintUrl, task);
			const unsubscribed = this.unsubscribedByMint.get(mintUrl);
			if (task.subId && unsubscribed?.has(task.subId)) unsubscribed.delete(task.subId);
			else s.queue.push(task);
		} catch (err) {
			this.logger?.error("Polling task error", {
				mintUrl,
				err
			});
		} finally {
			s.nextAllowedAt = Date.now() + this.getIntervalForMint(mintUrl);
			s.running = false;
			const delay = Math.max(0, s.nextAllowedAt - Date.now());
			setTimeout(() => {
				this.maybeRun(mintUrl);
			}, delay);
		}
	}
	async performTask(mintUrl, task) {
		if (task.kind === "proof_state" && task.batch) {
			const yToSubs = this.yToSubsByMint.get(mintUrl) ?? /* @__PURE__ */ new Map();
			const queue = this.proofQueueByMint.get(mintUrl) ?? [];
			if (queue.length === 0 || yToSubs.size === 0) return;
			const selected = [];
			while (selected.length < 100 && queue.length > 0) {
				const y = queue.shift();
				const subs = yToSubs.get(y);
				if (subs && subs.size > 0) {
					selected.push(y);
					queue.push(y);
				} else {
					const set = this.proofSetByMint.get(mintUrl);
					if (set) set.delete(y);
				}
			}
			if (selected.length === 0) return;
			const results = await this.mintAdapter.checkProofStates(mintUrl, selected);
			for (let i = 0; i < results.length; i++) {
				const payload = results[i];
				const y = (payload && typeof payload.Y === "string" ? payload.Y : void 0) ?? selected[i] ?? "";
				if (!y) continue;
				const subs = yToSubs.get(y);
				if (!subs) continue;
				for (const subId of subs.values()) {
					const notification = {
						jsonrpc: "2.0",
						method: "subscribe",
						params: {
							subId,
							payload
						}
					};
					this.emit(mintUrl, "message", { data: JSON.stringify(notification) });
				}
			}
			return;
		}
		let payload;
		switch (task.kind) {
			case "bolt11_mint_quote":
				payload = await this.mintAdapter.checkMintQuoteState(mintUrl, task.filter);
				break;
			case "bolt11_melt_quote":
				payload = await this.mintAdapter.checkMeltQuoteState(mintUrl, task.filter);
				break;
			default: return;
		}
		const notification = {
			jsonrpc: "2.0",
			method: "subscribe",
			params: {
				subId: task.subId,
				payload
			}
		};
		this.emit(mintUrl, "message", { data: JSON.stringify(notification) });
	}
	emit(mintUrl, event, evt) {
		const set = this.listenersByMint.get(mintUrl)?.get(event);
		if (!set) return;
		for (const handler of set.values()) try {
			handler(evt);
		} catch {}
	}
};

//#endregion
//#region infra/WsConnectionManager.ts
var WsConnectionManager = class {
	sockets = /* @__PURE__ */ new Map();
	isOpenByMint = /* @__PURE__ */ new Map();
	sendQueueByMint = /* @__PURE__ */ new Map();
	logger;
	listenersByMint = /* @__PURE__ */ new Map();
	reconnectAttemptsByMint = /* @__PURE__ */ new Map();
	reconnectTimeoutByMint = /* @__PURE__ */ new Map();
	options;
	paused = false;
	constructor(wsFactory, logger, options) {
		this.wsFactory = wsFactory;
		this.logger = logger;
		this.options = { disableReconnect: options?.disableReconnect ?? false };
	}
	buildWsUrl(baseMintUrl) {
		const url = new URL(baseMintUrl);
		url.protocol = url.protocol === "https:" ? "wss:" : "ws:";
		url.pathname = `${url.pathname.endsWith("/") ? url.pathname.slice(0, -1) : url.pathname}/v1/ws`;
		return url.toString();
	}
	ensureSocket(mintUrl) {
		const existing = this.sockets.get(mintUrl);
		if (existing) return existing;
		const wsUrl = this.buildWsUrl(mintUrl);
		const socket = this.wsFactory(wsUrl);
		this.sockets.set(mintUrl, socket);
		this.isOpenByMint.set(mintUrl, false);
		const onOpen = () => {
			this.isOpenByMint.set(mintUrl, true);
			const pending = this.reconnectTimeoutByMint.get(mintUrl);
			if (pending) {
				clearTimeout(pending);
				this.reconnectTimeoutByMint.delete(mintUrl);
			}
			this.reconnectAttemptsByMint.delete(mintUrl);
			const queue = this.sendQueueByMint.get(mintUrl);
			if (queue && queue.length > 0) {
				this.logger?.debug("Flushing queued messages", {
					mintUrl,
					count: queue.length
				});
				for (const payload of queue) try {
					socket.send(payload);
					this.logger?.debug("Sent queued message", {
						mintUrl,
						payloadLength: payload.length
					});
				} catch (err) {
					this.logger?.error("WS send error while flushing queue", {
						mintUrl,
						err
					});
				}
				this.sendQueueByMint.set(mintUrl, []);
			}
			this.logger?.info("WS opened", { mintUrl });
		};
		const onError = (err) => {
			this.logger?.error("WS error", {
				mintUrl,
				err
			});
		};
		const onClose = () => {
			this.logger?.info("WS closed", { mintUrl });
			this.sockets.delete(mintUrl);
			this.isOpenByMint.set(mintUrl, false);
			this.sendQueueByMint.delete(mintUrl);
			if (!this.paused && !this.options.disableReconnect) {
				const hasListeners = this.listenersByMint.get(mintUrl);
				if (hasListeners && Array.from(hasListeners.values()).some((s) => s.size > 0)) this.scheduleReconnect(mintUrl);
			}
		};
		socket.addEventListener("open", onOpen);
		socket.addEventListener("error", onError);
		socket.addEventListener("close", onClose);
		const map = this.listenersByMint.get(mintUrl);
		if (map) for (const [type, set] of map.entries()) for (const listener of set.values()) socket.addEventListener(type, listener);
		return socket;
	}
	scheduleReconnect(mintUrl) {
		if (this.reconnectTimeoutByMint.get(mintUrl)) return;
		const attempt = (this.reconnectAttemptsByMint.get(mintUrl) ?? 0) + 1;
		this.reconnectAttemptsByMint.set(mintUrl, attempt);
		const delayMs = Math.min(3e4, 1e3 * 2 ** Math.min(6, attempt - 1));
		this.logger?.info("Scheduling WS reconnect", {
			mintUrl,
			attempt,
			delayMs
		});
		const timeoutId = setTimeout(() => {
			this.reconnectTimeoutByMint.delete(mintUrl);
			try {
				this.ensureSocket(mintUrl);
			} catch (err) {
				this.logger?.error("WS reconnect attempt failed to create socket", {
					mintUrl,
					err
				});
			}
		}, delayMs);
		this.reconnectTimeoutByMint.set(mintUrl, timeoutId);
	}
	on(mintUrl, type, listener) {
		const socketExists = this.sockets.has(mintUrl);
		let map = this.listenersByMint.get(mintUrl);
		if (!map) {
			map = /* @__PURE__ */ new Map();
			this.listenersByMint.set(mintUrl, map);
		}
		let set = map.get(type);
		if (!set) {
			set = /* @__PURE__ */ new Set();
			map.set(type, set);
		}
		if (set.has(listener)) return;
		set.add(listener);
		const socket = this.ensureSocket(mintUrl);
		if (socketExists) socket.addEventListener(type, listener);
	}
	off(mintUrl, type, listener) {
		this.ensureSocket(mintUrl).removeEventListener(type, listener);
		(this.listenersByMint.get(mintUrl)?.get(type))?.delete(listener);
	}
	send(mintUrl, message) {
		const socket = this.ensureSocket(mintUrl);
		const payload = typeof message === "string" ? message : JSON.stringify(message);
		if (this.isOpenByMint.get(mintUrl)) {
			try {
				socket.send(payload);
				this.logger?.debug("Sent message immediately (socket open)", {
					mintUrl,
					payloadLength: payload.length
				});
			} catch (err) {
				this.logger?.error("WS send error", {
					mintUrl,
					err
				});
			}
			return;
		}
		let queue = this.sendQueueByMint.get(mintUrl);
		if (!queue) {
			queue = [];
			this.sendQueueByMint.set(mintUrl, queue);
		}
		queue.push(payload);
		this.logger?.debug("Queued message (socket not open)", {
			mintUrl,
			queueLength: queue.length,
			payloadLength: payload.length
		});
	}
	closeAll() {
		for (const [mintUrl, socket] of this.sockets.entries()) try {
			socket.close(1e3, "Normal Closure");
		} catch (err) {
			this.logger?.warn("Error while closing WS", {
				mintUrl,
				err
			});
		}
		this.sockets.clear();
		this.isOpenByMint.clear();
		this.sendQueueByMint.clear();
		for (const timeout of this.reconnectTimeoutByMint.values()) clearTimeout(timeout);
		this.reconnectTimeoutByMint.clear();
		this.reconnectAttemptsByMint.clear();
	}
	closeMint(mintUrl) {
		const socket = this.sockets.get(mintUrl);
		if (socket) {
			try {
				socket.close(1e3, "Mint closed");
				this.logger?.debug("WS closed for mint", { mintUrl });
			} catch (err) {
				this.logger?.warn("Error while closing WS for mint", {
					mintUrl,
					err
				});
			}
			this.sockets.delete(mintUrl);
		}
		this.isOpenByMint.delete(mintUrl);
		this.sendQueueByMint.delete(mintUrl);
		this.listenersByMint.delete(mintUrl);
		const timeout = this.reconnectTimeoutByMint.get(mintUrl);
		if (timeout) {
			clearTimeout(timeout);
			this.reconnectTimeoutByMint.delete(mintUrl);
		}
		this.reconnectAttemptsByMint.delete(mintUrl);
		this.logger?.info("WsConnectionManager closed mint", { mintUrl });
	}
	pause() {
		this.paused = true;
		for (const timeout of this.reconnectTimeoutByMint.values()) clearTimeout(timeout);
		this.reconnectTimeoutByMint.clear();
		this.reconnectAttemptsByMint.clear();
		for (const [mintUrl, socket] of this.sockets.entries()) try {
			socket.close(1e3, "Paused");
			this.logger?.debug("WS closed for pause", { mintUrl });
		} catch (err) {
			this.logger?.warn("Error while closing WS for pause", {
				mintUrl,
				err
			});
		}
		this.sockets.clear();
		this.isOpenByMint.clear();
		this.sendQueueByMint.clear();
		this.logger?.info("WsConnectionManager paused");
	}
	resume() {
		this.paused = false;
		for (const [mintUrl, listenerMap] of this.listenersByMint.entries()) if (Array.from(listenerMap.values()).some((s) => s.size > 0)) try {
			this.ensureSocket(mintUrl);
			this.logger?.debug("WS reconnecting after resume", { mintUrl });
		} catch (err) {
			this.logger?.error("Failed to reconnect WS after resume", {
				mintUrl,
				err
			});
		}
		this.logger?.info("WsConnectionManager resumed");
	}
};

//#endregion
//#region infra/WsTransport.ts
var WsTransport = class {
	ws;
	constructor(wsFactoryOrManager, logger, options) {
		this.ws = typeof wsFactoryOrManager === "function" ? new WsConnectionManager(wsFactoryOrManager, logger, options) : wsFactoryOrManager;
	}
	on(mintUrl, event, handler) {
		this.ws.on(mintUrl, event, handler);
	}
	send(mintUrl, req) {
		this.ws.send(mintUrl, req);
	}
	closeAll() {
		this.ws.closeAll();
	}
	closeMint(mintUrl) {
		this.ws.closeMint(mintUrl);
	}
	pause() {
		this.ws.pause();
	}
	resume() {
		this.ws.resume();
	}
};

//#endregion
//#region infra/HybridTransport.ts
/**
* HybridTransport runs both WebSocket and polling transports in parallel.
*
* - WebSocket: Primary transport for real-time updates. One-shot per mintno reconnection on failure.
* - Polling: Backup transport always running. Starts slow (20s), speeds up (5s) if WS fails.
* - Deduplication: Both transports emit the same notifications, so we deduplicate at this layer.
*/
var HybridTransport = class {
	wsTransport;
	pollingTransport;
	logger;
	options;
	wsFailedByMint = /* @__PURE__ */ new Set();
	wsConnectedByMint = /* @__PURE__ */ new Set();
	hasInternalHandlersByMint = /* @__PURE__ */ new Set();
	lastStateByKey = /* @__PURE__ */ new Map();
	hasEmittedOpenByMint = /* @__PURE__ */ new Set();
	paused = false;
	constructor(wsFactory, mintAdapter, options, logger) {
		this.logger = logger;
		this.options = {
			slowPollingIntervalMs: options?.slowPollingIntervalMs ?? 2e4,
			fastPollingIntervalMs: options?.fastPollingIntervalMs ?? 5e3
		};
		this.wsTransport = new WsTransport(wsFactory, logger, { disableReconnect: true });
		this.pollingTransport = new PollingTransport(mintAdapter, { intervalMs: this.options.slowPollingIntervalMs }, logger);
	}
	on(mintUrl, event, handler) {
		const wrappedHandler = this.createDedupeHandler(mintUrl, event, handler);
		this.wsTransport.on(mintUrl, event, wrappedHandler);
		this.pollingTransport.on(mintUrl, event, wrappedHandler);
		this.ensureInternalHandlers(mintUrl);
	}
	send(mintUrl, req) {
		this.wsTransport.send(mintUrl, req);
		this.pollingTransport.send(mintUrl, req);
	}
	closeAll() {
		this.wsTransport.closeAll();
		this.pollingTransport.closeAll();
		this.wsFailedByMint.clear();
		this.wsConnectedByMint.clear();
		this.hasInternalHandlersByMint.clear();
		this.lastStateByKey.clear();
		this.hasEmittedOpenByMint.clear();
	}
	closeMint(mintUrl) {
		this.wsTransport.closeMint(mintUrl);
		this.pollingTransport.closeMint(mintUrl);
		this.wsFailedByMint.delete(mintUrl);
		this.wsConnectedByMint.delete(mintUrl);
		this.hasInternalHandlersByMint.delete(mintUrl);
		this.hasEmittedOpenByMint.delete(mintUrl);
		for (const key of this.lastStateByKey.keys()) if (key.startsWith(`${mintUrl}::`)) this.lastStateByKey.delete(key);
	}
	pause() {
		this.paused = true;
		this.wsTransport.pause();
		this.pollingTransport.pause();
		this.wsFailedByMint.clear();
		this.wsConnectedByMint.clear();
		this.hasEmittedOpenByMint.clear();
	}
	resume() {
		this.paused = false;
		this.wsTransport.resume();
		this.pollingTransport.resume();
	}
	/**
	* Register internal handlers on WsTransport to track connection state.
	* Only registers once per mint.
	*/
	ensureInternalHandlers(mintUrl) {
		if (this.hasInternalHandlersByMint.has(mintUrl)) return;
		this.hasInternalHandlersByMint.add(mintUrl);
		this.wsTransport.on(mintUrl, "open", () => {
			this.wsConnectedByMint.add(mintUrl);
		});
		this.wsTransport.on(mintUrl, "close", () => {
			this.handleWsFailure(mintUrl);
		});
	}
	/**
	* Handle WS failure - mark as failed and speed up polling.
	*/
	handleWsFailure(mintUrl) {
		if (this.paused) return;
		if (this.wsFailedByMint.has(mintUrl)) return;
		this.wsFailedByMint.add(mintUrl);
		this.updatePollingInterval(mintUrl);
		this.logger?.info("HybridTransport: WS failed, polling will compensate", { mintUrl });
	}
	/**
	* Speed up polling for a mint after WS failure.
	*/
	updatePollingInterval(mintUrl) {
		this.pollingTransport.setIntervalForMint(mintUrl, this.options.fastPollingIntervalMs);
	}
	/**
	* Create a handler wrapper that deduplicates events.
	*/
	createDedupeHandler(mintUrl, event, originalHandler) {
		return (evt) => {
			if (event === "open") {
				if (this.hasEmittedOpenByMint.has(mintUrl)) return;
				this.hasEmittedOpenByMint.add(mintUrl);
				originalHandler(evt);
				return;
			}
			if (event === "close" || event === "error") {
				originalHandler(evt);
				return;
			}
			try {
				const data = typeof evt.data === "string" ? evt.data : evt.data?.toString?.();
				if (!data) {
					originalHandler(evt);
					return;
				}
				const parsed = JSON.parse(data);
				if (parsed.method !== "subscribe") {
					originalHandler(evt);
					return;
				}
				const key = this.getStateKey(mintUrl, parsed);
				const stateJson = JSON.stringify(parsed.params?.payload?.state);
				if (this.lastStateByKey.get(key) === stateJson) return;
				this.lastStateByKey.set(key, stateJson);
				originalHandler(evt);
			} catch {
				originalHandler(evt);
			}
		};
	}
	/**
	* Generate a deduplication key for a notification.
	* Includes mintUrl, subId, and identifier (Y for proofs, quote for quotes).
	*/
	getStateKey(mintUrl, notification) {
		const subId = notification.params?.subId ?? "";
		const payload = notification.params?.payload;
		return `${mintUrl}::${subId}::${payload?.Y ?? payload?.quote ?? ""}`;
	}
};

//#endregion
//#region infra/SubscriptionManager.ts
var SubscriptionManager = class {
	nextIdByMint = /* @__PURE__ */ new Map();
	subscriptions = /* @__PURE__ */ new Map();
	activeByMint = /* @__PURE__ */ new Map();
	pendingSubscribeByMint = /* @__PURE__ */ new Map();
	transportByMint = /* @__PURE__ */ new Map();
	logger;
	messageHandlerByMint = /* @__PURE__ */ new Map();
	openHandlerByMint = /* @__PURE__ */ new Map();
	hasOpenedByMint = /* @__PURE__ */ new Map();
	wsFactory;
	mintAdapter;
	options;
	paused = false;
	constructor(wsFactoryOrManager, mintAdapter, logger, options) {
		this.logger = logger;
		this.mintAdapter = mintAdapter;
		this.options = {
			slowPollingIntervalMs: options?.slowPollingIntervalMs ?? 2e4,
			fastPollingIntervalMs: options?.fastPollingIntervalMs ?? 5e3
		};
		if (typeof wsFactoryOrManager === "function") this.wsFactory = wsFactoryOrManager;
		else {
			const injected = wsFactoryOrManager;
			this.transportByMint.set("*", injected);
		}
	}
	/**
	* Get or create a transport for a mint.
	*
	* Uses HybridTransport (WS + polling in parallel) when a wsFactory is available.
	* HybridTransport handles WS failures gracefully by speeding up polling, so we
	* don't need to check mint capabilities or WebSocket availability upfront.
	*
	* Falls back to pure PollingTransport only when no wsFactory is provided.
	*/
	getTransport(mintUrl) {
		const injected = this.transportByMint.get("*");
		if (injected) return injected;
		let t = this.transportByMint.get(mintUrl);
		if (t) return t;
		if (this.wsFactory) t = new HybridTransport(this.wsFactory, this.mintAdapter, {
			slowPollingIntervalMs: this.options.slowPollingIntervalMs,
			fastPollingIntervalMs: this.options.fastPollingIntervalMs
		}, this.logger);
		else t = new PollingTransport(this.mintAdapter, { intervalMs: this.options.fastPollingIntervalMs }, this.logger);
		this.transportByMint.set(mintUrl, t);
		return t;
	}
	getNextId(mintUrl) {
		const next = (this.nextIdByMint.get(mintUrl) ?? 0) + 1;
		this.nextIdByMint.set(mintUrl, next);
		return next;
	}
	ensureMessageListener(mintUrl) {
		if (this.messageHandlerByMint.has(mintUrl)) return;
		const handler = (evt) => {
			try {
				const data = typeof evt.data === "string" ? evt.data : evt.data?.toString?.();
				if (!data) return;
				const parsed = JSON.parse(data);
				this.logger?.debug("Received WS message", {
					mintUrl,
					hasMethod: "method" in parsed,
					method: "method" in parsed ? parsed.method : void 0,
					hasId: "id" in parsed,
					id: "id" in parsed ? parsed.id : void 0,
					hasResult: "result" in parsed,
					hasError: "error" in parsed
				});
				if ("method" in parsed && parsed.method === "subscribe") {
					const subId = parsed.params?.subId;
					const active = subId ? this.subscriptions.get(subId) : void 0;
					if (active) for (const cb of active.callbacks) Promise.resolve(cb(parsed.params.payload)).catch((err) => this.logger?.error("Subscription callback error", {
						mintUrl,
						subId,
						err
					}));
				} else if ("error" in parsed && parsed.error) {
					const resp = parsed;
					const respId = Number(resp.id);
					const err = resp.error;
					const pendingMap = this.pendingSubscribeByMint.get(mintUrl);
					const maybeSubId = Number.isFinite(respId) && pendingMap ? pendingMap.get(respId) : void 0;
					if (maybeSubId) {
						this.subscriptions.delete(maybeSubId);
						pendingMap?.delete(respId);
						this.logger?.error("Subscribe request rejected", {
							mintUrl,
							id: resp.id,
							subId: maybeSubId,
							code: err.code,
							message: err.message
						});
					} else this.logger?.error("WS request error", {
						mintUrl,
						id: resp.id,
						code: err.code,
						message: err.message
					});
				} else if ("result" in parsed && parsed.result) {
					const resp = parsed;
					const respId = Number(resp.id);
					const pendingMap = this.pendingSubscribeByMint.get(mintUrl);
					if (Number.isFinite(respId) && pendingMap && pendingMap.has(respId)) {
						const subId = pendingMap.get(respId);
						pendingMap.delete(respId);
						this.logger?.info("Subscribe request accepted", {
							mintUrl,
							id: resp.id,
							subId: subId || resp.result?.subId
						});
					} else this.logger?.debug("Unmatched subscribe response", {
						mintUrl,
						id: resp.id,
						respId,
						hasPendingMap: !!pendingMap,
						pendingMapSize: pendingMap?.size ?? 0
					});
				}
			} catch (err) {
				this.logger?.error("WS message handling error", {
					mintUrl,
					err
				});
			}
		};
		this.getTransport(mintUrl).on(mintUrl, "message", handler);
		this.messageHandlerByMint.set(mintUrl, handler);
		const onOpen = (_evt) => {
			try {
				if (this.hasOpenedByMint.get(mintUrl) === true) {
					this.logger?.info("WS open detected, re-subscribing active subscriptions", { mintUrl });
					this.reSubscribeMint(mintUrl);
				} else {
					this.hasOpenedByMint.set(mintUrl, true);
					this.logger?.info("WS open detected, initial open - skipping re-subscribe", { mintUrl });
				}
			} catch (err) {
				this.logger?.error("Failed to handle open event", {
					mintUrl,
					err
				});
			}
		};
		this.getTransport(mintUrl).on(mintUrl, "open", onOpen);
		this.openHandlerByMint.set(mintUrl, onOpen);
	}
	async subscribe(mintUrl, kind, filters, onNotification) {
		if (!filters || filters.length === 0) throw new Error("filters must be a non-empty array");
		this.ensureMessageListener(mintUrl);
		const filtersKey = JSON.stringify([...filters].sort());
		for (const [existingSubId, existingSub] of this.subscriptions.entries()) if (existingSub.mintUrl === mintUrl && existingSub.kind === kind && JSON.stringify([...existingSub.filters].sort()) === filtersKey) {
			if (onNotification) {
				existingSub.callbacks.add(onNotification);
				this.logger?.debug("Reusing existing subscription", {
					mintUrl,
					kind,
					subId: existingSubId,
					filterCount: filters.length
				});
			}
			return {
				subId: existingSubId,
				unsubscribe: async () => {
					if (onNotification) this.removeCallback(existingSubId, onNotification);
					if (existingSub.callbacks.size === 0) await this.unsubscribe(mintUrl, existingSubId);
				}
			};
		}
		const id = this.getNextId(mintUrl);
		const subId = generateSubId();
		const req = {
			jsonrpc: "2.0",
			method: "subscribe",
			params: {
				kind,
				subId,
				filters
			},
			id
		};
		const active = {
			subId,
			mintUrl,
			kind,
			filters,
			callbacks: /* @__PURE__ */ new Set()
		};
		if (onNotification) active.callbacks.add(onNotification);
		this.subscriptions.set(subId, active);
		let set = this.activeByMint.get(mintUrl);
		if (!set) {
			set = /* @__PURE__ */ new Set();
			this.activeByMint.set(mintUrl, set);
		}
		set.add(subId);
		let pendingById = this.pendingSubscribeByMint.get(mintUrl);
		if (!pendingById) {
			pendingById = /* @__PURE__ */ new Map();
			this.pendingSubscribeByMint.set(mintUrl, pendingById);
		}
		pendingById.set(id, subId);
		if (this.paused) {
			this.logger?.info("Subscription created while paused, will activate on resume", {
				mintUrl,
				kind,
				subId
			});
			return {
				subId,
				unsubscribe: async () => {
					await this.unsubscribe(mintUrl, subId);
				}
			};
		}
		const t = this.getTransport(mintUrl);
		this.logger?.debug("Sending subscribe request", {
			mintUrl,
			kind,
			subId,
			id,
			filterCount: filters.length
		});
		t.send(mintUrl, req);
		this.logger?.info("Subscribed to NUT-17", {
			mintUrl,
			kind,
			subId,
			filterCount: filters.length
		});
		return {
			subId,
			unsubscribe: async () => {
				await this.unsubscribe(mintUrl, subId);
			}
		};
	}
	addCallback(subId, cb) {
		const active = this.subscriptions.get(subId);
		if (!active) throw new Error("Subscription not found");
		active.callbacks.add(cb);
	}
	removeCallback(subId, cb) {
		const active = this.subscriptions.get(subId);
		if (!active) return;
		active.callbacks.delete(cb);
	}
	async unsubscribe(mintUrl, subId) {
		this.logger?.debug("SubscriptionManager: unsubscribe called", {
			mintUrl,
			subId,
			hasSubscription: this.subscriptions.has(subId),
			activeForMint: this.activeByMint.get(mintUrl)?.size ?? 0
		});
		const id = this.getNextId(mintUrl);
		const req = {
			jsonrpc: "2.0",
			method: "unsubscribe",
			params: { subId },
			id
		};
		const t = this.getTransport(mintUrl);
		this.logger?.debug("SubscriptionManager: sending unsubscribe to transport", {
			mintUrl,
			subId,
			requestId: id
		});
		t.send(mintUrl, req);
		this.subscriptions.delete(subId);
		const set = this.activeByMint.get(mintUrl);
		set?.delete(subId);
		this.logger?.info("Unsubscribed from NUT-17", {
			mintUrl,
			subId,
			remainingSubscriptions: this.subscriptions.size,
			remainingActiveForMint: set?.size ?? 0
		});
	}
	closeAll() {
		const seen = /* @__PURE__ */ new Set();
		for (const t of this.transportByMint.values()) {
			if (seen.has(t)) continue;
			seen.add(t);
			t.closeAll();
		}
		this.subscriptions.clear();
		this.activeByMint.clear();
		this.pendingSubscribeByMint.clear();
		this.hasOpenedByMint.clear();
	}
	closeMint(mintUrl) {
		this.logger?.info("Closing all subscriptions for mint", { mintUrl });
		const subIds = this.activeByMint.get(mintUrl);
		if (subIds) for (const subId of subIds) this.subscriptions.delete(subId);
		this.activeByMint.delete(mintUrl);
		this.pendingSubscribeByMint.delete(mintUrl);
		this.nextIdByMint.delete(mintUrl);
		this.messageHandlerByMint.delete(mintUrl);
		this.openHandlerByMint.delete(mintUrl);
		this.hasOpenedByMint.delete(mintUrl);
		const transport = this.transportByMint.get(mintUrl);
		if (transport) {
			transport.closeMint(mintUrl);
			this.transportByMint.delete(mintUrl);
		}
		this.logger?.info("SubscriptionManager closed mint", { mintUrl });
	}
	reSubscribeMint(mintUrl) {
		const set = this.activeByMint.get(mintUrl);
		if (!set || set.size === 0) return;
		for (const subId of set) {
			const active = this.subscriptions.get(subId);
			if (!active) continue;
			const id = this.getNextId(mintUrl);
			const req = {
				jsonrpc: "2.0",
				method: "subscribe",
				params: {
					kind: active.kind,
					subId: active.subId,
					filters: active.filters
				},
				id
			};
			let pendingById = this.pendingSubscribeByMint.get(mintUrl);
			if (!pendingById) {
				pendingById = /* @__PURE__ */ new Map();
				this.pendingSubscribeByMint.set(mintUrl, pendingById);
			}
			pendingById.set(id, subId);
			this.getTransport(mintUrl).send(mintUrl, req);
			this.logger?.info("Re-subscribed to NUT-17 after reconnect", {
				mintUrl,
				kind: active.kind,
				subId: active.subId,
				filterCount: active.filters.length
			});
		}
	}
	pause() {
		this.paused = true;
		const seen = /* @__PURE__ */ new Set();
		for (const t of this.transportByMint.values()) {
			if (seen.has(t)) continue;
			seen.add(t);
			t.pause();
		}
		this.logger?.info("SubscriptionManager paused");
	}
	resume() {
		this.paused = false;
		const seen = /* @__PURE__ */ new Set();
		for (const t of this.transportByMint.values()) {
			if (seen.has(t)) continue;
			seen.add(t);
			t.resume();
		}
		this.logger?.info("SubscriptionManager resumed");
	}
};

//#endregion
//#region infra/handlers/MeltHandlerProvider.ts
/**
* Runtime registry for melt method handlers.
* Keeps wiring concerns out of the core melt domain.
*/
var MeltHandlerProvider = class {
	registry = {};
	constructor(initialHandlers) {
		if (initialHandlers) this.registerMany(initialHandlers);
	}
	register(method, handler) {
		this.registry[method] = handler;
	}
	registerMany(handlers) {
		for (const [method, handler] of Object.entries(handlers)) if (handler) this.registry[method] = handler;
	}
	get(method) {
		const handler = this.registry[method];
		if (!handler) throw new Error(`No melt handler registered for method ${method}`);
		return handler;
	}
	getAll() {
		return this.registry;
	}
};

//#endregion
//#region infra/handlers/MeltBolt11Handler.utils.ts
/**
* If the selected proof amount exceeds the required amount by this ratio (10%),
* we perform a swap first to get exact-amount proofs. This avoids sending
* significantly more value to the mint than needed, which could result in
* larger change amounts and potential privacy/fee implications.
*
* Example: If we need 100 sats but selected proofs total 115 sats,
* that's 1.15x (15% over) which exceeds 1.1x, so we swap first.
*/
const SWAP_THRESHOLD_RATIO = 1.1;
/**
* Calculate the total amount of a proof set.
*/
function sumProofs(proofs) {
	return proofs.reduce((sum, p) => sum + p.amount, 0);
}
/**
* Extract the send proof secrets from serialized swap output data.
* These are the secrets of proofs that were created during the swap
* and will be used as melt inputs.
*/
function getSwapSendSecrets(swapOutputData) {
	return deserializeOutputData(swapOutputData).send.map((o) => new TextDecoder().decode(o.secret));
}
/**
* Build a PAID execution result.
* Used when the melt completed successfully.
*/
function buildPaidResult(operation) {
	return {
		status: "PAID",
		finalized: {
			...operation,
			state: "finalized",
			updatedAt: Date.now()
		}
	};
}
/**
* Build a PENDING execution result.
* Used when the melt is in-flight and awaiting confirmation.
*/
function buildPendingResult(operation) {
	return {
		status: "PENDING",
		pending: {
			...operation,
			state: "pending",
			updatedAt: Date.now()
		}
	};
}
/**
* Build a FAILED execution result with optional error message.
* Used when the melt failed and proofs need recovery.
*/
function buildFailedResult(operation, error) {
	return {
		status: "FAILED",
		failed: {
			...operation,
			state: "failed",
			updatedAt: Date.now(),
			error
		}
	};
}

//#endregion
//#region infra/handlers/MeltBolt11Handler.ts
var MeltBolt11Handler = class {
	/**
	* Prepare a bolt11 melt operation.
	*
	* This method:
	* 1. Creates a melt quote from the mint for the lightning invoice
	* 2. Selects proofs to cover the quote amount + fee reserve
	* 3. Determines if a pre-swap is needed (when selected amount >> required)
	* 4. Reserves the input proofs for this operation
	* 5. Creates blank outputs for receiving change
	*
	* @returns Prepared operation ready for execution
	*/
	async prepare(ctx) {
		const { mintUrl, id: operationId } = ctx.operation;
		ctx.logger?.debug("Preparing bolt11 melt operation", {
			operationId,
			mintUrl
		});
		const quote = await ctx.wallet.createMeltQuote(ctx.operation.methodData.invoice);
		const { amount, fee_reserve } = quote;
		const totalAmount = amount + fee_reserve;
		ctx.logger?.debug("Melt quote created", {
			operationId,
			quoteId: quote.quote,
			amount,
			fee_reserve,
			totalAmount
		});
		const selectedProofs = await ctx.proofService.selectProofsToSend(mintUrl, totalAmount, false);
		const selectedAmount = sumProofs(selectedProofs);
		const needsSwap = selectedAmount >= Math.floor(totalAmount * SWAP_THRESHOLD_RATIO);
		ctx.logger?.debug("Proofs selected for melt", {
			operationId,
			selectedAmount,
			proofCount: selectedProofs.length,
			needsSwap
		});
		if (!needsSwap) return this.prepareDirectMelt(ctx, quote, selectedProofs);
		return this.prepareSwapThenMelt(ctx, quote, totalAmount);
	}
	/**
	* Prepare a direct melt (no swap needed).
	* Used when selected proofs are close to the required amount.
	*/
	async prepareDirectMelt(ctx, quote, selectedProofs) {
		const { mintUrl, id: operationId } = ctx.operation;
		const { amount, fee_reserve } = quote;
		const inputSecrets = selectedProofs.map((p) => p.secret);
		const selectedAmount = sumProofs(selectedProofs);
		ctx.logger?.debug("Preparing direct melt (no swap)", {
			operationId,
			selectedAmount
		});
		await ctx.proofService.reserveProofs(mintUrl, inputSecrets, operationId);
		const blankOutputs = await this.createChangeOutputs(amount, selectedAmount, ctx);
		ctx.logger?.info("Direct melt prepared", {
			operationId,
			quoteId: quote.quote,
			amount,
			fee_reserve,
			inputAmount: selectedAmount
		});
		return {
			...ctx.operation,
			...ctx.operation.methodData,
			quoteId: quote.quote,
			changeOutputData: serializeOutputData({
				keep: blankOutputs,
				send: []
			}),
			needsSwap: false,
			amount,
			fee_reserve,
			inputAmount: selectedAmount,
			inputProofSecrets: inputSecrets,
			swap_fee: 0,
			state: "prepared"
		};
	}
	/**
	* Prepare a swap-then-melt operation.
	* Used when selected proofs significantly exceed the required amount.
	*/
	async prepareSwapThenMelt(ctx, quote, totalAmount) {
		const { mintUrl, id: operationId } = ctx.operation;
		const { amount, fee_reserve } = quote;
		ctx.logger?.debug("Preparing swap-then-melt", {
			operationId,
			totalAmount
		});
		const selectedProofs = await ctx.proofService.selectProofsToSend(mintUrl, totalAmount, true);
		const selectedAmount = sumProofs(selectedProofs);
		const inputSecrets = selectedProofs.map((p) => p.secret);
		const swapFee = ctx.wallet.getFeesForProofs(selectedProofs);
		const sendAmount = totalAmount;
		const keepAmount = selectedAmount - sendAmount - swapFee;
		ctx.logger?.debug("Swap amounts calculated", {
			operationId,
			selectedAmount,
			sendAmount,
			keepAmount,
			swapFee
		});
		await ctx.proofService.reserveProofs(mintUrl, inputSecrets, operationId);
		const blankOutputs = await this.createChangeOutputs(amount, sendAmount, ctx);
		const swapOutputData = await ctx.proofService.createOutputsAndIncrementCounters(mintUrl, {
			keep: keepAmount,
			send: sendAmount
		}, { includeFees: true });
		ctx.logger?.info("Swap-then-melt prepared", {
			operationId,
			quoteId: quote.quote,
			amount,
			fee_reserve,
			inputAmount: selectedAmount,
			swapFee
		});
		return {
			...ctx.operation,
			...ctx.operation.methodData,
			quoteId: quote.quote,
			swapOutputData: serializeOutputData(swapOutputData),
			changeOutputData: serializeOutputData({
				keep: blankOutputs,
				send: []
			}),
			needsSwap: true,
			swap_fee: swapFee,
			amount,
			fee_reserve,
			inputAmount: selectedAmount,
			inputProofSecrets: inputSecrets,
			state: "prepared"
		};
	}
	/**
	* Create blank outputs to receive change from the melt operation.
	* The change is the difference between what we send and the quote amount.
	*/
	async createChangeOutputs(quoteAmount, sendAmount, ctx) {
		const changeDelta = sendAmount - quoteAmount;
		return ctx.proofService.createBlankOutputs(changeDelta, ctx.operation.mintUrl);
	}
	/**
	* Execute the bolt11 melt operation.
	*
	* This method:
	* 1. Retrieves the reserved input proofs
	* 2. If swap is needed, performs the swap first to get exact-amount proofs
	* 3. Sends the melt request to the mint
	* 4. Handles the response (PAID  finalize, PENDING  wait, UNPAID  restore proofs)
	*/
	async execute(ctx) {
		const { quoteId, mintUrl, changeOutputData: serializedChangeOutputData, id: operationId } = ctx.operation;
		ctx.logger?.debug("Executing bolt11 melt", {
			operationId,
			quoteId,
			needsSwap: ctx.operation.needsSwap
		});
		const inputProofs = await this.getInputProofs(ctx);
		const proofsToMelt = ctx.operation.needsSwap ? await this.executeSwap(ctx, inputProofs) : inputProofs;
		if (!ctx.operation.needsSwap) await ctx.proofService.setProofState(mintUrl, ctx.operation.inputProofSecrets, "inflight");
		ctx.logger?.debug("Sending melt request to mint", {
			operationId,
			quoteId,
			proofCount: proofsToMelt.length
		});
		const changeOutputData = deserializeOutputData(serializedChangeOutputData);
		const res = await ctx.mintAdapter.customMeltBolt11(mintUrl, proofsToMelt, changeOutputData.keep, quoteId);
		ctx.logger?.info("Melt execution completed", {
			operationId,
			quoteId,
			state: res.state
		});
		return this.handleMeltResponse(ctx, res.state, proofsToMelt, res.change);
	}
	/**
	* Handle the melt response and return the appropriate execution result.
	*/
	async handleMeltResponse(ctx, state, proofsToMelt, change) {
		const { mintUrl } = ctx.operation;
		switch (state) {
			case "PAID":
				await this.finalizeOperation(ctx, change);
				return buildPaidResult(ctx.operation);
			case "PENDING": return buildPendingResult(ctx.operation);
			case "UNPAID":
				await ctx.proofService.restoreProofsToReady(mintUrl, proofsToMelt.map((p) => p.secret));
				return buildFailedResult(ctx.operation);
			default: throw new Error(`Unexpected melt response state: ${state} for quote ${ctx.operation.quoteId}`);
		}
	}
	/**
	* Retrieve the input proofs reserved for this operation.
	*/
	async getInputProofs(ctx) {
		const { mintUrl, id: operationId } = ctx.operation;
		const proofs = await ctx.proofRepository.getProofsByOperationId(mintUrl, operationId);
		if (proofs.length !== ctx.operation.inputProofSecrets.length) throw new Error("Could not find all input proofs");
		return proofs;
	}
	/**
	* Execute the pre-melt swap to get exact-amount proofs.
	* Returns the "send" proofs from the swap which will be used for the melt.
	*/
	async executeSwap(ctx, inputProofs) {
		const { swapOutputData, inputProofSecrets, id: operationId, mintUrl } = ctx.operation;
		if (!swapOutputData) throw new Error("Swap is required, but swap output data is missing");
		const swapData = deserializeOutputData(swapOutputData);
		const sendAmount = swapData.send.reduce((a, c) => a + c.blindedMessage.amount, 0);
		const { wallet } = await ctx.walletService.getWalletWithActiveKeysetId(mintUrl);
		ctx.logger?.debug("Executing pre-melt swap", {
			operationId,
			sendAmount,
			inputProofCount: inputProofs.length
		});
		await ctx.proofService.setProofState(mintUrl, inputProofSecrets, "inflight");
		const outputConfig = {
			send: {
				type: "custom",
				data: swapData.send
			},
			keep: {
				type: "custom",
				data: swapData.keep
			}
		};
		const { send, keep } = await wallet.send(sendAmount, inputProofs, void 0, outputConfig);
		await ctx.proofService.setProofState(mintUrl, inputProofSecrets, "spent");
		const newProofs = [...mapProofToCoreProof(mintUrl, "ready", keep, { createdByOperationId: operationId }), ...mapProofToCoreProof(mintUrl, "inflight", send, { createdByOperationId: operationId })];
		await ctx.proofService.saveProofs(mintUrl, newProofs);
		ctx.logger?.debug("Pre-melt swap completed", {
			operationId,
			keepCount: keep.length,
			sendCount: send.length
		});
		return send;
	}
	/**
	* Finalize a pending melt operation that has succeeded.
	* Called by MeltOperationService when checkPending returns 'finalize'.
	*/
	async finalize(ctx) {
		const { mintUrl, quoteId, id: operationId } = ctx.operation;
		ctx.logger?.debug("Finalizing pending melt operation", {
			operationId,
			quoteId
		});
		const res = await ctx.mintAdapter.checkMeltQuote(mintUrl, quoteId);
		if (res.state !== "PAID") throw new Error(`Cannot finalize: melt quote ${quoteId} is ${res.state}, expected PAID`);
		await this.finalizeOperation(ctx, res.change);
	}
	/**
	* Finalize a melt operation by marking input proofs as spent and saving change proofs.
	* Called immediately when melt returns PAID, or later when a pending melt succeeds.
	*/
	async finalizeOperation(ctx, change) {
		const { mintUrl, id: operationId, changeOutputData: serializedChangeOutputData } = ctx.operation;
		const meltInputSecrets = this.getMeltInputSecrets(ctx.operation);
		await ctx.proofService.setProofState(mintUrl, meltInputSecrets, "spent");
		if (change && change.length > 0) {
			const changeOutputData = deserializeOutputData(serializedChangeOutputData).keep;
			await ctx.proofService.unblindAndSaveChangeProofs(mintUrl, changeOutputData, change, { createdByOperationId: operationId });
		}
		ctx.logger?.info("Melt operation finalized", {
			operationId,
			spentProofCount: meltInputSecrets.length,
			changeProofCount: change?.length ?? 0
		});
	}
	/**
	* Check the state of a pending melt operation.
	* Returns 'finalize' if paid, 'stay_pending' if still pending, 'rollback' if unpaid/failed.
	*/
	async checkPending(ctx) {
		const { mintUrl, quoteId, id: operationId } = ctx.operation;
		ctx.logger?.debug("Checking pending melt operation", {
			operationId,
			quoteId
		});
		const state = await ctx.mintAdapter.checkMeltQuoteState(mintUrl, quoteId);
		ctx.logger?.debug("Pending melt quote state", {
			operationId,
			quoteId,
			state
		});
		switch (state) {
			case "PAID": return "finalize";
			case "PENDING": return "stay_pending";
			case "UNPAID": return "rollback";
			default: throw new Error(`Unexpected melt quote state: ${state} for quote ${quoteId}`);
		}
	}
	/**
	* Rollback a melt operation by restoring input proofs to ready state.
	*/
	async rollback(ctx) {
		const { id: operationId, mintUrl, needsSwap } = ctx.operation;
		ctx.logger?.debug("Rolling back bolt11 melt operation", {
			operationId,
			needsSwap
		});
		const secretsToRestore = this.getMeltInputSecrets(ctx.operation);
		await ctx.proofService.restoreProofsToReady(mintUrl, secretsToRestore);
		ctx.logger?.info("Melt operation rolled back, proofs restored", {
			operationId,
			needsSwap,
			proofCount: secretsToRestore.length
		});
	}
	/**
	* Recover an executing operation after a crash/restart.
	*
	* Recovery logic:
	* - PAID: Finalize the operation (mark proofs spent, save change)
	* - PENDING: Transition to pending state for continued monitoring
	* - UNPAID: Determine what happened and restore/recover proofs appropriately
	*   - If no swap was needed or swap never happened: release original proofs
	*   - If swap happened and proofs exist locally: restore them to ready
	*   - If swap happened but proofs missing: recover from mint
	*/
	async recoverExecuting(ctx) {
		const { operation } = ctx;
		const { mintUrl, quoteId, needsSwap, id: operationId } = operation;
		ctx.logger?.debug("Recovering executing bolt11 melt operation", {
			operationId,
			quoteId,
			needsSwap
		});
		const state = await ctx.mintAdapter.checkMeltQuoteState(mintUrl, quoteId);
		ctx.logger?.debug("Melt quote state checked during recovery", {
			operationId,
			quoteId,
			state
		});
		switch (state) {
			case "PAID": return this.recoverExecutingPaidOperation(ctx);
			case "PENDING": return this.recoverExecutingPendingOperation(ctx);
			case "UNPAID": return this.recoverExecutingUnpaidOperation(ctx);
			default: throw new Error(`Unexpected melt response state: ${state} for quote ${quoteId}`);
		}
	}
	/**
	* Recover an executing operation that was actually paid.
	* Fetches change signatures and finalizes the operation.
	*/
	async recoverExecutingPaidOperation(ctx) {
		const { mintUrl, quoteId, id: operationId } = ctx.operation;
		ctx.logger?.debug("Recovering executing operation as paid, fetching change", {
			operationId,
			quoteId
		});
		const res = await ctx.mintAdapter.checkMeltQuote(mintUrl, quoteId);
		await this.finalizeOperation(ctx, res.change);
		ctx.logger?.info("Recovered and finalized paid melt operation", {
			operationId,
			quoteId
		});
		return buildPaidResult(ctx.operation);
	}
	/**
	* Recover an executing operation that is now pending.
	* Transitions to pending state for continued monitoring.
	*/
	async recoverExecutingPendingOperation(ctx) {
		ctx.logger?.info("Recovered executing operation as pending", {
			operationId: ctx.operation.id,
			quoteId: ctx.operation.quoteId
		});
		return buildPendingResult(ctx.operation);
	}
	/**
	* Recover an executing operation that is unpaid.
	* Determines the appropriate recovery path based on whether a swap occurred.
	*/
	async recoverExecutingUnpaidOperation(ctx) {
		const { needsSwap, id: operationId } = ctx.operation;
		if (!needsSwap || !await this.checkSwapHappened(ctx)) {
			ctx.logger?.debug("Unpaid quote recovery: no swap occurred", { operationId });
			return this.recoverExecutingWithoutSwap(ctx);
		}
		ctx.logger?.debug("Unpaid quote recovery: swap occurred, checking local proofs", { operationId });
		const localSwapProofs = await this.findLocalSwapSendProofs(ctx);
		if (localSwapProofs.length > 0) return this.recoverExecutingWithLocalSwapProofs(ctx, localSwapProofs);
		return this.recoverExecutingSwapProofsFromMint(ctx);
	}
	/**
	* Recover when swap happened and proofs exist locally.
	* Restores the swap send proofs to ready state.
	*/
	async recoverExecutingWithLocalSwapProofs(ctx, swapSendProofs) {
		const { operation } = ctx;
		const { mintUrl, id: operationId } = operation;
		const swappedSecrets = swapSendProofs.map((p) => p.secret);
		await ctx.proofService.restoreProofsToReady(mintUrl, swappedSecrets);
		ctx.logger?.info("Recovered swap proofs, melt failed", {
			operationId,
			recoveredProofCount: swapSendProofs.length
		});
		return buildFailedResult(operation, "Recovered: Swap happened but melt failed / never executed");
	}
	/**
	* Recover when swap happened but proofs weren't saved locally.
	* This can happen if the app crashed after the swap but before saving proofs.
	* Recovers proofs from the mint using the swap output data.
	*/
	async recoverExecutingSwapProofsFromMint(ctx) {
		const { operation } = ctx;
		const { swapOutputData, id: operationId, mintUrl } = operation;
		if (!swapOutputData) throw new Error("Swap was required but swapOutputData is missing");
		ctx.logger?.debug("Swap proofs not found locally, recovering from mint", { operationId });
		await ctx.proofService.recoverProofsFromOutputData(mintUrl, swapOutputData);
		try {
			await ctx.proofService.setProofState(mintUrl, operation.inputProofSecrets, "spent");
		} catch {
			ctx.logger?.warn("Failed to mark input proofs as spent", { operationId });
		}
		ctx.logger?.info("Recovered proofs from mint after swap", { operationId });
		return buildFailedResult(operation, "Recovered: Swap happened, proofs restored from mint");
	}
	/**
	* Recover when no swap occurred - release original proofs.
	*/
	async recoverExecutingWithoutSwap(ctx) {
		const { operation } = ctx;
		const { mintUrl, inputProofSecrets, id: operationId } = operation;
		await ctx.proofService.releaseProofs(mintUrl, inputProofSecrets);
		ctx.logger?.info("Released proofs after failed melt (no swap occurred)", {
			operationId,
			proofCount: inputProofSecrets.length
		});
		return buildFailedResult(operation, "Recovered: Swap never executed, released original proofs");
	}
	/**
	* Check if the swap was executed by verifying if input proofs are spent.
	*/
	async checkSwapHappened(ctx) {
		const { operation, mintAdapter } = ctx;
		const { inputProofSecrets, mintUrl } = operation;
		const Ys = computeYHexForSecrets(inputProofSecrets);
		return (await mintAdapter.checkProofStates(mintUrl, Ys)).some((proofState) => proofState.state === "SPENT");
	}
	/**
	* Find swap send proofs that were saved locally during the swap.
	* Returns empty array if proofs don't exist (crash before save).
	*/
	async findLocalSwapSendProofs(ctx) {
		const { swapOutputData, id: operationId, mintUrl } = ctx.operation;
		if (!swapOutputData) return [];
		const swapSendSecrets = getSwapSendSecrets(swapOutputData);
		return (await ctx.proofRepository.getProofsByOperationId(mintUrl, operationId)).filter((p) => swapSendSecrets.includes(p.secret));
	}
	/**
	* Get the secrets of proofs that were sent to the melt operation.
	* For direct melt: these are the original input proofs.
	* For swap-then-melt: these are the swap send proofs (derived from swapOutputData).
	*/
	getMeltInputSecrets(operation) {
		if (!operation.needsSwap) return operation.inputProofSecrets;
		if (!operation.swapOutputData) throw new Error("Swap was required but swapOutputData is missing");
		return getSwapSendSecrets(operation.swapOutputData);
	}
};

//#endregion
//#region logging/ConsoleLogger.ts
var ConsoleLogger = class ConsoleLogger {
	prefix;
	level;
	static levelPriority = {
		error: 0,
		warn: 1,
		info: 2,
		debug: 3
	};
	constructor(prefix = "coco-cashu", options = {}) {
		this.prefix = prefix;
		this.level = options.level ?? "info";
	}
	shouldLog(level) {
		return ConsoleLogger.levelPriority[level] <= ConsoleLogger.levelPriority[this.level];
	}
	error(message, ...meta) {
		if (!this.shouldLog("error")) return;
		console.error(`[${this.prefix}] ERROR: ${message}`, ...meta);
	}
	warn(message, ...meta) {
		if (!this.shouldLog("warn")) return;
		console.warn(`[${this.prefix}] WARN: ${message}`, ...meta);
	}
	info(message, ...meta) {
		if (!this.shouldLog("info")) return;
		console.info(`[${this.prefix}] INFO: ${message}`, ...meta);
	}
	debug(message, ...meta) {
		if (!this.shouldLog("debug")) return;
		console.debug(`[${this.prefix}] DEBUG: ${message}`, ...meta);
	}
	log(level, message, ...meta) {
		switch (level) {
			case "error":
				this.error(message, ...meta);
				break;
			case "warn":
				this.warn(message, ...meta);
				break;
			case "info":
				this.info(message, ...meta);
				break;
			case "debug":
				this.debug(message, ...meta);
				break;
			default: this.info(message, ...meta);
		}
	}
	child(bindings) {
		return new ConsoleLogger([this.prefix, ...Object.entries(bindings).map(([k, v]) => `${k}=${String(v)}`)].join(" "), { level: this.level });
	}
};

//#endregion
//#region logging/NullLogger.ts
var NullLogger = class {
	error(_message, ..._meta) {}
	warn(_message, ..._meta) {}
	info(_message, ..._meta) {}
	debug(_message, ..._meta) {}
	log(_level, _message, ..._meta) {}
	child(_bindings) {
		return this;
	}
};

//#endregion
//#region api/WalletApi.ts
var WalletApi = class {
	mintService;
	walletService;
	proofService;
	walletRestoreService;
	transactionService;
	paymentRequestService;
	sendOperationService;
	logger;
	constructor(mintService, walletService, proofService, walletRestoreService, transactionService, paymentRequestService, sendOperationService, logger) {
		this.mintService = mintService;
		this.walletService = walletService;
		this.proofService = proofService;
		this.walletRestoreService = walletRestoreService;
		this.transactionService = transactionService;
		this.paymentRequestService = paymentRequestService;
		this.sendOperationService = sendOperationService;
		this.logger = logger;
	}
	async receive(token) {
		return this.transactionService.receive(token);
	}
	/**
	* Send tokens from a mint.
	*
	* @deprecated Use `SendApi.prepareSend()` and SendApi.executePreparedSend() instead.
	*
	* @param mintUrl - The mint URL to send from
	* @param amount - The amount to send
	* @returns The token to share with the recipient
	*/
	async send(mintUrl, amount) {
		return this.sendOperationService.send(mintUrl, amount);
	}
	async getBalances() {
		return this.proofService.getBalances();
	}
	/**
	* Parse and validate a payment request string.
	*/
	async processPaymentRequest(paymentRequest) {
		return this.paymentRequestService.processPaymentRequest(paymentRequest);
	}
	/**
	* Prepare a payment request transaction.
	* @param mintUrl - The mint to send from
	* @param request - The parsed payment request
	* @param amount - Optional amount (required if not specified in request)
	* @returns The payment request transaction
	*/
	async preparePaymentRequestTransaction(mintUrl, request, amount) {
		return this.paymentRequestService.preparePaymentRequestTransaction(mintUrl, request, amount);
	}
	/**
	* Handle an inband payment request by sending tokens and calling the handler.
	* @param mintUrl - The mint to send from
	* @param request - The prepared payment request (from readPaymentRequest)
	* @param inbandHandler - Callback to deliver the token (e.g., display QR, send via NFC)
	* @param amount - Optional amount (required if not specified in request)
	*/
	async handleInbandPaymentRequest(transaction, inbandHandler) {
		return this.paymentRequestService.handleInbandPaymentRequest(transaction, inbandHandler);
	}
	/**
	* Handle an HTTP payment request by sending tokens to the specified URL.
	* @param mintUrl - The mint to send from
	* @param request - The prepared payment request (from readPaymentRequest)
	* @param amount - Optional amount (required if not specified in request)
	* @returns The HTTP response from the payment endpoint
	*/
	async handleHttpPaymentRequest(transaction) {
		return this.paymentRequestService.handleHttpPaymentRequest(transaction);
	}
	async restore(mintUrl) {
		this.logger?.info("Starting restore", { mintUrl });
		const mint = await this.mintService.addMintByUrl(mintUrl, { trusted: true });
		this.logger?.debug("Mint fetched for restore", {
			mintUrl,
			keysetCount: mint.keysets.length
		});
		const { wallet } = await this.walletService.getWalletWithActiveKeysetId(mintUrl);
		const failedKeysetIds = {};
		for (const keyset of mint.keysets) try {
			await this.walletRestoreService.restoreKeyset(mintUrl, wallet, keyset.id);
		} catch (error) {
			this.logger?.error("Keyset restore failed", {
				mintUrl,
				keysetId: keyset.id,
				error
			});
			failedKeysetIds[keyset.id] = error;
		}
		if (Object.keys(failedKeysetIds).length > 0) {
			this.logger?.error("Restore completed with failures", {
				mintUrl,
				failedKeysetIds: Object.keys(failedKeysetIds)
			});
			throw new Error("Failed to restore some keysets");
		}
		this.logger?.info("Restore completed successfully", { mintUrl });
	}
	/**
	* Sweeps a mint by sweeping each keyset and adds the swept proofs to the wallet
	* @param mintUrl - The URL of the mint to sweep
	* @param bip39seed - The BIP39 seed of the wallet to sweep
	*/
	async sweep(mintUrl, bip39seed) {
		this.logger?.info("Starting sweep", { mintUrl });
		const mint = await this.mintService.addMintByUrl(mintUrl, { trusted: true });
		this.logger?.debug("Mint fetched for sweep", {
			mintUrl,
			keysetCount: mint.keysets.length
		});
		const failedKeysetIds = {};
		for (const keyset of mint.keysets) try {
			await this.walletRestoreService.sweepKeyset(mintUrl, keyset.id, bip39seed);
		} catch (error) {
			this.logger?.error("Keyset restore failed", {
				mintUrl,
				keysetId: keyset.id,
				error
			});
			failedKeysetIds[keyset.id] = error;
		}
		if (Object.keys(failedKeysetIds).length > 0) {
			this.logger?.error("Restore completed with failures", {
				mintUrl,
				failedKeysetIds: Object.keys(failedKeysetIds)
			});
			throw new Error("Failed to restore some keysets");
		}
		this.logger?.info("Restore completed successfully", { mintUrl });
	}
	async decodeToken(tokenString) {
		const metadata = getTokenMetadata(tokenString);
		return (await this.walletService.getWallet(metadata.mint)).decodeToken(tokenString);
	}
	encodeToken(token) {
		return getEncodedToken$1(token);
	}
};

//#endregion
//#region api/QuotesApi.ts
var QuotesApi = class {
	mintQuoteService;
	meltQuoteService;
	meltOperationService;
	constructor(mintQuoteService, meltQuoteService, meltOperationService) {
		this.mintQuoteService = mintQuoteService;
		this.meltQuoteService = meltQuoteService;
		this.meltOperationService = meltOperationService;
	}
	async createMintQuote(mintUrl, amount) {
		return this.mintQuoteService.createMintQuote(mintUrl, amount);
	}
	async redeemMintQuote(mintUrl, quoteId) {
		return this.mintQuoteService.redeemMintQuote(mintUrl, quoteId);
	}
	/**
	* Create a bolt11 melt quote
	* @deprecated Use {@link prepareMeltBolt11} instead
	*/
	async createMeltQuote(mintUrl, invoice) {
		return this.meltQuoteService.createMeltQuote(mintUrl, invoice);
	}
	/**
	* Pay a bolt11 melt quote
	* @deprecated Use {@link executeMeltBolt11} instead
	*/
	async payMeltQuote(mintUrl, quoteId) {
		return this.meltQuoteService.payMeltQuote(mintUrl, quoteId);
	}
	async prepareMeltBolt11(mintUrl, invoice) {
		const initOperation = await this.meltOperationService.init(mintUrl, "bolt11", { invoice });
		return await this.meltOperationService.prepare(initOperation.id);
	}
	async executeMelt(operationId) {
		return this.meltOperationService.execute(operationId);
	}
	async executeMeltByQuote(mintUrl, quoteId) {
		const operation = await this.meltOperationService.getOperationByQuote(mintUrl, quoteId);
		if (!operation) return null;
		return this.meltOperationService.execute(operation.id);
	}
	async checkPendingMelt(operationId) {
		return this.meltOperationService.checkPendingOperation(operationId);
	}
	async checkPendingMeltByQuote(mintUrl, quoteId) {
		const operation = await this.meltOperationService.getOperationByQuote(mintUrl, quoteId);
		if (!operation) return null;
		return this.meltOperationService.checkPendingOperation(operation.id);
	}
	async addMintQuote(mintUrl, quotes) {
		return this.mintQuoteService.addExistingMintQuotes(mintUrl, quotes);
	}
	async requeuePaidMintQuotes(mintUrl) {
		return this.mintQuoteService.requeuePaidMintQuotes(mintUrl);
	}
};

//#endregion
//#region api/MintApi.ts
var MintApi = class {
	constructor(mintService) {
		this.mintService = mintService;
	}
	async addMint(mintUrl, options) {
		return this.mintService.addMintByUrl(mintUrl, options);
	}
	async getMintInfo(mintUrl) {
		return this.mintService.getMintInfo(mintUrl);
	}
	async isTrustedMint(mintUrl) {
		return this.mintService.isTrustedMint(mintUrl);
	}
	async getAllMints() {
		return this.mintService.getAllMints();
	}
	async getAllTrustedMints() {
		return this.mintService.getAllTrustedMints();
	}
	async trustMint(mintUrl) {
		return this.mintService.trustMint(mintUrl);
	}
	async untrustMint(mintUrl) {
		return this.mintService.untrustMint(mintUrl);
	}
};

//#endregion
//#region api/KeyRingApi.ts
var KeyRingApi = class {
	constructor(keyRingService) {
		this.keyRingService = keyRingService;
	}
	async generateKeyPair(dumpSecretKey) {
		if (dumpSecretKey === true) return this.keyRingService.generateNewKeyPair({ dumpSecretKey: true });
		return this.keyRingService.generateNewKeyPair({ dumpSecretKey: false });
	}
	/**
	* Adds an existing keypair to the keyring using a secret key.
	* @param secretKey - The 32-byte secret key as Uint8Array
	*/
	async addKeyPair(secretKey) {
		return this.keyRingService.addKeyPair(secretKey);
	}
	/**
	* Removes a keypair from the keyring.
	* @param publicKey - The public key (hex string) of the keypair to remove
	*/
	async removeKeyPair(publicKey) {
		return this.keyRingService.removeKeyPair(publicKey);
	}
	/**
	* Retrieves a specific keypair by its public key.
	* @param publicKey - The public key (hex string) to look up
	* @returns The keypair if found, null otherwise
	*/
	async getKeyPair(publicKey) {
		return this.keyRingService.getKeyPair(publicKey);
	}
	/**
	* Gets the most recently added keypair.
	* @returns The latest keypair if any exist, null otherwise
	*/
	async getLatestKeyPair() {
		return this.keyRingService.getLatestKeyPair();
	}
	/**
	* Gets all keypairs stored in the keyring.
	* @returns Array of all keypairs
	*/
	async getAllKeyPairs() {
		return this.keyRingService.getAllKeyPairs();
	}
};

//#endregion
//#region api/SubscriptionApi.ts
var SubscriptionApi = class {
	subs;
	logger;
	constructor(subs, logger) {
		this.subs = subs;
		this.logger = logger;
	}
	async awaitMintQuotePaid(mintUrl, quoteId) {
		return this.awaitFirstNotification(mintUrl, "bolt11_mint_quote", [quoteId]);
	}
	async awaitMeltQuotePaid(mintUrl, quoteId) {
		return this.awaitFirstNotification(mintUrl, "bolt11_melt_quote", [quoteId]);
	}
	async awaitFirstNotification(mintUrl, kind, filters) {
		return new Promise(async (resolve, reject) => {
			try {
				const { unsubscribe } = await this.subs.subscribe(mintUrl, kind, filters, (payload) => {
					try {
						resolve(payload);
					} finally {
						unsubscribe().catch(() => void 0);
					}
				});
			} catch (err) {
				this.logger?.error("Failed to await subscription notification", {
					mintUrl,
					kind,
					err
				});
				reject(err);
			}
		});
	}
};

//#endregion
//#region api/HistoryApi.ts
var HistoryApi = class {
	historyService;
	constructor(historyService) {
		this.historyService = historyService;
	}
	async getPaginatedHistory(offset = 0, limit = 25) {
		return this.historyService.getPaginatedHistory(offset, limit);
	}
	async getHistoryEntryById(id) {
		return this.historyService.getHistoryEntryById(id);
	}
};

//#endregion
//#region api/SendApi.ts
/**
* API for managing send operations.
*
* Provides methods to:
* - Query pending send operations
* - Rollback or finalize operations by operationId
* - Recover pending operations on startup
*/
var SendApi = class {
	sendOperationService;
	constructor(sendOperationService) {
		this.sendOperationService = sendOperationService;
	}
	/**
	* Prepare a send operation without executing it.
	* This reserves the proofs and calculates the fee.
	*
	* Use this when you want to show the user the fee before committing.
	* The returned operation contains:
	* - `fee`: The swap fee (0 if exact match)
	* - `needsSwap`: Whether a swap is required
	* - `inputAmount`: Total input proof amount
	*
	* After reviewing, call `executePreparedSend()` to execute, or `rollback()` to cancel.
	*
	* @param mintUrl - The mint URL to send from
	* @param amount - The amount to send
	* @returns The prepared operation with fee information
	*/
	async prepareSend(mintUrl, amount) {
		const initOp = await this.sendOperationService.init(mintUrl, amount);
		return this.sendOperationService.prepare(initOp);
	}
	/**
	* Execute a prepared send operation.
	* Call this after `prepareSend()` to complete the send.
	*
	* @param operationId - The ID of the prepared operation
	* @returns The pending operation and the token to share
	* @throws If the operation is not in 'prepared' state
	*/
	async executePreparedSend(operationId) {
		const operation = await this.sendOperationService.getOperation(operationId);
		if (!operation) throw new Error(`Operation ${operationId} not found`);
		if (operation.state !== "prepared") throw new Error(`Cannot execute operation in state '${operation.state}'. Expected 'prepared'.`);
		return this.sendOperationService.execute(operation);
	}
	/**
	* Get a send operation by its ID.
	*/
	async getOperation(operationId) {
		return this.sendOperationService.getOperation(operationId);
	}
	/**
	* Get all pending send operations.
	* Pending operations are in 'executing' or 'pending' state.
	*/
	async getPendingOperations() {
		return this.sendOperationService.getPendingOperations();
	}
	/**
	* Finalize a send operation by operationId.
	* This marks the operation as completed after proofs are confirmed spent.
	*/
	async finalize(operationId) {
		return this.sendOperationService.finalize(operationId);
	}
	/**
	* Rollback a send operation by operationId.
	* Reclaims proofs and cancels the operation.
	*/
	async rollback(operationId) {
		return this.sendOperationService.rollback(operationId);
	}
	/**
	* Recover all pending operations.
	* Should be called during application initialization.
	*/
	async recoverPendingOperations() {
		return this.sendOperationService.recoverPendingOperations();
	}
	/**
	* Check a pending operation and finalize it if it should be finalized.
	*/
	async checkPendingOperation(operationId) {
		const operation = await this.sendOperationService.getOperation(operationId);
		if (!operation) throw new Error(`Operation ${operationId} not found`);
		if (operation.state !== "pending") throw new Error(`Operation ${operationId} is not in pending state`);
		return this.sendOperationService.checkPendingOperation(operation);
	}
	/**
	* Check if a specific operation is currently locked (in progress).
	* Useful for UI to disable buttons while an operation is executing.
	*/
	isOperationLocked(operationId) {
		return this.sendOperationService.isOperationLocked(operationId);
	}
	/**
	* Check if recovery is currently in progress.
	* Useful to prevent multiple recovery calls.
	*/
	isRecoveryInProgress() {
		return this.sendOperationService.isRecoveryInProgress();
	}
};

//#endregion
//#region plugins/types.ts
/**
* Error thrown when a plugin attempts to register an extension key that is already registered.
*/
var ExtensionRegistrationError = class extends Error {
	constructor(pluginName, key) {
		super(`Plugin "${pluginName}" attempted to register extension "${key}", but it is already registered`);
		this.name = "ExtensionRegistrationError";
	}
};

//#endregion
//#region plugins/PluginHost.ts
var PluginHost = class {
	plugins = [];
	cleanups = [];
	extensions = {};
	services;
	initialized = false;
	readyPhase = false;
	use(plugin) {
		this.plugins.push(plugin);
		if (this.initialized && this.services) {
			this.runInit(plugin, this.services);
			if (this.readyPhase) this.runReady(plugin, this.services);
		}
	}
	async init(services) {
		this.services = services;
		this.initialized = true;
		for (const p of this.plugins) await this.runInit(p, services);
	}
	async ready() {
		if (!this.services) return;
		this.readyPhase = true;
		for (const p of this.plugins) await this.runReady(p, this.services);
	}
	async dispose() {
		const errors = [];
		for (const p of this.plugins) try {
			await p.onDispose?.();
		} catch (err) {
			console.error("Plugin dispose error", {
				plugin: p.name,
				err
			});
			errors.push(err);
		}
		while (this.cleanups.length) {
			const fn = this.cleanups.pop();
			try {
				await fn();
			} catch (err) {
				errors.push(err);
			}
		}
		if (errors.length > 0) console.error("One or more plugin dispose/cleanup handlers failed");
	}
	/**
	* Get all registered plugin extensions
	*/
	getExtensions() {
		return this.extensions;
	}
	async runInit(plugin, services) {
		const ctx = this.createContext(plugin, services);
		try {
			const cleanup = await plugin.onInit?.(ctx);
			if (typeof cleanup === "function") this.cleanups.push(cleanup);
		} catch (err) {
			if (err instanceof ExtensionRegistrationError) throw err;
			console.error("Plugin init error", {
				plugin: plugin.name,
				err
			});
		}
	}
	async runReady(plugin, services) {
		const ctx = this.createContext(plugin, services);
		try {
			const cleanup = await plugin.onReady?.(ctx);
			if (typeof cleanup === "function") this.cleanups.push(cleanup);
		} catch (err) {
			if (err instanceof ExtensionRegistrationError) throw err;
			console.error("Plugin ready error", {
				plugin: plugin.name,
				err
			});
		}
	}
	createContext(plugin, services) {
		const required = plugin.required ?? [];
		const selected = {};
		for (const k of required) selected[k] = services[k];
		const registerExtension = (key, api) => {
			if (key in this.extensions) throw new ExtensionRegistrationError(plugin.name, key);
			this.extensions[key] = api;
		};
		return {
			services: selected,
			registerExtension
		};
	}
};

//#endregion
//#region Manager.ts
/**
* Initializes and configures a new Coco Cashu manager instance
* @param config - Configuration options including repositories, seed, and optional features
* @returns A fully initialized Manager instance
*/
async function initializeCoco(config) {
	await config.repo.init();
	const coco = new Manager(config.repo, config.seedGetter, config.logger, config.webSocketFactory, config.plugins, config.watchers, config.processors, config.subscriptions);
	await coco.initPlugins();
	const mintQuoteWatcherConfig = config.watchers?.mintQuoteWatcher;
	if (!mintQuoteWatcherConfig?.disabled) await coco.enableMintQuoteWatcher(mintQuoteWatcherConfig);
	const proofStateWatcherConfig = config.watchers?.proofStateWatcher;
	if (!proofStateWatcherConfig?.disabled) await coco.enableProofStateWatcher(proofStateWatcherConfig);
	const mintQuoteProcessorConfig = config.processors?.mintQuoteProcessor;
	if (!mintQuoteProcessorConfig?.disabled) {
		await coco.enableMintQuoteProcessor(mintQuoteProcessorConfig);
		await coco.quotes.requeuePaidMintQuotes();
	}
	await coco.recoverPendingSendOperations();
	await coco.recoverPendingMeltOperations();
	return coco;
}
var Manager = class {
	mint;
	wallet;
	quotes;
	keyring;
	subscription;
	history;
	send;
	ext;
	mintService;
	walletService;
	proofService;
	walletRestoreService;
	keyRingService;
	eventBus;
	logger;
	subscriptions;
	mintQuoteService;
	mintQuoteWatcher;
	mintQuoteProcessor;
	mintQuoteRepository;
	proofStateWatcher;
	meltQuoteService;
	historyService;
	seedService;
	counterService;
	transactionService;
	paymentRequestService;
	sendOperationService;
	sendOperationRepository;
	meltOperationService;
	meltOperationRepository;
	proofRepository;
	pluginHost = new PluginHost();
	subscriptionsPaused = false;
	originalWatcherConfig;
	originalProcessorConfig;
	mintRequestProvider;
	mintAdapter;
	constructor(repositories, seedGetter, logger, webSocketFactory, plugins, watchers, processors, subscriptions) {
		this.logger = logger ?? new NullLogger();
		this.eventBus = this.createEventBus();
		this.mintRequestProvider = new MintRequestProvider({
			capacity: 20,
			refillPerMinute: 20,
			logger: this.getChildLogger("RequestRateLimiter")
		});
		this.mintAdapter = new MintAdapter(this.mintRequestProvider);
		this.subscriptions = this.createSubscriptionManager(webSocketFactory, subscriptions);
		this.originalWatcherConfig = watchers;
		this.originalProcessorConfig = processors;
		if (plugins && plugins.length > 0) for (const p of plugins) this.pluginHost.use(p);
		const core = this.buildCoreServices(repositories, seedGetter);
		this.mintService = core.mintService;
		this.walletService = core.walletService;
		this.proofService = core.proofService;
		this.walletRestoreService = core.walletRestoreService;
		this.keyRingService = core.keyRingService;
		this.seedService = core.seedService;
		this.counterService = core.counterService;
		this.mintQuoteService = core.mintQuoteService;
		this.mintQuoteRepository = core.mintQuoteRepository;
		this.meltQuoteService = core.meltQuoteService;
		this.historyService = core.historyService;
		this.transactionService = core.transactionService;
		this.paymentRequestService = core.paymentRequestService;
		this.sendOperationService = core.sendOperationService;
		this.sendOperationRepository = core.sendOperationRepository;
		this.meltOperationService = core.meltOperationService;
		this.meltOperationRepository = core.meltOperationRepository;
		this.proofRepository = repositories.proofRepository;
		const apis = this.buildApis();
		this.mint = apis.mint;
		this.wallet = apis.wallet;
		this.quotes = apis.quotes;
		this.keyring = apis.keyring;
		this.subscription = apis.subscription;
		this.history = apis.history;
		this.send = apis.send;
		this.ext = this.pluginHost.getExtensions();
		this.eventBus.on("mint:untrusted", ({ mintUrl }) => {
			this.logger.info("Mint untrusted, closing subscriptions", { mintUrl });
			this.subscriptions.closeMint(mintUrl);
		});
		const services = {
			mintService: this.mintService,
			walletService: this.walletService,
			proofService: this.proofService,
			keyRingService: this.keyRingService,
			seedService: this.seedService,
			walletRestoreService: this.walletRestoreService,
			counterService: this.counterService,
			mintQuoteService: this.mintQuoteService,
			meltQuoteService: this.meltQuoteService,
			historyService: this.historyService,
			transactionService: this.transactionService,
			sendOperationService: this.sendOperationService,
			paymentRequestService: this.paymentRequestService,
			meltOperationService: this.meltOperationService,
			subscriptions: this.subscriptions,
			eventBus: this.eventBus,
			logger: this.logger
		};
		this.pluginHost.init(services).then(() => this.pluginHost.ready()).catch((err) => {
			this.logger.error("Plugin system initialization failed", err);
		});
	}
	on(event, handler) {
		return this.eventBus.on(event, handler);
	}
	once(event, handler) {
		return this.eventBus.once(event, handler);
	}
	use(plugin) {
		this.pluginHost.use(plugin);
	}
	/**
	* Initialize the plugin system.
	* This is called automatically by `initializeCoco()`.
	* Only call this directly if you instantiate Manager without using the factory.
	*/
	async initPlugins() {
		const services = {
			mintService: this.mintService,
			walletService: this.walletService,
			proofService: this.proofService,
			keyRingService: this.keyRingService,
			seedService: this.seedService,
			walletRestoreService: this.walletRestoreService,
			paymentRequestService: this.paymentRequestService,
			counterService: this.counterService,
			mintQuoteService: this.mintQuoteService,
			meltQuoteService: this.meltQuoteService,
			meltOperationService: this.meltOperationService,
			historyService: this.historyService,
			transactionService: this.transactionService,
			sendOperationService: this.sendOperationService,
			subscriptions: this.subscriptions,
			eventBus: this.eventBus,
			logger: this.logger
		};
		await this.pluginHost.init(services);
		await this.pluginHost.ready();
	}
	async dispose() {
		await this.pluginHost.dispose();
	}
	off(event, handler) {
		return this.eventBus.off(event, handler);
	}
	async enableMintQuoteWatcher(options) {
		if (this.mintQuoteWatcher?.isRunning()) return;
		const watcherLogger = this.logger.child ? this.logger.child({ module: "MintQuoteWatcherService" }) : this.logger;
		this.mintQuoteWatcher = new MintQuoteWatcherService(this.mintQuoteRepository, this.subscriptions, this.mintService, this.mintQuoteService, this.eventBus, watcherLogger, { watchExistingPendingOnStart: options?.watchExistingPendingOnStart ?? true });
		await this.mintQuoteWatcher.start();
	}
	async disableMintQuoteWatcher() {
		if (!this.mintQuoteWatcher) return;
		await this.mintQuoteWatcher.stop();
		this.mintQuoteWatcher = void 0;
	}
	async enableMintQuoteProcessor(options) {
		if (this.mintQuoteProcessor?.isRunning()) return false;
		const processorLogger = this.logger.child ? this.logger.child({ module: "MintQuoteProcessor" }) : this.logger;
		this.mintQuoteProcessor = new MintQuoteProcessor(this.mintQuoteService, this.eventBus, processorLogger, options);
		await this.mintQuoteProcessor.start();
		return true;
	}
	async disableMintQuoteProcessor() {
		if (!this.mintQuoteProcessor) return;
		await this.mintQuoteProcessor.stop();
		this.mintQuoteProcessor = void 0;
	}
	async waitForMintQuoteProcessor() {
		if (!this.mintQuoteProcessor) return;
		await this.mintQuoteProcessor.waitForCompletion();
	}
	async enableProofStateWatcher(options) {
		if (this.proofStateWatcher?.isRunning()) return;
		const watcherLogger = this.logger.child ? this.logger.child({ module: "ProofStateWatcherService" }) : this.logger;
		this.proofStateWatcher = new ProofStateWatcherService(this.subscriptions, this.mintService, this.proofService, this.proofRepository, this.eventBus, watcherLogger, { watchExistingInflightOnStart: options?.watchExistingInflightOnStart ?? true });
		this.proofStateWatcher.setSendOperationService(this.sendOperationService);
		await this.proofStateWatcher.start();
	}
	async disableProofStateWatcher() {
		if (!this.proofStateWatcher) return;
		await this.proofStateWatcher.stop();
		this.proofStateWatcher = void 0;
	}
	async recoverPendingSendOperations() {
		await this.sendOperationService.recoverPendingOperations();
	}
	async recoverPendingMeltOperations() {
		await this.meltOperationService.recoverPendingOperations();
	}
	async pauseSubscriptions() {
		if (this.subscriptionsPaused) {
			this.logger.debug("Subscriptions already paused");
			return;
		}
		this.subscriptionsPaused = true;
		this.logger.info("Pausing subscriptions");
		this.subscriptions.pause();
		await this.disableMintQuoteWatcher();
		await this.disableProofStateWatcher();
		await this.disableMintQuoteProcessor();
		this.logger.info("Subscriptions paused");
		await this.eventBus.emit("subscriptions:paused", void 0);
	}
	async resumeSubscriptions() {
		this.subscriptionsPaused = false;
		this.logger.info("Resuming subscriptions");
		await this.eventBus.emit("subscriptions:resumed", void 0);
		this.subscriptions.resume();
		const mintQuoteWatcherConfig = this.originalWatcherConfig?.mintQuoteWatcher;
		if (!mintQuoteWatcherConfig?.disabled) await this.enableMintQuoteWatcher(mintQuoteWatcherConfig);
		const proofStateWatcherConfig = this.originalWatcherConfig?.proofStateWatcher;
		if (!proofStateWatcherConfig?.disabled) await this.enableProofStateWatcher(proofStateWatcherConfig);
		const mintQuoteProcessorConfig = this.originalProcessorConfig?.mintQuoteProcessor;
		if (!mintQuoteProcessorConfig?.disabled) {
			if (await this.enableMintQuoteProcessor(mintQuoteProcessorConfig)) await this.quotes.requeuePaidMintQuotes();
		}
		this.logger.info("Subscriptions resumed");
	}
	getChildLogger(moduleName) {
		return this.logger.child ? this.logger.child({ module: moduleName }) : this.logger;
	}
	createEventBus() {
		const eventLogger = this.getChildLogger("EventBus");
		return new EventBus({ onError: (args) => {
			eventLogger.error("Event handler error", args);
		} });
	}
	createSubscriptionManager(webSocketFactory, subscriptionOptions) {
		const wsLogger = this.getChildLogger("SubscriptionManager");
		const defaultFactory = typeof globalThis.WebSocket !== "undefined" ? (url) => new globalThis.WebSocket(url) : void 0;
		const wsFactoryToUse = webSocketFactory ?? defaultFactory;
		const options = {
			slowPollingIntervalMs: subscriptionOptions?.slowPollingIntervalMs ?? 2e4,
			fastPollingIntervalMs: subscriptionOptions?.fastPollingIntervalMs ?? 5e3
		};
		if (!wsFactoryToUse) return new SubscriptionManager(new PollingTransport(this.mintAdapter, { intervalMs: options.fastPollingIntervalMs }, wsLogger), this.mintAdapter, wsLogger, options);
		return new SubscriptionManager(wsFactoryToUse, this.mintAdapter, wsLogger, options);
	}
	buildCoreServices(repositories, seedGetter) {
		const mintLogger = this.getChildLogger("MintService");
		const walletLogger = this.getChildLogger("WalletService");
		const counterLogger = this.getChildLogger("CounterService");
		const proofLogger = this.getChildLogger("ProofService");
		const mintQuoteLogger = this.getChildLogger("MintQuoteService");
		const walletRestoreLogger = this.getChildLogger("WalletRestoreService");
		const keyRingLogger = this.getChildLogger("KeyRingService");
		const meltQuoteLogger = this.getChildLogger("MeltQuoteService");
		const historyLogger = this.getChildLogger("HistoryService");
		const mintService = new MintService(repositories.mintRepository, repositories.keysetRepository, this.mintAdapter, mintLogger, this.eventBus);
		const seedService = new SeedService(seedGetter);
		const keyRingService = new KeyRingService(repositories.keyRingRepository, seedService, keyRingLogger);
		const walletService = new WalletService(mintService, seedService, this.mintRequestProvider, walletLogger);
		const counterService = new CounterService(repositories.counterRepository, counterLogger, this.eventBus);
		const proofService = new ProofService(counterService, repositories.proofRepository, walletService, mintService, keyRingService, seedService, proofLogger, this.eventBus);
		const walletRestoreService = new WalletRestoreService(proofService, counterService, walletService, this.mintRequestProvider, walletRestoreLogger);
		const mintQuoteService = new MintQuoteService(repositories.mintQuoteRepository, mintService, walletService, proofService, this.eventBus, mintQuoteLogger);
		const mintQuoteRepository = repositories.mintQuoteRepository;
		const meltQuoteService = new MeltQuoteService(mintService, proofService, walletService, repositories.meltQuoteRepository, this.eventBus, meltQuoteLogger);
		const historyService = new HistoryService(repositories.historyRepository, this.eventBus, historyLogger);
		const transactionLogger = this.getChildLogger("TransactionService");
		const transactionService = new TransactionService(mintService, walletService, proofService, this.eventBus, transactionLogger);
		const sendOperationLogger = this.getChildLogger("SendOperationService");
		const sendOperationService = new SendOperationService(repositories.sendOperationRepository, repositories.proofRepository, proofService, mintService, walletService, this.eventBus, sendOperationLogger);
		const sendOperationRepository = repositories.sendOperationRepository;
		const meltOperationLogger = this.getChildLogger("MeltOperationService");
		const meltOperationService = new MeltOperationService(new MeltHandlerProvider({ bolt11: new MeltBolt11Handler() }), repositories.meltOperationRepository, repositories.proofRepository, proofService, mintService, walletService, this.mintAdapter, this.eventBus, meltOperationLogger);
		const meltOperationRepository = repositories.meltOperationRepository;
		return {
			mintService,
			seedService,
			walletService,
			counterService,
			proofService,
			walletRestoreService,
			keyRingService,
			mintQuoteService,
			mintQuoteRepository,
			meltQuoteService,
			historyService,
			transactionService,
			paymentRequestService: new PaymentRequestService(sendOperationService, proofService, this.getChildLogger("PaymentRequestService")),
			sendOperationService,
			sendOperationRepository,
			meltOperationService,
			meltOperationRepository
		};
	}
	buildApis() {
		const walletApiLogger = this.getChildLogger("WalletApi");
		const subscriptionApiLogger = this.getChildLogger("SubscriptionApi");
		return {
			mint: new MintApi(this.mintService),
			wallet: new WalletApi(this.mintService, this.walletService, this.proofService, this.walletRestoreService, this.transactionService, this.paymentRequestService, this.sendOperationService, walletApiLogger),
			quotes: new QuotesApi(this.mintQuoteService, this.meltQuoteService, this.meltOperationService),
			keyring: new KeyRingApi(this.keyRingService),
			subscription: new SubscriptionApi(this.subscriptions, subscriptionApiLogger),
			history: new HistoryApi(this.historyService),
			send: new SendApi(this.sendOperationService)
		};
	}
};

//#endregion
//#region repositories/memory/MemoryCounterRepository.ts
var MemoryCounterRepository = class {
	counters = /* @__PURE__ */ new Map();
	key(mintUrl, keysetId) {
		return `${mintUrl}::${keysetId}`;
	}
	async getCounter(mintUrl, keysetId) {
		return this.counters.get(this.key(mintUrl, keysetId)) ?? null;
	}
	async setCounter(mintUrl, keysetId, counter) {
		const key = this.key(mintUrl, keysetId);
		this.counters.set(key, {
			mintUrl,
			keysetId,
			counter
		});
	}
};

//#endregion
//#region repositories/memory/MemoryKeysetRepository.ts
var MemoryKeysetRepository = class {
	keysetsByMint = /* @__PURE__ */ new Map();
	getMintMap(mintUrl) {
		if (!this.keysetsByMint.has(mintUrl)) this.keysetsByMint.set(mintUrl, /* @__PURE__ */ new Map());
		return this.keysetsByMint.get(mintUrl);
	}
	async getKeysetsByMintUrl(mintUrl) {
		return Array.from(this.getMintMap(mintUrl).values());
	}
	async getKeysetById(mintUrl, id) {
		return this.getMintMap(mintUrl).get(id) ?? null;
	}
	async updateKeyset(keyset) {
		const mintMap = this.getMintMap(keyset.mintUrl);
		const existing = mintMap.get(keyset.id);
		if (!existing) {
			mintMap.set(keyset.id, {
				...keyset,
				keypairs: {},
				updatedAt: Math.floor(Date.now() / 1e3)
			});
			return;
		}
		mintMap.set(keyset.id, {
			...existing,
			unit: keyset.unit,
			active: keyset.active,
			feePpk: keyset.feePpk,
			updatedAt: Math.floor(Date.now() / 1e3)
		});
	}
	async addKeyset(keyset) {
		this.getMintMap(keyset.mintUrl).set(keyset.id, {
			...keyset,
			updatedAt: Math.floor(Date.now() / 1e3)
		});
	}
	async deleteKeyset(mintUrl, keysetId) {
		this.getMintMap(mintUrl).delete(keysetId);
	}
};

//#endregion
//#region repositories/memory/MemoryKeyRingRepository.ts
var MemoryKeyRingRepository = class {
	keyPairs = /* @__PURE__ */ new Map();
	insertionOrder = [];
	async getPersistedKeyPair(publicKey) {
		return this.keyPairs.get(publicKey) ?? null;
	}
	async setPersistedKeyPair(keyPair) {
		if (!this.keyPairs.has(keyPair.publicKeyHex)) this.insertionOrder.push(keyPair.publicKeyHex);
		let derivationIndex = keyPair.derivationIndex;
		if (derivationIndex == null) {
			const existing = this.keyPairs.get(keyPair.publicKeyHex);
			if (existing?.derivationIndex != null) derivationIndex = existing.derivationIndex;
		}
		this.keyPairs.set(keyPair.publicKeyHex, {
			...keyPair,
			derivationIndex
		});
	}
	async deletePersistedKeyPair(publicKey) {
		this.keyPairs.delete(publicKey);
		const index = this.insertionOrder.indexOf(publicKey);
		if (index !== -1) this.insertionOrder.splice(index, 1);
	}
	async getAllPersistedKeyPairs() {
		return Array.from(this.keyPairs.values());
	}
	async getLatestKeyPair() {
		if (this.insertionOrder.length === 0) return null;
		const latestPublicKey = this.insertionOrder[this.insertionOrder.length - 1];
		return this.keyPairs.get(latestPublicKey) ?? null;
	}
	async getLastDerivationIndex() {
		let maxIndex = -1;
		for (const keypair of this.keyPairs.values()) if (keypair.derivationIndex != null && keypair.derivationIndex > maxIndex) maxIndex = keypair.derivationIndex;
		return maxIndex;
	}
};

//#endregion
//#region repositories/memory/MemoryMintRepository.ts
var MemoryMintRepository = class {
	mints = /* @__PURE__ */ new Map();
	async isTrustedMint(mintUrl) {
		return this.mints.get(mintUrl)?.trusted ?? false;
	}
	async getMintByUrl(mintUrl) {
		const mint = this.mints.get(mintUrl);
		if (!mint) throw new Error(`Mint not found: ${mintUrl}`);
		return mint;
	}
	async getAllMints() {
		return Array.from(this.mints.values());
	}
	async getAllTrustedMints() {
		return Array.from(this.mints.values()).filter((mint) => mint.trusted);
	}
	async addNewMint(mint) {
		this.mints.set(mint.mintUrl, mint);
	}
	async addOrUpdateMint(mint) {
		this.mints.set(mint.mintUrl, mint);
	}
	async updateMint(mint) {
		this.mints.set(mint.mintUrl, mint);
	}
	async setMintTrusted(mintUrl, trusted) {
		const mint = this.mints.get(mintUrl);
		if (mint) {
			mint.trusted = trusted;
			this.mints.set(mintUrl, mint);
		}
	}
	async deleteMint(mintUrl) {
		this.mints.delete(mintUrl);
	}
};

//#endregion
//#region repositories/memory/MemoryProofRepository.ts
var MemoryProofRepository = class {
	proofsByMint = /* @__PURE__ */ new Map();
	getMintMap(mintUrl) {
		if (!this.proofsByMint.has(mintUrl)) this.proofsByMint.set(mintUrl, /* @__PURE__ */ new Map());
		return this.proofsByMint.get(mintUrl);
	}
	async saveProofs(mintUrl, proofs) {
		if (!proofs || proofs.length === 0) return;
		const map = this.getMintMap(mintUrl);
		for (const p of proofs) if (map.has(p.secret)) throw new Error(`Proof with secret already exists: ${p.secret}`);
		for (const p of proofs) map.set(p.secret, {
			...p,
			mintUrl
		});
	}
	async getReadyProofs(mintUrl) {
		const map = this.getMintMap(mintUrl);
		return Array.from(map.values()).filter((p) => p.state === "ready").map((p) => ({ ...p }));
	}
	async getInflightProofs(mintUrls) {
		if (!mintUrls || mintUrls.length === 0) {
			const all = [];
			for (const map of this.proofsByMint.values()) for (const p of map.values()) if (p.state === "inflight") all.push({ ...p });
			return all;
		}
		const mintUrlList = mintUrls.map((url) => url.trim()).filter((url) => url.length > 0);
		if (mintUrlList.length === 0) return [];
		const uniqueMintUrls = Array.from(new Set(mintUrlList));
		const results = [];
		for (const mintUrl of uniqueMintUrls) {
			const map = this.proofsByMint.get(mintUrl);
			if (!map) continue;
			for (const p of map.values()) if (p.state === "inflight") results.push({ ...p });
		}
		return results;
	}
	async getAllReadyProofs() {
		const all = [];
		for (const map of this.proofsByMint.values()) for (const p of map.values()) if (p.state === "ready") all.push({ ...p });
		return all;
	}
	async getProofsByKeysetId(mintUrl, keysetId) {
		const map = this.getMintMap(mintUrl);
		const results = [];
		for (const p of map.values()) if (p.state === "ready" && p.id === keysetId) results.push({ ...p });
		return results;
	}
	async setProofState(mintUrl, secrets, state) {
		const map = this.getMintMap(mintUrl);
		for (const secret of secrets) {
			const p = map.get(secret);
			if (p) map.set(secret, {
				...p,
				state
			});
		}
	}
	async deleteProofs(mintUrl, secrets) {
		const map = this.getMintMap(mintUrl);
		for (const s of secrets) map.delete(s);
	}
	async wipeProofsByKeysetId(mintUrl, keysetId) {
		const map = this.getMintMap(mintUrl);
		for (const [secret, p] of Array.from(map.entries())) if (p.id === keysetId) map.delete(secret);
	}
	async reserveProofs(mintUrl, secrets, operationId) {
		const map = this.getMintMap(mintUrl);
		for (const secret of secrets) {
			const p = map.get(secret);
			if (!p) throw new Error(`Proof with secret not found: ${secret}`);
			if (p.state !== "ready") throw new Error(`Proof is not ready, cannot reserve: ${secret}`);
			if (p.usedByOperationId) throw new Error(`Proof already reserved by operation ${p.usedByOperationId}: ${secret}`);
		}
		for (const secret of secrets) {
			const p = map.get(secret);
			map.set(secret, {
				...p,
				usedByOperationId: operationId
			});
		}
	}
	async releaseProofs(mintUrl, secrets) {
		const map = this.getMintMap(mintUrl);
		for (const secret of secrets) {
			const p = map.get(secret);
			if (p) {
				const { usedByOperationId: _, ...rest } = p;
				map.set(secret, rest);
			}
		}
	}
	async setCreatedByOperation(mintUrl, secrets, operationId) {
		const map = this.getMintMap(mintUrl);
		for (const secret of secrets) {
			const p = map.get(secret);
			if (p) map.set(secret, {
				...p,
				createdByOperationId: operationId
			});
		}
	}
	async getProofBySecret(mintUrl, secret) {
		const proof = this.getMintMap(mintUrl).get(secret);
		return proof ? { ...proof } : null;
	}
	async getProofsByOperationId(mintUrl, operationId) {
		const map = this.getMintMap(mintUrl);
		const results = [];
		for (const p of map.values()) if (p.usedByOperationId === operationId || p.createdByOperationId === operationId) results.push({ ...p });
		return results;
	}
	async getAvailableProofs(mintUrl) {
		const map = this.getMintMap(mintUrl);
		return Array.from(map.values()).filter((p) => p.state === "ready" && !p.usedByOperationId).map((p) => ({ ...p }));
	}
	async getReservedProofs() {
		const all = [];
		for (const map of this.proofsByMint.values()) for (const p of map.values()) if (p.state === "ready" && p.usedByOperationId) all.push({ ...p });
		return all;
	}
};

//#endregion
//#region repositories/memory/MemoryMintQuoteRepository.ts
var MemoryMintQuoteRepository = class {
	quotes = /* @__PURE__ */ new Map();
	makeKey(mintUrl, quoteId) {
		return `${mintUrl}::${quoteId}`;
	}
	async getMintQuote(mintUrl, quoteId) {
		const key = this.makeKey(mintUrl, quoteId);
		return this.quotes.get(key) ?? null;
	}
	async addMintQuote(quote) {
		const key = this.makeKey(quote.mintUrl, quote.quote);
		this.quotes.set(key, quote);
	}
	async setMintQuoteState(mintUrl, quoteId, state) {
		const key = this.makeKey(mintUrl, quoteId);
		const existing = this.quotes.get(key);
		if (!existing) return;
		this.quotes.set(key, {
			...existing,
			state
		});
	}
	async getPendingMintQuotes() {
		const result = [];
		for (const q of this.quotes.values()) if (q.state !== "ISSUED") result.push(q);
		return result;
	}
};

//#endregion
//#region repositories/memory/MemoryMeltQuoteRepository.ts
var MemoryMeltQuoteRepository = class {
	quotes = /* @__PURE__ */ new Map();
	makeKey(mintUrl, quoteId) {
		return `${mintUrl}::${quoteId}`;
	}
	async getMeltQuote(mintUrl, quoteId) {
		const key = this.makeKey(mintUrl, quoteId);
		return this.quotes.get(key) ?? null;
	}
	async addMeltQuote(quote) {
		const key = this.makeKey(quote.mintUrl, quote.quote);
		this.quotes.set(key, quote);
	}
	async setMeltQuoteState(mintUrl, quoteId, state) {
		const key = this.makeKey(mintUrl, quoteId);
		const existing = this.quotes.get(key);
		if (!existing) return;
		this.quotes.set(key, {
			...existing,
			state
		});
	}
	async getPendingMeltQuotes() {
		const result = [];
		for (const q of this.quotes.values()) if (q.state !== "PAID") result.push(q);
		return result;
	}
};

//#endregion
//#region repositories/memory/MemoryHistoryRepository.ts
var MemoryHistoryRepository = class {
	entries = [];
	nextId = 1;
	async getPaginatedHistoryEntries(limit, offset) {
		return [...this.entries].sort((a, b) => {
			if (a.createdAt !== b.createdAt) return b.createdAt - a.createdAt;
			return Number(b.id) - Number(a.id);
		}).slice(offset, offset + limit);
	}
	async getHistoryEntryById(id) {
		return this.entries.find((e) => e.id === id) ?? null;
	}
	async addHistoryEntry(history) {
		const entry = {
			id: String(this.nextId++),
			...history
		};
		this.entries.push(entry);
		return entry;
	}
	async getMintHistoryEntry(mintUrl, quoteId) {
		for (let i = this.entries.length - 1; i >= 0; i--) {
			const e = this.entries[i];
			if (!e) continue;
			if (e.type === "mint" && e.mintUrl === mintUrl && e.quoteId === quoteId) return e;
		}
		return null;
	}
	async getMeltHistoryEntry(mintUrl, quoteId) {
		for (let i = this.entries.length - 1; i >= 0; i--) {
			const e = this.entries[i];
			if (!e) continue;
			if (e.type === "melt" && e.mintUrl === mintUrl && e.quoteId === quoteId) return e;
		}
		return null;
	}
	async getSendHistoryEntry(mintUrl, operationId) {
		for (let i = this.entries.length - 1; i >= 0; i--) {
			const e = this.entries[i];
			if (!e) continue;
			if (e.type === "send" && e.mintUrl === mintUrl && e.operationId === operationId) return e;
		}
		return null;
	}
	async updateHistoryEntry(history) {
		const idx = this.entries.findIndex((e) => {
			if (e.type === "mint" && history.type === "mint") return e.mintUrl === history.mintUrl && e.quoteId === history.quoteId;
			if (e.type === "melt" && history.type === "melt") return e.mintUrl === history.mintUrl && e.quoteId === history.quoteId;
			if (e.type === "send" && history.type === "send") return e.mintUrl === history.mintUrl && e.operationId === history.operationId;
			return false;
		});
		if (idx === -1) throw new Error("History entry not found");
		const updated = {
			...this.entries[idx],
			...history
		};
		this.entries[idx] = updated;
		return updated;
	}
	async updateSendHistoryState(mintUrl, operationId, state) {
		const entry = await this.getSendHistoryEntry(mintUrl, operationId);
		if (!entry) throw new Error(`Send history entry not found for operationId: ${operationId}`);
		entry.state = state;
	}
	async deleteHistoryEntry(mintUrl, quoteId) {
		for (let i = this.entries.length - 1; i >= 0; i--) {
			const e = this.entries[i];
			if (!e) continue;
			if ((e.type === "mint" || e.type === "melt") && e.mintUrl === mintUrl && e.quoteId === quoteId) this.entries.splice(i, 1);
		}
	}
};

//#endregion
//#region repositories/memory/MemorySendOperationRepository.ts
var MemorySendOperationRepository = class {
	operations = /* @__PURE__ */ new Map();
	async create(operation) {
		if (this.operations.has(operation.id)) throw new Error(`SendOperation with id ${operation.id} already exists`);
		this.operations.set(operation.id, { ...operation });
	}
	async update(operation) {
		if (!this.operations.has(operation.id)) throw new Error(`SendOperation with id ${operation.id} not found`);
		this.operations.set(operation.id, {
			...operation,
			updatedAt: Date.now()
		});
	}
	async getById(id) {
		const op = this.operations.get(id);
		return op ? { ...op } : null;
	}
	async getByState(state) {
		const results = [];
		for (const op of this.operations.values()) if (op.state === state) results.push({ ...op });
		return results;
	}
	async getPending() {
		const results = [];
		for (const op of this.operations.values()) if (op.state === "executing" || op.state === "pending" || op.state === "rolling_back") results.push({ ...op });
		return results;
	}
	async getByMintUrl(mintUrl) {
		const results = [];
		for (const op of this.operations.values()) if (op.mintUrl === mintUrl) results.push({ ...op });
		return results;
	}
	async delete(id) {
		this.operations.delete(id);
	}
};

//#endregion
//#region repositories/memory/MemoryMeltOperationRepository.ts
var MemoryMeltOperationRepository = class {
	operations = /* @__PURE__ */ new Map();
	async create(operation) {
		if (this.operations.has(operation.id)) throw new Error(`MeltOperation with id ${operation.id} already exists`);
		this.operations.set(operation.id, { ...operation });
	}
	async update(operation) {
		if (!this.operations.has(operation.id)) throw new Error(`MeltOperation with id ${operation.id} not found`);
		this.operations.set(operation.id, {
			...operation,
			updatedAt: Date.now()
		});
	}
	async getById(id) {
		const operation = this.operations.get(id);
		return operation ? { ...operation } : null;
	}
	async getByState(state) {
		const results = [];
		for (const operation of this.operations.values()) if (operation.state === state) results.push({ ...operation });
		return results;
	}
	async getPending() {
		const results = [];
		for (const operation of this.operations.values()) if (operation.state === "executing" || operation.state === "pending") results.push({ ...operation });
		return results;
	}
	async getByMintUrl(mintUrl) {
		const results = [];
		for (const operation of this.operations.values()) if (operation.mintUrl === mintUrl) results.push({ ...operation });
		return results;
	}
	async getByQuoteId(mintUrl, quoteId) {
		const results = [];
		for (const operation of this.operations.values()) if (operation.mintUrl === mintUrl && "quoteId" in operation && operation.quoteId === quoteId) results.push({ ...operation });
		return results;
	}
	async delete(id) {
		this.operations.delete(id);
	}
};

//#endregion
//#region repositories/memory/MemoryRepositories.ts
var MemoryRepositories = class {
	mintRepository;
	keyRingRepository;
	counterRepository;
	keysetRepository;
	proofRepository;
	mintQuoteRepository;
	meltQuoteRepository;
	historyRepository;
	sendOperationRepository;
	meltOperationRepository;
	constructor() {
		this.mintRepository = new MemoryMintRepository();
		this.keyRingRepository = new MemoryKeyRingRepository();
		this.counterRepository = new MemoryCounterRepository();
		this.keysetRepository = new MemoryKeysetRepository();
		this.proofRepository = new MemoryProofRepository();
		this.mintQuoteRepository = new MemoryMintQuoteRepository();
		this.meltQuoteRepository = new MemoryMeltQuoteRepository();
		this.historyRepository = new MemoryHistoryRepository();
		this.sendOperationRepository = new MemorySendOperationRepository();
		this.meltOperationRepository = new MemoryMeltOperationRepository();
	}
	async init() {}
	async withTransaction(fn) {
		return fn(this);
	}
};

//#endregion
export { ConsoleLogger, CounterService, ExtensionRegistrationError, HistoryApi, HistoryService, HttpResponseError, KeyRingApi, KeyRingService, KeysetSyncError, Manager, MeltOperationService, MeltQuoteService, MemoryCounterRepository, MemoryHistoryRepository, MemoryKeyRingRepository, MemoryKeysetRepository, MemoryMeltOperationRepository, MemoryMeltQuoteRepository, MemoryMintQuoteRepository, MemoryMintRepository, MemoryProofRepository, MemoryRepositories, MemorySendOperationRepository, MintApi, MintFetchError, MintOperationError, MintQuoteProcessor, MintQuoteService, MintQuoteWatcherService, MintService, NetworkError, OperationInProgressError, PaymentRequestError, PaymentRequestService, PluginHost, ProofOperationError, ProofService, ProofStateWatcherService, ProofValidationError, QuotesApi, SeedService, SendApi, SendOperationService, SubscriptionApi, SubscriptionManager, TokenValidationError, TransactionService, UnknownMintError, WalletApi, WalletRestoreService, WalletService, WsConnectionManager, createSendOperation, getDecodedToken, getEncodedToken, getKeepProofSecrets, getSendProofSecrets, hasPreparedData, initializeCoco, isExecutingOperation, isFinalizedOperation, isInitOperation, isPendingOperation, isPreparedOperation, isRolledBackOperation, isRollingBackOperation, isTerminalOperation, normalizeMintUrl };