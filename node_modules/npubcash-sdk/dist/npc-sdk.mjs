import { getToken as y } from "nostr-tools/nip98";
class X {
  info(e, ...t) {
    console.info(`[SDK Info] ${e}`, ...t);
  }
  warn(e, ...t) {
    console.warn(`[SDK Warning] ${e}`, ...t);
  }
  error(e, ...t) {
    console.error(`[SDK Error] ${e}`, ...t);
  }
  debug(e, ...t) {
    console.debug(`[SDK Debug] ${e}`, ...t);
  }
}
class v {
  info(e, ...t) {
  }
  warn(e, ...t) {
  }
  error(e, ...t) {
  }
  debug(e, ...t) {
  }
}
class f extends Error {
  statusCode;
  constructor(e, t) {
    super(e), this.name = "ApiError", this.statusCode = t || 500;
  }
}
class T extends f {
  paymentRequest;
  constructor(e, t) {
    super(e, 402), this.paymentRequest = t;
  }
}
async function O(r, e, t = {}, n = new v()) {
  const s = new URL(r);
  try {
    const i = `${s.protocol}//${s.host}${s.pathname}`;
    n.debug(
      `Auth token obtained for URL: ${i} - METHOD: ${t.method || "GET"}`
    );
    const o = await fetch(r.toString(), {
      ...t,
      headers: {
        ...t.headers,
        Authorization: e
      }
    });
    if (!o.ok) {
      const u = await o.json();
      throw n.error(`API Error: ${u.message || o.statusText}`, {
        status: o.status,
        url: r.toString()
      }), new f(u.message || o.statusText, o.status);
    }
    const a = await o.json();
    return n.debug("Request successful", { url: r.toString() }), a;
  } catch (i) {
    throw n.error("Authenticated request failed:", i), i;
  }
}
class Y {
  storedToken;
  signer;
  _baseUrl;
  logger;
  /**
   * @param baseUrl Base URL of the NpubCash server (e.g., `https://npubx.cash`).
   * @param signer Function that signs a Nostr event template (NIP‑98).
   * @param logger Optional logger for diagnostics.
   */
  constructor(e, t, n) {
    this._baseUrl = e, this.signer = t, this.logger = n;
  }
  /**
   * Returns an HTTP Authorization header value.
   * Fetches and caches a short‑lived JWT via NIP‑98 if needed.
   * @param url The URL being requested (scheme+host+path only used for logging/context).
   * @param method HTTP method (for context).
   * @returns Authorization header value in the form `Bearer <token>`.
   */
  async getAuthToken(e, t) {
    return this.logger?.debug(
      `Provider getting token for URL: ${e} - METHOD: ${t}`
    ), `Bearer ${await this._ensureCachedToken()}`;
  }
  /**
   * Produce a NIP‑98 token for challenge/response authentication (e.g., WebSocket).
   * @param url The URL being authenticated.
   * @param method The HTTP verb indicated by the server challenge.
   * @returns Raw NIP‑98 token string.
   */
  async getNostrToken(e, t) {
    return y(e, t, this.signer);
  }
  async _ensureCachedToken() {
    if (this.storedToken && this.storedToken.expiresAt > /* @__PURE__ */ new Date())
      return this.logger?.debug("Returning cached token."), this.storedToken.token;
    this.logger?.debug("No valid cached token found, fetching a new one.");
    const e = `${this._baseUrl}/api/v2/auth/nip98`, t = await y(e, "GET", async (i) => await this.signer(i)), s = (await O(
      e,
      `Nostr ${t}`,
      void 0,
      this.logger
    )).data.token;
    if (typeof s != "string")
      throw this.logger?.error("Token received from auth endpoint is invalid."), new Error("Received invalid token from authentication endpoint.");
    return this.storedToken = {
      token: s,
      expiresAt: new Date((/* @__PURE__ */ new Date()).getTime() + 300 * 1e3)
    }, this.logger?.info("Successfully fetched and cached new token."), s;
  }
}
class _ {
  _authenticatedRequest;
  logger;
  constructor(e, t) {
    this._authenticatedRequest = e, this.logger = t;
  }
  /**
   * Set a logger implementation for diagnostics.
   * @internal Called by NPCClient when its logger is updated.
   */
  setLogger(e) {
    this.logger = e;
  }
  /**
   * Update the user's preferred mint URL.
   * @param mintUrl Fully-qualified Cashu mint URL.
   * @returns Updated user settings resource.
   */
  async setMintUrl(e) {
    try {
      const t = await this._authenticatedRequest(
        "/api/v2/user/mint",
        {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ mint_url: e })
        }
      );
      return this.logger?.info("Mint URL updated successfully"), t;
    } catch (t) {
      throw this.logger?.error("Error updating mint URL:", t), t;
    }
  }
  /**
   * Enable or disable quote locking for the user.
   * @param lockQuotes When true, new quotes are locked by default.
   * @returns Updated user settings resource.
   */
  async setLock(e) {
    try {
      const t = await this._authenticatedRequest(
        "/api/v2/user/lock",
        {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ lockQuotes: e })
        }
      );
      return this.logger?.info("Lock setting updated successfully"), t;
    } catch (t) {
      throw this.logger?.error("Error updating lock setting:", t), t;
    }
  }
}
class R {
  socket;
  provider;
  onUpdate;
  onError;
  logger;
  boundOnOpen;
  boundOnMessage;
  boundOnError;
  boundOnClose;
  constructor(e, t, n, s, i) {
    this.provider = t, this.onUpdate = n, this.onError = i, this.logger = s, this.socket = new WebSocket(e), this.boundOnOpen = this.onOpen.bind(this), this.boundOnMessage = this.onMessage.bind(this), this.boundOnError = this.onSocketError.bind(this), this.boundOnClose = this.onClose.bind(this), this.socket.addEventListener("open", this.boundOnOpen), this.socket.addEventListener("message", this.boundOnMessage), this.socket.addEventListener("error", this.boundOnError), this.socket.addEventListener("close", this.boundOnClose);
  }
  dispose() {
    if (this.socket) {
      this.socket.removeEventListener("open", this.boundOnOpen), this.socket.removeEventListener("message", this.boundOnMessage), this.socket.removeEventListener("error", this.boundOnError), this.socket.removeEventListener("close", this.boundOnClose);
      try {
        this.socket.close(1e3);
      } catch {
      }
      this.socket = null;
    }
  }
  onOpen() {
    this.logger?.debug("WebSocket connection opened");
  }
  onClose() {
    this.logger?.debug("WebSocket connection closed");
  }
  onSocketError(e) {
    this.logger?.error("WebSocket error"), this.onError?.("WebSocket connection error");
  }
  onMessage(e) {
    if (typeof e.data == "string")
      try {
        const t = JSON.parse(e.data);
        switch (t.type) {
          case "challenge":
            this.handleChallenge(t.payload);
            break;
          case "challenge-success":
            this.logger?.debug("WebSocket challenge success");
            break;
          case "update":
            this.onUpdate(t.payload.quoteId);
            break;
          case "error":
            this.logger?.error(
              `WebSocket server error${t.payload ? ": " + t.payload : ""}`
            ), this.onError?.(t.payload || "Unknown WebSocket error");
            break;
          default:
            this.logger?.debug("Received unknown WebSocket message type");
        }
      } catch (t) {
        this.logger?.error("Failed to parse WebSocket message", t);
      }
  }
  async handleChallenge(e) {
    try {
      const t = await this.provider.getNostrToken(
        e.url,
        e.method
      );
      this.socket?.send(
        JSON.stringify({
          type: "challenge-response",
          payload: "Nostr " + t
        })
      );
    } catch (t) {
      this.logger?.error("Failed to handle WebSocket challenge", t), this.onError?.("Authentication failed"), this.dispose();
    }
  }
}
function k(r) {
  if (typeof r != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(r));
}
class E {
  static fromHex(e) {
    if (e = e.trim(), e.length === 0)
      return new Uint8Array(0);
    if (e.length < 2 || e.length & 1)
      throw new Error("Invalid hex string: odd length.");
    if ((e.startsWith("0x") || e.startsWith("0X")) && (e = e.slice(2)), !e.match(/^[0-9a-fA-F]*$/))
      throw new Error("Invalid hex string: contains non-hex characters");
    const t = e.match(/.{1,2}/g);
    if (!t)
      throw new Error("Invalid hex string");
    return new Uint8Array(t.map((n) => parseInt(n, 16)));
  }
  static toHex(e) {
    return Array.from(e, (t) => t.toString(16).padStart(2, "0")).join("");
  }
  static fromString(e) {
    return e = e.trim(), new TextEncoder().encode(e);
  }
  static toString(e) {
    return new TextDecoder("utf-8").decode(e);
  }
  static concat(...e) {
    const t = e.reduce((i, o) => i + o.length, 0), n = new Uint8Array(t);
    let s = 0;
    for (const i of e)
      n.set(i, s), s += i.length;
    return n;
  }
  static alloc(e) {
    return new Uint8Array(e);
  }
  static writeBigUint64BE(e) {
    const t = new ArrayBuffer(8);
    return new DataView(t).setBigUint64(0, e, !1), new Uint8Array(t);
  }
  static toBase64(e) {
    if (typeof Buffer < "u")
      return Buffer.from(e).toString("base64");
    if (e.length > 32768) {
      let t = "";
      for (let n = 0; n < e.length; n += 32768) {
        const s = e.slice(n, n + 32768);
        t += btoa(String.fromCharCode(...s));
      }
      return t;
    }
    return btoa(String.fromCharCode(...e));
  }
  static fromBase64(e) {
    e = e.trim();
    let t = e.replace(/-/g, "+").replace(/_/g, "/");
    for (; t.length % 4; )
      t += "=";
    return typeof Buffer < "u" ? new Uint8Array(Buffer.from(t, "base64")) : new Uint8Array([...atob(t)].map((n) => n.charCodeAt(0)));
  }
  // NOTE: MUST remain a constant-time implementation (full byte check)
  // because callers rely on it (e.g. deriveP2BKSecretKey).
  static equals(e, t) {
    if (e.length !== t.length) return !1;
    let n = 0;
    for (let s = 0; s < e.length; s++)
      n |= e[s] ^ t[s];
    return n === 0;
  }
  static compare(e, t) {
    const n = Math.min(e.length, t.length);
    for (let s = 0; s < n; s++) {
      if (e[s] < t[s]) return -1;
      if (e[s] > t[s]) return 1;
    }
    return e.length - t.length;
  }
}
function q(r) {
  return E.fromBase64(r);
}
function $(r) {
  return typeof r == "number" || typeof r == "string";
}
function L(r) {
  const e = [];
  return p(r, e), new Uint8Array(e);
}
function p(r, e) {
  if (r === null)
    e.push(246);
  else if (r === void 0)
    e.push(247);
  else if (typeof r == "boolean")
    e.push(r ? 245 : 244);
  else if (typeof r == "number")
    D(r, e);
  else if (typeof r == "string")
    U(r, e);
  else if (Array.isArray(r))
    I(r, e);
  else if (r instanceof Uint8Array)
    N(r, e);
  else if (
    // Defensive: POJO only (null/array handled above)
    typeof r == "object" && r !== null && !Array.isArray(r)
  )
    M(r, e);
  else
    throw new Error("Unsupported type");
}
function C(r, e) {
  if (r < 24)
    e.push(r);
  else if (r < 256)
    e.push(24, r);
  else if (r < 65536)
    e.push(25, r >>> 8 & 255, r & 255);
  else if (r < 4294967296)
    e.push(
      26,
      r >>> 24 & 255,
      r >>> 16 & 255,
      r >>> 8 & 255,
      r & 255
    );
  else
    throw new Error("Unsupported integer size");
}
function x(r, e) {
  const t = -1 - r;
  if (t < 24)
    e.push(32 | t);
  else if (t < 256)
    e.push(56, t & 255);
  else if (t < 65536)
    e.push(57, t >>> 8 & 255, t & 255);
  else if (t < 4294967296)
    e.push(
      58,
      t >>> 24 & 255,
      t >>> 16 & 255,
      t >>> 8 & 255,
      t & 255
    );
  else
    throw new Error("Unsupported integer size");
}
function P(r, e) {
  const t = new ArrayBuffer(8), n = new DataView(t);
  n.setFloat64(0, r, !1), e.push(251);
  for (let s = 0; s < 8; s++) e.push(n.getUint8(s));
}
function D(r, e) {
  Number.isInteger(r) ? r >= 0 ? C(r, e) : x(r, e) : P(r, e);
}
function N(r, e) {
  const t = r.length;
  if (t < 24)
    e.push(64 + t);
  else if (t < 256)
    e.push(88, t);
  else if (t < 65536)
    e.push(89, t >> 8 & 255, t & 255);
  else if (t < 4294967296)
    e.push(
      90,
      t >>> 24 & 255,
      t >>> 16 & 255,
      t >>> 8 & 255,
      t & 255
    );
  else
    throw new Error("Byte string too long to encode");
  for (let n = 0; n < r.length; n++)
    e.push(r[n]);
}
function U(r, e) {
  const t = new TextEncoder().encode(r), n = t.length;
  if (n < 24)
    e.push(96 + n);
  else if (n < 256)
    e.push(120, n);
  else if (n < 65536)
    e.push(121, n >>> 8 & 255, n & 255);
  else if (n < 4294967296)
    e.push(
      122,
      n >>> 24 & 255,
      n >>> 16 & 255,
      n >>> 8 & 255,
      n & 255
    );
  else
    throw new Error("String too long to encode");
  for (let s = 0; s < t.length; s++)
    e.push(t[s]);
}
function I(r, e) {
  const t = r.length;
  if (t < 24)
    e.push(128 | t);
  else if (t < 256)
    e.push(152, t);
  else if (t < 65536)
    e.push(153, t >>> 8 & 255, t & 255);
  else
    throw new Error("Unsupported array length");
  for (const n of r)
    p(n, e);
}
function M(r, e) {
  const t = Object.keys(r), n = t.length;
  if (n >= 4294967296)
    throw new Error("Object has too many keys to encode");
  n < 24 ? e.push(160 | n) : n < 256 ? e.push(184, n) : n < 65536 ? e.push(185, n >> 8 & 255, n & 255) : e.push(
    186,
    n >> 24 & 255,
    n >> 16 & 255,
    n >> 8 & 255,
    n & 255
  );
  for (const s of t)
    U(s, e), p(r[s], e);
}
function B(r) {
  const e = new DataView(r.buffer, r.byteOffset, r.byteLength);
  return g(e, 0).value;
}
function g(r, e) {
  if (e >= r.byteLength)
    throw new Error("Unexpected end of data");
  const t = r.getUint8(e++), n = t >> 5, s = t & 31;
  switch (n) {
    case 0:
      return j(r, e, s);
    case 1:
      return W(r, e, s);
    case 2:
      return F(r, e, s);
    case 3:
      return Q(r, e, s);
    case 4:
      return H(r, e, s);
    case 5:
      return J(r, e, s);
    case 7:
      return G(r, e, s);
    default:
      throw new Error(`Unsupported major type: ${n}`);
  }
}
function h(r, e, t) {
  if (e + t > r.byteLength)
    throw new Error("Unexpected end of data");
}
function l(r, e, t) {
  if (t < 24) return { value: t, offset: e };
  if (t === 24)
    return h(r, e, 1), { value: r.getUint8(e++), offset: e };
  if (t === 25) {
    h(r, e, 2);
    const n = r.getUint16(e, !1);
    return e += 2, { value: n, offset: e };
  }
  if (t === 26) {
    h(r, e, 4);
    const n = r.getUint32(e, !1);
    return e += 4, { value: n, offset: e };
  }
  if (t === 27) {
    h(r, e, 8);
    const n = r.getUint32(e, !1), s = r.getUint32(e + 4, !1);
    return e += 8, { value: n * 2 ** 32 + s, offset: e };
  }
  throw new Error(`Unsupported length: ${t}`);
}
function j(r, e, t) {
  const { value: n, offset: s } = l(r, e, t);
  return { value: n, offset: s };
}
function W(r, e, t) {
  const { value: n, offset: s } = l(r, e, t);
  return { value: -1 - n, offset: s };
}
function F(r, e, t) {
  const { value: n, offset: s } = l(r, e, t);
  if (s + n > r.byteLength)
    throw new Error("Byte string length exceeds data length");
  return { value: new Uint8Array(r.buffer, r.byteOffset + s, n), offset: s + n };
}
function Q(r, e, t) {
  const { value: n, offset: s } = l(r, e, t);
  if (s + n > r.byteLength)
    throw new Error("String length exceeds data length");
  const i = new Uint8Array(r.buffer, r.byteOffset + s, n);
  return { value: new TextDecoder().decode(i), offset: s + n };
}
function H(r, e, t) {
  const { value: n, offset: s } = l(r, e, t), i = [];
  let o = s;
  for (let a = 0; a < n; a++) {
    const u = g(r, o);
    i.push(u.value), o = u.offset;
  }
  return { value: i, offset: o };
}
function J(r, e, t) {
  const { value: n, offset: s } = l(r, e, t), i = {};
  let o = s;
  for (let a = 0; a < n; a++) {
    const u = g(r, o);
    if (!$(u.value))
      throw new Error("Invalid key type");
    const c = g(r, u.offset);
    i[u.value] = c.value, o = c.offset;
  }
  return { value: i, offset: o };
}
function z(r) {
  const e = (r & 31744) >> 10, t = r & 1023, n = r & 32768 ? -1 : 1;
  return e === 0 ? n * 2 ** -14 * (t / 1024) : e === 31 ? t ? NaN : n * (1 / 0) : n * 2 ** (e - 15) * (1 + t / 1024);
}
function G(r, e, t) {
  if (t < 24)
    switch (t) {
      case 20:
        return { value: !1, offset: e };
      case 21:
        return { value: !0, offset: e };
      case 22:
        return { value: null, offset: e };
      case 23:
        return { value: void 0, offset: e };
      default:
        throw new Error(`Unknown simple value: ${t}`);
    }
  if (t === 24)
    return h(r, e, 1), { value: r.getUint8(e++), offset: e };
  if (t === 25) {
    h(r, e, 2);
    const n = z(r.getUint16(e, !1));
    return e += 2, { value: n, offset: e };
  }
  if (t === 26) {
    h(r, e, 4);
    const n = r.getFloat32(e, !1);
    return e += 4, { value: n, offset: e };
  }
  if (t === 27) {
    h(r, e, 8);
    const n = r.getFloat64(e, !1);
    return e += 8, { value: n, offset: e };
  }
  throw new Error(`Unknown simple or float value: ${t}`);
}
k("Secp256k1_HashToCurve_Cashu_");
k("Cashu_P2BK_v1");
class w {
  constructor(e, t, n, s, i, o, a = !1, u, c = !1) {
    this.transport = e, this.id = t, this.amount = n, this.unit = s, this.mints = i, this.description = o, this.singleUse = a, this.nut10 = u, this.nut26 = c;
  }
  toRawRequest() {
    const e = {};
    return this.transport && (e.t = this.transport.map((t) => ({
      t: t.type,
      a: t.target,
      g: t.tags
    }))), this.id && (e.i = this.id), this.amount && (e.a = this.amount), this.unit && (e.u = this.unit), this.mints && (e.m = this.mints), this.description && (e.d = this.description), this.singleUse && (e.s = this.singleUse), this.nut10 && (e.nut10 = {
      k: this.nut10.kind,
      d: this.nut10.data,
      t: this.nut10.tags
    }), this.nut26 && (e.nut26 = this.nut26), e;
  }
  toEncodedRequest() {
    const e = this.toRawRequest(), t = L(e);
    return "creqA" + E.toBase64(t);
  }
  getTransport(e) {
    return this.transport?.find((t) => t.type === e);
  }
  static fromRawRequest(e) {
    const t = e.t ? e.t.map((s) => ({
      type: s.t,
      target: s.a,
      tags: s.g
    })) : void 0, n = e.nut10 ? {
      kind: e.nut10.k,
      data: e.nut10.d,
      tags: e.nut10.t
    } : void 0;
    return new w(
      t,
      e.i,
      e.a,
      e.u,
      e.m,
      e.d,
      e.s,
      n,
      e.nut26
    );
  }
  static fromEncodedRequest(e) {
    if (!e.startsWith("creq"))
      throw new Error("unsupported pr: invalid prefix");
    if (e[4] !== "A")
      throw new Error("unsupported pr version");
    const t = e.slice(5), n = q(t), s = B(n);
    return this.fromRawRequest(s);
  }
}
const d = {
  QUOTES: "/api/v2/wallet/quotes",
  INFO: "/api/v2/user/info",
  USERNAME: "/api/v2/user/username"
}, b = 50, m = 200, K = (r) => new Promise((e) => setTimeout(e, r));
class Z {
  _baseUrl;
  authProvider;
  /**
   * Settings API for the authenticated user account.
   * Use {@link SettingsManager.setMintUrl} and {@link SettingsManager.setLock}.
   */
  settings;
  logger;
  /**
   * Create a client.
   * @param baseUrl Base URL of the NpubCash server, e.g. `https://npubx.cash`.
   * @param authProvider Provider that supplies HTTP and NIP‑98 auth tokens.
   */
  constructor(e, t) {
    this._baseUrl = e, this.authProvider = t, this.settings = new _(this._authenticatedRequest.bind(this)), this.logger = new v();
  }
  /**
   * Set a logger implementation for SDK diagnostics.
   * @param logger Logger implementation to use (e.g., {@link ConsoleLogger}).
   */
  setLogger(e) {
    this.logger = e, this.settings.setLogger(e);
  }
  /**
   * Fetch account information for the authenticated user.
   *
   * @returns The user's account information.
   * @throws {ApiError} When the request fails.
   */
  async getInfo() {
    const e = await this._authenticatedRequest(
      d.INFO
    );
    return console.log(e), e.data.user;
  }
  /**
   * Set the username for the authenticated user.
   *
   * This method supports the Cashu payment flow. Call without a token first
   * to receive payment requirements, then call again with the token to complete.
   *
   * @param username The desired username.
   * @param token Optional Cashu token for payment.
   * @throws {PaymentRequiredError} When payment is required. Contains the
   *         {@link PaymentRequest} with amount and mint details.
   * @throws {ApiError} When the request fails for other reasons.
   */
  async setUsername(e, t) {
    const n = {
      method: "POST",
      body: JSON.stringify({ username: e }),
      headers: {
        "content-type": "application/json",
        ...t ? { "X-Cashu": t } : {}
      }
    };
    return await this._authenticatedRequest(
      d.USERNAME,
      n
    );
  }
  /**
   * Fetch quotes created since a UNIX timestamp (in seconds).
   * Handles pagination internally.
   * @param since UNIX timestamp in seconds.
   * @returns All quotes since the given time.
   */
  async getQuotesSince(e) {
    return this.logger.debug(`Fetching quotes since timestamp: ${e}`), this._fetchPaginatedQuotes(e);
  }
  /**
   * Fetch all quotes for the authenticated user.
   * Handles pagination internally.
   * @returns All available quotes.
   */
  async getAllQuotes() {
    return this.logger.debug("Fetching all quotes."), this._fetchPaginatedQuotes();
  }
  /**
   * Subscribe to realtime quote update notifications.
   *
   * Opens a WebSocket to `${baseUrl}/api/v2/ws/quote` and authenticates via NIP‑98
   * challenge/response. The callback receives the updated `quoteId`.
   *
   * @param onUpdate Called whenever a quote is updated.
   * @param onError Optional callback for WebSocket/auth errors. Receives a message.
   * @returns Disposer function to close the subscription.
   */
  subscribe(e, t) {
    const n = new URL(`${this._baseUrl}/api/v2/ws/quote`), s = `${n.protocol === "https:" ? "wss:" : "ws:"}//${n.host}${n.pathname}`, i = new R(
      s,
      this.authProvider,
      e,
      this.logger,
      t
    );
    return () => i.dispose();
  }
  async _fetchPaginatedQuotes(e) {
    let t = [], n = 0;
    for (; ; ) {
      const s = {
        offset: n,
        limit: b
      };
      e && (s.since = e);
      const i = await this._authenticatedRequest(
        d.QUOTES,
        { params: s }
      ), o = i.data.quotes;
      t = t.concat(o), this.logger.debug(
        `Fetched ${o.length} quotes. Total fetched: ${t.length}`
      );
      const a = i.metadata.total;
      if (n += b, n >= a)
        break;
      this.logger.debug(`Throttling for ${m}ms...`), await K(m);
    }
    return this.logger.info(
      `Successfully fetched a total of ${t.length} quotes.`
    ), t;
  }
  async _authenticatedRequest(e, t = {}) {
    const n = new URL(`${this._baseUrl}${e}`);
    if (t.params)
      for (const s in t.params)
        Object.prototype.hasOwnProperty.call(t.params, s) && n.searchParams.append(s, String(t.params[s]));
    try {
      const s = `${n.protocol}//${n.host}${n.pathname}`, i = await this.authProvider.getAuthToken(
        s,
        t.method || "GET"
      );
      this.logger.debug(`Auth token obtained for URL: ${s}`);
      const o = await fetch(n.toString(), {
        ...t,
        headers: {
          ...t.headers,
          Authorization: i
        }
      });
      if (!o.ok) {
        const c = (await o.json()).message || o.statusText;
        if (this.logger.error(`API Error: ${c}`, {
          status: o.status,
          url: n.toString()
        }), o.status === 402) {
          const A = o.headers.get("X-Cashu"), S = w.fromEncodedRequest(A);
          throw new T(c, S);
        }
        throw new f(c, o.status);
      }
      const a = await o.json();
      return this.logger.debug("Request successful", { url: n.toString() }), a;
    } catch (s) {
      throw s instanceof f || this.logger.error("Authenticated request failed unexpectedly:", s), s;
    }
  }
}
export {
  f as ApiError,
  X as ConsoleLogger,
  Y as JWTAuthProvider,
  Z as NPCClient,
  T as PaymentRequiredError
};
